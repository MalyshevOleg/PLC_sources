diff -x .svn -Nru linux-3.0.x-orig/arch/arm/common/Makefile linux-3.0.x-arm/arch/arm/common/Makefile
--- linux-3.0.x-orig/arch/arm/common/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/common/Makefile	2012-12-19 11:26:04.000000000 +0200
@@ -17,3 +17,5 @@
 obj-$(CONFIG_ARCH_IXP23XX)	+= uengine.o
 obj-$(CONFIG_PCI_HOST_ITE8152)  += it8152.o
 obj-$(CONFIG_ARM_TIMER_SP804)	+= timer-sp.o
+
+obj-$(CONFIG_OWEN_RETAIN_MEMORY)	+= owen-retain-memory.o
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/common/owen-retain-memory.c linux-3.0.x-arm/arch/arm/common/owen-retain-memory.c
--- linux-3.0.x-orig/arch/arm/common/owen-retain-memory.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/common/owen-retain-memory.c	2012-12-19 11:26:04.000000000 +0200
@@ -0,0 +1,99 @@
+/*
+ * arch/arm/common/owen-retain-memory.c
+ *
+ * Copyright (c) 2012 Softerra LLC (alex@softerra.com)
+ *
+ * Allocation of bootmem block for shadow of retain memory 
+ * (e.g. file or eeprom connected via SPI)
+ *
+ * Retain memory shadow is used on Owen PLC304, HE5684, PLC240(SPK210)
+ * On SPK210 immediate flush to eeprom is performed on FIQ - the data is copied 
+ * directly from the allocated buffer via DMA, so the buffer should contain extra space for
+ * WRITE command's opcode and address bytes, therefore extra page is allocated.
+ *
+ * User applications are informed about allocated buffer physical address and size via
+ * printk, so they can use dmesg to extract the information. (Note: dmesg may 
+ * not contain this information if much debug info is printed during system start-up)
+ */
+
+#include <linux/bootmem.h>
+#include <linux/proc_fs.h>
+
+#include <owen-common.h>
+
+/* keep local copy of memory configuration for /proc/ interface */
+static struct owen_rm_info rm_info;
+
+static ssize_t owen_rm_info_read(char *buf, char **start, off_t offset, int len, int *eof, void *private)
+{
+	size_t data_len;
+
+	data_len = snprintf(buf, len, "size=%lu, address=0x%lx\n", 
+						rm_info.size, rm_info.phys_addr);
+	*eof = 1;
+	return data_len;
+}
+
+void __init owen_setup_rm_info_iface(void)
+{
+	struct proc_dir_entry *owen_rm_info;
+
+	owen_rm_info = create_proc_entry(OWEN_RM_INFO_NAME, S_IRUGO, NULL);
+	if(!owen_rm_info) {
+		pr_err("Failed to create proc entry: " OWEN_RM_INFO_NAME "\n");
+	} else {
+		owen_rm_info->read_proc = &owen_rm_info_read;
+	}
+}
+
+void __init owen_alloc_retain_memory(struct owen_rm_info *rm)
+{
+	unsigned long size = CONFIG_OWEN_RETAIN_MEMORY_KB * SZ_1K;
+	unsigned long alloc_size;
+	unsigned long phys_addr = 0;
+	void *addr = NULL;
+
+	do {
+		if (!size) {
+			break;
+		}
+
+#if defined(CONFIG_OWEN_LPVD_FIQ)
+		alloc_size = size + PAGE_SIZE;
+#else
+		alloc_size = size;
+#endif
+
+		addr = alloc_bootmem_low_pages(alloc_size);
+		if (!addr) {
+			pr_err("failed to alloc %lu bytes for retain memory\n", alloc_size);
+			size = 0;
+			break;
+		}
+		printk("really allocated: s=%lu, a=%p\n", alloc_size, addr);
+
+#if defined(CONFIG_OWEN_LPVD_FIQ)
+		addr += PAGE_SIZE;
+#endif
+
+		phys_addr = virt_to_phys(addr);
+	} while(0);
+
+	/* inform applications about size configured by Kconfig 
+	 * If extra page was allocated (for SPK210) then address the user apps informed about 
+	 * is shifted by the page. So application will use memory as though it was allocated as configured, but
+	 * fiq handler will be able to organize one DMA request to spi eeprom to send WRITE command
+	 * which contain the data set by use app: 1st PAGE: WRITE cmd, address bytes, 
+	 * 2nd(,3d..) PAGE(s): retain memory shadow buffer
+	 */
+	printk("Retain memory: size=%lu, address=0x%lx\n", size, phys_addr);
+
+	rm_info.addr = addr;
+	rm_info.phys_addr = phys_addr;
+	rm_info.size = size;
+
+	if (rm) {
+		*rm = rm_info;
+	}
+}
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/include/asm/termbits.h linux-3.0.x-arm/arch/arm/include/asm/termbits.h
--- linux-3.0.x-orig/arch/arm/include/asm/termbits.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/include/asm/termbits.h	2012-12-19 11:25:52.000000000 +0200
@@ -73,6 +73,7 @@
 #define IXOFF	0010000
 #define IMAXBEL	0020000
 #define IUTF8	0040000
+#define IRS485	0100000
 
 /* c_oflag bits */
 #define OPOST	0000001
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/include/owen-common.h linux-3.0.x-arm/arch/arm/include/owen-common.h
--- linux-3.0.x-orig/arch/arm/include/owen-common.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/include/owen-common.h	2012-12-19 11:25:52.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * linux/arch/arm/include/owen-common.h
+ *
+ * Copyright (c) 2012 Softerra LLC (alex@softerra.com)
+ */
+
+/* Retain memory stuff */
+
+
+#include <linux/spi/spi.h>
+
+/* /proc/interface entries */
+#define OWEN_LPVD_FIQ_ENABLE_NAME	"owen_lpvd_fiq_enable"
+#define OWEN_RM_INFO_NAME			"owen_rm_info"
+
+struct owen_rm_info {
+	unsigned long size;
+	unsigned long phys_addr;
+	void *addr;
+};
+
+/* required to be called on early initialization - uses bootmem */
+extern void __init owen_alloc_retain_memory(struct owen_rm_info *rm);
+/* required to be called after early initialization - uses kmalloc */
+extern void __init owen_setup_rm_info_iface(void);
+
+/* set up FIQ handler for saving retain memory shadow buffer on 
+ * detection of low power voltage
+ */
+extern void __init owen_setup_lpvd_fiq(struct spi_board_info *devices, int nr_devices, 
+								const char *name, struct owen_rm_info *rm);
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/Kconfig linux-3.0.x-arm/arch/arm/Kconfig
--- linux-3.0.x-orig/arch/arm/Kconfig	2013-09-19 17:39:58.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/Kconfig	2012-12-19 11:26:07.000000000 +0200
@@ -1007,6 +1007,9 @@
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+# Owen common features
+source "arch/arm/Kconfig-owen"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/Kconfig-owen linux-3.0.x-arm/arch/arm/Kconfig-owen
--- linux-3.0.x-orig/arch/arm/Kconfig-owen	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/Kconfig-owen	2013-09-19 17:09:29.000000000 +0300
@@ -0,0 +1,97 @@
+comment "OWEN Common Features"
+	depends on MACH_OWEN
+
+config MACH_OWEN
+	bool
+	default n
+
+if MACH_OWEN
+
+config OWEN_RETAIN_MEMORY
+	bool
+	default n
+	help
+	  Enables allocation of boot memory for retain memory
+	  shadow buffer. 
+	  Selected by Owen's PLC configuration
+
+config OWEN_LPVD_FIQ
+	bool
+	default n
+	select OWEN_RETAIN_MEMORY
+	help
+	  Enable support of LPVD (Low Power Voltage Detector) 
+	  FIQ handler for Owen PLC.
+	  Selected by Owen's PLC configuration
+
+config OWEN_RETAIN_MEMORY_KB
+	int "Size of retain memory shadow buffer (KB)"
+	range 4 256 if MACH_OWEN_HE5684
+	range 4 128 if (OWEN_PLC240_SPK210 || MACH_OWEN_SPK2XX_VAR)
+	range 4 64 if MACH_OWEN_PLC304
+	default 4
+	depends on OWEN_RETAIN_MEMORY
+	help
+	  Allocate boot memory for retain memory shadow buffer.
+	  The memory physical address is printed on kernel start.
+	  Then the address is passed to CodeSys config and a user-space driver
+	  which synchronizes the buffer and real retain memory.
+
+if ARCH_OMAP
+config OMAP_SERIAL_OVERRIDE
+	bool "Override standard properties of OMAP serial tty devices"
+	default n
+	help
+	  Whether or not to override standard properties (e.g. name, order)
+	  of serial devices.
+
+if OMAP_SERIAL_OVERRIDE
+config OMAP_SERIAL_NAME
+	string "Use specified name for serial devices instead of standard one"
+	default "ttyS"
+	help
+	  Specify ttyS to have on OWENs Variscite PLCs the same names for ttys 
+	  as they are on Atmel PLCs.
+
+config OMAP_SERIAL_REORDER
+	bool "Board-specific re-ordering of serial devices"
+	default y
+	help
+	  Allow board-specific code to change standard order of tty devices
+	  (ttyLn -> ttyLm).
+	  For instance OWEN SPK2XX Variscite board may change order to 
+	  have the same one as SPK2XX Atmel board has.
+endif
+endif
+
+if AT91RM9200_WATCHDOG
+config OWEN_WATCHDOG_RESET_BY_IRQ
+	bool "Enable watchdog reset by interrupt handler"
+	default n
+	help
+	  Disables immediate reset on watchdog overflow, instead sets up
+	  interrupt hndler which calls some helpers and then re-programs
+	  watchdog for reset within minimal possible time interval.
+	  The optiona enables kernel param 'wdt_irq' which defines whether 
+	  or not the functionality is active (it's value 1 by default - active).
+	  To diable the functionality at runtime pass wdt_irq=0.
+
+config OWEN_FLASH_SETUP_ON_WATCHDOG
+	bool "Enable flash setup before CPU reset by watchdog interrupt handler"
+	depends on OWEN_WATCHDOG_RESET_BY_IRQ
+	default n
+	help
+	  AT91RM9200 CPU's watchdog is not capable of resetting any external device:
+	  when it resets the CPU it doesn't reset flash memory.
+	  Quite often the flash is not in the Read Array mode in this moment, 
+	  so the CPU fails to read a boot program.
+	  A workaround is introduced by this option: watchdog is programmed to generate
+	  an interrupt without reset. When the interrupt occurs, the handler tries to 
+	  set up flash into Read Array mode, then re-programms watchdog for reset in
+	  the smallest possible delay.
+	  However, this method gives no guarantee, because it requires the kernel 
+	  to be alive and able to handle interrupts. But it may help to recover when 
+	  user-space applications hang.
+endif
+
+endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/at91rm9200_devices.c linux-3.0.x-arm/arch/arm/mach-at91/at91rm9200_devices.c
--- linux-3.0.x-orig/arch/arm/mach-at91/at91rm9200_devices.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/at91rm9200_devices.c	2012-12-19 11:25:55.000000000 +0200
@@ -449,7 +449,7 @@
 	.sda_is_open_drain	= 1,
 	.scl_pin		= AT91_PIN_PA26,
 	.scl_is_open_drain	= 1,
-	.udelay			= 2,		/* ~100 kHz */
+	.udelay			= 6,		/* ~50 kHz */
 };
 
 static struct platform_device at91rm9200_twi_device = {
@@ -513,7 +513,15 @@
  *  SPI
  * -------------------------------------------------------------------- */
 
-#if defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)
+#if defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)		/* legacy SPI driver */
+#define SPI_DEVNAME	"at91_spi"
+
+#elif defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)	/* new SPI driver */
+#define SPI_DEVNAME	"atmel_spi"
+
+#endif
+
+#ifdef SPI_DEVNAME
 static u64 spi_dmamask = DMA_BIT_MASK(32);
 
 static struct resource spi_resources[] = {
@@ -530,7 +538,7 @@
 };
 
 static struct platform_device at91rm9200_spi_device = {
-	.name		= "atmel_spi",
+	.name		= SPI_DEVNAME,
 	.id		= 0,
 	.dev		= {
 				.dma_mask		= &spi_dmamask,
@@ -563,6 +571,12 @@
 		else
 			at91_set_gpio_output(cs_pin, 1);
 
+#if defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)
+		/*
+		 * Force peripheral mode when using the legacy SPI driver.
+		 */
+		at91_set_A_periph(cs_pin, 0);
+#endif
 
 		/* pass chip-select pin to driver */
 		devices[i].controller_data = (void *) cs_pin;
@@ -1139,6 +1153,25 @@
 	}
 }
 
+/* rs485_switch_pin - defines the switching pin and the possibility of switching */
+void __init set_485(unsigned char port, unsigned char init_mode, 
+	unsigned int switch_pin, unsigned char active_level)
+{
+	struct atmel_uart_data *uart_data;
+
+	uart_data = (struct atmel_uart_data*)at91_uarts[port]->dev.platform_data;
+	if (init_mode) {
+		uart_data->rs485.flags |= SER_RS485_ENABLED;
+	} else {
+		uart_data->rs485.flags &= ~SER_RS485_ENABLED;
+	}
+	uart_data->rs485_switch_pin = switch_pin;
+	uart_data->rs485_active_level = active_level;
+	if (switch_pin) {
+		at91_set_gpio_output(switch_pin, !active_level); /* serial driver will init it according to the mode later */
+	}
+}
+
 void __init at91_add_device_serial(void)
 {
 	int i;
@@ -1152,7 +1185,6 @@
 		printk(KERN_INFO "AT91: No default serial console defined.\n");
 }
 #else
-void __init __deprecated at91_init_serial(struct at91_uart_config *config) {}
 void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins) {}
 void __init at91_set_serial_console(unsigned portnr) {}
 void __init at91_add_device_serial(void) {}
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/at91rm9200_time.c linux-3.0.x-arm/arch/arm/mach-at91/at91rm9200_time.c
--- linux-3.0.x-orig/arch/arm/mach-at91/at91rm9200_time.c	2013-09-19 17:39:58.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/at91rm9200_time.c	2013-09-20 18:29:46.000000000 +0300
@@ -32,6 +32,19 @@
 static u32 irqmask;
 static struct clock_event_device clkevt;
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+int at91_wdt_irq_enabled = 1;	/* enabled by default */
+atomic_t at91_wdt_ovf_counter;
+
+static int __init wdt_irq_setup(char *line)
+{
+	at91_wdt_irq_enabled = (int)simple_strtoul(line, NULL, 0);
+	return 1;
+}
+
+__setup("wdt_irq=", wdt_irq_setup);
+#endif
+
 /*
  * The ST_CRTR is updated asynchronously to the master clock ... but
  * the updates as seen by the CPU don't seem to be strictly monotonic.
@@ -56,7 +69,19 @@
  */
 static irqreturn_t at91rm9200_timer_interrupt(int irq, void *dev_id)
 {
+#if !defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
 	u32	sr = at91_sys_read(AT91_ST_SR) & irqmask;
+#else
+	u32 sr;
+	u32 imr = 0;
+
+	if (at91_wdt_irq_enabled) {
+		imr = at91_sys_read(AT91_ST_IMR);
+		sr = at91_sys_read(AT91_ST_SR) & (irqmask | AT91_ST_WDOVF);
+	} else {
+		sr = at91_sys_read(AT91_ST_SR) & irqmask;
+	}
+#endif
 
 	/*
 	 * irqs should be disabled here, but as the irq is shared they are only
@@ -64,6 +89,17 @@
 	 */
 	WARN_ON_ONCE(!irqs_disabled());
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	/* imr is required - as tests revealed OVF flag in SR sometimes is set for no reason */
+	if (at91_wdt_irq_enabled) {
+		if (sr & AT91_ST_WDOVF & imr) {
+			atomic_inc(&at91_wdt_ovf_counter);
+			pr_debug("sys timer irq: WD irq got: SR=0x%08X, IMR=0x%08X\n", sr, imr);
+			return IRQ_NONE;		/* will be handled by watchdog driver's irq handler */
+		}
+	}
+#endif
+
 	/* simulate "oneshot" timer with alarm */
 	if (sr & AT91_ST_ALMS) {
 		clkevt.event_handler(&clkevt);
@@ -109,7 +145,24 @@
 {
 	/* Disable and flush pending timer interrupts */
 	at91_sys_write(AT91_ST_IDR, AT91_ST_PITS | AT91_ST_ALMS);
-	(void) at91_sys_read(AT91_ST_SR);
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (at91_wdt_irq_enabled) {
+		u32 sr = at91_sys_read(AT91_ST_SR);
+		/* check SR for WDOVF after each SR reading in order to not miss the flag */
+		if (sr & AT91_ST_WDOVF) {
+			u32 imr = at91_sys_read(AT91_ST_IMR);
+			if (imr & AT91_ST_WDOVF) {
+				atomic_inc(&at91_wdt_ovf_counter);
+				pr_warn("sys timer %s(): WD irq got in wrong place, SR=0x%08X, IMR=0x%08X\n",
+					__func__, sr, imr);
+			}
+		}
+	} else {
+#endif
+		(void) at91_sys_read(AT91_ST_SR);
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	}
+#endif
 
 	last_crtr = read_CRTR();
 	switch (mode) {
@@ -157,7 +210,26 @@
 
 	/* Cancel any pending alarm; flush any pending IRQ */
 	at91_sys_write(AT91_ST_RTAR, alm);
-	(void) at91_sys_read(AT91_ST_SR);
+
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (at91_wdt_irq_enabled) {
+		u32 sr = at91_sys_read(AT91_ST_SR);
+
+		/* check SR for WDOVF after each SR reading in order to not miss the flag */
+		if (sr & AT91_ST_WDOVF) {
+			u32 imr = at91_sys_read(AT91_ST_IMR);
+			if (imr & AT91_ST_WDOVF) {
+				atomic_inc(&at91_wdt_ovf_counter);
+				pr_warn("sys timer %s(): WD irq got in wrong place, SR=0x%08X, IMR=0x%08X\n",
+					__func__, sr, imr);
+			}
+		}
+	} else {
+#endif
+		(void) at91_sys_read(AT91_ST_SR);
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	}
+#endif
 
 	/* Schedule alarm by writing RTAR. */
 	alm += delta;
@@ -185,6 +257,10 @@
 		AT91_ST_PITS | AT91_ST_WDOVF | AT91_ST_RTTINC | AT91_ST_ALMS);
 	(void) at91_sys_read(AT91_ST_SR);
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	atomic_set(&at91_wdt_ovf_counter, 0);
+#endif
+
 	/* Make IRQs happen for the system timer */
 	setup_irq(AT91_ID_SYS, &at91rm9200_timer_irq);
 
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/at91sam9263_devices.c linux-3.0.x-arm/arch/arm/mach-at91/at91sam9263_devices.c
--- linux-3.0.x-orig/arch/arm/mach-at91/at91sam9263_devices.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/at91sam9263_devices.c	2012-12-19 11:25:55.000000000 +0200
@@ -8,6 +8,8 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
+ * 2010/08/04 Softerra
+ *		- Added initialization of PC0 as LCDVSYNC
  */
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -698,7 +700,6 @@
 void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices) {}
 #endif
 
-
 /* --------------------------------------------------------------------
  *  AC97
  * -------------------------------------------------------------------- */
@@ -828,6 +829,7 @@
 	if (!data)
 		return;
 
+	at91_set_A_periph(AT91_PIN_PC0, 0);     /* LCDVSYNC */
 	at91_set_A_periph(AT91_PIN_PC1, 0);	/* LCDHSYNC */
 	at91_set_A_periph(AT91_PIN_PC2, 0);	/* LCDDOTCK */
 	at91_set_A_periph(AT91_PIN_PC3, 0);	/* LCDDEN */
@@ -1399,6 +1401,51 @@
 	}
 }
 
+/* rs485_switch_pin - defines the switching pin and the possibility of switching */
+void __init set_485(unsigned char port, unsigned char init_mode, 
+	unsigned int switch_pin, unsigned char active_level)
+{
+	struct atmel_uart_data *uart_data;
+
+	uart_data = (struct atmel_uart_data*)at91_uarts[port]->dev.platform_data;
+	if (init_mode) {
+		uart_data->rs485.flags |= SER_RS485_ENABLED;
+	} else {
+		uart_data->rs485.flags &= ~SER_RS485_ENABLED;
+	}
+	uart_data->rs485_switch_pin = switch_pin;
+	uart_data->rs485_active_level = active_level;
+	if (switch_pin) {
+		at91_set_gpio_output(switch_pin, !active_level); /* serial driver will init it according to the mode later */
+	}
+}
+
+/* specify pins for signals: DTR, DSR, DCD, RI) */
+void __init set_full_modem(unsigned char port, unsigned int pin_dtr, 
+			unsigned int pin_dsr, unsigned int pin_dcd, unsigned int pin_ri)
+{
+	struct atmel_uart_data *uart_data;
+
+	uart_data = (struct atmel_uart_data*)at91_uarts[port]->dev.platform_data;
+	uart_data->pin_DTR = pin_dtr;
+	uart_data->pin_DSR = pin_dsr;
+	uart_data->pin_DCD = pin_dcd;
+	uart_data->pin_RI = pin_ri;
+
+	if (pin_dtr) {
+		at91_set_gpio_output(pin_dtr, 1);
+	}
+	if (pin_dsr) {
+		at91_set_gpio_input(pin_dsr, 1);
+	}
+	if (pin_dcd) {
+		at91_set_gpio_input(pin_dcd, 1);
+	}
+	if (pin_ri) {
+		at91_set_gpio_input(pin_ri, 1);
+	}
+}
+
 void __init at91_add_device_serial(void)
 {
 	int i;
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/board-owen-he5684.c linux-3.0.x-arm/arch/arm/mach-at91/board-owen-he5684.c
--- linux-3.0.x-orig/arch/arm/mach-at91/board-owen-he5684.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/board-owen-he5684.c	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,401 @@
+/*
+ * linux/arch/arm/mach-at91/board-owen-he5684.c
+ *
+ *  Copyright (C) 2010 Softerra LLC
+ *
+ * Based on board-owen-plc240.c
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/spi/eeprom.h>
+#include <linux/i2c/at24.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/bootmem.h>
+
+#include <linux/mtd/plat-ram.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/memory.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+#include <mach/system_rev.h>
+#include <mach/at91sam9263_matrix.h>
+
+#if defined(CONFIG_MACB_BB)
+#include <linux/mdio-gpio.h>
+#endif
+
+#include "sam9_smc.h"
+#include "generic.h"
+#include "owen-release.h"
+#include <owen-common.h>
+#include "owen-panic-blink.h"
+
+static void __init ek_init_early(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91sam9263_initialize(18432000);
+
+	/* DBGU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+	
+	/* USART0 on ttyS1. (Rx, Tx only) */
+	at91_register_uart(AT91SAM9263_ID_US0, 1, 0);
+
+	/* USART1 on ttyS2. (Rx, Tx, RTS) - not configured, used by HPR driver */
+	/*at91_register_uart(AT91SAM9263_ID_US1, 1, ATMEL_UART_RTS);*/
+
+	/* USART2 on ttyS3. (Rx, Tx, RTS, CTS) - circuit is not completed */
+	/*at91_register_uart(AT91SAM9263_ID_US2, 1, ATMEL_UART_RTS | ATMEL_UART_CTS);*/
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+
+	/* allocate retain memory shadow buffer */
+	owen_alloc_retain_memory(NULL);
+}
+
+static void __init ek_init_irq(void)
+{
+	at91sam9263_init_interrupts(NULL);
+}
+
+/*
+ * USB Host port
+ */
+static struct at91_usbh_data __initdata ek_usbh_data = {
+	.ports		= 2,
+	
+	/* should satisfy both at91sam9263_devices.c and ohci-at91.c */
+	.vbus_pin	= { 0, 0 }, 
+};
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= 0,
+	.pullup_pin	= 0,		/* pull-up driven by UDC */
+};
+
+/*
+ * SPI devices.
+ */
+static struct spi_eeprom eeprom_data = {
+	.name = "fm25h20",	/* chip marked as RG5H20 */
+	.byte_len = 262144,	/* 256 KB */
+	.page_size = 4092,		/* the max page size for a successful spi transfer(write) as tests have revealed */
+	.flags = EE_ADDR3 | EE_NODELAY_WRITE | EE_ARBITRARY_WRITE,
+};
+
+static struct spi_board_info ek_spi_devices[] = {
+	{
+		.modalias	= "at25",
+		.chip_select	= 2,
+//		.chip_select	= 7, /* for testing: set CONFIG_SPI_ATMEL_CS_COUNT > 7, controller_data is mandatory */
+		.max_speed_hz	= 40 * 1000 * 1000, /* actual rate is close but not exact as specified, e.g. 33109333 Hz */
+		.controller_data = (void*)AT91_PIN_PA4,
+		.platform_data  = &eeprom_data,
+	},
+};
+
+/*
+ * MCI (SD/MMC)
+ */
+static struct at91_mmc_data __initdata ek_mmc_data = {
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PB20,
+/*	.wp_pin		= ... not connected
+	.vcc_pin	= ... not connected
+*/
+};
+
+/*
+ * MACB Ethernet device
+ * 
+ * Note, we have additional RST pin for PHY - PB25
+ */
+#if defined(CONFIG_MACB_BB)
+static struct mdio_gpio_platform_data he5684_mdio_gpio_data = {
+	.mdc = AT91_PIN_PE29,
+	.mdio = AT91_PIN_PE30,
+	.phy_mask = ~0xe, /* ..111 0001 - addresses 1, 2, 3 as specified by 0-bits */
+};
+static struct platform_device he5684_mii_bus_device = {
+	.name	= "mdio-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &he5684_mdio_gpio_data,
+	}
+};
+#endif
+
+static struct at91_eth_data __initdata ek_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PE31,
+	.is_rmii	= 1,
+	.phy_addr	= 3,
+#if defined(CONFIG_MACB_BB)
+	.mii_bus_pdev	= &he5684_mii_bus_device,
+#else
+	.mii_bus_pdev	= NULL,
+#endif
+};
+
+#if defined(CONFIG_MACB) || defined(CONFIG_MACB_MODULE)
+void __init he5684_add_network_devices(void)
+{
+	at91_add_device_eth(&ek_macb_data);
+
+#if defined(CONFIG_MACB_BB)
+	/* set up mdio-gpio pins to be GPIO */
+	at91_set_GPIO_periph(he5684_mdio_gpio_data.mdio, 1);
+	at91_set_GPIO_periph(he5684_mdio_gpio_data.mdc, 1);
+
+	platform_device_register(&he5684_mii_bus_device);
+#endif
+}
+#else
+void __init he5684_add_network_devices(void) {}
+#endif
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata ek_nand_partition[] = {
+	{
+		.name	= "Bootstrap",
+		.offset	= 0,
+		.size	= SZ_4M, //TODO: actually bootstrap+u-boot+env+kernel
+	},
+	{
+		.name	= "root",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(ek_nand_partition);
+	return ek_nand_partition;
+}
+
+static struct atmel_nand_data __initdata ek_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PA22,
+	.enable_pin	= AT91_PIN_PD15,
+	.partition_info	= nand_partitions,
+};
+
+static struct sam9_smc_config __initdata ek_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 3,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 3,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 5,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+	.tdf_cycles		= 2,
+};
+
+static void __init ek_add_device_nand(void)
+{
+	ek_nand_data.bus_width_16 = board_have_nand_16bit();
+	/* setup bus-width (8 or 16) */
+	if (ek_nand_data.bus_width_16)
+		ek_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &ek_nand_smc_config);
+
+	at91_add_device_nand(&ek_nand_data);
+}
+
+/*
+ * I2C devices
+ */
+static struct i2c_board_info __initdata ek_i2c_devices[] = {
+	{	/* RTC DS1340 */
+		I2C_BOARD_INFO("ds1340", 0x68),
+	},
+};
+                                                                                  
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button owen_he5684_buttons[] = {
+	{	/* BTN, "KN", SB2 */
+		.code		= BTN_0,
+		.gpio		= AT91_PIN_PB19,
+		.active_low	= 1,
+		.desc		= "kn",
+		.wakeup		= 1,
+	},
+	
+	/* The next two are actually a tumbler SA2 */
+	{	/* BTN, "TUM1" */
+		.code		= BTN_1,
+		.gpio		= AT91_PIN_PB21,
+		.active_low	= 1,
+		.desc		= "tum1",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "TUM2" */
+		.code		= BTN_2,
+		.gpio		= AT91_PIN_PB22,
+		.active_low	= 1,
+		.desc		= "tum2",
+		.wakeup		= 1,
+	},
+};
+
+static struct gpio_keys_platform_data owen_he5684_button_data = {
+	.buttons	= owen_he5684_buttons,
+	.nbuttons	= ARRAY_SIZE(owen_he5684_buttons),
+};
+
+static struct platform_device owen_he5684_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &owen_he5684_button_data,
+	}
+};
+
+static void __init owen_he5684_add_device_buttons(void)
+{
+	at91_set_GPIO_periph(AT91_PIN_PB19, 1);	/* BTN, "KN" */
+	at91_set_deglitch(AT91_PIN_PB19, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB21, 1);	/* BTN, "TUM1" */
+	at91_set_deglitch(AT91_PIN_PB21, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB22, 1);	/* BTN, "TUM2" */
+	at91_set_deglitch(AT91_PIN_PB22, 1);
+
+	platform_device_register(&owen_he5684_button_device);
+}
+#else
+static void __init owen_he5684_add_device_buttons(void) {}
+#endif
+
+/*
+ * LEDs ... these could all be PWM-driven, for variable brightness
+ */
+static struct gpio_led owen_he5684_leds[] = {
+	{	/* SV1 */
+		.name			= "power",
+		.gpio			= AT91_PIN_PE1,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV2 */
+		.name			= "err",
+		.gpio			= AT91_PIN_PE2,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV3 */
+		.name			= "stat",
+		.gpio			= AT91_PIN_PE3,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV4 */
+		.name			= "bs",
+		.gpio			= AT91_PIN_PE4,
+		.active_low		= 0,
+		.default_trigger	= "mmc0",
+	},
+	{	/* SV5 */
+		.name			= "s",
+		.gpio			= AT91_PIN_PE5,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV6 */
+		.name			= "rx",
+		.gpio			= AT91_PIN_PE6,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV7 */
+		.name			= "tx",
+		.gpio			= AT91_PIN_PE7,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+};
+
+static void __init ek_board_init(void)
+{
+	/* setup blinking of the LED "err" when kernel is panic */
+	owen_setup_panic_blink(owen_he5684_leds[1].gpio);
+	/* Serial */
+	at91_add_device_serial();
+	/* USB Host */
+	at91_add_device_usbh(&ek_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&ek_udc_data);
+	/* SPI */
+	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
+	/* MMC */
+	at91_add_device_mmc(1, &ek_mmc_data);
+	/* Ethernet */
+	he5684_add_network_devices();
+	/* NAND */
+	ek_add_device_nand();
+	/* I2C */
+	at91_add_device_i2c(ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
+	/* Push Buttons */
+	owen_he5684_add_device_buttons();
+	/* LEDs */
+	at91_gpio_leds(owen_he5684_leds, ARRAY_SIZE(owen_he5684_leds));
+
+	/* shutdown controller, wakeup button (5 msec low) */
+	//at91_sys_write(AT91_SHDW_MR, AT91_SHDW_CPTWK0_(10) | AT91_SHDW_WKMODE0_LOW
+	//			| AT91_SHDW_RTTWKEN);
+	system_serial_low = OWEN_RELEASE;
+	owen_setup_rm_info_iface();
+}
+
+MACHINE_START(OWEN_HE5684, "Owen HE5684")
+	/* Maintainer: Softerra LLC */
+	.timer		= &at91sam926x_timer,
+	.map_io		= at91sam9263_map_io,
+	.init_early	= ek_init_early,
+	.init_irq	= ek_init_irq,
+	.init_machine	= ek_board_init,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc240.c linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc240.c
--- linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc240.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc240.c	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,765 @@
+/*
+ * linux/arch/arm/mach-at91/board-owen-plc240.c
+ *
+ *  Copyright (C) 2010 Softerra LLC
+ *
+ * Based on OWEN's board-owen-plc240.c (from linux-2.6.34), 
+ * which is based on board-sam9263ek.c
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/spi/eeprom.h>
+#include <linux/i2c/at24.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+
+#include <linux/mtd/plat-ram.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+#include <mach/system_rev.h>
+#include <mach/at91sam9263_matrix.h>
+#include <mach/at91_rstc.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+#include "owen-release.h"
+#include <owen-common.h>
+
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+static struct owen_rm_info __initdata owen_rm;
+#endif
+
+#if defined(CONFIG_OWEN_PLC240_SPK210)
+static void owen_plc240_reset(void)
+{
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST | AT91_RSTC_EXTRST);
+}
+#endif
+
+static void __init ek_init_early(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91sam9263_initialize(18432000);
+	/* redefine reset function for SPK210: include external reset */
+#if defined(CONFIG_OWEN_PLC240_SPK210)
+	at91_arch_reset = owen_plc240_reset;
+#endif
+
+	/* DBGU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+
+	/* USART0 on ttyS1. (Rx, Tx, RTS, CTS + GPIO: DTR, DSR, DCD, RI) */
+	at91_register_uart(AT91SAM9263_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS);
+	set_full_modem(1, AT91_PIN_PA17, AT91_PIN_PA20, AT91_PIN_PA23, AT91_PIN_PA24);
+
+	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9263_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
+#if !(defined(CONFIG_CAN_AT91) || defined(CONFIG_CAN_AT91_MODULE))
+	/* not CAN - run-time switching enabled (default state: RS232) */
+	set_485(2, 0, AT91_PIN_PB8, 0);
+#endif
+
+	/* USART2 on ttyS3. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9263_ID_US2, 3, ATMEL_UART_CTS | ATMEL_UART_RTS);
+	/* run-time switching enabled (default state: RS232) */
+	set_485(3, 0, AT91_PIN_PB12, 0);
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	/* allocate retain memory shadow buffer */
+	owen_alloc_retain_memory(&owen_rm);
+#endif
+}
+
+static void __init ek_init_irq(void)
+{
+	at91sam9263_init_interrupts(NULL);
+}
+
+/*
+ * USB Host port
+ */
+static struct at91_usbh_data __initdata ek_usbh_data = {
+	.ports		= 2,
+	.vbus_pin	= { AT91_PIN_PE13, AT91_PIN_PE14 },
+};
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata ek_udc_data = {
+	.vbus_pin	= AT91_PIN_PB18,
+	.pullup_pin	= AT91_PIN_PB19,		/* pull-up driven by UDC */
+};
+
+/*
+ * ADS7846 Touchscreen
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+static int ads7843_pendown_state(void)
+{
+	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
+}
+
+static struct ads7846_platform_data ads_info = {
+	.model			= 7843,
+	.x_plate_ohms		= 660,
+	.y_plate_ohms		= 300,
+	.pressure_max		= 15000,
+	.keep_vref_on           = true,
+	.settle_delay_usecs	= 150,
+	.debounce_max		= 10,
+	.debounce_rep		= 4,
+	.debounce_tol		= 5,
+	.get_pendown_state	= ads7843_pendown_state,
+};
+
+static void __init ek_add_device_ts(void)
+{
+	at91_set_B_periph(AT91_PIN_PA15, 1);	/* External IRQ1, with pullup */
+	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* Touchscreen BUSY signal */
+}
+#else
+static void __init ek_add_device_ts(void) {}
+#endif
+
+/*
+ * SPI devices.
+ */
+
+static struct spi_eeprom eeprom_data = {
+	.name = "mr25h10",
+	.byte_len = 131072,	/* 128 KB */
+	.page_size = 4092,		/* the max page size for a successful spi transfer(4 byte WRITE + 4092=PAGE_SIZE ) */
+	.flags = EE_ADDR3 | EE_NODELAY_WRITE | EE_ARBITRARY_WRITE,
+};
+
+static struct spi_board_info ek_spi_devices[] = {
+#if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
+	{	/* DataFlash card */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+	},
+#endif
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias	= "ads7846",
+		.chip_select	= 3,
+		.max_speed_hz	= 125000 * 16,	/* max sample rate * clocks per sample */
+		.bus_num	= 0,
+		.platform_data	= &ads_info,
+		.irq		= AT91SAM9263_ID_IRQ1,
+	},
+#endif
+	{
+		.modalias	= "at25",
+		.chip_select	= 1,
+		.max_speed_hz	= 40 * 1000 * 1000, /* actual rate is close but not exact as specified, e.g. 33109333 Hz */
+		.controller_data = (void*)AT91_PIN_PA3,
+		.platform_data  = &eeprom_data,
+	},
+	{ /* peripheral processor on ATtiny */
+		.modalias = "spidev",
+		.chip_select = 2,
+		.max_speed_hz = 400 * 1000,
+		.bus_num = 0,
+		.mode = SPI_MODE_0,
+	},
+};
+
+/*
+ * MCI (SD/MMC)
+ * uses MCI1 (PA6), slot A (PA7), 4 data wires(PA8-PA11), CD signal (PE18)
+ */
+static struct at91_mmc_data __initdata ek_mmc_data = {
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PE18,
+//	.wp_pin		= ... not connected
+//	.vcc_pin	= ... not connected
+};
+
+/*
+ * MACB Ethernet device
+ */
+static struct at91_eth_data __initdata ek_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PE31,
+	.is_rmii	= 1,
+};
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata ek_nand_partition[] = {
+	{
+		.name	= "Bootstrap",
+		.offset	= 0,
+		.size	= SZ_4M, //TODO: actually bootstrap+u-boot+env+kernel
+	},
+	{
+		.name	= "root",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(ek_nand_partition);
+	return ek_nand_partition;
+}
+
+static struct atmel_nand_data __initdata ek_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PA22,
+	.enable_pin	= AT91_PIN_PD15,
+	.partition_info	= nand_partitions,
+};
+
+static struct sam9_smc_config __initdata ek_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 3,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 3,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 5,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+	.tdf_cycles		= 2,
+};
+
+static void __init ek_add_device_nand(void)
+{
+	ek_nand_data.bus_width_16 = board_have_nand_16bit();
+	/* setup bus-width (8 or 16) */
+	if (ek_nand_data.bus_width_16)
+		ek_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		ek_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &ek_nand_smc_config);
+
+	at91_add_device_nand(&ek_nand_data);
+}
+
+//TODO: test and recheck code related to NVRAM and LCD
+/*
+ * NVRAM ( AS6C4008 - 2MiB battery buffered SRAM, 8 bit width )
+ */
+#if defined(CONFIG_MTD_PLATRAM)
+static struct sam9_smc_config __initdata owen_plc240_nvram_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 0,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 0,
+
+	.ncs_read_pulse		= 0x0A,
+	.nrd_pulse		= 8,
+	.ncs_write_pulse	= 0x0A,
+	.nwe_pulse		= 8,
+
+	.read_cycle		= 0x0A,
+	.write_cycle		= 0x0A,
+
+	.mode			= AT91_SMC_BAT_WRITE | AT91_SMC_PS_8,
+	.tdf_cycles		= 0,
+};
+
+struct platdata_mtd_ram owen_plc240_nvram_pdata = {
+	.mapname	= "SRAM",
+	.bankwidth	= 1,
+};
+
+static struct resource owen_plc240_nvram_resource[] = {
+	[0] = {
+		.start = AT91_CHIPSELECT_6,
+		.end   = AT91_CHIPSELECT_6 + SZ_512K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device owen_plc240_nvram = {
+	.name		= "mtd-ram",
+	.id		= 0,
+	.resource	= owen_plc240_nvram_resource,
+	.num_resources	= ARRAY_SIZE(owen_plc240_nvram_resource),
+	.dev	= {
+		.platform_data = &owen_plc240_nvram_pdata,
+	},
+};
+
+static struct platform_device *owen_plc240_nvram_device[] __initdata = {
+	&owen_plc240_nvram
+};
+
+void __init sam9_smc1_configure(int cs, struct sam9_smc_config* config)
+{
+	/* Setup register */
+	at91_sys_write(AT91_SMC1_SETUP(cs),
+		  AT91_SMC_NWESETUP_(config->nwe_setup)
+		| AT91_SMC_NCS_WRSETUP_(config->ncs_write_setup)
+		| AT91_SMC_NRDSETUP_(config->nrd_setup)
+		| AT91_SMC_NCS_RDSETUP_(config->ncs_read_setup)
+	);
+
+	/* Pulse register */
+	at91_sys_write(AT91_SMC1_PULSE(cs),
+		  AT91_SMC_NWEPULSE_(config->nwe_pulse)
+		| AT91_SMC_NCS_WRPULSE_(config->ncs_write_pulse)
+                | AT91_SMC_NRDPULSE_(config->nrd_pulse)
+		| AT91_SMC_NCS_RDPULSE_(config->ncs_read_pulse)
+	);
+
+	/* Cycle register */
+	at91_sys_write(AT91_SMC1_CYCLE(cs),
+		  AT91_SMC_NWECYCLE_(config->write_cycle)
+		| AT91_SMC_NRDCYCLE_(config->read_cycle)
+	);
+
+	/* Mode register */
+	at91_sys_write(AT91_SMC1_MODE(cs),
+		  config->mode
+		| AT91_SMC_TDF_(config->tdf_cycles)
+	);
+}
+
+static void __init owen_plc240_add_device_nvram(void)
+{
+	/* Enable CS3  3.3v, no pull-ups */
+	unsigned long csa;
+	csa = at91_sys_read(AT91_MATRIX_EBI1CSA);
+	at91_sys_write(AT91_MATRIX_EBI1CSA,
+		       csa | AT91_MATRIX_EBI1_DBPUC |
+		       AT91_MATRIX_EBI1_VDDIOMSEL_3_3V);
+
+	/* configure chip-select 0 EBI1 (NVRAM) */
+	sam9_smc1_configure(0, &owen_plc240_nvram_smc_config);
+	platform_add_devices(owen_plc240_nvram_device, ARRAY_SIZE(owen_plc240_nvram_device));
+}
+#else
+static void __init owen_plc240_add_device_nvram(void) {}
+#endif
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+/* Innolux - 8", 800x480, LVDS */
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+		.name		= "AT070TN83 @ 60",
+		.refresh	= 60,
+		.xres		= 800,		.yres		= 480,
+		.pixclock	= KHZ2PICOS(30000),
+
+		.left_margin	= 40,		.right_margin	= 40,
+		.upper_margin	= 13,		.lower_margin	= 29,
+		.hsync_len	= 4,		.vsync_len	= 1,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "Inno",	/* "Innolux" - the field is 4 bytes long */
+	.monitor	= "AT070TN83",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 10000,
+	.hfmax		= 35000,
+	.vfmin		= 40,
+	.vfmax		= 90,
+	.dclkmax	= 35000000,
+};
+
+#define AT91SAM9263_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata owen_plc240_lcdc_data = {
+	.lcdcon_is_backlight		= true,
+	.default_bpp			= 24,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9263_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.lcd_wiring_mode		= ATMEL_LCDC_WIRING_RGB,
+	.guard_time			= 2,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata owen_plc240_lcdc_data;
+#endif
+
+
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button owen_plc240_buttons[] = {
+	{	/* BTN, "KN1" */
+		.code		= BTN_0,
+		.gpio		= AT91_PIN_PB22,
+		.active_low	= 1,
+		.desc		= "kn1",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN2" */
+		.code		= BTN_1,
+		.gpio		= AT91_PIN_PB23,
+		.active_low	= 1,
+		.desc		= "kn2",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN3" */
+		.code		= BTN_2,
+		.gpio		= AT91_PIN_PB24,
+		.active_low	= 1,
+		.desc		= "kn3",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN4" */
+		.code		= BTN_3,
+		.gpio		= AT91_PIN_PB25,
+		.active_low	= 1,
+		.desc		= "kn4",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN5" */
+		.code		= BTN_4,
+		.gpio		= AT91_PIN_PB26,
+		.active_low	= 1,
+		.desc		= "kn5",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN6" */
+		.code		= BTN_5,
+		.gpio		= AT91_PIN_PB27,
+		.active_low	= 1,
+		.desc		= "kn6",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN7" */
+		.code		= BTN_6,
+		.gpio		= AT91_PIN_PB28,
+		.active_low	= 1,
+		.desc		= "kn7",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN8" */
+		.code		= BTN_7,
+		.gpio		= AT91_PIN_PB29,
+		.active_low	= 1,
+		.desc		= "kn8",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN9" */
+		.code		= BTN_8,
+		.gpio		= AT91_PIN_PB30,
+		.active_low	= 1,
+		.desc		= "kn9",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN10" */
+		.code		= BTN_9,
+		.gpio		= AT91_PIN_PB31,
+		.active_low	= 1,
+		.desc		= "kn10",
+		.wakeup		= 1,
+	}
+};
+
+static struct gpio_keys_platform_data owen_plc240_button_data = {
+	.buttons	= owen_plc240_buttons,
+	.nbuttons	= ARRAY_SIZE(owen_plc240_buttons),
+};
+
+static struct platform_device owen_plc240_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &owen_plc240_button_data,
+	}
+};
+
+static void __init owen_plc240_add_device_buttons(void)
+{
+	at91_set_GPIO_periph(AT91_PIN_PB22, 1);	/* BTN, "KN1" */
+	at91_set_deglitch(AT91_PIN_PB22, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB23, 1);	/* BTN, "KN2" */
+	at91_set_deglitch(AT91_PIN_PB23, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB24, 1);	/* BTN, "KN3" */
+	at91_set_deglitch(AT91_PIN_PB24, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB25, 1);	/* BTN, "KN4" */
+	at91_set_deglitch(AT91_PIN_PB25, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB26, 1);	/* BTN, "KN5" */
+	at91_set_deglitch(AT91_PIN_PB26, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB27, 1);	/* BTN, "KN6" */
+	at91_set_deglitch(AT91_PIN_PB27, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB28, 1);	/* BTN, "KN7" */
+	at91_set_deglitch(AT91_PIN_PB28, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB29, 1);	/* BTN, "KN8" */
+	at91_set_deglitch(AT91_PIN_PB29, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB30, 1);	/* BTN, "KN9" */
+	at91_set_deglitch(AT91_PIN_PB30, 1);
+	at91_set_GPIO_periph(AT91_PIN_PB31, 1);	/* BTN, "KN10" */
+	at91_set_deglitch(AT91_PIN_PB31, 1);
+	at91_set_gpio_input(AT91_PIN_PB10, 0);	/* Tumbler */
+	at91_set_deglitch(AT91_PIN_PB10, 1);
+#if defined(CONFIG_OWEN_PLC240_SPK210)
+	at91_set_gpio_input(AT91_PIN_PB7, 0);	/* Tumbler 2 */
+	at91_set_deglitch(AT91_PIN_PB7, 1);
+#endif
+
+	platform_device_register(&owen_plc240_button_device);
+}
+#else
+static void __init owen_plc240_add_device_buttons(void) {}
+#endif
+
+/*
+ * AC97
+ * Reset PIN is connected to NRST and NR_PHY (PB21) 
+ * on both SPK207 and SPK210
+ */
+static struct ac97c_platform_data ek_ac97_data = {
+	/*.reset_pin	= AT91_PIN_PB21,*/  //TODO: why commented?
+};
+
+#if defined(CONFIG_OWEN_PLC240_SPK210)
+static struct i2c_board_info __initdata spk210_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("ds1340", 0x68),	/* DD7: DS1340 */
+	},
+};
+#endif
+
+/*
+ * LEDs ... these could all be PWM-driven, for variable brightness
+ */
+static struct gpio_led owen_plc240_leds[] = {
+	{	/* SV1 */
+		.name			= "sv1",
+		.gpio			= AT91_PIN_PE0,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV2 */
+		.name			= "sv2",
+		.gpio			= AT91_PIN_PE1,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV3 */
+		.name			= "sv3",
+		.gpio			= AT91_PIN_PE2,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV4 */
+		.name			= "sv4",
+		.gpio			= AT91_PIN_PE3,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV5 */
+		.name			= "sv5",
+		.gpio			= AT91_PIN_PE4,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV6 */
+		.name			= "sv6",
+		.gpio			= AT91_PIN_PE5,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV7 */
+		.name			= "sv7",
+		.gpio			= AT91_PIN_PE6,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV8 */
+		.name			= "sv8",
+		.gpio			= AT91_PIN_PE7,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV9 */
+		.name			= "sv9",
+		.gpio			= AT91_PIN_PE8,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV10 */
+		.name			= "sv10",
+		.gpio			= AT91_PIN_PE9,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* G0 */
+		.name			= "buzzer",
+		.gpio			= AT91_PIN_PA30,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* G0 */
+		.name			= "g0",
+		.gpio			= AT91_PIN_PB16,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* G1 */
+		.name			= "g1",
+		.gpio			= AT91_PIN_PB17,
+		.active_low		= 0,
+		.default_trigger	= "nand-disk",
+	},
+	{	/* G2 */
+		.name			= "g2",
+		.gpio			= AT91_PIN_PA21,
+		.default_trigger	= "heartbeat",
+	},
+	{	/* READY */
+		.name			= "ready",
+		.gpio			= AT91_PIN_PB20,
+		.default_trigger	= "none",
+	}
+};
+
+#if 0
+/*
+ * PWM Leds
+ */
+static struct gpio_led ek_pwm_led[] = {
+	/* For now only DS1 is PWM-driven (by pwm1) */
+	{
+		.name			= "ds1",
+		.gpio			= 1,	/* is PWM channel number */
+		.active_low		= 1,
+		.default_trigger	= "none",
+	}
+};
+#endif
+
+/*
+ * CAN
+ */
+#if defined(CONFIG_CAN_AT91) || defined(CONFIG_CAN_AT91_MODULE)
+static void sam9263ek_transceiver_switch(int on)
+{
+	if (on) {
+		at91_set_gpio_output(AT91_PIN_PA18, 1); /* CANRXEN */
+		at91_set_gpio_output(AT91_PIN_PA19, 0); /* CANRS */
+	} else {
+		at91_set_gpio_output(AT91_PIN_PA18, 0); /* CANRXEN */
+		at91_set_gpio_output(AT91_PIN_PA19, 1); /* CANRS */
+	}
+}
+
+static struct at91_can_data owen_plc240_can_data = {
+	.transceiver_switch = sam9263ek_transceiver_switch,
+};
+#else
+static struct at91_can_data owen_plc240_can_data = {};
+#endif
+
+static void __init ek_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* USB Host */
+	at91_add_device_usbh(&ek_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&ek_udc_data);
+	/* SPI */
+	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
+	/* Touchscreen */
+	ek_add_device_ts();
+	/* MMC */
+	at91_add_device_mmc(1, &ek_mmc_data);
+	/* Ethernet */
+	at91_add_device_eth(&ek_macb_data);
+	/* NAND */
+	ek_add_device_nand();
+	/* I2C */
+#if defined(CONFIG_OWEN_PLC240_SPK210)
+	at91_add_device_i2c(spk210_i2c_devices, ARRAY_SIZE(spk210_i2c_devices));
+	//setup external interrupt delay, 2E(14+1)=32768ticks, 1tick is 30us => delay = 32768*30us=1s
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY | (14<<8) | AT91_RSTC_URSTEN);
+#endif
+	/* LCD Controller */
+	at91_add_device_lcdc(&owen_plc240_lcdc_data);
+	/* Push Buttons */
+	owen_plc240_add_device_buttons();
+	/* AC97 */
+	at91_add_device_ac97(&ek_ac97_data);
+	/* LEDs */
+	at91_gpio_leds(owen_plc240_leds, ARRAY_SIZE(owen_plc240_leds));
+	//at91_pwm_leds(ek_pwm_led, ARRAY_SIZE(ek_pwm_led));
+
+	/* CAN */
+	at91_add_device_can(&owen_plc240_can_data);
+	/* NVRAM */
+	owen_plc240_add_device_nvram();
+
+	/* shutdown controller, wakeup button (5 msec low) */
+	//at91_sys_write(AT91_SHDW_MR, AT91_SHDW_CPTWK0_(10) | AT91_SHDW_WKMODE0_LOW
+	//			| AT91_SHDW_RTTWKEN);
+	system_serial_low = OWEN_RELEASE;
+
+	/* setup LPVD FIQ handler as need */
+#if defined(CONFIG_OWEN_LPVD_FIQ)	
+	owen_setup_lpvd_fiq(ek_spi_devices, ARRAY_SIZE(ek_spi_devices), "at25", &owen_rm);
+#endif
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	owen_setup_rm_info_iface();
+#endif
+}
+
+MACHINE_START(OWEN_PLC240, "Owen PLC240")
+	/* Maintainer: Softerra LLC */
+	.timer		= &at91sam926x_timer,
+	.map_io		= at91sam9263_map_io,
+	.init_early	= ek_init_early,
+	.init_irq	= ek_init_irq,
+	.init_machine	= ek_board_init,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc304.c linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc304.c
--- linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc304.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc304.c	2013-08-23 18:09:53.000000000 +0300
@@ -0,0 +1,267 @@
+/*
+ * linux/arch/arm/mach-at91/board-owen-plc304.c
+ *
+ *  Copyright (C) 2010 Mikhail Lodigin, Softerra LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/mtd/physmap.h>
+#include <linux/bootmem.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91rm9200_mc.h>
+
+#include "generic.h"
+#include "owen-release.h"
+#include <owen-common.h>
+#include "owen-panic-blink.h"
+
+#ifdef CONFIG_MACH_OWEN_PLC304_DK
+char is_dbg_console[3];
+
+static int __init dbg_console_setup(char *line)
+{
+	memcpy(is_dbg_console, line, 3);
+	return 1;
+}
+
+__setup("dbg=", dbg_console_setup);
+#endif /* CONFIG_MACH_OWEN_PLC304_DK */
+
+static void __init dk_init_early(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91rm9200_initialize(18432000);
+
+	/* Setup the LEDs */
+	at91_init_leds(AT91_PIN_PB2, AT91_PIN_PB2);
+
+	/* USART0 on ttyS1. (Rx, Tx, CTS, RTS) */
+	at91_register_uart(AT91RM9200_ID_US0, 1, ATMEL_UART_CTS);
+	at91_set_A_periph(AT91_PIN_PD21, 0);	/* non-standard RTS0 - not broken (instead of broken PA21) */
+
+	/* USART1 on ttyS2. (Rx, Tx, CTS, RTS, DTR, DSR, DCD) */
+	at91_register_uart(AT91RM9200_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS | ATMEL_UART_DSR | ATMEL_UART_DCD);
+	at91_set_A_periph(AT91_PIN_PD25, 0);	/* non-standard DTR1 */
+
+	/* USART3 on ttyS4. (Rx, Tx, CTS, RTS) */
+	at91_register_uart(AT91RM9200_ID_US3, 4, ATMEL_UART_CTS | ATMEL_UART_RTS);
+
+	/* allocate retain memory shadow buffer */
+	owen_alloc_retain_memory(NULL);
+}
+
+static void __init dk_init_irq(void)
+{
+	at91rm9200_init_interrupts(NULL);
+}
+
+static struct at91_eth_data __initdata dk_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PA25,
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	.phy_rst_pin	= AT91_PIN_PB9,
+#endif
+	.is_rmii	= 0,
+};
+
+static struct at91_usbh_data __initdata dk_usbh_data = {
+	.ports		= 2,
+};
+
+static struct at91_udc_data __initdata dk_udc_data = {
+	.vbus_pin = AT91_PIN_PA19,
+	.pullup_pin = AT91_PIN_PA24,
+};
+
+static struct at91_mmc_data __initdata dk_mmc_data = {
+	.slot_b		= 0,
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PB10,
+};
+
+static struct spi_eeprom eeprom_25lc512 = {
+		.name = "25lc512",
+		.byte_len = 65536,
+		.page_size = 128,
+		.flags = EE_ADDR2,
+
+		                            
+		                     
+		                                  
+		                                                                                  
+		//                                                                                                       
+};
+
+static struct spi_board_info dk_spi_devices[] = {
+	{	/* RTC DS1390 */
+		.modalias	= "rtc-ds1390",
+		.chip_select	= 1,
+//		.chip_select	= 8, /* for testing: set CONFIG_SPI_ATMEL_CS_COUNT > 8, controller_data is mandatory */
+		.max_speed_hz	= 250 *  1000,
+		//.bus_num	= 0,
+		.controller_data = (void*)AT91_PIN_PA4,
+	},
+	{	/* EEPROM Microchip, driver is equivalent of at25  */
+		.modalias	= "at25",
+		.chip_select	= 2,
+//		.chip_select	= 9, /* for testing: set CONFIG_SPI_ATMEL_CS_COUNT > 9, controller_data is mandatory */
+		.max_speed_hz	= 20 * 1000 * 1000,
+		.controller_data = (void*) AT91_PIN_PD19,
+		.platform_data	= &eeprom_25lc512,
+		//.bus_num	= 0,
+	},
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	{	/* DataFlash card */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 3,
+		.max_speed_hz	= 15 * 1000 * 1000,
+	}
+#endif
+};
+
+static void plc304_gpio_init(void)
+{
+	at91_set_gpio_output(AT91_PIN_PB22, 0);	/* G0 */
+	at91_set_gpio_output(AT91_PIN_PB27, 1);	/* G1 */
+	at91_set_gpio_output(AT91_PIN_PB28, 0);	/* G2 */
+	at91_set_gpio_output(AT91_PIN_PD26, 1);	/* G3 */
+	at91_set_gpio_input(AT91_PIN_PC0, 0);	/* DIP1 */
+	at91_set_gpio_input(AT91_PIN_PC1, 0);	/* DIP2 */
+	at91_set_gpio_input(AT91_PIN_PC2, 0);	/* DIP3 */
+	at91_set_gpio_input(AT91_PIN_PC3, 0);	/* DIP4 */
+
+	/* switching RS232/485 at runtime disabled */
+
+	if (!at91_get_gpio_value(AT91_PIN_PC0))
+	{
+		at91_set_gpio_output(AT91_PIN_PD0, 0);	/* ttyS1 is using 485 interface */
+		set_485(1, 1, 0, 0);
+	}
+	else
+	{
+		at91_set_gpio_output(AT91_PIN_PD0, 1);	/* ttyS1 is using 232 interface */
+		set_485(1, 0, 0, 0);
+	}
+	if (!at91_get_gpio_value(AT91_PIN_PC3))
+	{
+		at91_set_gpio_output(AT91_PIN_PD3, 0);	/* ttyS4 is using 485 interface */
+		set_485(4, 1, 0, 0);
+	}
+	else
+	{
+		set_485(4, 0, 0, 0);
+		at91_set_gpio_output(AT91_PIN_PD3, 1);	/* ttyS4 is using 232 interface */
+	}
+}
+
+#define DK_FLASH_BASE	AT91_CHIPSELECT_0
+#define DK_FLASH_SIZE	SZ_16M
+
+static struct physmap_flash_data dk_flash_data = {
+	.width		= 2,
+};
+
+static struct resource dk_flash_resource = {
+	.start		= DK_FLASH_BASE,
+	.end		= DK_FLASH_BASE + DK_FLASH_SIZE - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device dk_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+				.platform_data	= &dk_flash_data,
+			},
+	.resource	= &dk_flash_resource,
+	.num_resources	= 1,
+};
+
+static void plc304_uart_dbg_setup(void)
+{
+#ifdef CONFIG_MACH_OWEN_PLC304_DK
+	if (memcmp(is_dbg_console, "yes",3))
+#else
+	at91_set_gpio_input(AT91_PIN_PC2, 0);	/* DIP3 */
+
+	if (at91_get_gpio_value(AT91_PIN_PC2))
+#endif /* CONFIG_MACH_OWEN_PLC304_DK */
+		at91_register_uart(AT91RM9200_ID_US2, 3, ATMEL_UART_CTS | ATMEL_UART_RTS);/* USART2 on ttyS3. (Rx, Tx, CTS, RTS) */
+	else
+	{
+		at91_register_uart(0, 0, 0);
+		at91_set_serial_console(0);
+	}
+}
+
+static void __init dk_board_init(void)
+{
+	/* setup blinking of the LED "err" when kernel is panic */
+	owen_setup_panic_blink(AT91_PIN_PB2);
+
+	/* choose between debug console and USART3*/
+	plc304_uart_dbg_setup();
+
+	/* Serial */
+	at91_add_device_serial();
+	/* Ethernet */
+	at91_add_device_eth(&dk_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&dk_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&dk_udc_data);
+	at91_set_multi_drive(dk_udc_data.pullup_pin, 1);	/* pullup_pin is connected to reset */
+	/* SPI */
+	at91_add_device_spi(dk_spi_devices, ARRAY_SIZE(dk_spi_devices));
+	/* MMC */
+	at91_set_gpio_output(AT91_PIN_PB7, 1);	/* this MMC card slot can optionally use SPI signaling (CS3). */
+	at91_add_device_mmc(0, &dk_mmc_data);
+	/* NOR Flash */
+	platform_device_register(&dk_flash);
+
+	/* inputs and outputs */
+	plc304_gpio_init();
+
+	system_serial_low = OWEN_RELEASE;
+	owen_setup_rm_info_iface();
+}
+
+MACHINE_START(OWEN_PLC304, "Owen PLC304")
+	/* Maintainer: SAN People/Atmel */
+	.timer		= &at91rm9200_timer,
+	.map_io		= at91rm9200_map_io,
+	.init_early	= dk_init_early,
+	.init_irq	= dk_init_irq,
+	.init_machine	= dk_board_init,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc323.c linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc323.c
--- linux-3.0.x-orig/arch/arm/mach-at91/board-owen-plc323.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/board-owen-plc323.c	2013-08-23 18:09:53.000000000 +0300
@@ -0,0 +1,347 @@
+/*
+ * linux/arch/arm/mach-at91/board-owen-plc323.c
+ *
+ *  Copyright (C) 2012 Mikhail Lodigin, Softerra LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/mtd/physmap.h>
+#include <linux/bootmem.h>
+#include <linux/can/platform/mcp251x.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91rm9200_mc.h>
+
+#include "generic.h"
+#include "owen-release.h"
+#include <owen-common.h>
+
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+static struct owen_rm_info __initdata owen_rm;
+#endif
+
+static void __init dk_init_early(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91rm9200_initialize(18432000);
+
+	/* USART0 on ttyS1. (Rx, Tx, RTS) */
+	at91_register_uart(AT91RM9200_ID_US0, 1, 0); /* RTS0 & CTS0 are not used */
+
+	/* USART1 on ttyS2. (Rx, Tx, CTS, RTS, DTR, DSR, DCD) */
+	at91_register_uart(AT91RM9200_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS | ATMEL_UART_DSR | ATMEL_UART_DCD);
+	at91_set_A_periph(AT91_PIN_PD25, 0);	/* non-standard DTR1 */
+
+	/* USART2 on ttyS3. (Rx, Tx, RTS) */
+	at91_register_uart(AT91RM9200_ID_US2, 3, 0);
+	at91_set_A_periph(AT91_PIN_PD23, 0);	/* non-standard RTS2 pin */
+
+	/* USART3 on ttyS4. (Rx, Tx, RTS) */
+	at91_register_uart(AT91RM9200_ID_US3, 4, ATMEL_UART_RTS);
+
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	/* allocate retain memory shadow buffer */
+	owen_alloc_retain_memory(&owen_rm);
+#endif
+}
+
+static void __init dk_init_irq(void)
+{
+	at91rm9200_init_interrupts(NULL);
+}
+
+static struct at91_eth_data __initdata dk_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PA25,
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	.phy_rst_pin	= AT91_PIN_PB9,
+#endif
+	.is_rmii	= 0,
+};
+
+static struct at91_usbh_data __initdata dk_usbh_data = {
+	.ports		= 1,
+};
+
+static struct at91_udc_data __initdata dk_udc_data = {
+	.vbus_pin	= 0,
+	.pullup_pin	= AT91_PIN_PA24,
+};
+
+static struct at91_mmc_data __initdata dk_mmc_data = {
+	.slot_b		= 0,
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PB10,
+};
+
+static int mcp251x_common_setup(struct spi_device *spi)
+{
+	switch (spi->irq) {
+		case AT91RM9200_ID_IRQ0:
+			at91_set_A_periph(AT91_PIN_PB29, 0);
+			break;
+		case AT91RM9200_ID_IRQ1:
+			at91_set_B_periph(AT91_PIN_PA26, 0);
+			break;
+	}
+	return 0;
+}
+
+static struct mcp251x_platform_data mcp251x_info1 = {
+	.oscillator_frequency = 20000000,
+	.board_specific_setup = &mcp251x_common_setup,
+	.power_enable = NULL,
+	.transceiver_enable = NULL,
+};
+
+static struct mcp251x_platform_data mcp251x_info2 = {
+	.oscillator_frequency = 20000000,
+	.board_specific_setup = &mcp251x_common_setup,
+	.power_enable = NULL,
+	.transceiver_enable = NULL,
+};
+
+static struct spi_eeprom eeprom_data = {
+	.name = "mr25h10",
+	.byte_len = 131072,	/* 128 KB */
+	.page_size = 4092,		/* the max page size for a successful spi transfer(4 byte WRITE + 4092=PAGE_SIZE ) */
+	.flags = EE_ADDR3 | EE_NODELAY_WRITE | EE_ARBITRARY_WRITE,
+};
+
+static struct spi_board_info plc323_spi_devices[] = {
+	{	/* MRAM MR25H10 */
+		.modalias	= "at25",
+		.chip_select	= 1,
+		.max_speed_hz	= 10 * 1000 * 1000, /* don't set bigger value -see #4533; actual rate is 9984000 Hz */
+		.controller_data = (void*) AT91_PIN_PA4,
+		.platform_data	= &eeprom_data,
+		//.bus_num	= 0,
+	},
+	{	/* CAN1 - NPCS 2 */
+		.modalias = "mcp2515",
+		.platform_data = &mcp251x_info1,
+		.irq = AT91RM9200_ID_IRQ1,
+		.max_speed_hz = 10*1000*1000,
+		.chip_select = 2,
+		.controller_data = (void*)AT91_PIN_PD19,
+	},
+	{	/* CAN2 - NPCS 3 */
+		.modalias = "mcp2515",
+		.platform_data = &mcp251x_info2,
+		.irq = AT91RM9200_ID_IRQ0,
+		.max_speed_hz = 10*1000*1000,
+		.chip_select = 3,
+		.controller_data = (void*)AT91_PIN_PD20,
+	},
+	{	/* RTC DS3234 */
+		.modalias	= "ds3234",
+		.chip_select = 4,
+		.max_speed_hz = 250 *  1000,
+		.controller_data = (void*) AT91_PIN_PD0,
+		//.bus_num	= 0,
+	},
+	{ /* peripheral processor on ATtiny */
+		.modalias = "spidev",
+		.chip_select	= 5,
+		.max_speed_hz = 400 * 1000,
+		.mode = SPI_MODE_0,
+		.controller_data = (void*) AT91_PIN_PC14,
+	},
+};
+
+static void plc323_gpio_configuration(void)
+{
+	if (!at91_get_gpio_value(AT91_PIN_PC1))
+	{
+		// SA1.2 on PC1 - "0" D_OUT1...D_OUT4 are outputs
+		at91_set_gpio_output(AT91_PIN_PD1,  0);
+		at91_set_gpio_output(AT91_PIN_PD2,  0);
+		at91_set_gpio_output(AT91_PIN_PD3,  0);
+		at91_set_gpio_output(AT91_PIN_PD4,  0);
+		at91_set_gpio_output(AT91_PIN_PB27, 0); // VD6 LED ON
+	}
+	else
+	{
+		// SA1.2 off, PC1 - "1" D_INP1...D_INP4 are inputs
+		at91_set_gpio_input(AT91_PIN_PD1,   1);
+		at91_set_gpio_input(AT91_PIN_PD2,   1);
+		at91_set_gpio_input(AT91_PIN_PD3,   1);
+		at91_set_gpio_input(AT91_PIN_PD4,   1);
+		at91_set_gpio_output(AT91_PIN_PB27, 1); // VD6 LED OFF
+	}
+
+	if (!at91_get_gpio_value(AT91_PIN_PC2))
+	{
+		// SA1.3 on PC1 - "0" D_OUT5 is output
+		at91_set_gpio_output(AT91_PIN_PD5,  0);
+		at91_set_gpio_output(AT91_PIN_PD24, 0); // VD4 LED ON
+	}
+	else
+	{
+		//SA1.3 off, PC1 - "1" D_INP5 is input
+		at91_set_gpio_input(AT91_PIN_PD5,   1);
+		at91_set_gpio_output(AT91_PIN_PD24, 1); // VD4 LED OFF
+	}
+
+	set_485(3, 1, 0, 0);	/* ttyS3 is in rs485 mode always */
+	set_485(4, 1, 0, 0);	/* ttyS4 is in rs485 mode always */
+}
+
+#ifdef CONFIG_PLC323_COUNTER_BOARD
+static char console_disable_arg[] = "INITTAB=/etc/inittab_nc";
+static void plc323_counter_debug_setup(void)
+{
+	if (at91_get_gpio_value(AT91_PIN_PC0))
+	{
+		at91_set_gpio_output(AT91_PIN_PD27, 1);	/* Debug operational*/
+		at91_register_uart(0, 0, 0);				/* /dev/ttyS0 - console */
+		at91_set_serial_console(0);
+	}
+	else
+	{
+		extern char *envp_init[];
+		int i;
+
+		at91_set_gpio_output(AT91_PIN_PD27, 0);	/* Debug disabled */
+		at91_register_uart(0, 5, 0);				/* /dev/ttyS5 - ordinal UART */
+
+		for (i = 0; i < CONFIG_INIT_ENV_ARG_LIMIT; i++) {
+			if (!envp_init[i]) {
+				envp_init[i] = console_disable_arg;
+				pr_info("DIP1: console disabled: inittab altered by %s\n", console_disable_arg);
+				break;
+			}
+		}
+		if (i == CONFIG_INIT_ENV_ARG_LIMIT) {
+			pr_warning("DIP1: console disabled but failed to alter inittab\n");
+		}
+	}
+}
+#else
+static void plc323_counter_debug_setup(void) {}
+#endif
+
+#define DK_FLASH_BASE	AT91_CHIPSELECT_0
+#define DK_FLASH_SIZE	SZ_16M
+
+static struct physmap_flash_data dk_flash_data = {
+	.width		= 2,
+};
+
+static struct resource dk_flash_resource = {
+	.start		= DK_FLASH_BASE,
+	.end		= DK_FLASH_BASE + DK_FLASH_SIZE - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device dk_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+				.platform_data	= &dk_flash_data,
+			},
+	.resource	= &dk_flash_resource,
+	.num_resources	= 1,
+};
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+static int __init match_dbgu(struct device *dev, void *name)
+{
+	if (!strcmp(dev->kobj.name, name)) {
+		return 1;
+	}
+	return 0;
+}
+
+static void __init plc323_allow_dbgu_dma(void)
+{
+	struct device *dbgu;
+	struct atmel_uart_data *dbgu_data;
+
+	dbgu = device_find_child(&platform_bus, "atmel_usart.0", &match_dbgu);
+	if (!dbgu) {
+		pr_info("DBGU dev NOT found: DMA for DBGU is not allowed\n");
+		return;
+	}
+	/* dbgu dev found */
+	dbgu_data = dbgu->platform_data;
+	dbgu_data->use_dma_rx = 1;
+	dbgu_data->use_dma_tx = 1;
+	pr_info("DMA RX allowed for DBGU\n");
+}
+#else
+static void __init plc323_allow_dbgu_dma(void) {}
+#endif
+
+static void __init dk_board_init(void)
+{
+	plc323_counter_debug_setup();
+	plc323_gpio_configuration();
+	/* Serial */
+	at91_add_device_serial();
+	plc323_allow_dbgu_dma();
+	/* Ethernet */
+	at91_add_device_eth(&dk_eth_data);
+	/* USB Host */
+	at91_add_device_usbh(&dk_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&dk_udc_data);
+	/* SPI */
+	at91_add_device_spi(plc323_spi_devices, ARRAY_SIZE(plc323_spi_devices));
+	/* MMC */
+	at91_add_device_mmc(0, &dk_mmc_data);
+	/* NOR Flash */
+	platform_device_register(&dk_flash);
+
+	/*TODO: disable CAN RESET pin - make an interface in /proc??? */
+	at91_set_gpio_output(AT91_PIN_PC15, 1);
+
+	system_serial_low = OWEN_RELEASE;
+
+	/* setup LPVD FIQ handler as need */
+#if defined(CONFIG_OWEN_LPVD_FIQ)	
+	owen_setup_lpvd_fiq(plc323_spi_devices, ARRAY_SIZE(plc323_spi_devices), "at25", &owen_rm);
+#endif
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	owen_setup_rm_info_iface();
+#endif
+}
+
+MACHINE_START(OWEN_PLC323, "Owen PLC323")
+	/* Maintainer: SAN People/Atmel */
+	.timer		= &at91rm9200_timer,
+	.map_io		= at91rm9200_map_io,
+	.init_early	= dk_init_early,
+	.init_irq	= dk_init_irq,
+	.init_machine	= dk_board_init,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/clock.c linux-3.0.x-arm/arch/arm/mach-at91/clock.c
--- linux-3.0.x-orig/arch/arm/mach-at91/clock.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/clock.c	2012-12-19 11:25:55.000000000 +0200
@@ -272,6 +272,23 @@
 
 /*------------------------------------------------------------------------*/
 
+#ifdef CONFIG_PM
+
+int clk_must_disable(struct clk *clk)
+{
+	if (!at91_suspend_entering_slow_clock())
+		return 0;
+
+	while (clk->parent)
+		clk = clk->parent;
+	return clk != &clk32k;
+}
+EXPORT_SYMBOL(clk_must_disable);
+
+#endif
+
+/*------------------------------------------------------------------------*/
+
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
 
 /*
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/generic.h linux-3.0.x-arm/arch/arm/mach-at91/generic.h
--- linux-3.0.x-orig/arch/arm/mach-at91/generic.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/generic.h	2012-12-19 11:25:55.000000000 +0200
@@ -67,6 +67,7 @@
  /* Power Management */
 extern void at91_irq_suspend(void);
 extern void at91_irq_resume(void);
+extern int at91_suspend_entering_slow_clock(void);
 
 /* reset */
 extern void at91sam9_alt_reset(void);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/gpio.c linux-3.0.x-arm/arch/arm/mach-at91/gpio.c
--- linux-3.0.x-orig/arch/arm/mach-at91/gpio.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/gpio.c	2012-12-19 11:25:55.000000000 +0200
@@ -587,10 +587,13 @@
 		if (gpio_label) {
 			seq_printf(s, "[%s] GPIO%s%d: ",
 				   gpio_label, chip->label, i);
-			if (__raw_readl(pio + PIO_PSR) & mask)
-				seq_printf(s, "[gpio] %s\n",
-					   at91_get_gpio_value(pin) ?
-					   "set" : "clear");
+			if (__raw_readl(pio + PIO_PSR) & mask) {
+				seq_printf(s, "%s: [gpio] %s\n",
+					__raw_readl(pio + PIO_OSR) & mask ?
+					"out" : "in",
+					at91_get_gpio_value(pin) ?
+					"set" : "clear");
+			}
 			else
 				seq_printf(s, "[periph %s]\n",
 					   __raw_readl(pio + PIO_ABSR) &
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/include/mach/board.h linux-3.0.x-arm/arch/arm/mach-at91/include/mach/board.h
--- linux-3.0.x-orig/arch/arm/mach-at91/include/mach/board.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/include/mach/board.h	2013-08-23 18:09:53.000000000 +0300
@@ -85,7 +85,12 @@
 struct at91_eth_data {
 	u32		phy_mask;
 	u8		phy_irq_pin;	/* PHY IRQ */
+#if defined (CONFIG_OWEN_PHY_WATCHDOG)
+	u8		phy_rst_pin;
+#endif
 	u8		is_rmii;	/* using RMII interface? */
+	u8		phy_addr;	/* preferred phy addr -> macb_mii_probe() */
+	void		*mii_bus_pdev;	/* mii bus platform device */
 };
 extern void __init at91_add_device_eth(struct at91_eth_data *data);
 
@@ -139,14 +144,49 @@
 
 extern struct platform_device *atmel_default_console_device;
 
+/* Note about RS232/RS485 switching.
+ *
+ * 1. No switching (standard behaviour)
+ * Standard rs485.flags & RS485_ENABLED - defines the initial mode of the USART controller.
+ * When circuit is made so that switching is not possible, set this mode once at kernel initialization.
+ *    - Specify rs485_switch_pin = 0 (do not specify at all) => run-time switching is disabled. 
+ *
+ * 2. Switching (Owen-specific feature)
+ * The fields rs485_switch_pin and rs485_active_level which extend the functionality.
+ * It allows to switch between RS485 and RS232. 
+ * There are two cases:
+ * 2.1 Switching once at kernel initialization depending on some external conditions (e.g. state of DIP switches).
+ *    - Specify rs485_switch_pin = 0 => run-time switching is disabled. 
+ *    - switch output circuit once by board-specific initialization code along with 
+ *       setting standard rs485.flags to appropriate initial value.
+ * 2.2. Switching any number times at run time via IOCTL command
+ *    - Specify rs485_switch_pin = AT91_PIN_ => run-time switching is allowed
+ *    - Specify appropriate value of rs485_active_level 
+ *    (which level of the specified pin make the circuit to switch to RS485 mode)
+ *    When respective IOCTL is called it will set the specified GPIO pin with appropriate level.
+ */
 struct atmel_uart_data {
 	int			num;		/* port num */
 	short			use_dma_tx;	/* use transmit DMA? */
 	short			use_dma_rx;	/* use receive DMA? */
 	void __iomem		*regs;		/* virt. base address, if any */
-	struct serial_rs485	rs485;		/* rs485 settings */
+	struct serial_rs485	rs485;		/* rs485 standard settings */
+
+	/* rs485 Owen-specific settings */
+	unsigned int		rs485_switch_pin;	/* PIN switching the output circuit between rs485 and rs232 lines. If not speicified, switching is disabled */
+	unsigned char		rs485_active_level;	/* which level (0 or 1) is used to activate RS485 mode */
+
+	/* Owen-specific addition: pins implementing full-modem UART (see PLC240-SPK207) */
+	unsigned int		pin_DTR;	/* signal DTR output */
+	unsigned int		pin_DSR;	/* signal DSR input */
+	unsigned int		pin_DCD;	/* signal DCD input */
+	unsigned int		pin_RI;		/* signal RI input */
 };
 extern void __init at91_add_device_serial(void);
+extern void __init set_485(unsigned char port, unsigned char init_mode, 
+	unsigned int switch_pin, unsigned char active_level);
+extern void __init set_full_modem(unsigned char port, unsigned int pin_dtr, 
+			unsigned int pin_dsr, unsigned int pin_dcd, unsigned int pin_ri);
 
 /*
  * PWM
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/include/mach/spi.h linux-3.0.x-arm/arch/arm/mach-at91/include/mach/spi.h
--- linux-3.0.x-orig/arch/arm/mach-at91/include/mach/spi.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/include/mach/spi.h	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef AT91_LEGACY_SPI_H
+#define AT91_LEGACY_SPI_H
+
+#define SPI_MAJOR		153	/* registered device number */
+
+#define DEFAULT_SPI_CLK		6000000
+
+
+/* Maximum number of buffers in a single SPI transfer.
+ *  DataFlash uses maximum of 2
+ *  spidev interface supports up to 8.
+ */
+#define MAX_SPI_TRANSFERS	8
+#define NR_SPI_DEVICES		4	/* number of devices on SPI bus */
+
+/*
+ * Describes the buffers for a SPI transfer.
+ * A transmit & receive buffer must be specified for each transfer
+ */
+struct spi_transfer_list {
+	void* tx[MAX_SPI_TRANSFERS];	/* transmit */
+	int txlen[MAX_SPI_TRANSFERS];
+	void* rx[MAX_SPI_TRANSFERS];	/* receive */
+	int rxlen[MAX_SPI_TRANSFERS];
+	int nr_transfers;		/* number of transfers */
+	int curr;			/* current transfer */
+};
+
+struct spi_local {
+	unsigned int pcs;		/* Peripheral Chip Select value */
+
+	struct spi_transfer_list *xfers;	/* current transfer list */
+	dma_addr_t tx, rx;		/* DMA address for current transfer */
+	dma_addr_t txnext, rxnext;	/* DMA address for next transfer */
+};
+
+
+/* Exported functions */
+extern void spi_access_bus(short device);
+extern void spi_release_bus(short device);
+extern int spi_transfer(struct spi_transfer_list* list);
+
+#endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/Kconfig linux-3.0.x-arm/arch/arm/mach-at91/Kconfig
--- linux-3.0.x-orig/arch/arm/mach-at91/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/Kconfig	2013-08-22 15:43:08.000000000 +0300
@@ -182,7 +182,44 @@
 	help
 	  Select this if you are using the eco920 board
 
-endif
+config MACH_OWEN_PLC304
+	bool "Owen PLC304"
+	depends on ARCH_AT91RM9200
+	select MACH_OWEN
+	select OWEN_RETAIN_MEMORY
+	help
+	  Select this if you are using Owen's programming logic controller plc304
+	  based on Atmel AT91RM9200. <http://owen.ru/>
+
+config MACH_OWEN_PLC304_DK
+	bool "Owen PLC304 DK edition"
+	depends on MACH_OWEN_PLC304
+	default n
+	help
+	  Select this if you are using Owen PLC304 DK edition
+
+config MACH_OWEN_PLC323
+	bool "Owen PLC323"
+	depends on ARCH_AT91RM9200
+	select MACH_OWEN
+	select OWEN_RETAIN_MEMORY
+	select OWEN_LPVD_FIQ
+	help
+	  Select this if you are using Owen's programming logic controller plc323
+	  based on Atmel AT91RM9200. <http://owen.ru/>
+	
+config PLC323_COUNTER_BOARD
+	bool "Counter connected to debug"
+	depends on MACH_OWEN_PLC323
+	default y
+	help
+	  Select this if counter is connected to debug UART of the board
+endif
+
+config OWEN_PANIC_BLINK
+	bool
+	default y if MACH_OWEN_PLC304 || MACH_OWEN_HE5684
+	default n
 
 # ----------------------------------------------------------
 
@@ -307,9 +344,40 @@
 	help
 	  Select this if you are using the Adeneo Neocore 926 board.
 
-endif
+config MACH_OWEN_PLC240
+	bool "Owen PLC240"
+	depends on ARCH_AT91SAM9263
+	select MACH_OWEN
+	help
+	  Select this if you are using Owen's programming logic controller plc240 
+	  based on Atmel AT91SAM9263. <http://owen.ru/>
+
+choice
+	depends on (ARCH_AT91SAM9263 && MACH_OWEN_PLC240)
+	prompt "Board types of PLC240"
+
+config OWEN_PLC240_SPK207
+	bool "SPK207"
+	help
+	  SPK207 formely known as PLC240. Now it is one of PLC240's types.
+
+config OWEN_PLC240_SPK210
+	bool "SPK210"
+	select OWEN_RETAIN_MEMORY
+	select OWEN_LPVD_FIQ
+
+endchoice
+
+config MACH_OWEN_HE5684
+	bool "Owen HE5684"
+	depends on ARCH_AT91SAM9263
+	select MACH_OWEN
+	select OWEN_RETAIN_MEMORY
+	help
+	  Select this if you are using Owen's HE5684 controller 
+	  based on Atmel AT91SAM9263. <http://owen.ru/>
 
-# ----------------------------------------------------------
+endif
 
 if ARCH_AT91SAM9RL
 
@@ -474,12 +542,11 @@
 	  need to be completely re-initialized.
 
 config AT91_TIMER_HZ
-       int "Kernel HZ (jiffies per second)"
-       range 32 1024
-       depends on ARCH_AT91
-       default "128" if ARCH_AT91RM9200
-       default "100"
-       help
+	int "Kernel HZ (jiffies per second)"
+	range 32 1024
+	default "128" if ARCH_AT91RM9200
+	default "100"
+	help
 	  On AT91rm9200 chips where you're using a system clock derived
 	  from the 32768 Hz hardware clock, this tick rate should divide
 	  it exactly: use a power-of-two value, such as 128 or 256, to
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/Makefile linux-3.0.x-arm/arch/arm/mach-at91/Makefile
--- linux-3.0.x-orig/arch/arm/mach-at91/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/Makefile	2012-12-19 11:25:55.000000000 +0200
@@ -36,6 +36,8 @@
 obj-$(CONFIG_MACH_YL9200)	+= board-yl-9200.o
 obj-$(CONFIG_MACH_CPUAT91)	+= board-cpuat91.o
 obj-$(CONFIG_MACH_ECO920)	+= board-eco920.o
+obj-$(CONFIG_MACH_OWEN_PLC304)	+= board-owen-plc304.o
+obj-$(CONFIG_MACH_OWEN_PLC323)	+= board-owen-plc323.o
 
 # AT91SAM9260 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9260EK) += board-sam9260ek.o
@@ -55,6 +57,8 @@
 obj-$(CONFIG_MACH_AT91SAM9263EK) += board-sam9263ek.o
 obj-$(CONFIG_MACH_USB_A9263)	+= board-usb-a9263.o
 obj-$(CONFIG_MACH_NEOCORE926)	+= board-neocore926.o
+obj-$(CONFIG_MACH_OWEN_PLC240)	+= board-owen-plc240.o
+obj-$(CONFIG_MACH_OWEN_HE5684)	+= board-owen-he5684.o
 
 # AT91SAM9RL board-specific support
 obj-$(CONFIG_MACH_AT91SAM9RLEK)	+= board-sam9rlek.o
@@ -88,6 +92,10 @@
 obj-$(CONFIG_AT91_SLOW_CLOCK)	+= pm_slowclock.o
 obj-$(CONFIG_CPU_IDLE)	+= cpuidle.o
 
+# Owen board options
+obj-$(CONFIG_OWEN_LPVD_FIQ)		+= owen-lpvd-fiq.o
+obj-$(CONFIG_OWEN_PANIC_BLINK)		+= owen-panic-blink.o
+
 ifeq ($(CONFIG_PM_DEBUG),y)
 CFLAGS_pm.o += -DDEBUG
 endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/owen-lpvd-fiq.c linux-3.0.x-arm/arch/arm/mach-at91/owen-lpvd-fiq.c
--- linux-3.0.x-orig/arch/arm/mach-at91/owen-lpvd-fiq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/owen-lpvd-fiq.c	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,712 @@
+/*
+ * arch/arm/mach-at91/owen-lpvd-fiq.c
+ *
+ * Copyright (c) 2012 Softerra LLC (alex@softerra.com)
+ *
+ * Set up and handle FIQ which is connected to Low Power Voltage Detector on SPK210
+ * When FIQ occurs, program SPI controller to flush retain memory shadow buffer.
+ */
+
+//#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/cacheflush.h>
+
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/at91_pio.h>
+#include <mach/at91_rstc.h>
+
+#include <linux/proc_fs.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+/* use atmel_spi definitions and macros */
+#include <../drivers/spi/atmel_spi.h>
+
+/* at91_arch_reset(); */
+#include "generic.h"
+
+#include <owen-common.h>
+
+/* define for development code to test via echo 2 > /proc/owen_lpvd_fiq_ebable */
+//#define FIQ_CODE_TEST
+
+#define AT25_WREN	0x06	/* latch the write enable */
+#define AT25_WRITE	0x02	/* write byte(s)/sector */
+
+/* FIQ PIN */
+#if defined(CONFIG_ARCH_AT91SAM9263)
+#define FIQ_PIN	AT91_PIN_PD4
+#elif defined(CONFIG_ARCH_AT91RM9200)
+#define FIQ_PIN	AT91_PIN_PB28
+#else
+#error FIQ_PIN is not defined for selected board
+#endif
+
+/* actual FIQ vector address where execution starts after FIQ */
+#define AT91_FIQ_VECTOR	0xffff001c
+/* more than enough to cover jump instruction to the isr */
+#define SIZEOF_FIQ_JUMP		8
+/* more than enough to cover fiq_isr() (in 4K blocks) */
+#define SIZEOF_FIQ_ISR		0x2000
+
+struct owen_lpvd_fiq_data {
+	int fiq_enabled;			/* whether or not FIQ is enabled */
+
+	/* allocated shadow buffer params */
+	unsigned long phys_addr;	/* start addr of WRITE command */
+	unsigned long size;		/* size of the whole WRITE command contents */
+	u8 *addr;				/* virtual address of the phys_addr */
+
+	/* for ability to use this structure in spi_write/spi_read macroses from drivers/spi/atmel_spi.h */
+	void __iomem *regs;		/* SPI controller's (slected by bus_num) registers base */
+	
+	unsigned long cs_pin;		/* SPI chip select pin to be triggered via GPIO */
+	unsigned cs_active;		/* active level: 1 - high, 0 - low */
+	u32 csr;					/* SPI CSR value for transfer */
+
+	void __iomem *cs_pio;		/* to avoid BL commands in time-critical part of FIQ handler */
+	u32 cs_pin_mask;
+};
+
+#if 0
+/* The next marcos can be used only within FIQ ISR */
+#define CS_ACTIVATE() \
+{\
+	__raw_writel(pfd->csr, regs + SPI_CSR0); \
+	__raw_writel(SPI_BF(PCS, 0x0e) | SPI_BIT(MODFDIS) | SPI_BIT(MSTR), \
+					regs + SPI_MR); \
+	__raw_writel(pfd->cs_pin_mask, pio_regs + (pfd->cs_active ? PIO_SODR : PIO_CODR)); \
+}
+
+#define CS_DEACTIVATE() \
+{\
+	u32 mr; \
+	mr = __raw_readl(regs + SPI_MR); \
+	mr = SPI_BFINS(PCS, 0xf, mr); \
+	__raw_writel(pfd->cs_pin_mask, pio_regs + (!pfd->cs_active ? PIO_SODR : PIO_CODR)); \
+	__raw_writel(mr, regs + SPI_MR); \
+}
+#endif /* 0 */
+
+static __attribute__((always_inline)) void 
+cs_activate(const struct owen_lpvd_fiq_data *pfd)
+{
+	__raw_writel(pfd->csr, pfd->regs + SPI_CSR0);
+	__raw_writel(SPI_BF(PCS, 0x0e) | SPI_BIT(MODFDIS) | SPI_BIT(MSTR), pfd->regs + SPI_MR);
+	__raw_writel(pfd->cs_pin_mask, pfd->cs_pio + (pfd->cs_active ? PIO_SODR : PIO_CODR));
+}
+
+static __attribute__((always_inline)) void 
+cs_deactivate(const struct owen_lpvd_fiq_data *pfd)
+{
+	u32 mr;
+	mr = __raw_readl(pfd->regs + SPI_MR);
+	mr = SPI_BFINS(PCS, 0xf, mr);
+	__raw_writel(pfd->cs_pin_mask, pfd->cs_pio + (!pfd->cs_active ? PIO_SODR : PIO_CODR));
+	__raw_writel(mr, pfd->regs + SPI_MR);
+}
+
+/* Delay in few ticks using busy loop. WARNING: temporary solution. */
+static __attribute__((always_inline)) void 
+rdelay(volatile int count)
+{
+	while (count--);
+}
+
+/* FIQ ISR (must go into monolithic kernel) */
+static void __attribute__ ((naked)) fiq_isr(void)
+{
+	/* local vars: take care to set the frame size below accordingly */
+	struct owen_lpvd_fiq_data *pfd;
+
+	asm volatile (
+		"mov     ip, sp ;"
+		"stmdb	sp!, {r0-r8, r10-r12,  lr};" /* stash FIQ regs and r0-r8 normal regs */
+		"stmdb	sp!, {r9};" /* stash R9 separtely so we can have it before the others later */
+		"sub     fp, ip, #256 ;"  /* !!! THIS SETS THE FRAME, adjust argument to >= sizeof local symbols */
+		"mov %0, r10"
+		:"=r"(pfd)
+		:
+		:"r9"
+	);
+
+/*
+ * C code goes here
+ *
+ * Major Caveats for using FIQ
+ * ---------------------------
+ *
+ * 1) it CANNOT touch any vmalloc()'d memory, only memory
+ *    that was kmalloc()'d.  Static allocations in the monolithic kernel
+ *    are kmalloc()'d so they are okay.  You can touch memory-mapped IO, but
+ *    the pointer for it has to have been stored in kmalloc'd memory.  The
+ *    reason for this is simple: every now and then Linux turns off interrupts
+ *    and reorders the paging tables.  If a FIQ happens during this time, the
+ *    virtual memory space can be partly or entirely disordered or missing.
+ *
+ * 2) Because vmalloc() is used when a module is inserted, THIS FIQ
+ *    ISR HAS TO BE IN THE MONOLITHIC KERNEL, not a module.  But the way
+ *    it is set up, you can all to enable and disable it from your module
+ *    and intercommunicate with it through struct at91rm9200_fiq_ipc
+ *    at91rm9200_fiq_ipc which you can define in
+ *    asm/archat91rm9200_fiq_ipc_type.h.  The reason is the same as above, a
+ *    FIQ could happen while even the ISR is not present in virtual memory
+ *    space due to pagetables being changed at the time.
+ *
+ * 3) You can't call any Linux API code except simple macros
+ *    - understand that FIQ can come in at any time, no matter what
+ *      state of undress the kernel may privately be in, thinking it
+ *      locked the door by turning off interrupts... FIQ is an
+ *      unstoppable monster force (which is its value)
+ *    - they are not vmalloc()'d memory safe
+ *    - they might do crazy stuff like sleep: FIQ pisses fire and
+ *      is not interested in 'sleep' that the weak seem to need
+ *    - calling APIs from FIQ can re-enter un-renterable things
+ *    - summary: you cannot interoperate with linux APIs directly in the FIQ ISR 
+ */
+
+	/* program SPI to store all retain memory shadow buffer to the MARAM */
+	{
+		u32 rval;
+		void __iomem *regs = pfd->regs;
+		void __iomem *pio_regs = pfd->cs_pio;
+		unsigned long addr;
+		unsigned long count;
+		u32 c;
+		int started = 0;
+		u32 sr;
+
+#if defined(CONFIG_MACH_OWEN_PLC323)
+		/* GSM power off to save energy */
+		at91_set_gpio_output(AT91_PIN_PB6, 1);	/* turn VBAT off   */
+		at91_set_gpio_output(AT91_PIN_PB6, 0);	/* release PWR_KEY */
+#endif
+
+		/* stop spi transfer which may be in progress */
+		__raw_writel(SPI_BIT(TXTDIS) | SPI_BIT(RXTDIS), regs + SPI_PTCR);
+
+		/* deactivate CS line */
+		/* assume CS_PIN is configured as output, so just drive it with 0 or 1, in this case to !cs_active */
+		__raw_writel(pfd->cs_pin_mask, pio_regs + (!pfd->cs_active ? PIO_SODR : PIO_CODR));
+
+#if 0
+		/* re-init SPI controller */
+		__raw_writel(SPI_BIT(SWRST), regs + SPI_CR);
+		__raw_writel(SPI_BIT(SWRST), regs + SPI_CR);	/* AT91SAM9263 Rev B workaround */
+		__raw_writel(SPI_BIT(MSTR) | SPI_BIT(MODFDIS), regs + SPI_MR);
+		__raw_writel(SPI_BIT(TXTDIS) | SPI_BIT(RXTDIS), regs + SPI_PTCR);
+		__raw_writel(SPI_BIT(SPIEN), regs + SPI_CR);
+#endif
+
+		/* perform WREN command */
+		cs_activate(pfd);
+		rdelay(42); // temporary solution. value is found experimentally; may be unstable
+		__raw_writel(AT25_WREN, regs + SPI_TDR);
+		/* wait until transfered && read */
+		while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF)));	/* tx,rx,end of transaction */
+		rval = __raw_readl(regs + SPI_RDR);					/* clean up RDR & OVRES flag */
+		rdelay(42); // temporary solution. value is found experimentally; may be unstable
+		cs_deactivate(pfd);
+
+
+		/* prepare WRITE command */
+		addr = pfd->phys_addr;
+		count = pfd->size;
+
+		if (count >> 16) {
+			c = 0xffff;
+		} else {
+			c = (u16)count;
+		}
+
+		/* setup TPR, TCR */
+		__raw_writel(addr, regs + SPI_TPR);
+		__raw_writel(c, regs + SPI_TCR);
+
+		count -= c;
+		addr += c;
+
+		do {
+
+			if (count >> 16) {
+				c = 0xffff;
+			} else {
+				c = (u16)count;
+			}
+
+			/* setup TNPR, TNCR */
+			__raw_writel(addr, regs + SPI_TNPR);
+			__raw_writel(c, regs + SPI_TNCR);		/* may be 0 on the first iteration */
+
+			count -= c;
+			addr += c;
+
+			if (!started) {
+				/* start WRITE command */
+				started = 1;
+				cs_activate(pfd);
+				rdelay(42); // temporary solution. value is found experimentally; may be unstable
+				__raw_writel(SPI_BIT(TXTEN), regs + SPI_PTCR);
+			}
+
+			/* check end of transfer */
+			while (!((sr = __raw_readl(regs + SPI_SR)) & SPI_BIT(ENDTX)));
+		} while (!(sr & SPI_BIT(TXBUFE)) && count);
+
+		if (!(sr & SPI_BIT(TXBUFE))) {
+			while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(TXBUFE)));
+		}
+
+		/* here data stored */
+
+		/* wait for received data to clean it up 
+		 * (it was tested that no more data is sampled by MRAM 
+		 * during this reading before CS_DEACTIVATE:
+		 * retain buffer of 4096 bytes was saved to MRAM and
+		 * the next 4096 bytes in the MRAM, which had been filled 
+		 * with a pattern, were untouched)
+		 */
+		while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF)));
+
+		do {
+			rval = __raw_readl(regs + SPI_RDR);				/* clean up RDR & OVRES flag */
+		} while (__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF));
+
+		/* whait until transferred & read all data */
+        rdelay(2*42); // temporary solution. value is found experimentally; may be unstable
+		cs_deactivate(pfd);
+
+#if 0 /* TODO: define LEDs for indication for each board separately */
+		/* signal about saving retain memory */
+		at91_set_gpio_value(AT91_PIN_PB16, 1);
+		at91_set_gpio_value(AT91_PIN_PB17, 1);
+		at91_set_gpio_value(AT91_PIN_PA21, 1);
+#endif
+
+#if 0
+		/* check: EXIT from ISR or RESET the system */
+		/* TODO: how to ensure this check before about 30ms? how to measure such interval? */
+		rval = at91_get_gpio_value(FIQ_PIN);
+		if (!rval) {
+			/* reset 
+			 * for AT91SAM9263 the same as:
+			 *__raw_writel(AT91_RSTC_PROCRST | AT91_RSTC_PERRST | AT91_RSTC_KEY,
+			 *		AT91_VA_BASE_SYS + AT91_RSTC_CR);
+			 */
+			if (at91_arch_reset) {
+				at91_arch_reset();
+			}
+		}
+	}
+	asm volatile (
+		"ldmia	sp!, {r9};"  /* pop R9 to contain &AT91_SYS->AIC_FVR */
+		"ldr	r0, [r9];" /* read from it to acknowledge FIQ source */
+		"ldmia	sp!, {r0-r8, r10-r12, lr};" /* return FIQ regs back to pristine state and get normal regs back */
+		/* return */
+		"subs	pc, lr, #4;"
+	);
+#else
+		/* Always do RESET */
+		if (at91_arch_reset)
+			(at91_arch_reset)();
+		/* Wait until watchdog shot */
+		for (;;);
+	}
+#endif
+}
+
+/* jump to the FIQ ISR (must go into monolithic kernel) */
+void __attribute__ ((naked)) fiq_jump(void)
+{
+	asm volatile (
+		"mov pc, r8 ; @ jump to fiq_isr"
+	);
+}
+
+/* FIQ stack and shared data */
+static u8 fiq_stack[4096];
+static struct owen_lpvd_fiq_data fiq_data;
+
+/* Interface to enable/disable FIQ via procfs */
+
+#if defined(FIQ_CODE_TEST)
+static void fiq_code_test(void)
+{
+	struct owen_lpvd_fiq_data *pfd;
+	pfd = &fiq_data;
+
+	{
+		u32 rval;
+		void __iomem *regs = pfd->regs;
+		void __iomem *pio_regs = pfd->cs_pio;
+		unsigned long addr;
+		unsigned long count;
+		u32 c;
+		int started = 0;
+		u32 sr;
+
+		/* stop spi transfer which may be in progress */
+		__raw_writel(SPI_BIT(TXTDIS) | SPI_BIT(RXTDIS), regs + SPI_PTCR);
+
+		/* deactivate CS line */
+		/* assume CS_PIN is configured as output, so just drive it with 0 or 1, in this case to !cs_active */
+		__raw_writel(pfd->cs_pin_mask, pio_regs + (!pfd->cs_active ? PIO_SODR : PIO_CODR));
+
+		/* re-init SPI controller - required for test context */
+		__raw_writel(SPI_BIT(SWRST), regs + SPI_CR);
+		__raw_writel(SPI_BIT(SWRST), regs + SPI_CR);	/* AT91SAM9263 Rev B workaround */
+		__raw_writel(SPI_BIT(MSTR) | SPI_BIT(MODFDIS), regs + SPI_MR);
+		__raw_writel(SPI_BIT(TXTDIS) | SPI_BIT(RXTDIS), regs + SPI_PTCR);
+		__raw_writel(SPI_BIT(SPIEN), regs + SPI_CR);
+
+		/* perform WREN command */
+		cs_activate(pfd);
+ 		__raw_writel(AT25_WREN, regs + SPI_TDR);
+		/* wait until transfered && read */
+		while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF)));	/* tx,rx,end of transaction */
+		rval = __raw_readl(regs + SPI_RDR);					/* clean up RDR & OVRES flag */
+pr_info("%s: 1. SR=0x%08X\n", __func__, __raw_readl(regs + SPI_SR));
+		cs_deactivate(pfd);
+
+
+		/* prepare WRITE command */
+		addr = pfd->phys_addr;
+		count = pfd->size;
+
+		if (count >> 16) {
+			c = 0xffff;
+		} else {
+			c = (u16)count;
+		}
+
+		/* setup TPR, TCR */		
+		__raw_writel(addr, regs + SPI_TPR);
+		__raw_writel(c, regs + SPI_TCR);
+
+		count -= c;
+		addr += c;
+
+		do {
+
+			if (count >> 16) {
+				c = 0xffff;
+			} else {
+				c = (u16)count;
+			}
+
+			/* setup TNPR, TNCR */
+			__raw_writel(addr, regs + SPI_TNPR);
+			__raw_writel(c, regs + SPI_TNCR);		/* may be 0 on the first iteration */
+
+			count -= c;
+			addr += c;
+
+			if (!started) {
+				/* start WRITE command */
+				pr_info("%s: start WRITE\n", __func__);
+				preempt_disable();
+				started = 1;
+				cs_activate(pfd);
+				__raw_writel(SPI_BIT(TXTEN), regs + SPI_PTCR);
+			}
+
+			/* check end of transfer */
+			while (!((sr = __raw_readl(regs + SPI_SR)) & SPI_BIT(ENDTX)));
+		} while (!(sr & SPI_BIT(TXBUFE)) && count);
+
+		if (!(sr & SPI_BIT(TXBUFE))) {
+			while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(TXBUFE)));
+		}
+		preempt_enable();
+pr_info("%s: transferred %lu bytes of %lu, next addr=0x%08lX, count left=%lu\n", __func__,
+		pfd->size - count, pfd->size, addr, count);
+
+		/* wait for received data to clean it up */
+		while (!(__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF)));
+pr_info("%s: 2. SR=0x%08X\n", __func__, __raw_readl(regs + SPI_SR));
+
+		do {
+			rval = __raw_readl(regs + SPI_RDR);				/* clean up RDR & OVRES flag */
+		} while (__raw_readl(regs + SPI_SR) & SPI_BIT(RDRF));
+
+pr_info("%s: 3. SR=0x%08X\n", __func__, __raw_readl(regs + SPI_SR));
+		/* whait until transferred & read all data */
+		cs_deactivate(pfd);
+
+#if 0
+		/* signal about saving retain memory */
+		at91_set_gpio_value(AT91_PIN_PB16, 1);
+		at91_set_gpio_value(AT91_PIN_PB17, 1);
+		at91_set_gpio_value(AT91_PIN_PA21, 1);
+#endif
+	}
+	
+}
+#endif
+
+static ssize_t fiq_enable_read(char *buf, char **start, off_t offset, int len, int *eof, void *private)
+{
+	ssize_t n = 0;
+	if (offset < 2) {
+		buf[0] = fiq_data.fiq_enabled ? '1' : '0';
+		buf[1] = '\n';
+		n = 2;
+		*eof = 1;
+	}
+	return n;
+}
+
+static ssize_t fiq_enable_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	if (buffer[0] == '1') {
+		fiq_data.fiq_enabled = 1;
+		local_fiq_enable();
+		at91_sys_write(AT91_AIC_IECR, 1 << AT91_ID_FIQ);
+#if defined(DEBUG)
+		{
+			int i;
+			pr_info("SET UP WRITE:");
+			for (i = 0; i < 20; i++) {
+				printk(" %02X", fiq_data.addr[i]);
+			}
+			printk("\n");
+		}
+#endif
+	} else if (buffer[0] == '0') {
+		at91_sys_write(AT91_AIC_IDCR, 1 << AT91_ID_FIQ);
+		local_fiq_disable();
+		fiq_data.fiq_enabled = 0;
+
+#if defined(FIQ_CODE_TEST)
+	} else if (buffer[0] == '2') {
+		fiq_code_test();
+		pr_info("FIQ test done.\n");
+#endif
+
+	} else {
+		return -EINVAL;
+	}
+	return count;
+}
+
+/* FIQ initialization and setting up */
+static int __init setup_spi_csr(struct spi_board_info *sbi)
+{
+	u32	scbr;
+	struct clk *clk;
+	unsigned long bus_hz;
+
+	clk = clk_get(NULL, "mck");
+	if (IS_ERR(clk)) {
+		pr_err("%s: clock getting err\n", __func__);
+		return PTR_ERR(clk);
+	}
+	bus_hz = clk_get_rate(clk);
+	clk_put(clk);
+
+	if (sbi->max_speed_hz) {
+		scbr = DIV_ROUND_UP(bus_hz, sbi->max_speed_hz);
+		if (scbr >= (1 << SPI_SCBR_SIZE)) {
+			pr_err("%s: can't make apropriate SCBR field in SPI CSR\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		pr_err("%s: max_speed_hz is not defined\n", __func__);
+		return -EINVAL;
+	}
+
+#if defined(CONFIG_ARCH_AT91RM9200)
+	/* correct SBCR for AT91RM9200: value is 2..255, 0 and 1 turn SPI clock off */
+	if (scbr == 1) {
+		scbr = 2;
+	}
+#endif
+
+	fiq_data.csr = scbr << 8;
+	if (sbi->mode & SPI_CPOL)
+		fiq_data.csr |= 1;
+	if (!(sbi->mode & SPI_CPHA))
+		fiq_data.csr |= 2;
+
+	return 0;	
+}
+
+static int __init setup_fiq_data(struct spi_board_info *devices, int nr_devices, 
+						const char *name, struct owen_rm_info *rm)
+{
+	int i;
+	struct spi_board_info *sbi = NULL;
+	int r;
+	u16 ee_flags;
+	int addr_len = 0;
+	u8 *p_write;
+	int pio_n;
+	int pin_n;
+
+	pr_debug("%s: nr_devices=%d, name='%s'\n", __func__, nr_devices, name);
+	/* search for the spi board with the name specified */	
+	for (i = 0; i < nr_devices; i++) {
+		pr_debug("%s: trying dev %i, modalias='%s'\n", __func__, i, devices[i].modalias);
+		if (!strcmp(devices[i].modalias, name)) {
+			sbi = &devices[i];
+			pr_debug("%s: found: platform_data=%p\n", __func__, sbi->platform_data);
+			break;
+		}
+	}
+
+	if (!sbi || !sbi->platform_data) {
+		pr_err("%s: missing EEPROM info\n", __func__);
+		return -EINVAL;
+	}
+
+	/* determine and check EEPROM addressing */
+	ee_flags = ((struct spi_eeprom *)(sbi->platform_data))->flags;
+	if (ee_flags & EE_ADDR1) {
+		addr_len = 1;
+	} else if (ee_flags & EE_ADDR2) {
+		addr_len = 2;
+	} else if (ee_flags & EE_ADDR3) {
+		addr_len = 3;
+	} else {
+		pr_err("%s: unsupported EEPROM addressing\n", __func__);
+		return -EINVAL;
+	}
+
+	/* save chip select pin */
+	fiq_data.cs_pin = (unsigned long)(sbi->controller_data);
+	fiq_data.cs_active = sbi->mode & SPI_CS_HIGH;
+	/* check cs_pin */
+	if (fiq_data.cs_pin >= PIN_BASE + MAX_GPIO_BANKS * 32) {
+		pr_err("%s: invalid PIN number for CS line: %lu\n", __func__, fiq_data.cs_pin);
+		return -EINVAL;
+	}
+
+	/* optimization of CS line control */
+	pio_n = (fiq_data.cs_pin - PIN_BASE) / 32;
+	pin_n = (fiq_data.cs_pin - PIN_BASE) % 32;
+	fiq_data.cs_pio = (void __iomem *)AT91_VA_BASE_SYS + AT91_PIOA + (pio_n * 0x200);
+	fiq_data.cs_pin_mask = 1 << pin_n;
+
+	/* setup SPI CSR */
+	r = setup_spi_csr(sbi);
+	if (r) {
+		return r;
+	}
+
+	/* setup SPI regs */
+	switch (sbi->bus_num) {
+#if defined(CONFIG_ARCH_AT91SAM9263)
+		case 0:
+			fiq_data.regs = ioremap(AT91SAM9263_BASE_SPI0, SZ_16K);
+			break;
+		case 1:
+			fiq_data.regs = ioremap(AT91SAM9263_BASE_SPI1, SZ_16K);
+			break;
+#elif defined(CONFIG_ARCH_AT91RM9200)
+		case 0:
+			fiq_data.regs = ioremap(AT91RM9200_BASE_SPI, SZ_16K);
+			break;
+#endif
+		default:
+			pr_err("%s: unsupported SPI bus: %d\n", __func__, sbi->bus_num);
+			return -EINVAL;
+			break;
+	}
+	if (!fiq_data.regs) {
+		pr_err("%s: failed to map SPI bus registers\n", __func__);
+		return -ENOMEM;
+	}
+
+	pr_info("FIQ data setup: SPI: regs=%p, CS=%lu, CSR=0x%08X, "
+			"PIO: regs=%p, pin_mask=%u\n",
+			fiq_data.regs, fiq_data.cs_pin, fiq_data.csr,
+			fiq_data.cs_pio, fiq_data.cs_pin_mask);
+
+	/* prepare WRITE command and save retain memory info depending on EEPROM addressing */
+	p_write = (u8 *)(rm->addr) - 4;
+	*(u32 *)p_write = AT25_WRITE << ((4 - addr_len - 1) * 8);
+	
+	fiq_data.phys_addr = rm->phys_addr - addr_len - 1;
+	fiq_data.addr = rm->addr - addr_len - 1;
+	fiq_data.size = rm->size + addr_len + 1;
+	
+	pr_info("FIQ data setup: RM: phys_addr=0x%08lX, size=%lu\n", 
+			fiq_data.phys_addr, fiq_data.size);
+	return 0;
+}
+
+void __init owen_setup_lpvd_fiq(struct spi_board_info *devices, int nr_devices, 
+						const char *name, struct owen_rm_info *rm)
+{
+	struct proc_dir_entry *fiq_enable;
+	struct pt_regs regs;
+	register long tmp;
+	int r;
+
+	/* prepare data for the Fiq handler */
+	r = setup_fiq_data(devices, nr_devices, name, rm);
+	if (r) {
+		pr_err("Invalid FIQ data: FIQ is not set up\n");
+		return;
+	}
+
+	/* fiq is disabled on start */
+	fiq_data.fiq_enabled = 0;
+	
+	/* setup FIQ handler */
+
+	/* set FIQ pin in FIQ function */
+	at91_set_A_periph(FIQ_PIN, 0);						/* FIQ pin on AT91SAM9263 */
+	
+	/* disable FIQ interrupt */
+	at91_sys_write(AT91_AIC_IDCR, 1 << AT91_ID_FIQ);			/* write by remaped(if MMU on) address of IDCR reg */
+	local_fiq_disable();
+	
+	/* prepare FIQ mode specific registers */
+	memset(&regs, 0, sizeof(regs));
+	regs.ARM_r8 = (long)fiq_isr;									/* r8 = address of ISR */
+	regs.ARM_r9 = (long)AT91_VA_BASE_SYS + AT91_AIC_FVR;		/* r9 = remaped(if MMU on) address of FI vector register */
+	regs.ARM_r10 = (long)&fiq_data;							/* r10 = viatual address of shared FIQ data */
+	regs.ARM_sp = (long)fiq_stack + sizeof(fiq_stack) - 4;			/* sp = virtual address of the top of new stack */
+
+	/* setup FIQ mode specific registers including stack pointer */
+	asm volatile (	
+		"mrs     %0, cpsr         @ save current cpsr in tmp\n\
+		msr     cpsr_c, %2       @ select FIQ mode, disable IRQs, FIQ - modify control bits\n\
+		mov     r0, r0              @ ?\n\
+		ldmia   %1, {r8 - r14} @ load regs r8-r14 starting from regs.ARM_r8\n\
+		msr     cpsr_c, %0       @ return to SVC mode - restore control bits from tmp\n\
+		mov     r0, r0              @ ?\n"
+		: "=&r" (tmp)
+		: "r" (&regs.ARM_r8), "I" (PSR_I_BIT | PSR_F_BIT | FIQ_MODE)
+		: "r0"
+	);
+
+	/* ??? - used in arch/arm/kernel/fiq.c -- why and how? */
+	memcpy((void *)AT91_FIQ_VECTOR, fiq_jump, SIZEOF_FIQ_JUMP);
+
+	/* flush this area */
+	flush_icache_range(AT91_FIQ_VECTOR, AT91_FIQ_VECTOR + SIZEOF_FIQ_JUMP);
+	flush_icache_range((uint)fiq_isr, (uint)fiq_isr + SIZEOF_FIQ_ISR);
+	
+	/* switch FIQ to edge triggered mode */
+	at91_sys_write(AT91_AIC_SMR(0), 7 | AT91_AIC_SRCTYPE_FALLING);
+
+	/* set up interface for enabling FIQ */
+	fiq_enable = create_proc_entry(OWEN_LPVD_FIQ_ENABLE_NAME,
+									S_IRUGO|S_IWUSR|S_IWGRP, NULL);
+	if(!fiq_enable) {
+		pr_err("Failed to create proc entry: " OWEN_LPVD_FIQ_ENABLE_NAME "\n");
+	} else {
+		fiq_enable->read_proc = &fiq_enable_read;
+		fiq_enable->write_proc= &fiq_enable_write;
+	}
+	
+	pr_info("Owen LPVD FIQ handler is set up (FIQ interrupt disabled)\n");
+}
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/owen-panic-blink.c linux-3.0.x-arm/arch/arm/mach-at91/owen-panic-blink.c
--- linux-3.0.x-orig/arch/arm/mach-at91/owen-panic-blink.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/owen-panic-blink.c	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * arch/arm/mach-at91/owen-panic-blink.c
+ *
+ * Copyright (c) 2012 Softerra LLC (dimich@softerra.com)
+ *
+ * Handle kernel panic blinking with variuos periods.
+ *
+ */
+
+#include <linux/gpio.h>
+
+#include "owen-panic-blink.h"
+
+#define ROOTFS_PANIC_DIVIDER    16
+
+static int err_led = -1;
+
+static long owen_panic_blink(int state)
+{
+	static unsigned int counter = 0;
+
+	if (system_serial_low == 0) /* rootfs mounting problem */
+	{
+		state   = (counter >= ROOTFS_PANIC_DIVIDER);
+		counter = (counter + 1) % (2*ROOTFS_PANIC_DIVIDER);
+    }
+
+	if (err_led >= 0)
+	{
+		gpio_direction_output(err_led, state);
+	}
+
+	return 0;
+}
+
+void owen_setup_panic_blink(int led)
+{
+    err_led = led;
+    panic_blink = owen_panic_blink;
+}
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/owen-panic-blink.h linux-3.0.x-arm/arch/arm/mach-at91/owen-panic-blink.h
--- linux-3.0.x-orig/arch/arm/mach-at91/owen-panic-blink.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/owen-panic-blink.h	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef OWEN_PANIC_BLINK_H
+#define OWEN_PANIC_BLINK_H
+
+void owen_setup_panic_blink(int led);
+
+#endif /* OWEN_PANIC_BLINK_H */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/owen-release.h linux-3.0.x-arm/arch/arm/mach-at91/owen-release.h
--- linux-3.0.x-orig/arch/arm/mach-at91/owen-release.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/owen-release.h	2012-12-19 11:25:55.000000000 +0200
@@ -0,0 +1,17 @@
+/*
+ * linux/arch/arm/mach-at91/owen-release.h
+ *
+ * Copyright (C) 2010 Softerra, LLC
+ *	Oleg Oleshko <h2o <at> softerra.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __OWEN_RELEASE_H
+#define __OWEN_RELEASE_H
+
+#define OWEN_RELEASE	1599
+
+#endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-at91/pm.c linux-3.0.x-arm/arch/arm/mach-at91/pm.c
--- linux-3.0.x-orig/arch/arm/mach-at91/pm.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-at91/pm.c	2012-12-19 11:25:55.000000000 +0200
@@ -133,6 +133,7 @@
  * Verify that all the clocks are correct before entering
  * slow-clock mode.
  */
+#warning "This should probably be moved to clocks.c"
 static int at91_pm_verify_clocks(void)
 {
 	unsigned long scsr;
@@ -179,20 +180,15 @@
 }
 
 /*
- * Call this from platform driver suspend() to see how deeply to suspend.
+ * This is called from clk_must_disable(), to see how deeply to suspend.
  * For example, some controllers (like OHCI) need one of the PLL clocks
  * in order to act as a wakeup source, and those are not available when
  * going into slow clock mode.
- *
- * REVISIT: generalize as clk_will_be_available(clk)?  Other platforms have
- * the very same problem (but not using at91 main_clk), and it'd be better
- * to add one generic API rather than lots of platform-specific ones.
  */
 int at91_suspend_entering_slow_clock(void)
 {
 	return (target_state == PM_SUSPEND_MEM);
 }
-EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 
 static void (*slow_clock)(void);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-3430sdp.c linux-3.0.x-arm/arch/arm/mach-omap2/board-3430sdp.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-3430sdp.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-3430sdp.c	2012-12-19 11:25:53.000000000 +0200
@@ -642,9 +642,9 @@
 
 static inline void board_serial_init(void)
 {
-	omap_serial_init_port(&serial1_data);
-	omap_serial_init_port(&serial2_data);
-	omap_serial_init_port(&serial3_data);
+	omap_serial_init_port(&serial1_data, NULL);
+	omap_serial_init_port(&serial2_data, NULL);
+	omap_serial_init_port(&serial3_data, NULL);
 }
 #else
 #define board_mux	NULL
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-4430sdp.c linux-3.0.x-arm/arch/arm/mach-omap2/board-4430sdp.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-4430sdp.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-4430sdp.c	2012-12-19 11:25:53.000000000 +0200
@@ -708,11 +708,11 @@
 	bdata.pads_cnt	= 0;
 	bdata.id	= 0;
 	/* pass dummy data for UART1 */
-	omap_serial_init_port(&bdata);
+	omap_serial_init_port(&bdata, NULL);
 
-	omap_serial_init_port(&serial2_data);
-	omap_serial_init_port(&serial3_data);
-	omap_serial_init_port(&serial4_data);
+	omap_serial_init_port(&serial2_data, NULL);
+	omap_serial_init_port(&serial3_data, NULL);
+	omap_serial_init_port(&serial4_data, NULL);
 }
 #else
 #define board_mux	NULL
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-flash.c linux-3.0.x-arm/arch/arm/mach-omap2/board-flash.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-flash.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-flash.c	2012-12-19 11:25:53.000000000 +0200
@@ -151,6 +151,9 @@
 	board_nand_data.ecc_opt = OMAP_ECC_HAMMING_CODE_DEFAULT;
 	board_nand_data.gpmc_irq = OMAP_GPMC_IRQ_BASE + cs;
 	gpmc_nand_init(&board_nand_data);
+
+	if(cpu_is_omap3630())
+		board_nand_data.ecc_opt = OMAP_ECC_HAMMING_CODE_HW;
 }
 #else
 void
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-n8x0.c linux-3.0.x-arm/arch/arm/mach-omap2/board-n8x0.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-n8x0.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-n8x0.c	2012-12-19 11:25:53.000000000 +0200
@@ -656,15 +656,15 @@
 	bdata.pads_cnt = 0;
 
 	bdata.id = 0;
-	omap_serial_init_port(&bdata);
+	omap_serial_init_port(&bdata, NULL);
 
 	bdata.id = 1;
-	omap_serial_init_port(&bdata);
+	omap_serial_init_port(&bdata, NULL);
 
 	bdata.id = 2;
 	bdata.pads = serial2_pads;
 	bdata.pads_cnt = ARRAY_SIZE(serial2_pads);
-	omap_serial_init_port(&bdata);
+	omap_serial_init_port(&bdata, NULL);
 }
 
 #else
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-omap4panda.c linux-3.0.x-arm/arch/arm/mach-omap2/board-omap4panda.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-omap4panda.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-omap4panda.c	2012-12-19 11:25:53.000000000 +0200
@@ -552,11 +552,11 @@
 	bdata.pads_cnt  = 0;
 	bdata.id        = 0;
 	/* pass dummy data for UART1 */
-	omap_serial_init_port(&bdata);
+	omap_serial_init_port(&bdata, NULL);
 
-	omap_serial_init_port(&serial2_data);
-	omap_serial_init_port(&serial3_data);
-	omap_serial_init_port(&serial4_data);
+	omap_serial_init_port(&serial2_data, NULL);
+	omap_serial_init_port(&serial3_data, NULL);
+	omap_serial_init_port(&serial4_data, NULL);
 }
 #else
 #define board_mux	NULL
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-owen-spk2xx-var.c linux-3.0.x-arm/arch/arm/mach-omap2/board-owen-spk2xx-var.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-owen-spk2xx-var.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-owen-spk2xx-var.c	2013-03-19 18:43:18.000000000 +0200
@@ -0,0 +1,987 @@
+/*
+ * linux/arch/arm/mach-omap2/board-owen-spk2xx-var.c
+ *
+ * Copyright (C) 2012 Softerra LLC.
+ * Author: Alex Dsugan <alex@softerra.com>
+ *
+ * Based on mach-omap2/board-var-som-am35.c,
+ * which is based on mach-omap2/board-am3517evm.c
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/input.h>
+#include <linux/mmc/host.h>
+#include <linux/etherdevice.h>
+#include <linux/davinci_emac.h>
+#include <linux/regulator/machine.h>
+#include <linux/can/platform/ti_hecc.h>
+#include <linux/serial.h>
+
+#include <linux/spi/spi.h>
+#include <plat/mcspi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/spi/eeprom.h>
+
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+
+#include <mach/hardware.h>
+#include <mach/am35xx.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/usb.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
+#include <plat/omap_hwmod.h>
+#include <plat/serial.h>
+#include <plat/omap-serial.h>
+
+#include <video/omapdss.h>
+#include <video/omap-panel-generic-dpi.h>
+
+#include "mux.h"
+#include "control.h"
+#include "common-board-devices.h"
+#include "hsmmc.h"
+#include "board-flash.h"
+
+#include <owen-common.h>
+
+/* GPIOs Definitions */
+
+/*LCD */
+#define LCD_BKLIGHT_EN		55
+/* for SPK210 value is 0, for SPK207 value is 1 */
+#ifdef CONFIG_OWEN_SPK210_VAR
+#define LCD_BKLIGHT_EN_VAL		0
+#else	/* CONFIG_OWEN_SPK207_VAR */
+#define LCD_BKLIGHT_EN_VAL		1
+#endif
+
+/* USB */
+#define USB_ENA		153
+#define USB_ENB		157
+#define USB_FLA 		128
+#define USB_FLB 		129
+
+#define USB_PHY1_RESET		154
+#define USB_PHY2_RESET		152
+
+/* SD-Card */
+#define SD_CARD_CD		142
+#define SD_CARD_CD_LEVEL	1
+
+/* Buttons, tumblers, leds */
+#define KN_BASE			34
+#define KN_COUNT		10
+#define TUMBLER1		185
+
+#define LED_SV1			102
+#define LED_SV2			103
+#define LED_SV3			104
+#define LED_SV4			105
+#define LED_SV5			133
+#define LED_SV6			136
+#define LED_SV7			137
+#define LED_SV8			94
+#define LED_SV9			138
+#define LED_SV10		117
+
+#define LED_READY		65
+#define BUZZER			63
+
+/* UARTs */
+
+#define SEL1				126
+#define SEL2				59
+
+#define UART4_DSRG		160
+#define UART4_DTRG		156
+#define UART4_DCDG		61
+#define UART4_RIG		54
+
+#define MASTER1			170
+#define MASTER2			186
+
+/* CAN */
+#define CAN_RS			143
+
+static struct mtd_partition var_am35_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "xloader-nand",
+		.offset		= 0,
+		.size		= 4*(SZ_128K),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "uboot-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 14*(SZ_128K),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "params-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 2*(SZ_128K)
+	},
+	{
+		.name		= "linux-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 40*(SZ_128K)
+	},
+	{
+		.name		= "jffs2-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+/* 
+ * Ethernet Controller
+ */
+
+//#define AM35XX_PHY_MASK		(0xF)
+#define AM35XX_MDIO_FREQUENCY   (1000000)
+
+static struct mdio_platform_data am3517_evm_mdio_pdata = {
+	.bus_freq	= AM35XX_MDIO_FREQUENCY,
+};
+
+static struct resource am3517_mdio_resources[] = {
+	{
+		.start	= AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET,
+		.end	= AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET +
+			  SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device am3517_mdio_device = {
+	.name		= "davinci_mdio",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(am3517_mdio_resources),
+	.resource	= am3517_mdio_resources,
+	.dev.platform_data = &am3517_evm_mdio_pdata,
+};
+
+static struct emac_platform_data am3517_emac_pdata = {
+	.rmii_en        = 1,
+};
+
+static int __init eth_addr_setup(char *str)
+{
+	int i;
+
+	if(str == NULL)
+		return 0;
+	for(i = 0; i <  ETH_ALEN; i++)
+		am3517_emac_pdata.mac_addr[i] = simple_strtol(&str[i*3],
+							(char **)NULL, 16);
+	return 1;
+}
+
+/* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
+__setup("eth=", eth_addr_setup);
+
+static struct resource am3517_emac_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE,
+		.end    = AM35XX_IPSS_EMAC_BASE + 0x3FFFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.end    = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_emac_device = {
+	.name           = "davinci_emac",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(am3517_emac_resources),
+	.resource       = am3517_emac_resources,
+};
+
+static void am3517_enable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_MISC_PULSE_CLR |
+		AM35XX_CPGMAC_C0_RX_THRESH_CLR );
+	omap_ctrl_writel(regval,AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+static void am3517_disable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR);
+	omap_ctrl_writel(regval,AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+static const uint8_t zero_mac[ETH_ALEN];
+static const uint8_t var_mac[ETH_ALEN] = { 0xF8, 0xDC, 0x7A, 0x00, 0x00, 0x00 };
+void am3517_ethernet_init(struct emac_platform_data *pdata)
+{
+	unsigned int regval;
+
+	pdata->ctrl_reg_offset		= AM35XX_EMAC_CNTRL_OFFSET;
+	pdata->ctrl_mod_reg_offset	= AM35XX_EMAC_CNTRL_MOD_OFFSET;
+	pdata->ctrl_ram_offset		= AM35XX_EMAC_CNTRL_RAM_OFFSET;
+	pdata->ctrl_ram_size		= AM35XX_EMAC_CNTRL_RAM_SIZE;
+	pdata->version			= EMAC_VERSION_2;
+	pdata->hw_ram_addr		= AM35XX_EMAC_HW_RAM_ADDR;
+	pdata->interrupt_enable 	= am3517_enable_ethernet_int;
+	pdata->interrupt_disable	= am3517_disable_ethernet_int;
+	am3517_emac_device.dev.platform_data	= pdata;
+
+	if ( !memcmp(pdata->mac_addr, zero_mac, ETH_ALEN) ) {
+		memcpy(pdata->mac_addr, var_mac, ETH_ALEN);
+		printk(KERN_ERR "error: no MAC address on cmd. line, set to F8:DC:7A:00:00:00\n");
+	}
+
+	platform_device_register(&am3517_emac_device);
+	platform_device_register(&am3517_mdio_device);
+	clk_add_alias(NULL, dev_name(&am3517_mdio_device.dev),
+		NULL, &am3517_emac_device.dev);
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+	regval = regval & (~(AM35XX_CPGMACSS_SW_RST));
+	omap_ctrl_writel(regval,AM35XX_CONTROL_IP_SW_RESET);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+
+	return ;
+}
+
+static struct i2c_board_info __initdata var_am35_i2c1_boardinfo[] = {
+	/* Audio Codec */
+	{
+		I2C_BOARD_INFO("tlv320aic23", 0x1A),	/* default addr's used; can be 1B if pin CS=1 */
+	},
+	/* RTC */
+	{
+		I2C_BOARD_INFO("ds1307", 0x68),
+		.type		= "ds1307",
+	},
+};
+
+static int __init am3517_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, NULL, 0);
+	return 0;
+}
+
+//TODO: innolux instead of URT_UMSH8272
+static void __init am3517_display_init(void)
+{
+#ifdef CONFIG_PANEL_VARISCITE
+
+	int r;
+	/* init and disable LCD backlight */
+	r = gpio_request(LCD_BKLIGHT_EN, "LCD_BKLIGHT_EN");
+	if (r) {
+		printk(KERN_ERR "failed to get LCD_BKLIGHT_EN gpio\n");
+		return;
+	}
+	omap_mux_init_gpio(LCD_BKLIGHT_EN, OMAP_PIN_OUTPUT);
+	gpio_direction_output(LCD_BKLIGHT_EN, !LCD_BKLIGHT_EN_VAL);
+#endif
+}
+
+static int am3517_panel_enable_lcd(struct omap_dss_device *dssdev)
+{
+	pr_info("%s: called\n", __func__);
+	gpio_set_value(LCD_BKLIGHT_EN, LCD_BKLIGHT_EN_VAL);
+	return 0;
+}
+
+static void am3517_panel_disable_lcd(struct omap_dss_device *dssdev)
+{
+	pr_info("%s: called\n", __func__);
+	gpio_set_value(LCD_BKLIGHT_EN, !LCD_BKLIGHT_EN_VAL);
+}
+
+static struct omap_dss_device am3517_lcd_device = {
+	.type			= OMAP_DISPLAY_TYPE_DPI,
+	.name			= "lcd",
+	.driver_name		= "URT_UMSH8272MD",
+	.phy.dpi.data_lines 	= 24,
+	.platform_enable	= am3517_panel_enable_lcd,
+	.platform_disable	= am3517_panel_disable_lcd,
+};
+
+static struct omap_dss_device *am3517_dss_devices[] = {
+	&am3517_lcd_device,
+};
+
+static struct omap_dss_board_info am3517_dss_data = {
+	.num_devices	= ARRAY_SIZE(am3517_dss_devices),
+	.devices	= am3517_dss_devices,
+	.default_device	= &am3517_lcd_device,
+};
+
+static char *am3517_unused_hwmods[] = {
+	"iva",
+	"sr1_hwmod",
+	"sr2_hwmod",
+	"mailbox",
+	"usb_otg_hs",
+	NULL,
+};
+
+/*
+ * Board initialization
+ */
+static void __init am3517_init_early(void)
+{
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	/* allocate retain memory shadow buffer */
+	owen_alloc_retain_memory(NULL);
+#endif
+	omap2_disable_unused_hwmods(am3517_unused_hwmods);
+	omap2_init_common_infrastructure();
+	omap2_init_common_devices(NULL, NULL);
+}
+
+static struct omap_musb_board_data musb_board_data = {
+	.interface_type	= MUSB_INTERFACE_ULPI,
+	.mode		= MUSB_OTG,
+	.power		= 500,
+	.set_phy_power		= am35x_musb_phy_power,
+	.clear_irq		= am35x_musb_clear_irq,
+	.set_mode		= am35x_set_mode,
+	.reset			= am35x_musb_reset,
+};
+
+static __init void am3517_musb_init(void)
+{
+	u32 devconf2;
+
+	/*
+	 * Set up USB clock/mode in the DEVCONF2 register.
+	 */
+	devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);
+
+	/* USB2.0 PHY reference clock is 13 MHz */
+	devconf2 &= ~(CONF2_REFFREQ | CONF2_OTGMODE | CONF2_PHY_GPIOMODE);
+	devconf2 |=  CONF2_REFFREQ_13MHZ | CONF2_SESENDEN | CONF2_VBDTCTEN
+			| CONF2_DATPOL;
+
+	omap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);
+
+	usb_musb_init(&musb_board_data);
+}
+
+static const struct usbhs_omap_board_data ehci_pdata __initconst = {
+	.port_mode[0] = OMAP_EHCI_PORT_MODE_PHY,
+	.port_mode[1] = OMAP_EHCI_PORT_MODE_PHY, 
+	.port_mode[2] = OMAP_USBHS_PORT_MODE_UNUSED,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = USB_PHY1_RESET,
+	.reset_gpio_port[1]  = USB_PHY2_RESET,		
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	OMAP3_MUX(CHASSIS_DMAREQ3, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLDOWN),
+
+	/* configure pins like for spi1 (by debugfs) */
+	OMAP3_MUX(SDMMC2_CLK, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),	/* mcspi3_clk */
+	OMAP3_MUX(SDMMC2_CMD, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),	/* mcspi3_simo */
+	OMAP3_MUX(SDMMC2_DAT0, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),	/* mcspi3_somi */
+	OMAP3_MUX(SDMMC2_DAT2, OMAP_MUX_MODE1 | OMAP_PIN_INPUT_PULLDOWN),	/* mcspi3_cs1 */
+	OMAP3_MUX(SDMMC2_DAT3, OMAP_MUX_MODE1 | OMAP_PIN_INPUT_PULLDOWN),	/* mcspi3_cs0 */
+
+	/* UART4 RX, TX, RTS, CTS */
+	OMAP3_MUX(CCDC_WEN, OMAP_MUX_MODE2 | OMAP_PIN_INPUT),	/* uart4_rx, pin 57 */
+	OMAP3_MUX(CCDC_FIELD, OMAP_MUX_MODE2 | OMAP_PIN_OUTPUT),	/* uart4_tx, pin 80 */
+	OMAP3_MUX(CCDC_HD, OMAP_MUX_MODE2 | OMAP_PIN_OUTPUT),	/* uart4_rts, pin78 */
+	OMAP3_MUX(CCDC_VD, OMAP_MUX_MODE2 | OMAP_PIN_INPUT),		/* uart4_cts, pin 76 */
+
+	/* SEL1, SEL2 */
+	OMAP3_MUX(SDMMC1_DAT4, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),		/* Ambiguous: SEL1 = gpio126 (pin 27), out */
+	OMAP3_MUX(GPMC_CLK, OMAP_MUX_MODE4 | OMAP_PIN_OUTPUT),			/* SEL2 = gpio59, out */
+
+#if defined(CONFIG_CAN_TI_HECC) || defined(CONFIG_CAN_TI_HECC_MODULE)
+	/* CAN signals */
+	OMAP3_MUX(HECC1_TXD, OMAP_MUX_MODE0 | OMAP_PIN_OUTPUT),
+	OMAP3_MUX(HECC1_RXD, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLUP),
+#endif
+
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#endif
+
+/*
+ * Touch Panel: ADS 7846
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+
+#define ADS7846_PENDOWN_GPIO	57
+
+static void __init ads7846_dev_init(void)
+{
+	/* configure  GPIO for pendown interrupt */
+	omap_mux_init_gpio(ADS7846_PENDOWN_GPIO, OMAP_PIN_INPUT_PULLUP);
+
+	if (gpio_request(ADS7846_PENDOWN_GPIO, "ADS7846 pendown") < 0)
+		printk(KERN_ERR "can't get ads7846 pen down GPIO\n");
+
+	gpio_direction_input(ADS7846_PENDOWN_GPIO);
+
+	gpio_set_debounce(ADS7846_PENDOWN_GPIO, 1);
+}
+
+static int ads7846_get_pendown_state(void)
+{
+	return !gpio_get_value(ADS7846_PENDOWN_GPIO);
+}
+
+struct ads7846_platform_data ads7846_config = {
+	.x_plate_ohms		= 700,	/* 400 - 1000 DA0-A337A-BC0 */
+//	.y_plate_ohms		= 500,	/* 100 - 500 DA0-A337A-BC0 */
+//	.pressure_max		= 15000,	/* comment it to use max possible */
+
+	.debounce_max		= 10,
+	.debounce_tol		=	15,
+	.debounce_rep		= 1,
+	
+	.get_pendown_state	= ads7846_get_pendown_state,
+	.keep_vref_on		= 1,
+	.settle_delay_usecs	= 150,
+	.wakeup			= true,
+
+	.swap_xy = 1,				/* doesn't matter */
+};
+
+#else
+static void __init ads7846_dev_init(void) {}
+#endif /* CONFIG_TOUCHSCREEN_ADS7846 */
+
+/* mr25h10 */
+static struct spi_eeprom eeprom_data = {
+	.name = "mr25h10",
+	.byte_len = 131072,	/* 128 KB */
+	.page_size = 4092,		/* the max page size for a successful spi transfer(4 byte WRITE + 4092=PAGE_SIZE ) */
+	.flags = EE_ADDR3 | EE_NODELAY_WRITE | EE_ARBITRARY_WRITE,
+};
+
+/* SPI boards */
+struct spi_board_info spk2xx_var_spi_board_info[] = {
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias		= "ads7846",
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 1500000,
+		.irq			= OMAP_GPIO_IRQ(ADS7846_PENDOWN_GPIO),
+		.platform_data		= &ads7846_config,
+	},
+#endif	/* CONFIG_TOUCHSCREEN_ADS7846 */
+
+	{	/* MRAM */
+		.modalias = "at25",
+		.bus_num = 3,
+		.chip_select = 0,
+		.max_speed_hz = 40 * 1000000,
+		.platform_data = &eeprom_data,
+	},
+	{	/* ATtiny */
+		.modalias = "spidev",
+		.bus_num = 3,
+		.chip_select = 1,
+		.max_speed_hz = 50 * 1000,	/* actual freq. 46875 Hz */
+	},
+};
+
+#if defined(CONFIG_CAN_TI_HECC) || defined(CONFIG_CAN_TI_HECC_MODULE)
+static struct resource am3517_hecc_resources[] = {
+	{
+		.start	= AM35XX_IPSS_HECC_BASE,
+		.end	= AM35XX_IPSS_HECC_BASE + 0x3FFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= INT_35XX_HECC0_IRQ,
+		.end	= INT_35XX_HECC0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_hecc_device = {
+	.name			= "ti_hecc",
+	.id			= -1,	/* FIXME: it was +1 in the previous version */
+	.num_resources		= ARRAY_SIZE(am3517_hecc_resources),
+	.resource		= am3517_hecc_resources,
+};
+
+static void spk2xx_hecc_transceiver_switch(int on)
+{
+	gpio_set_value(CAN_RS, !!on);
+}
+
+static struct ti_hecc_platform_data am3517_hecc_pdata = {
+	.scc_hecc_offset	= AM35XX_HECC_SCC_HECC_OFFSET,
+	.scc_ram_offset		= AM35XX_HECC_SCC_RAM_OFFSET,
+	.hecc_ram_offset	= AM35XX_HECC_RAM_OFFSET,
+	.mbx_offset		= AM35XX_HECC_MBOX_OFFSET,
+	.int_line		= AM35XX_HECC_INT_LINE,
+	.version		= AM35XX_HECC_VERSION,
+	.transceiver_switch = spk2xx_hecc_transceiver_switch,
+};
+
+static void __init am3517_hecc_init(struct ti_hecc_platform_data *pdata)
+{
+	omap_mux_init_gpio(CAN_RS, OMAP_PIN_OUTPUT);
+	gpio_request(CAN_RS, "CAN_RS");
+	gpio_direction_output(CAN_RS, 0); /* set default - standby mode. CAN_RS inverted: 0 -high speed mode, 1 - standby mode */
+
+	am3517_hecc_device.dev.platform_data = pdata;
+	platform_device_register(&am3517_hecc_device);
+}
+#endif
+
+static struct omap2_hsmmc_info mmc[] = {
+	{
+		.mmc		= 1,
+		.caps		= MMC_CAP_4_BIT_DATA,
+		.gpio_cd	= SD_CARD_CD,
+		.cd_level	= SD_CARD_CD_LEVEL,
+		.gpio_wp	= -EINVAL, /* not suported */
+	},
+	{}      /* Terminator */
+};
+
+#if 0
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button owen_spk2xx_buttons[] = {
+	{	/* BTN, "KN1" */
+		.code		= BTN_0,
+		.gpio		= KN_BASE,
+		.active_low	= 1,
+		.desc		= "kn1",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN2" */
+		.code		= BTN_1,
+		.gpio		= KN_BASE + 1,
+		.active_low	= 1,
+		.desc		= "kn2",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN3" */
+		.code		= BTN_2,
+		.gpio		= KN_BASE + 2,
+		.active_low	= 1,
+		.desc		= "kn3",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN4" */
+		.code		= BTN_3,
+		.gpio		= KN_BASE + 3,
+		.active_low	= 1,
+		.desc		= "kn4",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN5" */
+		.code		= BTN_4,
+		.gpio		= KN_BASE + 4,
+		.active_low	= 1,
+		.desc		= "kn5",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN6" */
+		.code		= BTN_5,
+		.gpio		= KN_BASE + 5,
+		.active_low	= 1,
+		.desc		= "kn6",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN7" */
+		.code		= BTN_6,
+		.gpio		= KN_BASE + 6,
+		.active_low	= 1,
+		.desc		= "kn7",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN8" */
+		.code		= BTN_7,
+		.gpio		= KN_BASE + 7,
+		.active_low	= 1,
+		.desc		= "kn8",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN9" */
+		.code		= BTN_8,
+		.gpio		= KN_BASE + 8,
+		.active_low	= 1,
+		.desc		= "kn9",
+		.wakeup		= 1,
+	},
+	{	/* BTN, "KN10" */
+		.code		= BTN_9,
+		.gpio		= KN_BASE + 9,
+		.active_low	= 1,
+		.desc		= "kn10",
+		.wakeup		= 1,
+	}
+};
+
+static struct gpio_keys_platform_data owen_spk2xx_button_data = {
+	.buttons	= owen_spk2xx_buttons,
+	.nbuttons	= ARRAY_SIZE(owen_spk2xx_buttons),
+};
+
+static struct platform_device owen_spk2xx_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &owen_spk2xx_button_data,
+	}
+};
+
+static void __init owen_spk2xx_add_device_buttons(void)
+{
+	int i;
+	for (i = KN_BASE; i < KN_BASE + KN_COUNT; i++) {
+		omap_mux_init_gpio(i, OMAP_PIN_INPUT_PULLUP);
+	}
+
+	platform_device_register(&owen_spk2xx_button_device);
+}
+#else
+static void __init owen_spk2xx_add_device_buttons(void) {}
+#endif
+
+/*
+ * LEDs ... these could all be PWM-driven, for variable brightness
+ */
+static struct gpio_led owen_spk2xx_leds[] = {
+	{	/* SV1 */
+		.name			= "sv1",
+		.gpio			= LED_SV1,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV2 */
+		.name			= "sv2",
+		.gpio			= LED_SV2,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV3 */
+		.name			= "sv3",
+		.gpio			= LED_SV3,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV4 */
+		.name			= "sv4",
+		.gpio			= LED_SV4,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV5 */
+		.name			= "sv5",
+		.gpio			= LED_SV5,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV6 */
+		.name			= "sv6",
+		.gpio			= LED_SV6,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV7 */
+		.name			= "sv7",
+		.gpio			= LED_SV7,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV8 */
+		.name			= "sv8",
+		.gpio			= LED_SV8,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV9 */
+		.name			= "sv9",
+		.gpio			= LED_SV9,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* SV10 */
+		.name			= "sv10",
+		.gpio			= LED_SV10,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+
+	{	/* BUZZER */
+		.name			= "buzzer",
+		.gpio			= BUZZER,
+		.active_low		= 0,
+		.default_trigger	= "none",
+	},
+	{	/* READY */
+		.name			= "ready",
+		.gpio			= LED_READY,
+		.default_trigger	= "none",
+	}
+};
+#endif
+
+static struct omap_board_config_kernel am3517_config[] __initdata = {
+};
+
+static struct omap_uart_port_info board_uart_port_info[] = {
+	/* 0 - UART1: RS323 & CAN or RS232 | RS485 */
+	{
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		.pdev_id = 2,
+#endif
+		/* RS232 by default */
+		.rs485 = {
+			.flags = 0,
+		},
+		.rs485_switch = {
+#if !(defined(CONFIG_CAN_TI_HECC) || defined(CONFIG_CAN_TI_HECC_MODULE))
+			/* non-CAN version - switchable */
+			.enabled = 1,
+#else
+			/* CAN version - non-switchable, RS232 only */
+			.enabled = 0,
+#endif
+			.pin = SEL1,
+			.rs485_level = 1,
+		},
+	},
+
+	/* 1 - UART2:  RS232 | RS485 | no tty - HPR */
+	{
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		.pdev_id = 3,
+#endif
+		/* switchable, RS232 by default */
+		.rs485 = {
+			.flags = 0,
+		},
+		.rs485_switch = {
+			.enabled = 1,
+			.pin = SEL2,
+			.rs485_level = 1,
+		},
+	},
+
+	/* 2 - UART3: Debug */
+	{
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		.pdev_id = 0,
+#endif
+	},
+
+	/* 3 - UART4: RS232 full modem */
+	{
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		.pdev_id = 1,
+#endif
+			
+		.pin_DTR = UART4_DTRG,
+		.pin_DSR = UART4_DSRG,
+		.pin_DCD = UART4_DCDG,
+		.pin_RI = UART4_RIG,
+	},
+};
+
+#ifdef CONFIG_DEBUG_FS
+#define pin_name(name,n) (n==0?name ".0":(n==1?name ".1":(n==2?name ".2":(n==3?name ".3":name))))
+#else
+#define pin_name(name,n) NULL
+#endif
+
+static void __init board_serial_init(void)
+{
+	int i;
+	int pdev_id;
+	struct omap_board_data bdata;
+
+	bdata.flags = 0;
+	bdata.pads = NULL;
+	bdata.pads_cnt = 0;
+
+	for (i = 0; i < 4; i++) {
+		bdata.id = i;
+		omap_serial_init_port(&bdata, &board_uart_port_info[i]);
+
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		pdev_id = board_uart_port_info[i].pdev_id;
+#else
+		pdev_id = i;
+#endif
+
+		/* configure additional GPIO pads right here */
+		if (board_uart_port_info[i].rs485_switch.pin) {
+			/* muxed by board muxes, becuase SEL1 is ambiguous */
+			gpio_request(board_uart_port_info[i].rs485_switch.pin, 
+							pin_name("rs485_sw", pdev_id));
+			/* set initial state */
+			gpio_direction_output(board_uart_port_info[i].rs485_switch.pin, 
+					board_uart_port_info[i].rs485.flags & SER_RS485_ENABLED ?
+						board_uart_port_info[i].rs485_switch.rs485_level : 
+						!board_uart_port_info[i].rs485_switch.rs485_level);
+		}
+		
+		if (board_uart_port_info[i].pin_DTR) {
+			omap_mux_init_gpio(board_uart_port_info[i].pin_DTR, OMAP_PIN_OUTPUT);
+			gpio_request(board_uart_port_info[i].pin_DTR, pin_name("DTR", pdev_id));
+			gpio_direction_output(board_uart_port_info[i].pin_DTR, 1);
+		}
+		if (board_uart_port_info[i].pin_DSR) {
+			omap_mux_init_gpio(board_uart_port_info[i].pin_DSR, OMAP_PIN_INPUT_PULLUP);
+			gpio_request(board_uart_port_info[i].pin_DSR, pin_name("DSR", pdev_id));
+			gpio_direction_input(board_uart_port_info[i].pin_DSR); 
+		}
+		if (board_uart_port_info[i].pin_DCD) {
+			omap_mux_init_gpio(board_uart_port_info[i].pin_DCD, OMAP_PIN_INPUT_PULLUP);
+			gpio_request(board_uart_port_info[i].pin_DCD, pin_name("DCD", pdev_id));
+			gpio_direction_input(board_uart_port_info[i].pin_DCD); 
+		}
+		if (board_uart_port_info[i].pin_RI) {
+			omap_mux_init_gpio(board_uart_port_info[i].pin_RI, OMAP_PIN_INPUT_PULLUP);
+			gpio_request(board_uart_port_info[i].pin_RI, pin_name("RI", pdev_id));
+			gpio_direction_input(board_uart_port_info[i].pin_RI); 
+		}
+	}
+
+	omap_mux_init_gpio(MASTER1, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(MASTER2, OMAP_PIN_OUTPUT);
+	gpio_request(MASTER1, "MASTER1");
+	gpio_request(MASTER2, "MASTER2");
+	gpio_direction_output(MASTER1, 0);
+	gpio_direction_output(MASTER2, 0);
+	gpio_free(MASTER1);
+	gpio_free(MASTER2);
+}
+
+static void __init am3517_init(void)
+{
+	omap_board_config = am3517_config;
+	omap_board_config_size = ARRAY_SIZE(am3517_config);
+	omap3_mux_init(board_mux, OMAP_PACKAGE_ZCN);
+
+	am3517_i2c_init();
+	omap_display_init(&am3517_dss_data);
+	//omap_serial_init();
+	board_serial_init();
+
+	am3517_musb_init();
+
+	/* Configure EHCI ports */
+	omap_mux_init_gpio(USB_ENA, OMAP_PIN_OUTPUT);
+	gpio_request(USB_ENA, "USB_ENA");
+	gpio_direction_output(USB_ENA, 0);	// turn on (low is active - SP2526A-2)
+
+	omap_mux_init_gpio(USB_ENB, OMAP_PIN_OUTPUT);
+	gpio_request(USB_ENB, "USB_ENB");
+	gpio_direction_output(USB_ENB, 0);	// turn on (low is active - SP2526A-2)
+
+	omap_mux_init_gpio(USB_FLA, OMAP_PIN_INPUT_PULLUP);
+	omap_mux_init_gpio(USB_FLB, OMAP_PIN_INPUT_PULLUP);
+
+	omap_mux_init_gpio(USB_PHY1_RESET, OMAP_PIN_OUTPUT); // ECHI port 1 reset
+	omap_mux_init_gpio(USB_PHY2_RESET, OMAP_PIN_OUTPUT); // ECHI port 2 reset
+
+	usbhs_init(&ehci_pdata);
+	
+#if defined(CONFIG_CAN_TI_HECC) || defined(CONFIG_CAN_TI_HECC_MODULE)
+	am3517_hecc_init(&am3517_hecc_pdata); // available on CustomBoard V2.0 and forth
+#endif
+
+/* DSS */
+	am3517_display_init();
+
+	i2c_register_board_info(1, var_am35_i2c1_boardinfo,
+				ARRAY_SIZE(var_am35_i2c1_boardinfo));
+
+	/*Ethernet*/
+	am3517_ethernet_init(&am3517_emac_pdata);
+
+	/*NAND*/
+	board_nand_init(var_am35_nand_partitions,
+			ARRAY_SIZE(var_am35_nand_partitions),
+			0, NAND_BUSWIDTH_16);
+
+	/* register SPI interfaces */
+	spi_register_board_info(spk2xx_var_spi_board_info,
+				ARRAY_SIZE(spk2xx_var_spi_board_info));
+
+	/* ADS7846 init function */
+	ads7846_dev_init();
+
+	/* MMC init */
+	omap_mux_init_gpio(SD_CARD_CD, OMAP_PIN_INPUT_PULLUP);
+	omap2_hsmmc_init(mmc);
+
+	/* Push Buttons */
+	//owen_spk2xx_add_device_buttons();
+	/* Tumbler TUMB1 (SA2) */
+	omap_mux_init_gpio(TUMBLER1, OMAP_PIN_INPUT_PULLUP);
+
+#if defined (CONFIG_OWEN_RETAIN_MEMORY)
+	owen_setup_rm_info_iface();
+#endif
+}
+
+MACHINE_START(OWEN_SPK2XX_VAR, "Owen SPK2xx VAR")
+	.boot_params	= 0x80000100,
+	.reserve	= omap_reserve,
+	.map_io		= omap3_map_io,
+	.init_early	= am3517_init_early,
+	.init_irq	= omap_init_irq,
+	.init_machine	= am3517_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/board-var-som-am35.c linux-3.0.x-arm/arch/arm/mach-omap2/board-var-som-am35.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/board-var-som-am35.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/board-var-som-am35.c	2012-12-19 11:25:53.000000000 +0200
@@ -0,0 +1,710 @@
+/*
+ * linux/arch/arm/mach-omap2/board-var-som-am35.c
+ *
+ * Copyright (C) 2010,2011 Variscite LTD.
+ * Author: Alex Bikhdriker <alex@variscite.com>
+ * Modified: Vladik Goytin
+ *
+ * Based on mach-omap2/board-am3517evm.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as  published by the
+ * Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/input.h>
+#include <linux/mmc/host.h>
+#include <linux/etherdevice.h>
+#include <linux/davinci_emac.h>
+#include <linux/regulator/machine.h>
+#include <linux/can/platform/ti_hecc.h>
+
+#include <linux/spi/spi.h>
+#include <plat/mcspi.h>
+#include <linux/spi/ads7846.h>
+
+#include <mach/hardware.h>
+#include <mach/am35xx.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/usb.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
+#include <plat/omap_hwmod.h>
+#include <video/omapdss.h>
+#include <video/omap-panel-generic-dpi.h>
+
+#include "mux.h"
+#include "control.h"
+#include "common-board-devices.h"
+#include "hsmmc.h"
+#include "board-flash.h"
+
+// CustomBoard ver 2.1
+#define CUSTOM_VER_2_1 
+
+
+#define GPMC_CS0_BASE  0x60
+#define GPMC_CS_SIZE   0x30
+
+#define NAND_BLOCK_SIZE        SZ_128K
+
+/* GPIOs Definitions */
+
+
+
+// LCD
+#ifndef CUSTOM_VER_2_1
+// LCD Power and level shifters are always on at CustomBoard v2.1
+#define LCD_LVL_SFHT_BUF_ENn	43
+#define LCD_PWR_ENn		131
+#endif
+
+#define LCD_BKLIGHT_EN		186
+
+#ifdef CUSTOM_VER_2_1
+#define HDMI_TRCVR_PDn		43
+#else
+#define HDMI_TRCVR_PDn		133
+
+#endif
+
+
+// USB
+#ifdef CUSTOM_VER_2_1
+#define USB_HOST_PWR_EN		98
+#else
+#define USB_HOST_PWR_EN		132
+#endif
+
+#define USB_PHY1_RESET		154
+#define USB_PHY2_RESET		152
+
+
+// SD-Card
+#define SD_CARD_CD		61
+#define SD_CARD_WP		65
+
+
+
+static struct mtd_partition var_am35_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "xloader-nand",
+		.offset		= 0,
+		.size		= 4*(SZ_128K),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "uboot-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 14*(SZ_128K),
+		.mask_flags	= MTD_WRITEABLE
+	},
+	{
+		.name		= "params-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 2*(SZ_128K)
+	},
+	{
+		.name		= "linux-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 40*(SZ_128K)
+	},
+	{
+		.name		= "jffs2-nand",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+
+/* 
+ * Ethernet Controller
+ */
+
+#define AM35XX_PHY_MASK		(0xF)
+#define AM35XX_MDIO_FREQUENCY   (1000000)
+
+static struct mdio_platform_data am3517_evm_mdio_pdata = {
+	.bus_freq	= AM35XX_MDIO_FREQUENCY,
+};
+
+static struct resource am3517_mdio_resources[] = {
+	{
+		.start	= AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET,
+		.end	= AM35XX_IPSS_EMAC_BASE + AM35XX_EMAC_MDIO_OFFSET +
+			  SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device am3517_mdio_device = {
+	.name		= "davinci_mdio",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(am3517_mdio_resources),
+	.resource	= am3517_mdio_resources,
+	.dev.platform_data = &am3517_evm_mdio_pdata,
+};
+
+static struct emac_platform_data am3517_emac_pdata = {
+	.rmii_en        = 1,
+};
+
+static int __init eth_addr_setup(char *str)
+{
+	int i;
+
+	if(str == NULL)
+		return 0;
+	for(i = 0; i <  ETH_ALEN; i++)
+		am3517_emac_pdata.mac_addr[i] = simple_strtol(&str[i*3],
+							(char **)NULL, 16);
+	return 1;
+}
+
+/* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
+__setup("eth=", eth_addr_setup);
+
+static struct resource am3517_emac_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE,
+		.end    = AM35XX_IPSS_EMAC_BASE + 0x3FFFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.end    = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_emac_device = {
+	.name           = "davinci_emac",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(am3517_emac_resources),
+	.resource       = am3517_emac_resources,
+};
+
+static void am3517_enable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_MISC_PULSE_CLR |
+		AM35XX_CPGMAC_C0_RX_THRESH_CLR );
+	omap_ctrl_writel(regval,AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+static void am3517_disable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR);
+	omap_ctrl_writel(regval,AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+
+static const uint8_t zero_mac[ETH_ALEN];
+static const uint8_t var_mac[ETH_ALEN] = { 0xF8, 0xDC, 0x7A, 0x00, 0x00, 0x00 };
+void am3517_ethernet_init(struct emac_platform_data *pdata)
+{
+	unsigned int regval;
+
+	pdata->ctrl_reg_offset		= AM35XX_EMAC_CNTRL_OFFSET;
+	pdata->ctrl_mod_reg_offset	= AM35XX_EMAC_CNTRL_MOD_OFFSET;
+	pdata->ctrl_ram_offset		= AM35XX_EMAC_CNTRL_RAM_OFFSET;
+	pdata->ctrl_ram_size		= AM35XX_EMAC_CNTRL_RAM_SIZE;
+	pdata->version			= EMAC_VERSION_2;
+	pdata->hw_ram_addr		= AM35XX_EMAC_HW_RAM_ADDR;
+	pdata->interrupt_enable 	= am3517_enable_ethernet_int;
+	pdata->interrupt_disable	= am3517_disable_ethernet_int;
+	am3517_emac_device.dev.platform_data	= pdata;
+
+	if ( !memcmp(pdata->mac_addr, zero_mac, ETH_ALEN) ) {
+		memcpy(pdata->mac_addr, var_mac, ETH_ALEN);
+		printk(KERN_ERR "error: no MAC address on cmd. line, set to F8:DC:7A:00:00:00\n");
+	}
+
+	platform_device_register(&am3517_emac_device);
+	platform_device_register(&am3517_mdio_device);
+	clk_add_alias(NULL, dev_name(&am3517_mdio_device.dev),
+		NULL, &am3517_emac_device.dev);
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+	regval = regval & (~(AM35XX_CPGMACSS_SW_RST));
+	omap_ctrl_writel(regval,AM35XX_CONTROL_IP_SW_RESET);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+
+	return ;
+}
+
+static struct i2c_board_info __initdata var_am35_i2c1_boardinfo[] = {
+	/* Audio Codec */
+	{
+		I2C_BOARD_INFO("tlv320aic23", 0x1A),
+	},
+	/* RTC */
+	{
+		I2C_BOARD_INFO("ds1307", 0x68), /* 0xD0 */
+		.type		= "ds1307",
+	},
+};
+
+static int __init am3517_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, NULL,0);
+	omap_register_i2c_bus(2, 400, NULL, 0);
+	omap_register_i2c_bus(3, 400, NULL, 0);
+
+	return 0;
+}
+
+static int lcd_enabled;
+static int dvi_enabled;
+
+static void __init am3517_display_init(void)
+{
+#ifdef CONFIG_PANEL_VARISCITE
+	int r;
+
+	/* disable LCD backlight */
+	r = gpio_request(LCD_BKLIGHT_EN, "LCD_BKLIGHT_EN");
+	if (r) {
+		printk(KERN_ERR "failed to get LCD_BKLIGHT_EN gpio\n");
+		goto err_1;
+	}
+	omap_mux_init_gpio(LCD_BKLIGHT_EN, OMAP_PIN_OUTPUT);
+	gpio_direction_output(LCD_BKLIGHT_EN, 1);
+	gpio_set_value(LCD_BKLIGHT_EN, 0);
+
+#ifndef CUSTOM_VER_2_1
+// LCD power and level shifter are always on at CustomBoard v2.1
+
+	/* Enable VIO-> 3.3v level shifter */
+	r = gpio_request(LCD_LVL_SFHT_BUF_ENn, "LCD_LVL_SFHT_BUF_ENn");
+	if (r) {
+		printk(KERN_ERR "failed to get LCD_LVL_SFHT_BUF_ENn gpio\n");
+		goto err_2;
+	}
+	omap_mux_init_gpio(LCD_LVL_SFHT_BUF_ENn, OMAP_PIN_OUTPUT);
+	gpio_direction_output(LCD_LVL_SFHT_BUF_ENn, 1);
+	gpio_set_value(LCD_LVL_SFHT_BUF_ENn, 0);
+	
+	/* Enable LCD panel VCC */
+
+	r = gpio_request(LCD_PWR_ENn, "LCD_PWR_ENn");
+	if (r) {
+		printk(KERN_ERR "failed to get LCD_PWR_ENn\n");
+		goto err_3;
+	}
+
+	gpio_direction_output(LCD_PWR_ENn, 1);
+	gpio_set_value(LCD_PWR_ENn, 0);
+#endif
+
+	/* Disable HDMI transceiver */
+	r = gpio_request(HDMI_TRCVR_PDn, "HDMI_TRCVR_PDn");
+	if (r) {
+		printk(KERN_ERR "failed to get HDMI_TRCVR_PDn\n");
+		goto err_4;
+	}
+	omap_mux_init_gpio(HDMI_TRCVR_PDn, OMAP_PIN_OUTPUT);
+	gpio_direction_output(HDMI_TRCVR_PDn, 1);
+	gpio_set_value(HDMI_TRCVR_PDn, 0);
+
+	return;
+
+err_4:
+	gpio_free(HDMI_TRCVR_PDn);
+#ifndef CUSTOM_VER_2_1
+err_3:
+	gpio_free(LCD_LVL_SFHT_BUF_ENn);
+err_2:
+	gpio_free(LCD_PWR_ENn);
+#endif
+err_1:
+	gpio_free(LCD_BKLIGHT_EN);
+#endif /* CONFIG_PANEL_VARISCITE */
+}
+
+static int am3517_panel_enable_lcd(struct omap_dss_device *dssdev)
+{
+	if (dvi_enabled) {
+		printk(KERN_ERR "cannot enable LCD, DVI is enabled\n");
+		return -EINVAL;
+	}
+
+	gpio_set_value(LCD_BKLIGHT_EN, 1);
+	lcd_enabled = 1;
+
+	return 0;
+}
+
+static void am3517_panel_disable_lcd(struct omap_dss_device *dssdev)
+{
+	gpio_set_value(LCD_BKLIGHT_EN, 0);
+	lcd_enabled = 0;
+}
+
+static struct omap_dss_device am3517_lcd_device = {
+	.type			= OMAP_DISPLAY_TYPE_DPI,
+	.name			= "lcd",
+	.driver_name		= "URT_UMSH8272MD",
+	.phy.dpi.data_lines 	= 24,
+	.platform_enable	= am3517_panel_enable_lcd,
+	.platform_disable	= am3517_panel_disable_lcd,
+};
+
+/* 
+ * TV Output
+ */
+
+static int am3517_panel_enable_tv(struct omap_dss_device *dssdev)
+{
+	return 0;
+}
+
+static void am3517_panel_disable_tv(struct omap_dss_device *dssdev)
+{
+}
+
+static struct omap_dss_device am3517_tv_device = {
+	.type 			= OMAP_DISPLAY_TYPE_VENC,
+	.name 			= "tv",
+	.driver_name		= "venc",
+	.phy.venc.type		= OMAP_DSS_VENC_TYPE_SVIDEO,
+	.platform_enable	= am3517_panel_enable_tv,
+	.platform_disable	= am3517_panel_disable_tv,
+};
+
+/* 
+ * DVI/HDMI Output
+ */
+
+static int am3517_panel_enable_dvi(struct omap_dss_device *dssdev)
+{
+	if (lcd_enabled) {
+		printk(KERN_ERR "cannot enable DVI, LCD is enabled\n");
+		return -EINVAL;
+	}
+	dvi_enabled = 1;
+	gpio_set_value(HDMI_TRCVR_PDn, 1);
+	return 0;
+}
+
+static void am3517_panel_disable_dvi(struct omap_dss_device *dssdev)
+{
+	dvi_enabled = 0;
+	gpio_set_value(HDMI_TRCVR_PDn, 0);
+}
+
+static struct panel_generic_dpi_data dvi_panel = {
+	.name			= "generic",
+	.platform_enable	= am3517_panel_enable_dvi,
+	.platform_disable	= am3517_panel_disable_dvi,
+};
+
+static struct omap_dss_device am3517_dvi_device = {
+	.type			= OMAP_DISPLAY_TYPE_DPI,
+	.name			= "dvi",
+	.driver_name		= "generic_dpi_panel",
+	.data			= &dvi_panel,
+	.phy.dpi.data_lines	= 24,
+};
+
+static struct omap_dss_device *am3517_dss_devices[] = {
+	&am3517_lcd_device,
+	&am3517_tv_device,
+	&am3517_dvi_device,
+};
+
+static struct omap_dss_board_info am3517_dss_data = {
+	.num_devices	= ARRAY_SIZE(am3517_dss_devices),
+	.devices	= am3517_dss_devices,
+	.default_device	= &am3517_lcd_device,
+};
+
+static char *am3517_unused_hwmods[] = {
+	"iva",
+	"sr1_hwmod",
+	"sr2_hwmod",
+	"mailbox",
+	"usb_otg_hs",
+	NULL,
+};
+
+/*
+ * Board initialization
+ */
+static void __init am3517_init_early(void)
+{
+	omap2_disable_unused_hwmods(am3517_unused_hwmods);
+	omap2_init_common_infrastructure();
+	omap2_init_common_devices(NULL, NULL);
+}
+
+static struct omap_musb_board_data musb_board_data = {
+	.interface_type	= MUSB_INTERFACE_ULPI,
+	.mode		= MUSB_OTG,
+	.power		= 500,
+	.set_phy_power		= am35x_musb_phy_power,
+	.clear_irq		= am35x_musb_clear_irq,
+	.set_mode		= am35x_set_mode,
+	.reset			= am35x_musb_reset,
+};
+
+static __init void am3517_musb_init(void)
+{
+	u32 devconf2;
+
+	/*
+	 * Set up USB clock/mode in the DEVCONF2 register.
+	 */
+	devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);
+
+	/* USB2.0 PHY reference clock is 13 MHz */
+	devconf2 &= ~(CONF2_REFFREQ | CONF2_OTGMODE | CONF2_PHY_GPIOMODE);
+	devconf2 |=  CONF2_REFFREQ_13MHZ | CONF2_SESENDEN | CONF2_VBDTCTEN
+			| CONF2_DATPOL;
+
+	omap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);
+
+	usb_musb_init(&musb_board_data);
+}
+
+static const struct usbhs_omap_board_data ehci_pdata __initconst = {
+	.port_mode[0] = OMAP_EHCI_PORT_MODE_PHY,
+	.port_mode[1] = OMAP_EHCI_PORT_MODE_PHY, 
+	.port_mode[2] = OMAP_USBHS_PORT_MODE_UNUSED,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = USB_PHY1_RESET,
+	.reset_gpio_port[1]  = USB_PHY2_RESET,		
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	OMAP3_MUX(CHASSIS_DMAREQ3, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLDOWN),
+#ifndef CUSTOM_VER_2_1
+	OMAP3_MUX(SDMMC2_CMD, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN),
+#endif
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#endif
+
+#if 0
+struct platform_device am3517_dss_device = {
+	.name		= "omapdss",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &am3517_dss_data,
+	},
+};
+#endif
+
+/*
+ * Touch Panel: ADS 7846
+ */
+#ifdef CONFIG_TOUCHSCREEN_ADS7846
+
+#define ADS7846_PENDOWN_GPIO	57
+
+static void ads7846_dev_init(void)
+{
+	if (gpio_request(ADS7846_PENDOWN_GPIO, "ADS7846 pendown") < 0)
+		printk(KERN_ERR "can't get ads7846 pen down GPIO\n");
+
+	gpio_direction_input(ADS7846_PENDOWN_GPIO);
+
+	gpio_set_debounce(ADS7846_PENDOWN_GPIO, 1);
+}
+
+static int ads7846_get_pendown_state(void)
+{
+	return !gpio_get_value(ADS7846_PENDOWN_GPIO);
+}
+
+struct ads7846_platform_data ads7846_config = {
+	.x_max			= 0x0fff,
+	.y_max			= 0x0fff,
+	.x_plate_ohms		= 180,
+	.pressure_max		= 255,
+	.debounce_max		= 10,
+	.debounce_tol		= 3,
+	.debounce_rep		= 1,
+	.get_pendown_state	= ads7846_get_pendown_state,
+	.keep_vref_on		= 1,
+	.settle_delay_usecs	= 150,
+	.wakeup			= true,
+};
+
+static struct omap2_mcspi_device_config ads7846_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,	/* 0: slave, 1: master */
+};
+
+struct spi_board_info var_omap3530_spi_board_info[] = {
+	[0] = {
+		.modalias		= "ads7846",
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 1500000,
+		.controller_data	= &ads7846_mcspi_config,
+		.irq			= OMAP_GPIO_IRQ(ADS7846_PENDOWN_GPIO),
+		.platform_data		= &ads7846_config,
+	},
+};
+#endif /* CONFIG_TOUCHSCREEN_ADS7846 */
+
+static struct resource am3517_hecc_resources[] = {
+	{
+		.start	= AM35XX_IPSS_HECC_BASE,
+		.end	= AM35XX_IPSS_HECC_BASE + 0x3FFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= INT_35XX_HECC0_IRQ,
+		.end	= INT_35XX_HECC0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_hecc_device = {
+	.name			= "ti_hecc",
+	.id			= -1,	/* FIXME: it was +1 in the previous version */
+	.num_resources		= ARRAY_SIZE(am3517_hecc_resources),
+	.resource		= am3517_hecc_resources,
+};
+
+static struct ti_hecc_platform_data am3517_hecc_pdata = {
+	.scc_hecc_offset	= AM35XX_HECC_SCC_HECC_OFFSET,
+	.scc_ram_offset		= AM35XX_HECC_SCC_RAM_OFFSET,
+	.hecc_ram_offset	= AM35XX_HECC_RAM_OFFSET,
+	.mbx_offset		= AM35XX_HECC_MBOX_OFFSET,
+	.int_line		= AM35XX_HECC_INT_LINE,
+	.version		= AM35XX_HECC_VERSION,
+};
+
+static void am3517_hecc_init(struct ti_hecc_platform_data *pdata)
+{
+        am3517_hecc_device.dev.platform_data = pdata;
+        platform_device_register(&am3517_hecc_device);
+}
+
+static struct omap2_hsmmc_info mmc[] = {
+	{
+		.mmc		= 1,
+		.caps		= MMC_CAP_4_BIT_DATA,
+		.gpio_cd	= SD_CARD_CD,
+		.gpio_wp	= SD_CARD_WP
+	},
+	{}      /* Terminator */
+};
+
+static struct omap_board_config_kernel am3517_config[] __initdata = {
+};
+
+static void __init am3517_init(void)
+{
+	omap_board_config = am3517_config;
+	omap_board_config_size = ARRAY_SIZE(am3517_config);
+	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+
+	am3517_i2c_init();
+	omap_display_init(&am3517_dss_data);
+	omap_serial_init();
+
+	am3517_musb_init();
+
+	/* Configure EHCI ports */
+	omap_mux_init_gpio(USB_HOST_PWR_EN, OMAP_PIN_OUTPUT);
+	gpio_request(USB_HOST_PWR_EN, "USB_HOST_PWR_EN");
+	gpio_direction_output(USB_HOST_PWR_EN, 1);
+	gpio_set_value(USB_HOST_PWR_EN, 1);
+
+	omap_mux_init_gpio(USB_PHY1_RESET, OMAP_PIN_OUTPUT); // ECHI port 1 reset
+	omap_mux_init_gpio(USB_PHY2_RESET, OMAP_PIN_OUTPUT); // ECHI port 2 reset
+
+	usbhs_init(&ehci_pdata);
+	am3517_hecc_init(&am3517_hecc_pdata); // available on CustomBoard V2.0 and forth
+	/* DSS */
+	am3517_display_init();
+
+	i2c_register_board_info(1, var_am35_i2c1_boardinfo,
+				ARRAY_SIZE(var_am35_i2c1_boardinfo));
+
+	/*Ethernet*/
+	am3517_ethernet_init(&am3517_emac_pdata);
+
+	/*NAND*/
+	board_nand_init(var_am35_nand_partitions,
+			ARRAY_SIZE(var_am35_nand_partitions),
+			0, NAND_BUSWIDTH_16);
+
+#ifdef CONFIG_TOUCHSCREEN_ADS7846
+	/* register SPI interface */
+	spi_register_board_info(var_omap3530_spi_board_info,
+				ARRAY_SIZE(var_omap3530_spi_board_info));
+
+	/* configure  GPIO for pendown interrupt */
+	omap_mux_init_gpio(ADS7846_PENDOWN_GPIO, OMAP_PIN_INPUT_PULLUP);
+	/* ADS7846 init function */
+	ads7846_dev_init();
+#endif /* CONFIG_TOUCHSCREEN_ADS7846 */
+
+	/* MMC init */
+	omap_mux_init_gpio(SD_CARD_CD, OMAP_PIN_INPUT);
+	omap_mux_init_gpio(SD_CARD_WP, OMAP_PIN_INPUT);
+	omap2_hsmmc_init(mmc);
+}
+
+MACHINE_START(OMAP3517EVM, "VARISCITE VAR-SOM-AM35")
+	.boot_params	= 0x80000100,
+	.reserve	= omap_reserve,
+	.map_io		= omap3_map_io,
+	.init_early	= am3517_init_early,
+	.init_irq	= omap_init_irq,
+	.init_machine	= am3517_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/clock3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/clock3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/clock3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/clock3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -3078,6 +3078,7 @@
 	.name		= "gpt12_fck",
 	.ops		= &clkops_null,
 	.parent		= &secure_32k_fck,
+	.clkdm_name	= "wkup_clkdm",
 	.recalc		= &followparent_recalc,
 };
 
@@ -3179,10 +3180,18 @@
 	.recalc		= &followparent_recalc,
 };
 
-/*
- * The UART1/2 functional clock acts as the functional
- * clock for UART4. No separate fclk control available.
- */
+/* Documented as 'reserved' in latest technical manual (July 2010), 
+ * bit 23 in CM_CLKEN1_CORE really seems to control the UART4 fclk.. */
+static struct clk uart4_fck_am35xx = {
+	.name		= "uart4_fck",
+	.ops		= &clkops_omap2_dflt,
+	.parent		= &core_48m_fck,
+	.enable_reg	= OMAP_CM_REGADDR(CORE_MOD, CM_FCLKEN1),
+	.enable_bit	= AM35XX_EN_UART4_SHIFT,
+	.clkdm_name	= "core_l4_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
 static struct clk uart4_ick_am35xx = {
 	.name		= "uart4_ick",
 	.ops		= &clkops_omap2_iclk_dflt_wait,
@@ -3454,14 +3463,15 @@
 	CLK(NULL,	"ipss_ick",	&ipss_ick,	CK_AM35XX),
 	CLK(NULL,	"rmii_ck",	&rmii_ck,	CK_AM35XX),
 	CLK(NULL,	"pclk_ck",	&pclk_ck,	CK_AM35XX),
-	CLK("davinci_emac",	"emac_clk",	&emac_ick,	CK_AM35XX),
-	CLK("davinci_emac",	"phy_clk",	&emac_fck,	CK_AM35XX),
+	CLK("davinci_emac",	NULL,	&emac_ick,	CK_AM35XX),
+	CLK("davinci_mdio.0",	NULL,	&emac_fck,	CK_AM35XX),
 	CLK("vpfe-capture",	"master",	&vpfe_ick,	CK_AM35XX),
 	CLK("vpfe-capture",	"slave",	&vpfe_fck,	CK_AM35XX),
 	CLK("musb-am35x",	"ick",		&hsotgusb_ick_am35xx,	CK_AM35XX),
 	CLK("musb-am35x",	"fck",		&hsotgusb_fck_am35xx,	CK_AM35XX),
 	CLK(NULL,	"hecc_ck",	&hecc_ck,	CK_AM35XX),
 	CLK(NULL,	"uart4_ick",	&uart4_ick_am35xx,	CK_AM35XX),
+	CLK(NULL,	"uart4_fck",	&uart4_fck_am35xx,	CK_AM35XX),
 };
 
 
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/clockdomains2xxx_3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -71,17 +71,20 @@
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
 		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP24XX |
-					    CHIP_IS_OMAP3430)
+					    CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
 		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP24XX |
-					    CHIP_IS_OMAP3430)
+					    CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -208,23 +211,28 @@
 static struct clkdm_dep per_wkdeps[] = {
 	{
 		.clkdm_name = "core_l3_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "core_l4_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -233,23 +241,28 @@
 static struct clkdm_dep usbhost_wkdeps[] = {
 	{
 		.clkdm_name = "core_l3_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "core_l4_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					   CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -258,23 +271,28 @@
 static struct clkdm_dep mpu_3xxx_wkdeps[] = {
 	{
 		.clkdm_name = "core_l3_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "core_l4_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "dss_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "per_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -283,27 +301,33 @@
 static struct clkdm_dep iva2_wkdeps[] = {
 	{
 		.clkdm_name = "core_l3_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "core_l4_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "dss_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "per_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -313,15 +337,18 @@
 static struct clkdm_dep cam_wkdeps[] = {
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -330,15 +357,18 @@
 static struct clkdm_dep dss_wkdeps[] = {
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "wkup_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -347,7 +377,8 @@
 static struct clkdm_dep neon_wkdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -359,11 +390,13 @@
 static struct clkdm_dep dss_sleepdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -372,11 +405,13 @@
 static struct clkdm_dep per_sleepdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -385,11 +420,13 @@
 static struct clkdm_dep usbhost_sleepdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm_name = "iva2_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -398,7 +435,8 @@
 static struct clkdm_dep cam_sleepdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -412,7 +450,8 @@
 static struct clkdm_dep gfx_sgx_sleepdeps[] = {
 	{
 		.clkdm_name = "mpu_clkdm",
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 |
+					    CHIP_IS_AM35XX)
 	},
 	{ NULL },
 };
@@ -434,19 +473,22 @@
 	.name		= "wkup_clkdm",
 	.pwrdm		= { .name = "wkup_pwrdm" },
 	.dep_bit	= OMAP_EN_WKUP_SHIFT,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430 |
+					 CHIP_IS_AM35XX),
 };
 
 static struct clockdomain prm_clkdm = {
 	.name		= "prm_clkdm",
 	.pwrdm		= { .name = "wkup_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430 |
+					 CHIP_IS_AM35XX)
 };
 
 static struct clockdomain cm_clkdm = {
 	.name		= "cm_clkdm",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430 |
+					 CHIP_IS_AM35XX)
 };
 
 /*
@@ -619,7 +661,7 @@
 	.dep_bit	= OMAP3430_EN_MPU_SHIFT,
 	.wkdep_srcs	= mpu_3xxx_wkdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_MPU_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain neon_clkdm = {
@@ -628,7 +670,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 	.wkdep_srcs	= neon_wkdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_NEON_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain iva2_clkdm = {
@@ -638,7 +680,7 @@
 	.dep_bit	= OMAP3430_PM_WKDEP_MPU_EN_IVA2_SHIFT,
 	.wkdep_srcs	= iva2_wkdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_IVA2_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain gfx_3430es1_clkdm = {
@@ -673,7 +715,7 @@
 	.pwrdm		= { .name = "core_pwrdm" },
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 	.clktrctrl_mask = OMAP3430ES1_CLKTRCTRL_D2D_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /*
@@ -687,7 +729,7 @@
 	.flags		= CLKDM_CAN_HWSUP,
 	.dep_bit	= OMAP3430_EN_CORE_SHIFT,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_L3_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /*
@@ -701,7 +743,7 @@
 	.flags		= CLKDM_CAN_HWSUP,
 	.dep_bit	= OMAP3430_EN_CORE_SHIFT,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_L4_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* Another case of bit name collisions between several registers: EN_DSS */
@@ -713,7 +755,7 @@
 	.wkdep_srcs	= dss_wkdeps,
 	.sleepdep_srcs	= dss_sleepdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_DSS_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain cam_clkdm = {
@@ -723,7 +765,7 @@
 	.wkdep_srcs	= cam_wkdeps,
 	.sleepdep_srcs	= cam_sleepdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_CAM_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain usbhost_clkdm = {
@@ -733,7 +775,7 @@
 	.wkdep_srcs	= usbhost_wkdeps,
 	.sleepdep_srcs	= usbhost_sleepdeps,
 	.clktrctrl_mask = OMAP3430ES2_CLKTRCTRL_USBHOST_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain per_clkdm = {
@@ -744,7 +786,7 @@
 	.wkdep_srcs	= per_wkdeps,
 	.sleepdep_srcs	= per_sleepdeps,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_PER_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /*
@@ -756,37 +798,37 @@
 	.pwrdm		= { .name = "emu_pwrdm" },
 	.flags		= /* CLKDM_CAN_ENABLE_AUTO |  */CLKDM_CAN_SWSUP,
 	.clktrctrl_mask = OMAP3430_CLKTRCTRL_EMU_MASK,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain dpll1_clkdm = {
 	.name		= "dpll1_clkdm",
 	.pwrdm		= { .name = "dpll1_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain dpll2_clkdm = {
 	.name		= "dpll2_clkdm",
 	.pwrdm		= { .name = "dpll2_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain dpll3_clkdm = {
 	.name		= "dpll3_clkdm",
 	.pwrdm		= { .name = "dpll3_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain dpll4_clkdm = {
 	.name		= "dpll4_clkdm",
 	.pwrdm		= { .name = "dpll4_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct clockdomain dpll5_clkdm = {
 	.name		= "dpll5_clkdm",
 	.pwrdm		= { .name = "dpll5_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 | CHIP_IS_AM35XX),
 };
 
 #endif   /* CONFIG_ARCH_OMAP3 */
@@ -798,11 +840,11 @@
 static struct clkdm_autodep clkdm_autodeps[] = {
 	{
 		.clkdm	   = { .name = "mpu_clkdm" },
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm	   = { .name = "iva2_clkdm" },
-		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+		.omap_chip = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 	},
 	{
 		.clkdm	   = { .name = NULL },
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/gpmc.c linux-3.0.x-arm/arch/arm/mach-omap2/gpmc.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/gpmc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/gpmc.c	2012-12-19 11:25:53.000000000 +0200
@@ -49,6 +49,7 @@
 #define GPMC_ECC_CONTROL	0x1f8
 #define GPMC_ECC_SIZE_CONFIG	0x1fc
 #define GPMC_ECC1_RESULT        0x200
+#define GPMC_ECC_BCH_RESULT_0	0x240
 
 #define GPMC_CS0_OFFSET		0x60
 #define GPMC_CS_SIZE		0x30
@@ -95,7 +96,6 @@
 static struct resource	gpmc_cs_mem[GPMC_CS_NUM];
 static DEFINE_SPINLOCK(gpmc_mem_lock);
 static unsigned int gpmc_cs_map;	/* flag for cs which are initialized */
-static int gpmc_ecc_used = -EINVAL;	/* cs using ecc engine */
 
 static void __iomem *gpmc_base;
 
@@ -839,52 +839,76 @@
 
 /**
  * gpmc_enable_hwecc - enable hardware ecc functionality
+ * @ecc_type: ecc type e.g. Hamming, BCH
  * @cs: chip select number
  * @mode: read/write mode
  * @dev_width: device bus width(1 for x16, 0 for x8)
  * @ecc_size: bytes for which ECC will be generated
  */
-int gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size)
+int gpmc_enable_hwecc(int ecc_type, int cs, int mode,
+			int dev_width, int ecc_size)
 {
-	unsigned int val;
-
-	/* check if ecc module is in used */
-	if (gpmc_ecc_used != -EINVAL)
-		return -EINVAL;
-
-	gpmc_ecc_used = cs;
-
-	/* clear ecc and enable bits */
-	val = ((0x00000001<<8) | 0x00000001);
-	gpmc_write_reg(GPMC_ECC_CONTROL, val);
-
-	/* program ecc and result sizes */
-	val = ((((ecc_size >> 1) - 1) << 22) | (0x0000000F));
-	gpmc_write_reg(GPMC_ECC_SIZE_CONFIG, val);
+	unsigned int bch_mod = 0, bch_wrapmode = 0, eccsize1 = 0, eccsize0 = 0;
+	unsigned int ecc_conf_val = 0, ecc_size_conf_val = 0;
 
 	switch (mode) {
 	case GPMC_ECC_READ:
-		gpmc_write_reg(GPMC_ECC_CONTROL, 0x101);
+		if (ecc_type == OMAP_ECC_BCH4_CODE_HW) {
+			eccsize1 = 0xD; eccsize0 = 0x48;
+			bch_mod = 0;
+			bch_wrapmode = 0x09;
+		} else if (ecc_type == OMAP_ECC_BCH8_CODE_HW) {
+			eccsize1 = 0x1A; eccsize0 = 0x18;
+			bch_mod = 1;
+			bch_wrapmode = 0x04;
+		} else
+			eccsize1 = ((ecc_size >> 1) - 1) << 22;
 		break;
 	case GPMC_ECC_READSYN:
-		 gpmc_write_reg(GPMC_ECC_CONTROL, 0x100);
 		break;
 	case GPMC_ECC_WRITE:
-		gpmc_write_reg(GPMC_ECC_CONTROL, 0x101);
+		if (ecc_type == OMAP_ECC_BCH4_CODE_HW) {
+			eccsize1 = 0x20; eccsize0 = 0x00;
+			bch_mod = 0;
+			bch_wrapmode = 0x06;
+		} else if (ecc_type == OMAP_ECC_BCH8_CODE_HW) {
+			eccsize1 = 0x20; eccsize0 = 0x00;
+			bch_mod = 1;
+			bch_wrapmode = 0x06;
+		} else
+			eccsize1 = ((ecc_size >> 1) - 1) << 22;
 		break;
+
 	default:
 		printk(KERN_INFO "Error: Unrecognized Mode[%d]!\n", mode);
 		break;
 	}
 
-	/* (ECC 16 or 8 bit col) | ( CS  )  | ECC Enable */
-	val = (dev_width << 7) | (cs << 1) | (0x1);
-	gpmc_write_reg(GPMC_ECC_CONFIG, val);
+	/* clear ecc and enable bits */
+	if ((ecc_type == OMAP_ECC_BCH4_CODE_HW) ||
+		(ecc_type == OMAP_ECC_BCH8_CODE_HW)) {
+		gpmc_write_reg(GPMC_ECC_CONTROL, 0x00000001);
+		ecc_size_conf_val = (eccsize1 << 22) | (eccsize0 << 12);
+		ecc_conf_val = ((0x01 << 16) | (bch_mod << 12)
+			| (bch_wrapmode << 8) | (dev_width << 7)
+			| (0x03 << 4) | (cs << 1) | (0x1));
+	} else {
+		gpmc_write_reg(GPMC_ECC_CONTROL, 0x00000101);
+		ecc_size_conf_val = (eccsize1 << 22) | 0x0000000F;
+		ecc_conf_val = (dev_width << 7) | (cs << 1) | (0x1);
+	}
+
+	gpmc_write_reg(GPMC_ECC_SIZE_CONFIG, ecc_size_conf_val);
+ 	gpmc_write_reg(GPMC_ECC_CONFIG, ecc_conf_val);
+	gpmc_write_reg(GPMC_ECC_CONTROL, 0x00000101);
+
 	return 0;
 }
+EXPORT_SYMBOL(gpmc_enable_hwecc);
 
 /**
  * gpmc_calculate_ecc - generate non-inverted ecc bytes
+ * @ecc_type: ecc type e.g. Hamming, BCH
  * @cs: chip select number
  * @dat: data pointer over which ecc is computed
  * @ecc_code: ecc code buffer
@@ -895,20 +919,52 @@
  * an erased page will produce an ECC mismatch between generated and read
  * ECC bytes that has to be dealt with separately.
  */
-int gpmc_calculate_ecc(int cs, const u_char *dat, u_char *ecc_code)
+int gpmc_calculate_ecc(int ecc_type, int cs,
+			const u_char *dat, u_char *ecc_code)
 {
-	unsigned int val = 0x0;
-
-	if (gpmc_ecc_used != cs)
-		return -EINVAL;
+	unsigned int reg;
+	unsigned int val1 = 0x0, val2 = 0x0;
+	unsigned int val3 = 0x0, val4 = 0x0;
+	int i;
 
-	/* read ecc result */
-	val = gpmc_read_reg(GPMC_ECC1_RESULT);
-	*ecc_code++ = val;          /* P128e, ..., P1e */
-	*ecc_code++ = val >> 16;    /* P128o, ..., P1o */
-	/* P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e */
-	*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);
+	if ((ecc_type == OMAP_ECC_BCH4_CODE_HW) ||
+		(ecc_type == OMAP_ECC_BCH8_CODE_HW)) {
+		for (i = 0; i < 4; i++) {
+			/*
+			 * Reading HW ECC_BCH_Results
+			 * 0x240-0x24C, 0x250-0x25C, 0x260-0x26C, 0x270-0x27C
+			 */
+			reg =  GPMC_ECC_BCH_RESULT_0 + (0x10 * i);
+			val1 = gpmc_read_reg(reg);
+			val2 = gpmc_read_reg(reg + 4);
+			if (ecc_type == OMAP_ECC_BCH8_CODE_HW) {
+				val3 = gpmc_read_reg(reg + 8);
+				val4 = gpmc_read_reg(reg + 12);
+
+				*ecc_code++ = (val4 & 0xFF);
+				*ecc_code++ = ((val3 >> 24) & 0xFF);
+				*ecc_code++ = ((val3 >> 16) & 0xFF);
+				*ecc_code++ = ((val3 >> 8) & 0xFF);
+				*ecc_code++ = (val3 & 0xFF);
+				*ecc_code++ = ((val2 >> 24) & 0xFF);
+			}
+			*ecc_code++ = ((val2 >> 16) & 0xFF);
+			*ecc_code++ = ((val2 >> 8) & 0xFF);
+			*ecc_code++ = (val2 & 0xFF);
+			*ecc_code++ = ((val1 >> 24) & 0xFF);
+			*ecc_code++ = ((val1 >> 16) & 0xFF);
+			*ecc_code++ = ((val1 >> 8) & 0xFF);
+			*ecc_code++ = (val1 & 0xFF);
+		}
+	} else {
+		/* read ecc result */
+		val1 = gpmc_read_reg(GPMC_ECC1_RESULT);
+		*ecc_code++ = val1;          /* P128e, ..., P1e */
+		*ecc_code++ = val1 >> 16;    /* P128o, ..., P1o */
+		/* P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e */
+		*ecc_code++ = ((val1 >> 8) & 0x0f) | ((val1 >> 20) & 0xf0);
+	}
 
-	gpmc_ecc_used = -EINVAL;
 	return 0;
 }
+EXPORT_SYMBOL(gpmc_calculate_ecc);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/hsmmc.c linux-3.0.x-arm/arch/arm/mach-omap2/hsmmc.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/hsmmc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/hsmmc.c	2012-12-21 19:17:32.000000000 +0200
@@ -321,6 +321,7 @@
 	mmc->get_context_loss_count = hsmmc_get_context_loss;
 
 	mmc->slots[0].switch_pin = c->gpio_cd;
+	mmc->slots[0].switch_level = c->cd_level;
 	mmc->slots[0].gpio_wp = c->gpio_wp;
 
 	mmc->slots[0].remux = c->remux;
@@ -351,7 +352,15 @@
 	 *
 	 * temporary HACK: ocr_mask instead of fixed supply
 	 */
-	mmc->slots[0].ocr_mask = c->ocr_mask;
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		mmc->slots[0].ocr_mask = MMC_VDD_165_195 |
+					 MMC_VDD_26_27 |
+					 MMC_VDD_27_28 |
+					 MMC_VDD_29_30 |
+					 MMC_VDD_30_31 |
+					 MMC_VDD_31_32;
+	else
+		mmc->slots[0].ocr_mask = c->ocr_mask;
 
 	if (cpu_is_omap3517() || cpu_is_omap3505())
 		mmc->slots[0].set_power = nop_mmc_set_power;
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/hsmmc.h linux-3.0.x-arm/arch/arm/mach-omap2/hsmmc.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/hsmmc.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/hsmmc.h	2012-12-21 19:17:32.000000000 +0200
@@ -21,6 +21,7 @@
 	bool	no_off_init;	/* no power off when not in MMC sleep state */
 	bool	vcc_aux_disable_is_sleep; /* Regulator off remapped to sleep */
 	int	gpio_cd;	/* or -EINVAL */
+	int	cd_level;		/* insertion level 0 (fall - default, as it used to be in omap_hsmmc_card_detect()) or 1 (raise) */
 	int	gpio_wp;	/* or -EINVAL */
 	char	*name;		/* or NULL for default */
 	struct device *dev;	/* returned: pointer to mmc adapter */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/i2c.c linux-3.0.x-arm/arch/arm/mach-omap2/i2c.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/i2c.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/i2c.c	2012-12-19 11:25:53.000000000 +0200
@@ -21,9 +21,19 @@
 
 #include <plat/cpu.h>
 #include <plat/i2c.h>
+#include <plat/common.h>
+#include <plat/omap_hwmod.h>
 
 #include "mux.h"
 
+/* In register I2C_CON, Bit 15 is the I2C enable bit */
+#define I2C_EN					BIT(15)
+#define OMAP2_I2C_CON_OFFSET			0x24
+#define OMAP4_I2C_CON_OFFSET			0xA4
+
+/* Maximum microseconds to wait for OMAP module to softreset */
+#define MAX_MODULE_SOFTRESET_WAIT	10000
+
 void __init omap2_i2c_mux_pins(int bus_id)
 {
 	char mux_name[sizeof("i2c2_scl.i2c2_scl")];
@@ -37,3 +47,56 @@
 	sprintf(mux_name, "i2c%i_sda.i2c%i_sda", bus_id, bus_id);
 	omap_mux_init_signal(mux_name, OMAP_PIN_INPUT);
 }
+
+/**
+ * omap_i2c_reset - reset the omap i2c module.
+ * @oh: struct omap_hwmod *
+ *
+ * The i2c moudle in omap2, omap3 had a special sequence to reset. The
+ * sequence is:
+ * - Disable the I2C.
+ * - Write to SOFTRESET bit.
+ * - Enable the I2C.
+ * - Poll on the RESETDONE bit.
+ * The sequence is implemented in below function. This is called for 2420,
+ * 2430 and omap3.
+ */
+int omap_i2c_reset(struct omap_hwmod *oh)
+{
+	u32 v;
+	u16 i2c_con;
+	int c = 0;
+
+	if (cpu_is_omap44xx())
+		i2c_con = OMAP4_I2C_CON_OFFSET;
+	else
+		i2c_con = OMAP2_I2C_CON_OFFSET;
+
+	/* Disable I2C */
+	v = omap_hwmod_read(oh, i2c_con);
+	v = v & ~I2C_EN;
+	omap_hwmod_write(v, oh, i2c_con);
+
+	/* Write to the SOFTRESET bit */
+	omap_hwmod_softreset(oh);
+
+	/* Enable I2C */
+	v = omap_hwmod_read(oh, i2c_con);
+	v |= I2C_EN;
+	omap_hwmod_write(v, oh, i2c_con);
+
+	/* Poll on RESETDONE bit */
+	omap_test_timeout((omap_hwmod_read(oh,
+				oh->class->sysc->syss_offs)
+				& SYSS_RESETDONE_MASK),
+				MAX_MODULE_SOFTRESET_WAIT, c);
+
+	if (c == MAX_MODULE_SOFTRESET_WAIT)
+		pr_warning("%s: %s: softreset failed (waited %d usec)\n",
+			__func__, oh->name, MAX_MODULE_SOFTRESET_WAIT);
+	else
+		pr_debug("%s: %s: softreset in %d usec\n", __func__,
+			oh->name, c);
+
+	return 0;
+}
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/id.c linux-3.0.x-arm/arch/arm/mach-omap2/id.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/id.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/id.c	2012-12-19 11:25:53.000000000 +0200
@@ -195,14 +195,17 @@
 	status = omap_ctrl_readl(OMAP3_CONTROL_OMAP_STATUS);
 
 	OMAP3_CHECK_FEATURE(status, L2CACHE);
-	OMAP3_CHECK_FEATURE(status, IVA);
 	OMAP3_CHECK_FEATURE(status, SGX);
 	OMAP3_CHECK_FEATURE(status, NEON);
 	OMAP3_CHECK_FEATURE(status, ISP);
 	if (cpu_is_omap3630())
 		omap3_features |= OMAP3_HAS_192MHZ_CLK;
-	if (!cpu_is_omap3505() && !cpu_is_omap3517())
-		omap3_features |= OMAP3_HAS_IO_WAKEUP;
+	if (!cpu_is_omap3505() && !cpu_is_omap3517()) {
+ 		omap3_features |= (OMAP3_HAS_IO_WAKEUP
+ 					| OMAP3_HAS_SR
+ 					| OMAP3_HAS_SECURE_SRAM);
+		OMAP3_CHECK_FEATURE(status, IVA);
+	}
 
 	omap3_features |= OMAP3_HAS_SDRC;
 
@@ -284,10 +287,10 @@
 		 * Set the device to be OMAP3505 here. Actual device
 		 * is identified later based on the features.
 		 *
-		 * REVISIT: AM3505/AM3517 should have their own CHIP_IS
+		 * REVISIT: Should AM3505/AM3517 have independant CHIP_IS?
 		 */
 		omap_revision = OMAP3505_REV(rev);
-		omap_chip.oc |= CHIP_IS_OMAP3430ES3_1;
+		omap_chip.oc = CHIP_IS_AM35XX; 
 		break;
 	case 0xb891:
 		/* Handle 36xx devices */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/io.c linux-3.0.x-arm/arch/arm/mach-omap2/io.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/io.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/io.c	2012-12-19 11:25:53.000000000 +0200
@@ -419,7 +419,9 @@
 {
 	if (cpu_is_omap24xx() || omap3_has_sdrc()) {
 		omap2_sdrc_init(sdrc_cs0, sdrc_cs1);
+#ifndef CONFIG_MACH_VAR_SOM_AM35
 		_omap2_init_reprogram_sdrc();
+#endif
 	}
 
 	omap_irq_base_init();
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/Kconfig linux-3.0.x-arm/arch/arm/mach-omap2/Kconfig
--- linux-3.0.x-orig/arch/arm/mach-omap2/Kconfig	2013-09-19 17:39:45.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/Kconfig	2012-12-19 11:25:53.000000000 +0200
@@ -16,9 +16,6 @@
 	select I2C
 	select I2C_OMAP
 	select MFD_SUPPORT
-	select MENELAUS if ARCH_OMAP2
-	select TWL4030_CORE if ARCH_OMAP3 || ARCH_OMAP4
-	select TWL4030_POWER if ARCH_OMAP3 || ARCH_OMAP4
 	help
 	  Compile a kernel suitable for booting most boards
 
@@ -103,6 +100,9 @@
 config OMAP_PACKAGE_CBS
        bool
 
+config OMAP_PACKAGE_ZCN
+	bool
+
 comment "OMAP Board Type"
 	depends on ARCH_OMAP2PLUS
 
@@ -191,6 +191,34 @@
 	default y
 	select OMAP_PACKAGE_CBB
 
+config MACH_VAR_SOM_AM35
+	bool "Variscite VAR-SOM-AM35 board"
+	depends on ARCH_OMAP3
+	select OMAP_PACKAGE_CBB
+
+config MACH_OWEN_SPK2XX_VAR
+	bool "Owen SPK2XX VAR-SOM-AM35 based board"
+	depends on ARCH_OMAP3
+	select OMAP_PACKAGE_ZCN
+	select MACH_OWEN
+	select OWEN_RETAIN_MEMORY
+#	select OWEN_LPVD_FIQ
+	help
+	  Select this if you are using Owen's programming logic controller spk2xx
+	  based on variscite board VAR-SOM-AM35.
+
+choice
+	depends on (MACH_OWEN_SPK2XX_VAR)
+	prompt "Board types of SPK2XX-VAR"
+
+config OWEN_SPK207_VAR
+	bool "SPK207"
+	
+config OWEN_SPK210_VAR
+	bool "SPK210"
+
+endchoice
+
 config MACH_CRANEBOARD
 	bool "AM3517/05 CRANE board"
 	depends on ARCH_OMAP3
@@ -346,3 +374,4 @@
 endmenu
 
 endif
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/Makefile linux-3.0.x-arm/arch/arm/mach-omap2/Makefile
--- linux-3.0.x-orig/arch/arm/mach-omap2/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/Makefile	2012-12-19 11:25:53.000000000 +0200
@@ -18,7 +18,8 @@
 
 obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
 
-obj-$(CONFIG_TWL4030_CORE) += omap_twl.o
+obj-$(CONFIG_TWL4030_CORE)		+= omap_twl.o
+obj-$(CONFIG_REGULATOR_TPS65023)	+= pmic_tps65023.o
 
 # SMP support ONLY available for OMAP4
 obj-$(CONFIG_SMP)			+= omap-smp.o omap-headsmp.o
@@ -60,7 +61,7 @@
 ifeq ($(CONFIG_PM),y)
 obj-$(CONFIG_ARCH_OMAP2)		+= pm24xx.o
 obj-$(CONFIG_ARCH_OMAP2)		+= sleep24xx.o
-obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o \
+obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o sleep3517.o \
 					   cpuidle34xx.o
 obj-$(CONFIG_ARCH_OMAP4)		+= pm44xx.o
 obj-$(CONFIG_PM_DEBUG)			+= pm-debug.o
@@ -69,6 +70,7 @@
 
 AFLAGS_sleep24xx.o			:=-Wa,-march=armv6
 AFLAGS_sleep34xx.o			:=-Wa,-march=armv7-a$(plus_sec)
+AFLAGS_sleep3517.o			:=-Wa,-march=armv7-a$(plus_sec)
 
 ifeq ($(CONFIG_PM_VERBOSE),y)
 CFLAGS_pm_bus.o				+= -DDEBUG
@@ -246,6 +248,14 @@
 obj-$(CONFIG_MACH_SBC3530)		+= board-omap3stalker.o \
 					   hsmmc.o
 obj-$(CONFIG_MACH_TI8168EVM)		+= board-ti8168evm.o
+obj-$(CONFIG_MACH_VAR_SOM_AM35)		+= board-var-som-am35.o \
+					   board-flash.o \
+					   omap_phy_internal.o \
+					   hsmmc.o
+obj-$(CONFIG_MACH_OWEN_SPK2XX_VAR)	+= board-owen-spk2xx-var.o \
+					   board-flash.o \
+					   omap_phy_internal.o \
+					   hsmmc.o
 # Platform specific device init code
 usbfs-$(CONFIG_ARCH_OMAP_OTG)		:= usb-fs.o
 obj-y					+= $(usbfs-m) $(usbfs-y)
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/mux34xx.c linux-3.0.x-arm/arch/arm/mach-omap2/mux34xx.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/mux34xx.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/mux34xx.c	2012-12-19 11:25:53.000000000 +0200
@@ -696,6 +696,86 @@
 	_OMAP3_MUXENTRY(SAD2D_MCAD36, 0,
 		NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
+
+	/* Only on AM35xx, see am35xx_zcn_subset for the signals */
+	_OMAP3_MUXENTRY(CCDC_PCLK, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_FIELD, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_HD, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_VD, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_WEN, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA0, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA1, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA2, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA3, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA4, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA5, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA6, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(CCDC_DATA7, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_MDIO_DATA, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_MDIO_CLK, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_RXD0, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_RXD1, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_CRS_DV, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_RXER, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_TXD0, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_TXD1, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_TXEN, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(RMII_50MHZ_CLK, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(USB0_DRVVBUS, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(HECC1_TXD, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP3_MUXENTRY(HECC1_RXD, 0,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
 	{ .reg_offset = OMAP_MUX_TERMINATOR },
 };
 
@@ -2026,6 +2106,489 @@
 #define omap36xx_cbp_ball	 NULL
 #endif
 
+/*
+ * Signals different on AM35XX ZCN package comapared to 34XX CBC package
+ */
+#if defined(CONFIG_OMAP_MUX) && defined(CONFIG_OMAP_PACKAGE_ZCN)
+static struct omap_mux __initdata am35xx_zcn_subset[] = {
+	_OMAP3_MUXENTRY(GPMC_NCS2, 53,
+		"gpmc_ncs2", NULL, "gpt9_pwm_evt", NULL,
+		"gpio_53", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_NCS3, 54,
+		"gpmc_ncs3", "sys_ndmareq0", "gpt10_pwm_evt", NULL,
+		"gpio_54", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_NCS4, 55,
+		"gpmc_ncs4", "sys_ndmareq1", NULL, "gpt9_pwm_evt",
+		"gpio_55", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_NCS5, 56,
+		"gpmc_ncs5", "sys_ndmareq2", NULL, "gpt10_pwm_evt",
+		"gpio_56", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_NCS6, 57,
+		"gpmc_ncs6", "sys_ndmareq3", NULL, "gpt11_pwm_evt",
+		"gpio_57", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_NCS7, 58,
+		"gpmc_ncs7", "gpmc_io_dir", NULL, "gpt8_pwm_evt",
+		"gpio_58", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_WAIT1, 63,
+		"gpmc_wait1", "uart4_tx", NULL, NULL,
+		"gpio_63", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_WAIT2, 64,
+		"gpmc_wait2", "uart4_rx", NULL, NULL,
+		"gpio_64", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(GPMC_WAIT3, 65,
+		"gpmc_wait3", "sys_ndmareq1", "uart3_cts_rctx", NULL,
+		"gpio_65", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(DSS_DATA18, 88,
+		"dss_data18", NULL, "mcspi3_clk", "dss_data4",
+		"gpio_88", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(DSS_DATA19, 89,
+		"dss_data19", NULL, "mcspi3_simo", "dss_data3",
+		"gpio_89", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(DSS_DATA21, 91,
+		"dss_data21", NULL, "mcspi3_cs0", "dss_data1",
+		"gpio_91", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(DSS_DATA22, 92,
+		"dss_data22", NULL, "mcspi3_cs1", "dss_data0",
+		"gpio_92", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_PCLK, 94,
+		"ccdc_pclk", NULL, NULL, NULL,
+		"gpio_94", "hw_dbg0", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_FIELD, 95,
+		"ccdc_field", "ccdc_data8", "uart4_tx", "i2c3_scl",
+		"gpio_95", "hw_dbg1", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_HD, 96,
+		"ccdc_hd", NULL, "uart4_rts", NULL,
+		"gpio_96", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_VD, 97,
+		"ccdc_vd", NULL, "uart4_cts", NULL,
+		"gpio_97", "hw_dbg2", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_WEN, 98,
+		"ccdc_wen", "ccdc_data9", "uart4_rx", NULL,
+		"gpio_98", "hw_dbg3", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA0, 99,
+		"ccdc_data0", NULL, NULL, "i2c3_sda",
+		"gpio_99", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA1, 100,
+		"ccdc_data1", NULL, NULL, NULL,
+		"gpio_100", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA2, 101,
+		"ccdc_data2", NULL, NULL, NULL,
+		"gpio_101", "hw_dbg4", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA3, 102,
+		"ccdc_data3", NULL, NULL, NULL,
+		"gpio_102", "hw_dbg5", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA4, 103,
+		"ccdc_data4", NULL, NULL, NULL,
+		"gpio_103", "hw_dbg6", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA5, 104,
+		"ccdc_data5", NULL, NULL, NULL,
+		"gpio_104", "hw_dbg7", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA6, 105,
+		"ccdc_data6", NULL, NULL, NULL,
+		"gpio_105", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(CCDC_DATA7, 106,
+		"ccdc_data7", NULL, NULL, NULL,
+		"gpio_106", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_MDIO_DATA, 107,
+		"rmii_mdio_data", "ccdc_data8", NULL, NULL,
+		"gpio_107", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_MDIO_CLK, 108,
+		"rmii_mdio_clk", "ccdc_data9", NULL, NULL,
+		"gpio_108", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_RXD0, 109,
+		"rmii_rxd0", "ccdc_data10", NULL, NULL,
+		"gpio_109", "hw_dbg8", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_RXD1, 110,
+		"rmii_rxd1", "ccdc_data11", NULL, NULL,
+		"gpio_110", "hw_dbg9", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_CRS_DV, 111,
+		"rmii_crs_dv", "ccdc_data12", NULL, NULL,
+		"gpio_111", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_RXER, 167,
+		"rmii_rxer", "ccdc_data13", NULL, NULL,
+		"gpio_167", "hw_dbg10", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_TXD0, 126,
+		"rmii_txd0", "ccdc_data14", NULL, NULL,
+		"gpio_126", "hw_dbg11", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_TXD1, 112,
+		"rmii_txd1", "ccdc_data15", NULL, NULL,
+		"gpio_112", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_TXEN, 113,
+		"rmii_txen", NULL, NULL, NULL,
+		"gpio_113", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(RMII_50MHZ_CLK, 114,
+		"rmii_50mhz_clk", NULL, NULL, NULL,
+		"gpio_114", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT0, 122,
+		"sdmmc1_dat0", "mcspi2_clk", NULL, NULL,
+		"gpio_122", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT1, 123,
+		"sdmmc1_dat1", "mcspi2_simo", NULL, NULL,
+		"gpio_123", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT2, 124,
+		"sdmmc1_dat2", "mcspi2_somi", NULL, NULL,
+		"gpio_124", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT3, 125,
+		"sdmmc1_dat3", "mcspi2_cs0", NULL, NULL,
+		"gpio_125", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT4, 126,
+		"sdmmc1_dat4", NULL, NULL, NULL,
+		"gpio_126", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT5, 127,
+		"sdmmc1_dat5", NULL, NULL, NULL,
+		"gpio_127", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT6, 128,
+		"sdmmc1_dat6", NULL, NULL, NULL,
+		"gpio_128", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC1_DAT7, 129,
+		"sdmmc1_dat7", NULL, NULL, NULL,
+		"gpio_129", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_CLK, 130,
+		"sdmmc2_clk", "mcspi3_clk", "uart4_cts", NULL,
+		"gpio_130", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_CMD, 131,
+		"sdmmc2_cmd", "mcspi3_simo", "uart4_rts", NULL,
+		"gpio_131", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_DAT0, 132,
+		"sdmmc2_dat0", "mcspi3_somi", "uart4_tx", NULL,
+		"gpio_132", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_DAT1, 133,
+		"sdmmc2_dat1", NULL, "uart4_rx", NULL,
+		"gpio_133", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_DAT5, 137,
+		"sdmmc2_dat5", "sdmmc2_dir_dat1", NULL, "sdmmc3_dat1",
+		"gpio_137", NULL, "mm_fsusb3_rxdp", "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_DAT6, 138,
+		"sdmmc2_dat6", "sdmmc2_dir_cmd", NULL, "sdmmc3_dat2",
+		"gpio_138", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(SDMMC2_DAT7, 139,
+		"sdmmc2_dat7", "sdmmc2_clkin", NULL, "sdmmc3_dat3",
+		"gpio_139", NULL, "mm_fsusbb3_rxdm", "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP3_DX, 140,
+		"mcbsp3_dx", "uart2_cts", NULL, NULL,
+		"gpio_140", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP3_DR, 141,
+		"mcbsp3_dr", "uart2_rts", NULL, NULL,
+		"gpio_141", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP3_CLKX, 142,
+		"mcbsp3_clkx", "uart2_tx", NULL, NULL,
+		"gpio_142", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP3_FSX, 143,
+		"mcbsp3_fsx", "uart2_rx", NULL, NULL,
+		"gpio_143", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(UART1_CTS, 150,
+		"uart1_cts", NULL, NULL, NULL,
+		"gpio_150", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP4_CLKX, 152,
+		"mcbsp4_clkx", NULL, NULL, NULL,
+		"gpio_152", NULL, "mm_fsusb3_rxrcv", "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP4_DR, 153,
+		"mcbsp4_dr", NULL, NULL, NULL,
+		"gpio_153", NULL, "mm_fsusb3_txdat", "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP4_DX, 154,
+		"mcbsp4_dx", NULL, NULL, NULL,
+		"gpio_154", NULL, "mm_fsusb3_txen_n", "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP4_FSX, 155,
+		"mcbsp4_fsx", NULL, NULL, NULL,
+		"gpio_155", NULL, NULL , "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP1_FSR, 157,
+		"mcbsp1_fsr", NULL, NULL, NULL,
+		"gpio_157", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCBSP_CLKS, 160,
+		"mcbsp_clks", NULL, NULL, NULL,
+		"gpio_160", "uart1_cts", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(USB0_DRVVBUS, 125,
+		"usb0_drvvbus", NULL, "uart3_tx_irtx", NULL,
+		"gpio_125", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(HECC1_TXD, 130,
+		"hecc1_txd", NULL, "uart3_rx_irrx", NULL,
+		"gpio_130", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(HECC1_RXD, 131,
+		"hecc1_rxd", NULL, "uart3_rts_sd", NULL,
+		"gpio_131", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI1_CS3, 177,
+		"mcspi1_cs3", NULL, "hsusb2_tll_data2", "hsusb2_data2",
+		"gpio_177", "mm_fsusb2_txdat", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI2_CLK, 178,
+		"mcspi2_clk", NULL, "hsusb2_tll_data7", "hsusb2_data7",
+		"gpio_178", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI2_SIMO, 179,
+		"mcspi2_simo", "gpt9_pwm_evt",
+		"hsusb2_tll_data4", "hsusb2_data4",
+		"gpio_179", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI2_SOMI, 180,
+		"mcspi2_somi", "gpt10_pwm_evt",
+		"hsusb2_tll_data5", "hsusb2_data5",
+		"gpio_180", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI2_CS0, 181,
+		"mcspi2_cs0", "gpt11_pwm_evt",
+		"hsusb2_tll_data6", "hsusb2_data6",
+		"gpio_181", NULL, NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(MCSPI2_CS1, 182,
+		"mcspi2_cs1", "gpt8_pwm_evt",
+		"hsusb2_tll_data3", "hsusb2_data3",
+		"gpio_182", "mm_fsusb2_txen_n", NULL, "safe_mode"),
+	_OMAP3_MUXENTRY(ETK_CLK, 12,
+		"etk_clk", "mcbsp5_clkx", "sdmmc3_clk", "hsusb1_stp",
+		"gpio_12", NULL, NULL, "hw_dbg1"),
+	_OMAP3_MUXENTRY(ETK_CTL, 13,
+		"etk_ctl", NULL, "sdmmc3_cmd", "hsusb1_clk",
+		"gpio_13", "mm_fsusb1_rxdp", NULL, "hw_dbg2"),
+	_OMAP3_MUXENTRY(ETK_D0, 14,
+		"etk_d0", "mcspi3_simo", "sdmmc3_dat4", "hsusb1_data0",
+		"gpio_14", "mm_fsusb1_rxrcv", NULL, "hw_dbg3"),
+	_OMAP3_MUXENTRY(ETK_D1, 15,
+		"etk_d1", "mcspi3_somi", NULL, "hsusb1_data1",
+		"gpio_15", "mm_fsusb1_txse0", NULL, "hw_dbg4"),
+	_OMAP3_MUXENTRY(ETK_D2, 16,
+		"etk_d2", "mcspi3_cs0", NULL, "hsusb1_data2",
+		"gpio_16", "mm_fsusb1_txdat", NULL, "hw_dbg5"),
+	_OMAP3_MUXENTRY(ETK_D3, 17,
+		"etk_d3", "mcspi3_clk", "sdmmc3_dat3", "hsusb1_data7",
+		"gpio_17", NULL, NULL, "hw_dbg6"),
+	_OMAP3_MUXENTRY(ETK_D4, 18,
+		"etk_d4", "mcbsp5_dr", "sdmmc3_dat0", "hsusb1_data4",
+		"gpio_18", NULL, NULL, "hw_dbg7"),
+	_OMAP3_MUXENTRY(ETK_D5, 19,
+		"etk_d5", "mcbsp5_fsx", "sdmmc3_dat1", "hsusb1_data5",
+		"gpio_19", NULL, NULL, "hw_dbg8"),
+	_OMAP3_MUXENTRY(ETK_D6, 20,
+		"etk_d6", "mcbsp5_dx", "sdmmc3_dat2", "hsusb1_data6",
+		"gpio_20", NULL, NULL, "hw_dbg9"),
+	_OMAP3_MUXENTRY(ETK_D7, 21,
+		"etk_d7", "mcspi3_cs1", "sdmmc3_dat7", "hsusb1_data3",
+		"gpio_21", "mm_fsusb1_txen_n", NULL, "hw_dbg10"),
+	_OMAP3_MUXENTRY(ETK_D8, 22,
+		"etk_d8", NULL, "sdmmc3_dat6", "hsusb1_dir",
+		"gpio_22", NULL, NULL, "hw_dbg11"),
+	_OMAP3_MUXENTRY(ETK_D9, 23,
+		"etk_d9", NULL, "sdmmc3_dat5", "hsusb1_nxt",
+		"gpio_23", "mm_fsusb1_rxdm", NULL, "hw_dbg12"),
+	_OMAP3_MUXENTRY(ETK_D10, 24,
+		"etk_d10", NULL, "uart1_rx", "hsusb2_clk",
+		"gpio_24", NULL, NULL, "hw_dbg13"),
+	_OMAP3_MUXENTRY(ETK_D11, 25,
+		"etk_d11", "mcspi3_clk", NULL, "hsusb2_stp",
+		"gpio_25", "mm_fsusb2_rxdp", NULL, "hw_dbg14"),
+	_OMAP3_MUXENTRY(ETK_D12, 26,
+		"etk_d12", NULL, NULL, "hsusb2_dir",
+		"gpio_26", NULL, NULL, "hw_dbg15"),
+	_OMAP3_MUXENTRY(ETK_D13, 27,
+		"etk_d13", NULL, NULL, "hsusb2_nxt",
+		"gpio_27", "mm_fsusb2_rxdm", NULL, "hw_dbg15"),
+	_OMAP3_MUXENTRY(ETK_D14, 28,
+		"etk_d14", NULL, NULL, "hsusb2_data0",
+		"gpio_28", "mm_fsusb2_rxrcv", NULL, "hw_dbg16"),
+	_OMAP3_MUXENTRY(ETK_D15, 29,
+		"etk_d15", NULL, NULL, "hsusb2_data1",
+		"gpio_29", "mm_fsusb2_txse0", NULL, "hw_dbg17"),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define am35xx_zcn_subset	NULL
+#endif
+
+/*
+ * Balls for AM35XX ZCN package
+ * 491-pin s-PBGA Package, 0.65mm Ball Pitch
+ */
+#if defined(CONFIG_OMAP_MUX) && defined(CONFIG_DEBUG_FS)		\
+		&& defined (CONFIG_OMAP_PACKAGE_ZCN)
+static struct omap_ball __initdata am35xx_zcn_ball[] = {
+	_OMAP3_BALLENTRY(SDRC_CKE0, "d14", NULL),
+	_OMAP3_BALLENTRY(GPMC_A1, "e3", NULL),
+	_OMAP3_BALLENTRY(GPMC_A2, "e2", NULL),
+	_OMAP3_BALLENTRY(GPMC_A3, "e1", NULL),
+	_OMAP3_BALLENTRY(GPMC_A4, "f7", NULL),
+	_OMAP3_BALLENTRY(GPMC_A5, "f6", NULL),
+	_OMAP3_BALLENTRY(GPMC_A6, "f4", NULL),
+	_OMAP3_BALLENTRY(GPMC_A7, "f3", NULL),
+	_OMAP3_BALLENTRY(GPMC_A8, "f2", NULL),
+	_OMAP3_BALLENTRY(GPMC_A9, "f1", NULL),
+	_OMAP3_BALLENTRY(GPMC_A10, "g6", NULL),
+	_OMAP3_BALLENTRY(GPMC_D8, "j4", NULL),
+	_OMAP3_BALLENTRY(GPMC_D9, "j3", NULL),
+	_OMAP3_BALLENTRY(GPMC_D10, "j2", NULL),
+	_OMAP3_BALLENTRY(GPMC_D11, "j1", NULL),
+	_OMAP3_BALLENTRY(GPMC_D12, "k4", NULL),
+	_OMAP3_BALLENTRY(GPMC_D13, "k3", NULL),
+	_OMAP3_BALLENTRY(GPMC_D14, "k2", NULL),
+	_OMAP3_BALLENTRY(GPMC_D15, "k1", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS1, "l1", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS2, "m4", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS3, "m3", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS4, "m2", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS5, "m1", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS6, "n5", NULL),
+	_OMAP3_BALLENTRY(GPMC_NCS7, "n4", NULL),
+	_OMAP3_BALLENTRY(GPMC_CLK, "n1", NULL),
+	_OMAP3_BALLENTRY(GPMC_NBE0_CLE, "r4", NULL),
+	_OMAP3_BALLENTRY(GPMC_NBE1, "t1", NULL),
+	_OMAP3_BALLENTRY(GPMC_NWP, "t2", NULL),
+	_OMAP3_BALLENTRY(GPMC_WAIT1, "t4", NULL),
+	_OMAP3_BALLENTRY(GPMC_WAIT2, "t5", NULL),
+	_OMAP3_BALLENTRY(GPMC_WAIT3, "u1", NULL),
+	_OMAP3_BALLENTRY(DSS_PCLK, "ae23", NULL),
+	_OMAP3_BALLENTRY(DSS_HSYNC, "ad22", NULL),
+	_OMAP3_BALLENTRY(DSS_VSYNC, "ad23", NULL),
+	_OMAP3_BALLENTRY(DSS_ACBIAS, "ae24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA0, "ad24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA1, "ad25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA2, "ac23", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA3, "ac24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA4, "ac25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA5, "ab24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA6, "ab25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA7, "aa23", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA8, "aa24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA9, "aa25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA10, "y22", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA11, "y23", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA12, "y24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA13, "y25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA14, "w21", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA15, "w22", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA16, "w23", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA17, "w24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA18, "w25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA19, "v24", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA20, "v25", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA21, "u21", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA22, "u22", NULL),
+	_OMAP3_BALLENTRY(DSS_DATA23, "u23", NULL),
+	_OMAP3_BALLENTRY(CCDC_PCLK, "ad2", NULL),
+	_OMAP3_BALLENTRY(CCDC_FIELD, "ad1", NULL),
+	_OMAP3_BALLENTRY(CCDC_HD, "ae2", NULL),
+	_OMAP3_BALLENTRY(CCDC_VD, "ad3", NULL),
+	_OMAP3_BALLENTRY(CCDC_WEN, "ae3", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA0, "ad4", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA1, "ae4", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA2, "ac5", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA3, "ad5", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA4, "ae5", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA5, "y6", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA6, "ab6", NULL),
+	_OMAP3_BALLENTRY(CCDC_DATA7, "ac6", NULL),
+	_OMAP3_BALLENTRY(RMII_MDIO_DATA, "ae6", NULL),
+	_OMAP3_BALLENTRY(RMII_MDIO_CLK, "ad6", NULL),
+	_OMAP3_BALLENTRY(RMII_RXD0, "y7", NULL),
+	_OMAP3_BALLENTRY(RMII_RXD1, "aa7", NULL),
+	_OMAP3_BALLENTRY(RMII_CRS_DV, "ab7", NULL),
+	_OMAP3_BALLENTRY(RMII_RXER, "ac7", NULL),
+	_OMAP3_BALLENTRY(RMII_TXD0, "ad7", NULL),
+	_OMAP3_BALLENTRY(RMII_TXD1, "ae7", NULL),
+	_OMAP3_BALLENTRY(RMII_TXEN, "ad8", NULL),
+	_OMAP3_BALLENTRY(RMII_50MHZ_CLK, "ae8", NULL),
+	_OMAP3_BALLENTRY(MCBSP2_FSX, "d25", NULL),
+	_OMAP3_BALLENTRY(MCBSP2_CLKX, "c25", NULL),
+	_OMAP3_BALLENTRY(MCBSP2_DR, "b25", NULL),
+	_OMAP3_BALLENTRY(MCBSP2_DX, "d24", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_CLK, "aa9", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_CMD, "ab9", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT0, "ac9", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT1, "ad9", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT2, "ae9", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT3, "aa10", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT4, "ab10", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT5, "ac10", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT6, "ad10", NULL),
+	_OMAP3_BALLENTRY(SDMMC1_DAT7, "ae10", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_CLK, "ad11", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_CMD, "ae11", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT0, "ab12", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT1, "ac12", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT2, "ad12", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT3, "ae12", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT4, "ab13", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT5, "ac13", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT6, "ad13", NULL),
+	_OMAP3_BALLENTRY(SDMMC2_DAT7, "ae13", NULL),
+	_OMAP3_BALLENTRY(MCBSP3_DX, "b24", NULL),
+	_OMAP3_BALLENTRY(MCBSP3_DR, "c24", NULL),
+	_OMAP3_BALLENTRY(MCBSP3_CLKX, "a24", NULL),
+	_OMAP3_BALLENTRY(MCBSP3_FSX, "c23", NULL),
+	_OMAP3_BALLENTRY(UART2_CTS, "f20", NULL),
+	_OMAP3_BALLENTRY(UART2_RTS, "f19", NULL),
+	_OMAP3_BALLENTRY(UART2_TX, "e24", NULL),
+	_OMAP3_BALLENTRY(UART2_RX, "e23", NULL),
+	_OMAP3_BALLENTRY(UART1_TX, "aa19", NULL),
+	_OMAP3_BALLENTRY(UART1_RTS, "y19", NULL),
+	_OMAP3_BALLENTRY(UART1_CTS, "y20", NULL),
+	_OMAP3_BALLENTRY(UART1_RX, "w20", NULL),
+	_OMAP3_BALLENTRY(MCBSP4_CLKX, "b23", NULL),
+	_OMAP3_BALLENTRY(MCBSP4_DR, "a23", NULL),
+	_OMAP3_BALLENTRY(MCBSP4_DX, "b22", NULL),
+	_OMAP3_BALLENTRY(MCBSP4_FSX, "a22", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_CLKR, "r25", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_FSR, "p21", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_DX, "p22", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_DR, "p23", NULL),
+	_OMAP3_BALLENTRY(MCBSP_CLKS, "p25", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_FSX, "p24", NULL),
+	_OMAP3_BALLENTRY(MCBSP1_CLKX, "n24", NULL),
+	_OMAP3_BALLENTRY(UART3_CTS_RCTX, "n2", NULL),
+	_OMAP3_BALLENTRY(UART3_RTS_SD, "n3", NULL),
+	_OMAP3_BALLENTRY(UART3_RX_IRRX, "p1", NULL),
+	_OMAP3_BALLENTRY(UART3_TX_IRTX, "p2", NULL),
+	_OMAP3_BALLENTRY(USB0_DRVVBUS, "e25", NULL),
+	_OMAP3_BALLENTRY(HECC1_TXD, "v2", NULL),
+	_OMAP3_BALLENTRY(HECC1_RXD, "v3", NULL),
+	_OMAP3_BALLENTRY(I2C2_SCL, "w1", NULL),
+	_OMAP3_BALLENTRY(I2C2_SDA, "w2", NULL),
+	_OMAP3_BALLENTRY(I2C3_SCL, "w4", NULL),
+	_OMAP3_BALLENTRY(I2C3_SDA, "w5", NULL),
+	_OMAP3_BALLENTRY(HDQ_SIO, "l25", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_CLK, "ae14", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_SIMO, "ad15", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_SOMI, "ac15", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_CS0, "ab15", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_CS1, "ad14", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_CS2, "ae15", NULL),
+	_OMAP3_BALLENTRY(MCSPI1_CS3, "ae16", NULL),
+	_OMAP3_BALLENTRY(MCSPI2_CLK, "ad16", NULL),
+	_OMAP3_BALLENTRY(MCSPI2_SIMO, "ac16", NULL),
+	_OMAP3_BALLENTRY(MCSPI2_SOMI, "ab16", NULL),
+	_OMAP3_BALLENTRY(MCSPI2_CS0, "aa16", NULL),
+	_OMAP3_BALLENTRY(MCSPI2_CS1, "ae17", NULL),
+	_OMAP3_BALLENTRY(SYS_NIRQ, "y1", NULL),
+	_OMAP3_BALLENTRY(SYS_CLKOUT2, "m25", NULL),
+	_OMAP3_BALLENTRY(ETK_CLK, "ad17", NULL),
+	_OMAP3_BALLENTRY(ETK_CTL, "ae18", NULL),
+	_OMAP3_BALLENTRY(ETK_D0, "ad18", NULL),
+	_OMAP3_BALLENTRY(ETK_D1, "ac18", NULL),
+	_OMAP3_BALLENTRY(ETK_D10, "ac20", NULL),
+	_OMAP3_BALLENTRY(ETK_D11, "ab20", NULL),
+	_OMAP3_BALLENTRY(ETK_D12, "ae21", NULL),
+	_OMAP3_BALLENTRY(ETK_D13, "ad21", NULL),
+	_OMAP3_BALLENTRY(ETK_D14, "ac21", NULL),
+	_OMAP3_BALLENTRY(ETK_D15, "ae22", NULL),
+	_OMAP3_BALLENTRY(ETK_D2, "ab18", NULL),
+	_OMAP3_BALLENTRY(ETK_D3, "aa18", NULL),
+	_OMAP3_BALLENTRY(ETK_D4, "y18", NULL),
+	_OMAP3_BALLENTRY(ETK_D5, "ae19", NULL),
+	_OMAP3_BALLENTRY(ETK_D6, "ad19", NULL),
+	_OMAP3_BALLENTRY(ETK_D7, "ab19", NULL),
+	_OMAP3_BALLENTRY(ETK_D8, "ae20", NULL),
+	_OMAP3_BALLENTRY(ETK_D9, "d20", NULL),
+	_OMAP3_BALLENTRY(SYS_CLKREQ, "m24", NULL),
+	_OMAP3_BALLENTRY(SYS_NRESWARM, "y3", "aa5"),
+	_OMAP3_BALLENTRY(SYS_BOOT0, "y4", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT1, "aa1", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT2, "aa2", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT3, "aa3", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT4, "ab1", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT5, "ab2", NULL),
+	_OMAP3_BALLENTRY(SYS_BOOT6, "ac1", NULL),
+	_OMAP3_BALLENTRY(SYS_CLKOUT1, "n25", NULL),
+	_OMAP3_BALLENTRY(JTAG_EMU0, "t25", NULL),
+	_OMAP3_BALLENTRY(JTAG_EMU1, "r24", NULL),
+
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define am35xx_zcn_ball	 NULL
+#endif
+
 int __init omap3_mux_init(struct omap_board_mux *board_subset, int flags)
 {
 	struct omap_mux *package_subset;
@@ -2048,6 +2611,10 @@
 		package_subset = omap36xx_cbp_subset;
 		package_balls = omap36xx_cbp_ball;
 		break;
+	case OMAP_PACKAGE_ZCN:
+		package_subset = am35xx_zcn_subset;
+		package_balls = am35xx_zcn_ball;
+		break;
 	default:
 		pr_err("%s Unknown omap package, mux disabled\n", __func__);
 		return -EINVAL;
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/mux34xx.h linux-3.0.x-arm/arch/arm/mach-omap2/mux34xx.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/mux34xx.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/mux34xx.h	2012-12-19 11:25:53.000000000 +0200
@@ -316,6 +316,42 @@
 #define OMAP3_CONTROL_PADCONF_SDRC_CKE0_OFFSET			0x232
 #define OMAP3_CONTROL_PADCONF_SDRC_CKE1_OFFSET			0x234
 
+/* AM3505/3517 only */
+#define OMAP3_CONTROL_PADCONF_CCDC_PCLK_OFFSET			0x1b4
+#define OMAP3_CONTROL_PADCONF_CCDC_FIELD_OFFSET			0x1b6
+#define OMAP3_CONTROL_PADCONF_CCDC_HD_OFFSET			0x1b8
+#define OMAP3_CONTROL_PADCONF_CCDC_VD_OFFSET			0x1ba
+#define OMAP3_CONTROL_PADCONF_CCDC_WEN_OFFSET			0x1bc
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA0_OFFSET			0x1be
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA1_OFFSET			0x1c0
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA2_OFFSET			0x1c2
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA3_OFFSET			0x1c4
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA4_OFFSET			0x1c6
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA5_OFFSET			0x1c8
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA6_OFFSET			0x1ca
+#define OMAP3_CONTROL_PADCONF_CCDC_DATA7_OFFSET			0x1cc
+#define OMAP3_CONTROL_PADCONF_RMII_MDIO_DATA_OFFSET		0x1ce
+#define OMAP3_CONTROL_PADCONF_RMII_MDIO_CLK_OFFSET		0x1d0
+#define OMAP3_CONTROL_PADCONF_RMII_RXD0_OFFSET			0x1d2
+#define OMAP3_CONTROL_PADCONF_RMII_RXD1_OFFSET			0x1d4
+#define OMAP3_CONTROL_PADCONF_RMII_CRS_DV_OFFSET		0x1d6
+#define OMAP3_CONTROL_PADCONF_RMII_RXER_OFFSET			0x1d8
+#define OMAP3_CONTROL_PADCONF_RMII_TXD0_OFFSET			0x1da
+#define OMAP3_CONTROL_PADCONF_RMII_TXD1_OFFSET			0x1dc
+#define OMAP3_CONTROL_PADCONF_RMII_TXEN_OFFSET			0x1de
+#define OMAP3_CONTROL_PADCONF_RMII_50MHZ_CLK_OFFSET		0x1e0
+#define OMAP3_CONTROL_PADCONF_USB0_DRVVBUS_OFFSET		0x1e2
+#define OMAP3_CONTROL_PADCONF_HECC1_TXD_OFFSET			0x1e4
+#define OMAP3_CONTROL_PADCONF_HECC1_RXD_OFFSET			0x1e6
+#define OMAP3_CONTROL_PADCONF_SYS_BOOT7_OFFSET			0x1e8
+#define OMAP3_CONTROL_PADCONF_SDRC_DQS0N_OFFSET			0x1ea
+#define OMAP3_CONTROL_PADCONF_SDRC_DQS1N_OFFSET			0x1ec
+#define OMAP3_CONTROL_PADCONF_SDRC_DQS2N_OFFSET			0x1ee
+#define OMAP3_CONTROL_PADCONF_SDRC_DQS3N_OFFSET			0x1f0
+#define OMAP3_CONTROL_PADCONF_SDRC_STRBEN_DLY0_OFFSET		0x1f2
+#define OMAP3_CONTROL_PADCONF_SDRC_STRBEN_DLY1_OFFSET		0x1f4
+#define OMAP3_CONTROL_PADCONF_SYS_BOOT8_OFFSET			0x1f6
+
 /* 36xx only */
 #define OMAP3_CONTROL_PADCONF_GPMC_A11_OFFSET			0x236
 #define OMAP3_CONTROL_PADCONF_SDRC_BA0_OFFSET			0x570
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/mux.h linux-3.0.x-arm/arch/arm/mach-omap2/mux.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/mux.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/mux.h	2012-12-19 11:25:53.000000000 +0200
@@ -62,6 +62,7 @@
 
 /* Flags for omapX_mux_init */
 #define OMAP_PACKAGE_MASK		0xffff
+#define OMAP_PACKAGE_ZCN		9		/* 491-pin 0.65 */
 #define OMAP_PACKAGE_CBS		8		/* 547-pin 0.40 0.40 */
 #define OMAP_PACKAGE_CBL		7		/* 547-pin 0.40 0.40 */
 #define OMAP_PACKAGE_CBP		6		/* 515-pin 0.40 0.50 */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -156,7 +156,7 @@
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_l3_main_masters),
 	.slaves		= omap3xxx_l3_main_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_l3_main_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -164,7 +164,8 @@
 static struct omap_hwmod omap3xxx_uart1_hwmod;
 static struct omap_hwmod omap3xxx_uart2_hwmod;
 static struct omap_hwmod omap3xxx_uart3_hwmod;
-static struct omap_hwmod omap3xxx_uart4_hwmod;
+static struct omap_hwmod omap36xx_uart4_hwmod;
+static struct omap_hwmod am35xx_uart4_hwmod;
 static struct omap_hwmod omap3xxx_usbhsotg_hwmod;
 
 /* l3_core -> usbhsotg interface */
@@ -300,8 +301,8 @@
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* L4 PER -> UART4 interface */
-static struct omap_hwmod_addr_space omap3xxx_uart4_addr_space[] = {
+/* L4 PER -> UART4 interface on omap36xx */
+static struct omap_hwmod_addr_space omap36xx_uart4_addr_space[] = {
 	{
 		.pa_start	= OMAP3_UART4_BASE,
 		.pa_end		= OMAP3_UART4_BASE + SZ_1K - 1,
@@ -311,13 +312,32 @@
 
 static struct omap_hwmod_ocp_if omap3_l4_per__uart4 = {
 	.master		= &omap3xxx_l4_per_hwmod,
-	.slave		= &omap3xxx_uart4_hwmod,
+	.slave		= &omap36xx_uart4_hwmod,
+	.clk		= "uart4_ick",
+	.addr		= omap36xx_uart4_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap36xx_uart4_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* AM35xx L4 CORE -> UART4 interface */
+static struct omap_hwmod_addr_space am35xx_uart4_addr_space[] = {
+	{
+		.pa_start	= AM35XX_UART4_BASE,
+		.pa_end		= AM35XX_UART4_BASE + SZ_1K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if am35xx_l4_core__uart4 = {
+	.master		= &omap3xxx_l4_core_hwmod,
+	.slave		= &am35xx_uart4_hwmod,
 	.clk		= "uart4_ick",
-	.addr		= omap3xxx_uart4_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap3xxx_uart4_addr_space),
+	.addr		= am35xx_uart4_addr_space,
+	.addr_cnt	= ARRAY_SIZE(am35xx_uart4_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+
 /* I2C IP block address space length (in bytes) */
 #define OMAP2_I2C_AS_LEN		128
 
@@ -498,7 +518,7 @@
 	.class		= &l4_hwmod_class,
 	.slaves		= omap3xxx_l4_core_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_l4_core_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -513,7 +533,7 @@
 	.class		= &l4_hwmod_class,
 	.slaves		= omap3xxx_l4_per_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_l4_per_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -528,7 +548,7 @@
 	.class		= &l4_hwmod_class,
 	.slaves		= omap3xxx_l4_wkup_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_l4_wkup_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -544,7 +564,7 @@
 	.main_clk	= "arm_fck",
 	.masters	= omap3xxx_mpu_masters,
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_mpu_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /*
@@ -572,7 +592,7 @@
 	.class		= &iva_hwmod_class,
 	.masters	= omap3xxx_iva_masters,
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_iva_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer class */
@@ -656,7 +676,7 @@
 	.slaves		= omap3xxx_timer1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer1_slaves),
 	.class		= &omap3xxx_timer_1ms_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer2 */
@@ -706,7 +726,7 @@
 	.slaves		= omap3xxx_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer2_slaves),
 	.class		= &omap3xxx_timer_1ms_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer3 */
@@ -756,7 +776,7 @@
 	.slaves		= omap3xxx_timer3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer3_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer4 */
@@ -806,7 +826,7 @@
 	.slaves		= omap3xxx_timer4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer4_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer5 */
@@ -856,7 +876,7 @@
 	.slaves		= omap3xxx_timer5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer5_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer6 */
@@ -906,7 +926,7 @@
 	.slaves		= omap3xxx_timer6_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer6_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer7 */
@@ -956,7 +976,7 @@
 	.slaves		= omap3xxx_timer7_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer7_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer8 */
@@ -1006,7 +1026,7 @@
 	.slaves		= omap3xxx_timer8_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer8_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer9 */
@@ -1056,7 +1076,7 @@
 	.slaves		= omap3xxx_timer9_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer9_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer10 */
@@ -1106,7 +1126,7 @@
 	.slaves		= omap3xxx_timer10_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer10_slaves),
 	.class		= &omap3xxx_timer_1ms_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer11 */
@@ -1156,7 +1176,7 @@
 	.slaves		= omap3xxx_timer11_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_timer11_slaves),
 	.class		= &omap3xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX)
 };
 
 /* timer12*/
@@ -1283,7 +1303,7 @@
 	},
 	.slaves		= omap3xxx_wd_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_wd_timer2_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	/*
 	 * XXX: Use software supervised mode, HW supervised smartidle seems to
 	 * block CORE power domain idle transitions. Maybe a HW bug in wdt2?
@@ -1343,7 +1363,7 @@
 	.slaves		= omap3xxx_uart1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_uart1_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* UART2 */
@@ -1380,7 +1400,7 @@
 	.slaves		= omap3xxx_uart2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_uart2_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* UART3 */
@@ -1417,7 +1437,7 @@
 	.slaves		= omap3xxx_uart3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_uart3_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* UART4 */
@@ -1435,7 +1455,7 @@
 	&omap3_l4_per__uart4,
 };
 
-static struct omap_hwmod omap3xxx_uart4_hwmod = {
+static struct omap_hwmod omap36xx_uart4_hwmod = {
 	.name		= "uart4",
 	.mpu_irqs	= uart4_mpu_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(uart4_mpu_irqs),
@@ -1457,9 +1477,46 @@
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3630ES1),
 };
 
+static struct omap_hwmod_irq_info omap35xx_uart4_mpu_irqs[] = {
+	{ .irq = INT_35XX_UART4, },
+};
+
+static struct omap_hwmod_dma_info omap35xx_uart4_sdma_reqs[] = {
+	{ .name = "rx",	.dma_req = AM35XX_DMA_UART4_RX, },
+	{ .name = "tx",	.dma_req = AM35XX_DMA_UART4_TX, },
+};
+
+static struct omap_hwmod_ocp_if *am35xx_uart4_slaves[] = {
+	&am35xx_l4_core__uart4,
+};
+
+static struct omap_hwmod am35xx_uart4_hwmod = {
+	.name		= "uart4",
+	.mpu_irqs	= omap35xx_uart4_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap35xx_uart4_mpu_irqs),
+	.sdma_reqs	= omap35xx_uart4_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap35xx_uart4_sdma_reqs),
+	.main_clk	= "uart4_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = AM35XX_EN_UART4_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = AM35XX_EN_UART4_SHIFT,
+		},
+	},
+	.slaves		= am35xx_uart4_slaves,
+	.slaves_cnt	= ARRAY_SIZE(am35xx_uart4_slaves),
+	.class		= &uart_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_AM35XX),
+};
+
+
 static struct omap_hwmod_class i2c_class = {
 	.name = "i2c",
 	.sysc = &i2c_sysc,
+	.reset = &omap_i2c_reset,
 };
 
 /*
@@ -1596,7 +1653,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_dss_slaves),
 	.masters	= omap3xxx_dss_masters,
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_dss_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 |
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 | CHIP_IS_AM35XX |
 				CHIP_IS_OMAP3630ES1 | CHIP_GE_OMAP3630ES1_1),
 };
 
@@ -1671,7 +1728,7 @@
 	},
 	.slaves		= omap3xxx_dss_dispc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_dss_dispc_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 |
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 | CHIP_IS_AM35XX |
 				CHIP_GE_OMAP3430ES2 | CHIP_IS_OMAP3630ES1 |
 				CHIP_GE_OMAP3630ES1_1),
 	.flags		= HWMOD_NO_IDLEST,
@@ -1735,7 +1792,7 @@
 	},
 	.slaves		= omap3xxx_dss_dsi1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_dss_dsi1_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 |
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 | CHIP_IS_AM35XX |
 				CHIP_GE_OMAP3430ES2 | CHIP_IS_OMAP3630ES1 |
 				CHIP_GE_OMAP3630ES1_1),
 	.flags		= HWMOD_NO_IDLEST,
@@ -1804,7 +1861,7 @@
 	},
 	.slaves		= omap3xxx_dss_rfbi_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_dss_rfbi_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 |
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 | CHIP_IS_AM35XX |
 				CHIP_GE_OMAP3430ES2 | CHIP_IS_OMAP3630ES1 |
 				CHIP_GE_OMAP3630ES1_1),
 	.flags		= HWMOD_NO_IDLEST,
@@ -1864,7 +1921,7 @@
 	},
 	.slaves		= omap3xxx_dss_venc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_dss_venc_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 |
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES1 | CHIP_IS_AM35XX |
 				CHIP_GE_OMAP3430ES2 | CHIP_IS_OMAP3630ES1 |
 				CHIP_GE_OMAP3630ES1_1),
 	.flags		= HWMOD_NO_IDLEST,
@@ -1891,6 +1948,7 @@
 
 static struct omap_hwmod omap3xxx_i2c1_hwmod = {
 	.name		= "i2c1",
+	.flags          = HWMOD_16BIT_REG,
 	.mpu_irqs	= i2c1_mpu_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(i2c1_mpu_irqs),
 	.sdma_reqs	= i2c1_sdma_reqs,
@@ -1909,7 +1967,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_i2c1_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c1_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* I2C2 */
@@ -1933,6 +1991,7 @@
 
 static struct omap_hwmod omap3xxx_i2c2_hwmod = {
 	.name		= "i2c2",
+	.flags          = HWMOD_16BIT_REG,
 	.mpu_irqs	= i2c2_mpu_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(i2c2_mpu_irqs),
 	.sdma_reqs	= i2c2_sdma_reqs,
@@ -1951,7 +2010,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_i2c2_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c2_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* I2C3 */
@@ -1975,6 +2034,7 @@
 
 static struct omap_hwmod omap3xxx_i2c3_hwmod = {
 	.name		= "i2c3",
+	.flags          = HWMOD_16BIT_REG,
 	.mpu_irqs	= i2c3_mpu_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(i2c3_mpu_irqs),
 	.sdma_reqs	= i2c3_sdma_reqs,
@@ -1993,7 +2053,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_i2c3_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c3_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* l4_wkup -> gpio1 */
@@ -2160,7 +2220,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio1_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* gpio2 */
@@ -2197,7 +2257,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio2_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* gpio3 */
@@ -2234,7 +2294,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio3_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* gpio4 */
@@ -2271,7 +2331,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio4_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* gpio5 */
@@ -2308,7 +2368,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio5_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* gpio6 */
@@ -2345,7 +2405,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_gpio6_slaves),
 	.class		= &omap3xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* dma_system -> L3 */
@@ -2437,7 +2497,7 @@
 	.masters	= omap3xxx_dma_system_masters,
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_dma_system_masters),
 	.dev_attr	= &dma_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -2516,7 +2576,7 @@
 	},
 	.slaves		= omap3xxx_mcbsp1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp1_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcbsp2 */
@@ -2579,7 +2639,7 @@
 	.slaves		= omap3xxx_mcbsp2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp2_slaves),
 	.dev_attr	= &omap34xx_mcbsp2_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcbsp3 */
@@ -2642,7 +2702,7 @@
 	.slaves		= omap3xxx_mcbsp3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp3_slaves),
 	.dev_attr	= &omap34xx_mcbsp3_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcbsp4 */
@@ -2700,7 +2760,7 @@
 	},
 	.slaves		= omap3xxx_mcbsp4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp4_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcbsp5 */
@@ -2758,7 +2818,7 @@
 	},
 	.slaves		= omap3xxx_mcbsp5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp5_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 /* 'mcbsp sidetone' class */
 
@@ -2819,7 +2879,7 @@
 	},
 	.slaves		= omap3xxx_mcbsp2_sidetone_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp2_sidetone_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcbsp3_sidetone */
@@ -2868,7 +2928,7 @@
 	},
 	.slaves		= omap3xxx_mcbsp3_sidetone_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mcbsp3_sidetone_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 
@@ -3208,7 +3268,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap34xx_mcspi1_slaves),
 	.class		= &omap34xx_mcspi_class,
 	.dev_attr       = &omap_mcspi1_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcspi2 */
@@ -3251,7 +3311,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap34xx_mcspi2_slaves),
 	.class		= &omap34xx_mcspi_class,
 	.dev_attr       = &omap_mcspi2_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* mcspi3 */
@@ -3294,7 +3354,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap34xx_mcspi3_slaves),
 	.class		= &omap34xx_mcspi_class,
 	.dev_attr       = &omap_mcspi3_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* SPI4 */
@@ -3335,7 +3395,7 @@
 	.slaves_cnt	= ARRAY_SIZE(omap34xx_mcspi4_slaves),
 	.class		= &omap34xx_mcspi_class,
 	.dev_attr       = &omap_mcspi4_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /*
@@ -3420,7 +3480,7 @@
 	.slaves		= am35xx_usbhsotg_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am35xx_usbhsotg_slaves),
 	.class		= &am35xx_usbotg_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES3_1)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES3_1 | CHIP_IS_AM35XX)
 };
 
 /* MMC/SD/SDIO common */
@@ -3486,7 +3546,7 @@
 	.slaves		= omap3xxx_mmc1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mmc1_slaves),
 	.class		= &omap34xx_mmc_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* MMC/SD/SDIO2 */
@@ -3529,7 +3589,7 @@
 	.slaves		= omap3xxx_mmc2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mmc2_slaves),
 	.class		= &omap34xx_mmc_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 /* MMC/SD/SDIO3 */
@@ -3571,7 +3631,7 @@
 	.slaves		= omap3xxx_mmc3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap3xxx_mmc3_slaves),
 	.class		= &omap34xx_mmc_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static __initdata struct omap_hwmod *omap3xxx_hwmods[] = {
@@ -3602,7 +3662,9 @@
 	&omap3xxx_uart1_hwmod,
 	&omap3xxx_uart2_hwmod,
 	&omap3xxx_uart3_hwmod,
-	&omap3xxx_uart4_hwmod,
+	&omap36xx_uart4_hwmod,
+	&am35xx_uart4_hwmod,
+
 	/* dss class */
 	&omap3430es1_dss_core_hwmod,
 	&omap3xxx_dss_core_hwmod,
@@ -3659,6 +3721,24 @@
 	NULL,
 };
 
+void __init omap2_disable_unused_hwmods(char *unused_hwmods[])
+{
+	int index;
+
+	for (index = 0; omap3xxx_hwmods[index]; index++) {
+		char **hwmods = unused_hwmods;
+		while (*hwmods) {
+			if (strcmp(omap3xxx_hwmods[index]->name,
+					*hwmods) == 0) {
+				omap3xxx_hwmods[index]->flags
+							= HWMOD_UNUSED;
+				break;
+			}
+			hwmods++;
+		}
+	}
+}
+
 int __init omap3xxx_hwmod_init(void)
 {
 	return omap_hwmod_register(omap3xxx_hwmods);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/omap_hwmod.c linux-3.0.x-arm/arch/arm/mach-omap2/omap_hwmod.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/omap_hwmod.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/omap_hwmod.c	2012-12-19 11:25:53.000000000 +0200
@@ -1562,6 +1562,33 @@
 }
 
 /**
+ * omap_hwmod_softreset - reset a module via SYSCONFIG.SOFTRESET bit
+ * @oh: struct omap_hwmod *
+ *
+ * This is a public function exposed to drivers. Some drivers may need to do
+ * some settings before and after resetting the device.  Those drivers after
+ * doing the necessary settings could use this function to start a reset by
+ * setting the SYSCONFIG.SOFTRESET bit.
+ */
+int omap_hwmod_softreset(struct omap_hwmod *oh)
+{
+	u32 v;
+	int ret;
+
+	if (!oh || !(oh->_sysc_cache))
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+	ret = _set_softreset(oh, &v);
+	if (ret)
+		goto error;
+	_write_sysconfig(v, oh);
+
+error:
+	return ret;
+}
+
+/**
  * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
  * @oh: struct omap_hwmod *
  * @idlemode: SIDLEMODE field bits (shifted to bit 0)
@@ -1659,7 +1686,8 @@
 
 	i = 0;
 	do {
-		if (!omap_chip_is(ohs[i]->omap_chip))
+		if (!omap_chip_is(ohs[i]->omap_chip)
+			|| (ohs[i]->flags & HWMOD_UNUSED))
 			continue;
 
 		r = _register(ohs[i]);
@@ -1685,9 +1713,6 @@
 		return 0;
 
 	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
-	if (!oh->_mpu_rt_va)
-		pr_warning("omap_hwmod: %s found no _mpu_rt_va for %s\n",
-				__func__, oh->name);
 
 	return 0;
 }
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/omap_opp_data.h linux-3.0.x-arm/arch/arm/mach-omap2/omap_opp_data.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/omap_opp_data.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/omap_opp_data.h	2012-12-19 11:25:53.000000000 +0200
@@ -88,6 +88,7 @@
 extern struct omap_volt_data omap34xx_vddcore_volt_data[];
 extern struct omap_volt_data omap36xx_vddmpu_volt_data[];
 extern struct omap_volt_data omap36xx_vddcore_volt_data[];
+extern struct omap_volt_data am35xx_vdd_volt_data[];
 
 extern struct omap_volt_data omap44xx_vdd_mpu_volt_data[];
 extern struct omap_volt_data omap44xx_vdd_iva_volt_data[];
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/omap_twl.c linux-3.0.x-arm/arch/arm/mach-omap2/omap_twl.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/omap_twl.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/omap_twl.c	2012-12-19 11:25:53.000000000 +0200
@@ -266,7 +266,7 @@
 {
 	struct voltagedomain *voltdm;
 
-	if (!cpu_is_omap34xx())
+	if (!cpu_is_omap34xx() || cpu_is_omap3505() || cpu_is_omap3517() )
 		return -ENODEV;
 
 	if (cpu_is_omap3630()) {
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/opp3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/opp3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/opp3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/opp3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -85,6 +85,15 @@
 	VOLT_DATA_DEFINE(0, 0, 0, 0),
 };
 
+/* AM35x
+ *
+ * Fields related to SmartReflex and Voltage Processor are set to 0.
+ */
+struct omap_volt_data am35xx_vdd_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP3_UV, 0x0, 0x0, 0x0),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
 /* OPP data */
 
 static struct omap_opp_def __initdata omap34xx_opp_def_list[] = {
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/pm34xx.c linux-3.0.x-arm/arch/arm/mach-omap2/pm34xx.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/pm34xx.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/pm34xx.c	2012-12-19 11:25:53.000000000 +0200
@@ -86,6 +86,7 @@
 static void (*_omap_sram_idle)(u32 *addr, int save_state);
 
 static int (*_omap_save_secure_sram)(u32 *addr);
+void (*omap3517_do_wfi_sram)(void);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
@@ -150,6 +151,7 @@
 	/* Save the system control module context, padconf already save above*/
 	omap3_control_save_context();
 	omap_dma_global_context_save();
+//	omap_musb_save_context();
 }
 
 static void omap3_core_restore_context(void)
@@ -161,6 +163,7 @@
 	/* Restore the interrupt controller context */
 	omap_intc_restore_context();
 	omap_dma_global_context_restore();
+//	omap_musb_restore_context();
 }
 
 /*
@@ -497,6 +500,8 @@
 
 int omap3_can_sleep(void)
 {
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		return 0;
 	if (!sleep_while_idle)
 		return 0;
 	if (!omap_uart_can_sleep())
@@ -696,7 +701,12 @@
 					OMAP3630_GRPSEL_UART4_MASK : 0;
 
 	/* XXX This should be handled by hwmod code or SCM init code */
-	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
+	/*
+	 * This causes MUSB failure on AM3517 so disable it.
+	 */
+	if (!cpu_is_omap3517() && !cpu_is_omap3505())
+		omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK,
+					OMAP2_CONTROL_SYSCONFIG);
 
 	/*
 	 * Enable control of expternal oscillator through
@@ -854,11 +864,17 @@
 
 void omap_push_sram_idle(void)
 {
-	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		_omap_sram_idle = omap_sram_push(omap3517_cpu_suspend,
+					omap3517_do_wfi_sz);
+	else
+		_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
 					omap34xx_cpu_suspend_sz);
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
-		_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,
-				save_secure_ram_context_sz);
+		if (omap3_has_secure_sram())
+			_omap_save_secure_sram = omap_sram_push(
+						save_secure_ram_context,
+						save_secure_ram_context_sz);
 }
 
 static void __init pm_errata_configure(void)
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/pm.c linux-3.0.x-arm/arch/arm/mach-omap2/pm.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/pm.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/pm.c	2012-12-19 11:25:53.000000000 +0200
@@ -225,7 +225,8 @@
 {
 	if (!cpu_is_omap34xx())
 		return;
-
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		return;
 	omap2_set_init_voltage("mpu", "dpll1_ck", mpu_dev);
 	omap2_set_init_voltage("core", "l3_ick", l3_dev);
 }
@@ -252,8 +253,10 @@
 static int __init omap2_common_pm_late_init(void)
 {
 	/* Init the OMAP TWL parameters */
-	omap3_twl_init();
+	if (omap3_has_sr())
+		omap3_twl_init();
 	omap4_twl_init();
+	omap3_tps65023_init();
 
 	/* Init the voltage layer */
 	omap_voltage_late_init();
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/pm-debug.c linux-3.0.x-arm/arch/arm/mach-omap2/pm-debug.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/pm-debug.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/pm-debug.c	2012-12-19 11:25:53.000000000 +0200
@@ -595,7 +595,7 @@
 
 DEFINE_SIMPLE_ATTRIBUTE(pm_dbg_option_fops, option_get, option_set, "%llu\n");
 
-static int pm_dbg_init(void)
+static int __init pm_dbg_init(void)
 {
 	int i;
 	struct dentry *d;
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/pm.h linux-3.0.x-arm/arch/arm/mach-omap2/pm.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/pm.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/pm.h	2012-12-19 11:25:53.000000000 +0200
@@ -93,13 +93,17 @@
 extern void omap24xx_cpu_suspend(u32 dll_ctrl, void __iomem *sdrc_dlla_ctrl,
 					void __iomem *sdrc_power);
 extern void omap34xx_cpu_suspend(u32 *addr, int save_state);
+extern void omap3517_cpu_suspend(int save_state);
 extern int save_secure_ram_context(u32 *addr);
+extern void omap3517_save_secure_ram_context(u32 *addr);
 extern void omap3_save_scratchpad_contents(void);
 
 extern unsigned int omap24xx_idle_loop_suspend_sz;
 extern unsigned int save_secure_ram_context_sz;
+extern unsigned int omap3517_save_secure_ram_context_sz;
 extern unsigned int omap24xx_cpu_suspend_sz;
 extern unsigned int omap34xx_cpu_suspend_sz;
+extern unsigned int omap3517_do_wfi_sz;
 
 #define PM_RTA_ERRATUM_i608		(1 << 0)
 #define PM_SDRC_WAKEUP_ERRATUM_i583	(1 << 1)
@@ -139,5 +143,14 @@
 	return -EINVAL;
 }
 #endif
+#ifdef CONFIG_REGULATOR_TPS65023
+extern int omap3_tps65023_init(void);
+#else
+static inline int omap3_tps65023_init(void)
+{
+	return -EINVAL;
+}
+#endif
+
 
 #endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/pmic_tps65023.c linux-3.0.x-arm/arch/arm/mach-omap2/pmic_tps65023.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/pmic_tps65023.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/pmic_tps65023.c	2012-12-19 11:25:53.000000000 +0200
@@ -0,0 +1,84 @@
+/**
+ * Implements support for TPS65023
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/i2c/twl.h>
+
+#include "voltage.h"
+
+#include "pm.h"
+
+#define	TPS65023_VDCDC1_MIN		800000	/* 0.8V		*/
+#define	TPS65023_VDCDC1_STEP		25000	/* 0.025V	*/
+
+
+/*
+ * Get voltage corresponding to specified vsel value using this formula:
+ *	Vout = 0.8V + (25mV x Vsel)
+ */
+static unsigned long tps65023_vsel_to_uv(const u8 vsel)
+{
+	return TPS65023_VDCDC1_MIN + (TPS65023_VDCDC1_STEP * vsel);
+}
+
+/*
+ * Get vsel value corresponding to specified voltage using this formula:
+ *	Vsel = (Vout - 0.8V)/ 25mV
+ */
+static u8 tps65023_uv_to_vsel(unsigned long uv)
+{
+	return DIV_ROUND_UP(uv - TPS65023_VDCDC1_MIN, TPS65023_VDCDC1_STEP);
+}
+
+/*
+ * TPS65023 is currently supported only for AM35x devices.
+ * Therefore, implementation below is specific to this device pair.
+ */
+
+/**
+ * Voltage information related to the MPU voltage domain of the
+ * AM35x processors - in relation to the TPS65023.
+ */
+static struct omap_volt_pmic_info tps65023_am35xx_mpu_volt_info = {
+	.step_size		= 25000,
+	.on_volt                = 1200000,
+	.vsel_to_uv		= tps65023_vsel_to_uv,
+	.uv_to_vsel		= tps65023_uv_to_vsel,
+};
+
+int __init omap3_tps65023_init(void)
+{
+	struct voltagedomain *voltdm;
+
+	if (!cpu_is_omap34xx())
+		return -ENODEV;
+
+	if (cpu_is_omap3505() || cpu_is_omap3517()) {
+		voltdm = omap_voltage_domain_lookup("mpu");
+		omap_voltage_register_pmic(voltdm,
+					&tps65023_am35xx_mpu_volt_info);
+		voltdm = omap_voltage_domain_lookup("core");
+		omap_voltage_register_pmic(voltdm,
+					&tps65023_am35xx_mpu_volt_info);
+	} else {
+		/* TODO:
+		 * Support for other devices that support TPS65023
+		 */
+	}
+
+	return 0;
+}
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/powerdomains2xxx_3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/powerdomains2xxx_3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/powerdomains2xxx_3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/powerdomains2xxx_3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -75,6 +75,6 @@
 struct powerdomain wkup_omap2_pwrdm = {
 	.name		= "wkup_pwrdm",
 	.prcm_offs	= WKUP_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP24XX | CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.pwrsts		= PWRSTS_ON,
 };
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/powerdomains3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/powerdomains3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/powerdomains3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/powerdomains3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -36,7 +36,7 @@
 static struct powerdomain iva2_pwrdm = {
 	.name		  = "iva2_pwrdm",
 	.prcm_offs	  = OMAP3430_IVA2_MOD,
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_OFF_RET,
 	.banks		  = 4,
@@ -57,7 +57,7 @@
 static struct powerdomain mpu_3xxx_pwrdm = {
 	.name		  = "mpu_pwrdm",
 	.prcm_offs	  = MPU_MOD,
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_OFF_RET,
 	.flags		  = PWRDM_HAS_MPU_QUIRK,
@@ -104,7 +104,7 @@
 	.name		  = "core_pwrdm",
 	.prcm_offs	  = CORE_MOD,
 	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES3_1 |
-					  CHIP_GE_OMAP3630ES1_1),
+					  CHIP_GE_OMAP3630ES1_1 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_OFF_RET,
 	/*
@@ -125,7 +125,7 @@
 
 static struct powerdomain dss_pwrdm = {
 	.name		  = "dss_pwrdm",
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.prcm_offs	  = OMAP3430_DSS_MOD,
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_RET,
@@ -161,7 +161,7 @@
 
 static struct powerdomain cam_pwrdm = {
 	.name		  = "cam_pwrdm",
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.prcm_offs	  = OMAP3430_CAM_MOD,
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_RET,
@@ -177,7 +177,7 @@
 static struct powerdomain per_pwrdm = {
 	.name		  = "per_pwrdm",
 	.prcm_offs	  = OMAP3430_PER_MOD,
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_OFF_RET,
 	.banks		  = 1,
@@ -192,13 +192,13 @@
 static struct powerdomain emu_pwrdm = {
 	.name		= "emu_pwrdm",
 	.prcm_offs	= OMAP3430_EMU_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct powerdomain neon_pwrdm = {
 	.name		  = "neon_pwrdm",
 	.prcm_offs	  = OMAP3430_NEON_MOD,
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_RET,
 };
@@ -206,7 +206,7 @@
 static struct powerdomain usbhost_pwrdm = {
 	.name		  = "usbhost_pwrdm",
 	.prcm_offs	  = OMAP3430ES2_USBHOST_MOD,
-	.omap_chip	  = OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 | CHIP_IS_AM35XX),
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRSTS_RET,
 	/*
@@ -228,31 +228,31 @@
 static struct powerdomain dpll1_pwrdm = {
 	.name		= "dpll1_pwrdm",
 	.prcm_offs	= MPU_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct powerdomain dpll2_pwrdm = {
 	.name		= "dpll2_pwrdm",
 	.prcm_offs	= OMAP3430_IVA2_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct powerdomain dpll3_pwrdm = {
 	.name		= "dpll3_pwrdm",
 	.prcm_offs	= PLL_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct powerdomain dpll4_pwrdm = {
 	.name		= "dpll4_pwrdm",
 	.prcm_offs	= PLL_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430 | CHIP_IS_AM35XX),
 };
 
 static struct powerdomain dpll5_pwrdm = {
 	.name		= "dpll5_pwrdm",
 	.prcm_offs	= PLL_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2 | CHIP_IS_AM35XX),
 };
 
 /* As powerdomains are added or removed above, this list must also be changed */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/serial.c linux-3.0.x-arm/arch/arm/mach-omap2/serial.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/serial.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/serial.c	2012-12-19 11:25:53.000000000 +0200
@@ -104,6 +104,15 @@
 #endif
 };
 
+static struct omap_uart_port_info omap_serial_default_info[] __initdata = {
+	{
+		.dma_enabled = 0,
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+		.pdev_id = -1,
+#endif
+	},
+};
+
 static LIST_HEAD(uart_list);
 static u8 num_uarts;
 
@@ -389,6 +398,10 @@
 	omap_uart_allow_sleep(uart);
 }
 
+/* NOTE: num - is physical order of UART
+* dev_id CAN'T be used as num if CONFIG_OMAP_SERIAL_REORDER defined! 
+* called from /mach-omap2/pmNNxx.c with num=direct number of UART
+*/
 void omap_uart_prepare_idle(int num)
 {
 	struct omap_uart_state *uart;
@@ -401,6 +414,10 @@
 	}
 }
 
+/* NOTE: num - is physical order of UART
+* dev_id CAN'T be used as num if CONFIG_OMAP_SERIAL_REORDER defined! 
+* called from /mach-omap2/pmNNxx.c with num=direct number of UART
+*/
 void omap_uart_resume_idle(int num)
 {
 	struct omap_uart_state *uart;
@@ -707,7 +724,8 @@
  * Don't mix calls to omap_serial_init_port() and omap_serial_init(),
  * use only one of the two.
  */
-void __init omap_serial_init_port(struct omap_board_data *bdata)
+void __init omap_serial_init_port(struct omap_board_data *bdata,
+								struct omap_uart_port_info *info)
 {
 	struct omap_uart_state *uart;
 	struct omap_hwmod *oh;
@@ -715,6 +733,7 @@
 	void *pdata = NULL;
 	u32 pdata_size = 0;
 	char *name;
+	int pdev_id;
 #ifndef CONFIG_SERIAL_OMAP
 	struct plat_serial8250_port ports[2] = {
 		{},
@@ -738,6 +757,17 @@
 
 	oh = uart->oh;
 	uart->dma_enabled = 0;
+
+	if (!info) {
+		info = omap_serial_default_info;
+	}
+
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+	pdev_id = info->pdev_id;
+#else
+	pdev_id = uart->num;
+#endif
+
 #ifndef CONFIG_SERIAL_OMAP
 	name = "serial8250";
 
@@ -785,13 +815,26 @@
 
 	name = DRIVER_NAME;
 
-	omap_up.dma_enabled = uart->dma_enabled;
+	omap_up.dma_enabled = info->dma_enabled;
+	
 	omap_up.uartclk = OMAP24XX_BASE_BAUD * 16;
 	omap_up.mapbase = oh->slaves[0]->addr->pa_start;
 	omap_up.membase = omap_hwmod_get_mpu_rt_va(oh);
 	omap_up.irqflags = IRQF_SHARED;
 	omap_up.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
 
+	omap_up.pin_DCD = info->pin_DCD;
+	omap_up.pin_DSR = info->pin_DSR;
+	omap_up.pin_DTR = info->pin_DTR;
+	omap_up.pin_RI = info->pin_RI;
+
+	omap_up.rs485 = info->rs485;
+	omap_up.rs485_switch = info->rs485_switch;
+
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+	omap_up.uart_num = uart->num;
+#endif
+
 	pdata = &omap_up;
 	pdata_size = sizeof(struct omap_uart_port_info);
 #endif
@@ -799,7 +842,7 @@
 	if (WARN_ON(!oh))
 		return;
 
-	od = omap_device_build(name, uart->num, oh, pdata, pdata_size,
+	od = omap_device_build(name, pdev_id, oh, pdata, pdata_size,
 			       omap_uart_latency,
 			       ARRAY_SIZE(omap_uart_latency), false);
 	WARN(IS_ERR(od), "Could not build omap_device for %s: %s.\n",
@@ -871,7 +914,7 @@
 		bdata.flags = 0;
 		bdata.pads = NULL;
 		bdata.pads_cnt = 0;
-		omap_serial_init_port(&bdata);
-
+		omap_serial_init_port(&bdata, NULL);
 	}
 }
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/sleep3517.S linux-3.0.x-arm/arch/arm/mach-omap2/sleep3517.S
--- linux-3.0.x-orig/arch/arm/mach-omap2/sleep3517.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/sleep3517.S	2012-12-19 11:25:53.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ * AM3505/3517 Sleep Code.
+ * Ranjith Lohithakshan <ranjithl@xxxxxx>
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <plat/sram.h>
+#include <mach/io.h>
+
+#include "cm2xxx_3xxx.h"
+#include "prm2xxx_3xxx.h"
+#include "sdrc.h"
+#include "control.h"
+
+#define CM_IDLEST1_CORE_V	OMAP34XX_CM_REGADDR(CORE_MOD, CM_IDLEST1)
+#define CM_CLKST_CORE_V		OMAP34XX_CM_REGADDR(CORE_MOD,\
+					 OMAP3430_CM_CLKSTST)
+#define CM_ICLKEN1_CORE_V	OMAP34XX_CM_REGADDR(CORE_MOD, CM_ICLKEN1)
+
+#define EMIF_PM_CTR_V		OMAP2_L3_IO_ADDRESS(0x6D000038)
+#define OMAP3517_CONF1_REG_V	OMAP2_L4_IO_ADDRESS(0x48002584)
+
+/*
+ * Forces OMAP into idle state
+ *
+ * omap3517_suspend() - This bit of code just executes the WFI
+ * for normal idles.
+ *
+ */
+ENTRY(omap3517_cpu_suspend)
+	stmfd	sp!, {r4-r12, lr}		@ save registers on stack
+loop:
+	/*b	loop*/	@Enable to debug by stepping through code
+	ldr	r4, omap3517_do_wfi_sram_addr
+	ldr	r5, [r4]
+	/*
+	 * Since OFF mode is unsupported r0 is always 0, and so no need to
+	 * save context
+	 */
+	bx	r5                      @  jump to the WFI code in SRAM
+/*
+ * Local variables
+ */
+omap3517_do_wfi_sram_addr:
+	.word omap3517_do_wfi_sram
+
+/* ===================================
+ * == WFI instruction => Enter idle ==
+ * ===================================
+ */
+
+/*
+ * Do WFI instruction
+ * Includes the resume path for non-OFF modes
+ *
+ * This code gets copied to internal SRAM and is accessible
+ * from both SDRAM and SRAM
+ * Always executed from SRAM (omap3517_do_wfi_sram),as AM35x does not
+ * support OFF mode
+ */
+	.align  3
+ENTRY(omap3517_do_wfi)
+	/* Put EMIF in self-refresh */
+	ldr	r4, emif_pm_ctrl
+	ldr	r5, [r4]
+	orr	r5, r5, #0x200
+	str	r5, [r4]
+
+	/* Disable SDRC and Control Module */
+	ldr	r4, cm_iclken1_core
+	ldr	r5, [r4]
+	str	r5, iclk_core_enable
+	ldr	r4, cm_iclken1_core
+	ldr	r5, clk_core_disable
+	str	r5, [r4]
+wait_sdrc_ok:
+	ldr	r4, cm_idlest1_core
+	ldr	r5, [r4]
+	and	r5, r5, #0x2
+	cmp	r5, #0x2
+	bne	wait_sdrc_ok
+
+	/* Gate DDR Phy clock */
+	ldr	r4, omap3517_conf1
+	ldr	r5, emif_phy_gate
+	str	r5, [r4]
+
+	/* Data memory barrier and Data sync barrier */
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c10, 4
+	mcr	p15, 0, r1, c7, c10, 5
+
+	wfi
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* Enable SDRC and Control Module */
+	ldr	r4, cm_iclken1_core
+	ldr	r5, iclk_core_enable
+	str	r5, [r4]
+
+	/* Enable DDR Phy Clock */
+	ldr	r4, omap3517_conf1
+	ldr	r5, emif_phy_enable
+	str	r5, [r4]
+
+	/* Take EMIF out of self-refresh */
+	ldr	r4, emif_pm_ctrl
+	ldr	r5, [r4]
+	bic	r5, r5, #0x200
+	str	r5, [r4]
+
+	ldmfd	sp!, {r4-r12, pc}		@ restore regs and return
+
+clk_core_disable:
+	.word	0x0
+iclk_core_enable:
+	.word	0x0
+emif_phy_gate:
+	.word	0x2620
+emif_phy_enable:
+	.word	0x8620
+cm_idlest1_core:
+	.word	CM_IDLEST1_CORE_V
+cm_clkst_core:
+	.word	CM_CLKST_CORE_V
+emif_pm_ctrl:
+	.word	EMIF_PM_CTR_V
+cm_iclken1_core:
+	.word	CM_ICLKEN1_CORE_V
+omap3517_conf1:
+	.word	OMAP3517_CONF1_REG_V
+ENTRY(omap3517_do_wfi_sz)
+	.word	. - omap3517_do_wfi
+
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/vc3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/vc3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/vc3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/vc3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -61,3 +61,15 @@
 	.smps_volra_shift = OMAP3430_VOLRA1_SHIFT,
 	.smps_volra_mask = OMAP3430_VOLRA1_MASK,
 };
+
+//////////////////////AM35/////////////////////////
+static struct omap_vc_common_data am35_vc_common = {
+};
+
+struct omap_vc_instance_data am35_vc1_data = {
+	.vc_common = &am35_vc_common,
+};
+
+struct omap_vc_instance_data am35_vc2_data = {
+	.vc_common = &am35_vc_common,
+};
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/vc.h linux-3.0.x-arm/arch/arm/mach-omap2/vc.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/vc.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/vc.h	2012-12-19 11:25:53.000000000 +0200
@@ -79,5 +79,8 @@
 extern struct omap_vc_instance_data omap4_vc_iva_data;
 extern struct omap_vc_instance_data omap4_vc_core_data;
 
+extern struct omap_vc_instance_data am35_vc1_data;
+extern struct omap_vc_instance_data am35_vc2_data;
+
 #endif
 
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/voltage.c linux-3.0.x-arm/arch/arm/mach-omap2/voltage.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/voltage.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/voltage.c	2012-12-19 11:25:53.000000000 +0200
@@ -60,6 +60,12 @@
 static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 					unsigned long target_volt);
 
+static int volt_scale_nop(struct omap_vdd_info *vdd,
+				unsigned long target_volt)
+{
+	return 0;
+}
+
 static u32 omap3_voltage_read_reg(u16 mod, u8 offset)
 {
 	return omap2_prm_read_mod_reg(mod, offset);
@@ -114,6 +120,12 @@
 	sys_clk_speed /= 1000;
 
 	/* Generic voltage parameters */
+	if (cpu_is_omap3505() || cpu_is_omap3517()) {
+		vdd->volt_scale = volt_scale_nop;
+		vdd->vp_enabled = false;
+		return 0;
+	}
+
 	vdd->volt_scale = vp_forceupdate_scale_voltage;
 	vdd->vp_enabled = false;
 
@@ -217,6 +229,9 @@
 {
 	u32 vp_val;
 
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		return ;
+
 	if (!vdd->read_reg || !vdd->write_reg) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, vdd->voltdm.name);
@@ -598,6 +613,9 @@
 {
 	u32 vc_val;
 
+	if (cpu_is_omap3505() || cpu_is_omap3517())
+		return ;
+
 	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
 		pr_err("%s: PMIC info requried to configure vc for"
 			"vdd_%s not populated.Hence cannot initialize vc\n",
@@ -644,7 +662,7 @@
 {
 	int ret = -EINVAL;
 
-	if (!vdd->pmic_info) {
+	if (!cpu_is_omap3505() && !cpu_is_omap3517() && !vdd->pmic_info) {
 		pr_err("%s: PMIC info requried to configure vdd_%s not"
 			"populated.Hence cannot initialize vdd_%s\n",
 			__func__, vdd->voltdm.name, vdd->voltdm.name);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/voltagedomains3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/voltagedomains3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/voltagedomains3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/voltagedomains3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -67,6 +67,53 @@
 	&omap3_vdd2_info,
 };
 
+/*
+ * AM35x VDD structures
+ *
+ * In AM35x there neither scalable voltage domain nor any hook-up with
+ * voltage controller/processor. However, when trying to re-use the hwmod
+ * database for OMAP3, definition of "core" voltage domain is necessary.
+ * Else, changes in hwmod data structures grow spirally.
+ *
+ * As a workaround, "core" voltage domain is defined below. This is an ad hoc
+ * arrangement till code for SoCs without scalable voltage domains gets
+ * an overhaul.
+ */
+static const struct omap_vfsm_instance_data am35_vdd1_vfsm_data = {
+	.voltsetup_shift = OMAP3430_SETUP_TIME1_SHIFT,
+};
+
+static struct omap_vdd_info am3517_vdd1_info = {
+	.vp_data = &am35_vp1_data,
+	.vc_data = &am35_vc1_data,
+	.vfsm = &am35_vdd1_vfsm_data,
+	.vp_enabled     = false,
+
+	.voltdm = {
+		.name = "mpu",
+	},
+};
+
+static const struct omap_vfsm_instance_data am35_vdd2_vfsm_data = {
+	.voltsetup_shift = OMAP3430_SETUP_TIME2_SHIFT,
+};
+
+static struct omap_vdd_info am3517_vdd2_info = {
+	.vp_data = &am35_vp2_data,
+	.vc_data = &am35_vc2_data,
+	.vfsm = &am35_vdd2_vfsm_data,
+	.vp_enabled     = false,
+
+	.voltdm = {
+		.name = "core",
+	},
+};
+
+static struct omap_vdd_info *am3517_vdd_info[] = {
+	&am3517_vdd1_info,
+	&am3517_vdd2_info,
+};
+
 /* OMAP3 specific voltage init functions */
 static int __init omap3xxx_voltage_early_init(void)
 {
@@ -80,7 +127,13 @@
 	 * XXX Will depend on the process, validation, and binning
 	 * for the currently-running IC
 	 */
-	if (cpu_is_omap3630()) {
+	if (cpu_is_omap3505() || cpu_is_omap3517()) {
+		am3517_vdd1_info.volt_data = am35xx_vdd_volt_data;
+		am3517_vdd2_info.volt_data = am35xx_vdd_volt_data;
+		return omap_voltage_early_init(prm_mod, prm_irqst_ocp_mod,
+				       am3517_vdd_info,
+				       ARRAY_SIZE(am3517_vdd_info));
+	} else if (cpu_is_omap3630()) {
 		omap3_vdd1_info.volt_data = omap36xx_vddmpu_volt_data;
 		omap3_vdd2_info.volt_data = omap36xx_vddcore_volt_data;
 	} else {
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/vp3xxx_data.c linux-3.0.x-arm/arch/arm/mach-omap2/vp3xxx_data.c
--- linux-3.0.x-orig/arch/arm/mach-omap2/vp3xxx_data.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/vp3xxx_data.c	2012-12-19 11:25:53.000000000 +0200
@@ -80,3 +80,25 @@
 	.voltage = OMAP3_PRM_VP2_VOLTAGE_OFFSET,
 	.prm_irqst_data = &omap3_vp2_prm_irqst_data,
 };
+
+////////////////////////////////////////////////////
+static const struct omap_vp_common_data am35_vp_common = {
+};
+
+static const struct omap_vp_prm_irqst_data am35_vp1_prm_irqst_data = {
+	.prm_irqst_reg = OMAP3_PRM_IRQSTATUS_MPU_OFFSET,
+};
+
+struct omap_vp_instance_data am35_vp1_data = {
+	.vp_common = &am35_vp_common,
+	.prm_irqst_data = &am35_vp1_prm_irqst_data,
+};
+
+static const struct omap_vp_prm_irqst_data am35_vp2_prm_irqst_data = {
+	.prm_irqst_reg = OMAP3_PRM_IRQSTATUS_MPU_OFFSET,
+};
+
+struct omap_vp_instance_data am35_vp2_data = {
+	.vp_common = &am35_vp_common,
+	.prm_irqst_data = &am35_vp2_prm_irqst_data,
+};
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/mach-omap2/vp.h linux-3.0.x-arm/arch/arm/mach-omap2/vp.h
--- linux-3.0.x-orig/arch/arm/mach-omap2/vp.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/mach-omap2/vp.h	2012-12-19 11:25:53.000000000 +0200
@@ -140,4 +140,7 @@
 extern struct omap_vp_instance_data omap4_vp_iva_data;
 extern struct omap_vp_instance_data omap4_vp_core_data;
 
+extern struct omap_vp_instance_data am35_vp1_data;
+extern struct omap_vp_instance_data am35_vp2_data;
+
 #endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/cpu.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/cpu.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/cpu.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/cpu.h	2012-12-19 11:25:58.000000000 +0200
@@ -439,6 +439,7 @@
 #define CHIP_IS_OMAP4430ES2_1		(1 << 12)
 #define CHIP_IS_OMAP4430ES2_2		(1 << 13)
 #define CHIP_IS_TI816X			(1 << 14)
+#define CHIP_IS_AM35XX			(1 << 15)
 
 #define CHIP_IS_OMAP24XX		(CHIP_IS_OMAP2420 | CHIP_IS_OMAP2430)
 
@@ -478,6 +479,8 @@
 #define OMAP3_HAS_192MHZ_CLK		BIT(5)
 #define OMAP3_HAS_IO_WAKEUP		BIT(6)
 #define OMAP3_HAS_SDRC			BIT(7)
+#define OMAP3_HAS_SR			BIT(8)
+#define OMAP3_HAS_SECURE_SRAM		BIT(9)
 
 #define OMAP3_HAS_FEATURE(feat,flag)			\
 static inline unsigned int omap3_has_ ##feat(void)	\
@@ -493,5 +496,7 @@
 OMAP3_HAS_FEATURE(192mhz_clk, 192MHZ_CLK)
 OMAP3_HAS_FEATURE(io_wakeup, IO_WAKEUP)
 OMAP3_HAS_FEATURE(sdrc, SDRC)
+OMAP3_HAS_FEATURE(sr, SR)
+OMAP3_HAS_FEATURE(secure_sram, SECURE_SRAM)
 
 #endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/dma.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/dma.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/dma.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/dma.h	2012-12-19 11:25:58.000000000 +0200
@@ -195,6 +195,11 @@
 
 #define OMAP36XX_DMA_UART4_TX		81	/* S_DMA_80 */
 #define OMAP36XX_DMA_UART4_RX		82	/* S_DMA_81 */
+
+/* Only for AM35xx */
+#define AM35XX_DMA_UART4_TX		54
+#define AM35XX_DMA_UART4_RX		55
+
 /*----------------------------------------------------------------------------*/
 
 #define OMAP1_DMA_TOUT_IRQ		(1 << 0)
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/gpmc.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/gpmc.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/gpmc.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/gpmc.h	2012-12-19 11:25:58.000000000 +0200
@@ -92,6 +92,8 @@
 	OMAP_ECC_HAMMING_CODE_HW, /* gpmc to detect the error */
 		/* 1-bit ecc: stored at beginning of spare area as romcode */
 	OMAP_ECC_HAMMING_CODE_HW_ROMCODE, /* gpmc method & romcode layout */
+	OMAP_ECC_BCH4_CODE_HW, /* gpmc bch detection & s/w method correction */
+	OMAP_ECC_BCH8_CODE_HW, /* gpmc bch detection & s/w method correction */
 };
 
 /*
@@ -155,6 +157,6 @@
 extern int gpmc_nand_read(int cs, int cmd);
 extern int gpmc_nand_write(int cs, int cmd, int wval);
 
-int gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size);
-int gpmc_calculate_ecc(int cs, const u_char *dat, u_char *ecc_code);
+int gpmc_enable_hwecc(int ecc, int cs, int mode, int dev_width, int ecc_size);
+int gpmc_calculate_ecc(int ecc, int cs, const u_char *dat, u_char *ecc_code);
 #endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/i2c.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/i2c.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/i2c.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/i2c.h	2012-12-19 11:25:58.000000000 +0200
@@ -52,4 +52,7 @@
 void __init omap1_i2c_mux_pins(int bus_id);
 void __init omap2_i2c_mux_pins(int bus_id);
 
+struct omap_hwmod;
+int omap_i2c_reset(struct omap_hwmod *oh);
+
 #endif /* __ASM__ARCH_OMAP_I2C_H */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/irqs.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/irqs.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/irqs.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/irqs.h	2012-12-19 11:25:58.000000000 +0200
@@ -357,6 +357,7 @@
 #define INT_35XX_EMAC_C0_TX_PULSE_IRQ	69
 #define INT_35XX_EMAC_C0_MISC_PULSE_IRQ	70
 #define INT_35XX_USBOTG_IRQ		71
+#define INT_35XX_UART4			84
 #define INT_35XX_CCDC_VD0_IRQ		88
 #define INT_35XX_CCDC_VD1_IRQ		92
 #define INT_35XX_CCDC_VD2_IRQ		93
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/mmc.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/mmc.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/mmc.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/mmc.h	2012-12-21 19:17:32.000000000 +0200
@@ -113,6 +113,7 @@
 		unsigned features;
 
 		int switch_pin;			/* gpio (card detect) */
+		int switch_level;		/* insertion level 0 (fall - default, as it used to be in omap_hsmmc_card_detect()) or 1 (raise) */
 		int gpio_wp;			/* gpio (write protect) */
 
 		int (*set_bus_mode)(struct device *dev, int slot, int bus_mode);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/omap_hwmod.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/omap_hwmod.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/omap_hwmod.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/omap_hwmod.h	2012-12-19 11:25:58.000000000 +0200
@@ -392,6 +392,7 @@
  *     in order to complete the reset. Optional clocks will be disabled
  *     again after the reset.
  * HWMOD_16BIT_REG: Module has 16bit registers
+ * HWMOD_UNUSED: The IP for this module is unused or disabled on current SoC
  */
 #define HWMOD_SWSUP_SIDLE			(1 << 0)
 #define HWMOD_SWSUP_MSTANDBY			(1 << 1)
@@ -402,6 +403,7 @@
 #define HWMOD_NO_IDLEST				(1 << 6)
 #define HWMOD_CONTROL_OPT_CLKS_IN_RESET		(1 << 7)
 #define HWMOD_16BIT_REG				(1 << 8)
+#define HWMOD_UNUSED				(1 << 9)
 
 /*
  * omap_hwmod._int_flags definitions
@@ -572,6 +574,7 @@
 
 void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs);
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs);
+int omap_hwmod_softreset(struct omap_hwmod *oh);
 
 int omap_hwmod_count_resources(struct omap_hwmod *oh);
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res);
@@ -610,5 +613,6 @@
 extern int omap2430_hwmod_init(void);
 extern int omap3xxx_hwmod_init(void);
 extern int omap44xx_hwmod_init(void);
+extern void omap2_disable_unused_hwmods(char *unused_hwmods[]);
 
 #endif
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/omap-serial.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/omap-serial.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/omap-serial.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/omap-serial.h	2012-12-19 11:25:58.000000000 +0200
@@ -29,7 +29,11 @@
  * in bootargs we specify as console=ttyO0 if uart1
  * is used as console uart.
  */
+#ifdef CONFIG_OMAP_SERIAL_OVERRIDE
+#define OMAP_SERIAL_NAME	CONFIG_OMAP_SERIAL_NAME
+#else
 #define OMAP_SERIAL_NAME	"ttyO"
+#endif
 
 #define OMAP_MODE13X_SPEED	230400
 
@@ -63,6 +67,24 @@
 	resource_size_t		mapbase;	/* resource base */
 	unsigned long		irqflags;	/* request_irq flags */
 	upf_t			flags;		/* UPF_* flags */
+
+	/* passed from board initialization code to uart_omap_port */
+	
+	struct serial_rs485	rs485;		/* rs485 standard settings */
+
+	/* rs485 Owen-specific settings */
+	struct serial_rs485_switch rs485_switch;	/* config of run time switching the output circuit between rs485 and rs232 lines. */	
+
+	/* Owen-specific addition: pins implementing full-modem UART (see PLC240-SPK207) */
+	unsigned int		pin_DTR;	/* signal DTR output */
+	unsigned int		pin_DSR;	/* signal DSR input */
+	unsigned int		pin_DCD;	/* signal DCD input */
+	unsigned int		pin_RI;		/* signal RI input */
+
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+	int pdev_id;					/* in order to alter tty number, specify -1 to leave the number  */
+	int uart_num;					/* UART real order number */
+#endif
 };
 
 struct uart_omap_dma {
@@ -111,6 +133,18 @@
 	unsigned char		msr_saved_flags;
 	char			name[20];
 	unsigned long		port_activity;
+	struct serial_rs485	rs485;
+	unsigned int		tx_in_progress:1,
+				tx_wait_end:1;
+
+	/* rs485 Owen-specific settings */
+	struct serial_rs485_switch rs485_switch;	/* config of run time switching the output circuit between rs485 and rs232 lines. */	
+
+	/* Owen-specific addition: pins implementing full-modem UART (see PLC240-SPK207) */
+	unsigned int		pin_DTR;	/* signal DTR output */
+	unsigned int		pin_DSR;	/* signal DSR input */
+	unsigned int		pin_DCD;	/* signal DCD input */
+	unsigned int		pin_RI;		/* signal RI input */
 };
 
 #endif /* __OMAP_SERIAL_H__ */
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/include/plat/serial.h linux-3.0.x-arm/arch/arm/plat-omap/include/plat/serial.h
--- linux-3.0.x-orig/arch/arm/plat-omap/include/plat/serial.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/include/plat/serial.h	2012-12-19 11:25:58.000000000 +0200
@@ -56,6 +56,9 @@
 #define TI816X_UART2_BASE	0x48022000
 #define TI816X_UART3_BASE	0x48024000
 
+/* AM3505/3517 UART4 */
+#define AM35XX_UART4_BASE	0x4809E000	/* Only on AM3505/3517 */
+
 /* External port on Zoom2/3 */
 #define ZOOM_UART_BASE		0x10000000
 #define ZOOM_UART_VIRT		0xfa400000
@@ -103,9 +106,11 @@
 #ifndef __ASSEMBLER__
 
 struct omap_board_data;
+struct omap_uart_port_info;
 
 extern void omap_serial_init(void);
-extern void omap_serial_init_port(struct omap_board_data *bdata);
+extern void omap_serial_init_port(struct omap_board_data *bdata,
+						struct omap_uart_port_info *info);
 extern int omap_uart_can_sleep(void);
 extern void omap_uart_check_wakeup(void);
 extern void omap_uart_prepare_suspend(void);
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/plat-omap/omap_device.c linux-3.0.x-arm/arch/arm/plat-omap/omap_device.c
--- linux-3.0.x-orig/arch/arm/plat-omap/omap_device.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/plat-omap/omap_device.c	2012-12-19 11:25:59.000000000 +0200
@@ -146,12 +146,12 @@
 			odpl->activate_lat_worst = act_lat;
 			if (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {
 				odpl->activate_lat = act_lat;
-				pr_warning("omap_device: %s.%d: new worst case "
+				pr_debug("omap_device: %s.%d: new worst case "
 					   "activate latency %d: %llu\n",
 					   od->pdev.name, od->pdev.id,
 					   od->pm_lat_level, act_lat);
 			} else
-				pr_warning("omap_device: %s.%d: activate "
+				pr_debug("omap_device: %s.%d: activate "
 					   "latency %d higher than exptected. "
 					   "(%llu > %d)\n",
 					   od->pdev.name, od->pdev.id,
diff -x .svn -Nru linux-3.0.x-orig/arch/arm/tools/mach-types linux-3.0.x-arm/arch/arm/tools/mach-types
--- linux-3.0.x-orig/arch/arm/tools/mach-types	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/arch/arm/tools/mach-types	2012-12-19 11:25:47.000000000 +0200
@@ -1113,3 +1113,10 @@
 thales_adc		MACH_THALES_ADC		THALES_ADC		3492
 ubisys_p9d_evp		MACH_UBISYS_P9D_EVP	UBISYS_P9D_EVP		3493
 atdgp318		MACH_ATDGP318		ATDGP318		3494
+plc100			MACH_OWEN_PLC100	OWEN_PLC100		262
+plc110			MACH_OWEN_PLC110	OWEN_PLC110		262
+plc240			MACH_OWEN_PLC240	OWEN_PLC240		1202
+plc304			MACH_OWEN_PLC304	OWEN_PLC304		1335
+he5684			MACH_OWEN_HE5684	OWEN_HE5684		1202
+plc323			MACH_OWEN_PLC323	OWEN_PLC323		1335
+spk2xx_var		MACH_OWEN_SPK2XX_VAR	OWEN_SPK2XX_VAR		2200
diff -x .svn -Nru linux-3.0.x-orig/drivers/base/power/main.c linux-3.0.x-arm/drivers/base/power/main.c
--- linux-3.0.x-orig/drivers/base/power/main.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/base/power/main.c	2012-12-19 11:28:37.000000000 +0200
@@ -565,6 +565,7 @@
 	TRACE_RESUME(error);
 	return error;
 }
+EXPORT_SYMBOL_GPL(device_resume);
 
 static void async_resume(void *data, async_cookie_t cookie)
 {
@@ -924,6 +925,7 @@
 
 	return __device_suspend(dev, pm_transition, false);
 }
+EXPORT_SYMBOL_GPL(device_suspend);
 
 /**
  * dpm_suspend - Execute "suspend" callbacks for all non-sysdev devices.
diff -x .svn -Nru linux-3.0.x-orig/drivers/base/power/sysfs.c linux-3.0.x-arm/drivers/base/power/sysfs.c
--- linux-3.0.x-orig/drivers/base/power/sysfs.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/base/power/sysfs.c	2012-12-19 11:28:37.000000000 +0200
@@ -9,6 +9,57 @@
 #include <linux/jiffies.h>
 #include "power.h"
 
+/**
+ *	state - Control current power state of device
+ *
+ *	show() returns the current power state of the device. '0' indicates
+ *	the device is on. Other values (2) indicate the device is in some low
+ *	power state.
+ *
+ *	store() sets the current power state, which is an integer valued
+ *	0, 2, or 3.  Devices with bus.suspend_late(), or bus.resume_early()
+ *	methods fail this operation; those methods couldn't be called.
+ *	Otherwise,
+ *
+ *	- If the recorded dev->power.power_state.event matches the
+ *	  target value, nothing is done.
+ *	- If the recorded event code is nonzero, the device is reactivated
+ *	  by calling bus.resume() and/or class.resume().
+ *	- If the target value is nonzero, the device is suspended by
+ *	  calling class.suspend() and/or bus.suspend() with event code
+ *	  PM_EVENT_SUSPEND.
+ *
+ *	This mechanism is DEPRECATED and should only be used for testing.
+ */
+
+static ssize_t state_show(struct device * dev, struct device_attribute *attr, char * buf)
+{
+	if (dev->power.power_state.event)
+		return sprintf(buf, "2\n");
+	else
+		return sprintf(buf, "0\n");
+}
+
+static ssize_t state_store(struct device * dev, struct device_attribute *attr, const char * buf, size_t n)
+{
+	pm_message_t state;
+	int error = -EINVAL;
+// h2o async flag
+	if ((n == 2) && !strncmp(buf, "2", 1)) {
+		state.event = PM_EVENT_SUSPEND;
+//		error = device_suspend(dev, state, false);
+	}
+	if ((n == 2) && !strncmp(buf, "0", 1)) {
+		state.event = PM_EVENT_RESUME;
+//		device_resume(dev, state, false);
+		error = 0;
+	}
+
+	return error ? error : n;
+}
+
+static DEVICE_ATTR(state, 0644, state_show, state_store);
+
 /*
  *	control - Report/change current runtime PM setting of the device
  *
diff -x .svn -Nru linux-3.0.x-orig/drivers/input/touchscreen/ads7846.c linux-3.0.x-arm/drivers/input/touchscreen/ads7846.c
--- linux-3.0.x-orig/drivers/input/touchscreen/ads7846.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/input/touchscreen/ads7846.c	2012-12-19 11:27:11.000000000 +0200
@@ -865,9 +865,22 @@
 
 static irqreturn_t ads7846_hard_irq(int irq, void *handle)
 {
-	struct ads7846 *ts = handle;
+/* When threaded ONESHOT irq handling is used (as we have in this driver) 
+* the interrupt is masked until the threaded handler finishes its handling
+* (see kernel/irq/manage.c, irq_thread() which calls eventually 
+* irq_finalize_oneshot() unmasking the hard irq).
+* So we need the threaded handler to work every time when interrupt occurs
+* in order to unmask the interrupt. Therefore IRQ_WAKE_THREAD seems to be 
+* the only possible correct return value for the hard handler.
+*
+* Just use default hard irq handler's behaviour unblocking the thread.
+* Additional checking of prendown state is not needed here
+* because the pendown state seems to be handled correctly in the threaded handler.
+*/
+/*	struct ads7846 *ts = handle;
 
-	return get_pendown_state(ts) ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+	return get_pendown_state(ts) ? IRQ_WAKE_THREAD : IRQ_HANDLED; */
+	return IRQ_WAKE_THREAD;
 }
 
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/davinci/dm355_ccdc.c linux-3.0.x-arm/drivers/media/video/davinci/dm355_ccdc.c
--- linux-3.0.x-orig/drivers/media/video/davinci/dm355_ccdc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/davinci/dm355_ccdc.c	2012-12-19 11:26:55.000000000 +0200
@@ -964,7 +964,7 @@
 	},
 };
 
-static int __init dm355_ccdc_probe(struct platform_device *pdev)
+static int __devinit dm355_ccdc_probe(struct platform_device *pdev)
 {
 	void (*setup_pinmux)(void);
 	struct resource	*res;
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/davinci/dm644x_ccdc.c linux-3.0.x-arm/drivers/media/video/davinci/dm644x_ccdc.c
--- linux-3.0.x-orig/drivers/media/video/davinci/dm644x_ccdc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/davinci/dm644x_ccdc.c	2012-12-19 11:26:55.000000000 +0200
@@ -956,7 +956,7 @@
 	},
 };
 
-static int __init dm644x_ccdc_probe(struct platform_device *pdev)
+static int __devinit dm644x_ccdc_probe(struct platform_device *pdev)
 {
 	struct resource	*res;
 	int status = 0;
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/davinci/Kconfig linux-3.0.x-arm/drivers/media/video/davinci/Kconfig
--- linux-3.0.x-orig/drivers/media/video/davinci/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/davinci/Kconfig	2012-12-19 11:26:55.000000000 +0200
@@ -33,7 +33,7 @@
 
 config VIDEO_VPSS_SYSTEM
 	tristate "VPSS System module driver"
-	depends on ARCH_DAVINCI
+	depends on ARCH_DAVINCI || ARCH_OMAP3
 	help
 	  Support for vpss system module for video driver
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/davinci/vpfe_capture.c linux-3.0.x-arm/drivers/media/video/davinci/vpfe_capture.c
--- linux-3.0.x-orig/drivers/media/video/davinci/vpfe_capture.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/davinci/vpfe_capture.c	2012-12-19 11:26:55.000000000 +0200
@@ -1829,7 +1829,7 @@
  * itself to the V4L2 driver and initializes fields of each
  * device objects
  */
-static __init int vpfe_probe(struct platform_device *pdev)
+static __devinit int vpfe_probe(struct platform_device *pdev)
 {
 	struct vpfe_subdev_info *sdinfo;
 	struct vpfe_config *vpfe_cfg;
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/davinci/vpss.c linux-3.0.x-arm/drivers/media/video/davinci/vpss.c
--- linux-3.0.x-orig/drivers/media/video/davinci/vpss.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/davinci/vpss.c	2012-12-19 11:26:55.000000000 +0200
@@ -357,7 +357,7 @@
 }
 EXPORT_SYMBOL(dm365_vpss_set_pg_frame_size);
 
-static int __init vpss_probe(struct platform_device *pdev)
+static int __devinit vpss_probe(struct platform_device *pdev)
 {
 	struct resource		*r1, *r2;
 	char *platform_name;
diff -x .svn -Nru linux-3.0.x-orig/drivers/media/video/omap/omap_vout.c linux-3.0.x-arm/drivers/media/video/omap/omap_vout.c
--- linux-3.0.x-orig/drivers/media/video/omap/omap_vout.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/media/video/omap/omap_vout.c	2012-12-19 11:26:54.000000000 +0200
@@ -2496,7 +2496,7 @@
 	return 0;
 }
 
-static int __init omap_vout_probe(struct platform_device *pdev)
+static __devinit int omap_vout_probe(struct platform_device *pdev)
 {
 	int ret = 0, i;
 	struct omap_overlay *ovl;
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/eeprom/at25.c linux-3.0.x-arm/drivers/misc/eeprom/at25.c
--- linux-3.0.x-orig/drivers/misc/eeprom/at25.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/eeprom/at25.c	2012-12-19 11:31:58.000000000 +0200
@@ -20,6 +20,24 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/eeprom.h>
 
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <linux/scatterlist.h>
+
+                            
+	
+	
+	
+	
+	
+	
+	
+	
+	
+
+	
+	
+  
 
 /*
  * NOTE: this is an *EEPROM* driver.  The vagaries of product naming
@@ -35,6 +53,8 @@
 	struct spi_eeprom	chip;
 	struct bin_attribute	bin;
 	unsigned		addrlen;
+	struct device_attribute sr;
+	                                                   
 };
 
 #define	AT25_WREN	0x06		/* latch the write enable */
@@ -139,7 +159,6 @@
 	return at25_ee_read(at25, buf, off, count);
 }
 
-
 static ssize_t
 at25_ee_write(struct at25_data *at25, const char *buf, loff_t off,
 	      size_t count)
@@ -156,10 +175,19 @@
 	if (unlikely(!count))
 		return count;
 
+	/*pr_info("     %s: writing: off=%ld, count=%lu\n", __func__, (long)off, (unsigned long)count); */
 	/* Temp buffer starts with command and address */
 	buf_size = at25->chip.page_size;
-	if (buf_size > io_limit)
-		buf_size = io_limit;
+//	if (buf_size > io_limit)
+//		buf_size = io_limit;
+	/* alloc no more than io_limit ... = PAGE_SIZE */
+	if (buf_size + at25->addrlen + 1 > io_limit)
+		buf_size = io_limit - (at25->addrlen + 1);
+
+	dev_dbg(&at25->spi->dev,
+		"buf_size = %u bytes, alloc size = %u bytes\n",
+		buf_size, buf_size + at25->addrlen + 1);
+
 	bounce = kmalloc(buf_size + at25->addrlen + 1, GFP_KERNEL);
 	if (!bounce)
 		return -ENOMEM;
@@ -196,7 +224,11 @@
 		}
 
 		/* Write as much of a page as we can */
-		segment = buf_size - (offset % buf_size);
+		if (at25->chip.flags & EE_ARBITRARY_WRITE) {
+			segment = buf_size;
+		} else {
+			segment = buf_size - (offset % buf_size);
+		}
 		if (segment > count)
 			segment = count;
 		memcpy(cp, buf, segment);
@@ -212,32 +244,34 @@
 		 * to readonly sections of the EEPROM...
 		 */
 
-		/* Wait for non-busy status */
-		timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
-		retries = 0;
-		do {
-
-			sr = spi_w8r8(at25->spi, AT25_RDSR);
-			if (sr < 0 || (sr & AT25_SR_nRDY)) {
-				dev_dbg(&at25->spi->dev,
-					"rdsr --> %d (%02x)\n", sr, sr);
-				/* at HZ=100, this is sloooow */
-				msleep(1);
-				continue;
-			}
-			if (!(sr & AT25_SR_nRDY))
+		if (!(at25->chip.flags & EE_NODELAY_WRITE)) {
+			/* Wait for non-busy status */
+			timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+			retries = 0;
+			do {
+
+				sr = spi_w8r8(at25->spi, AT25_RDSR);
+				if (sr < 0 || (sr & AT25_SR_nRDY)) {
+					dev_dbg(&at25->spi->dev,
+						"rdsr --> %d (%02x)\n", sr, sr);
+					/* at HZ=100, this is sloooow */
+					msleep(1);
+					continue;
+				}
+				if (!(sr & AT25_SR_nRDY))
+					break;
+			} while (retries++ < 3 || time_before_eq(jiffies, timeout));
+
+			if ((sr < 0) || (sr & AT25_SR_nRDY)) {
+				dev_err(&at25->spi->dev,
+					"write %d bytes offset %d, "
+					"timeout after %u msecs\n",
+					segment, offset,
+					jiffies_to_msecs(jiffies -
+						(timeout - EE_TIMEOUT)));
+				status = -ETIMEDOUT;
 				break;
-		} while (retries++ < 3 || time_before_eq(jiffies, timeout));
-
-		if ((sr < 0) || (sr & AT25_SR_nRDY)) {
-			dev_err(&at25->spi->dev,
-				"write %d bytes offset %d, "
-				"timeout after %u msecs\n",
-				segment, offset,
-				jiffies_to_msecs(jiffies -
-					(timeout - EE_TIMEOUT)));
-			status = -ETIMEDOUT;
-			break;
+			}
 		}
 
 		off += segment;
@@ -264,6 +298,17 @@
 	dev = container_of(kobj, struct device, kobj);
 	at25 = dev_get_drvdata(dev);
 
+	/*pr_info("%s: called: off=%ld, count=%lu\n", __func__, (long)off, (unsigned long)count);*/
+	               
+	                                   
+		                                                    
+			                                                  
+				                                                                    
+			                                    
+	 	                           
+		 
+	 
+
 	return at25_ee_write(at25, buf, off, count);
 }
 
@@ -289,6 +334,186 @@
 
 /*-------------------------------------------------------------------------*/
 
+static ssize_t at25_sr_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int sr;
+	struct at25_data *at25 = container_of(attr, struct at25_data, sr);
+
+	sr = spi_w8r8(at25->spi, AT25_RDSR);
+	return sprintf(buf, "0x%X\n", sr);
+}
+
+static ssize_t at25_sr_store(struct device *dev, struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	ssize_t status = 0;
+	u8 cmd[2];
+	int sr;
+	struct at25_data *at25 = container_of(attr, struct at25_data, sr);
+
+	sr = simple_strtol(buf, NULL, 16);
+	if (sr < 0 || sr > 0xff) {
+		dev_err(&at25->spi->dev, "wrong status register value 0x%X\n", sr);
+		return -EINVAL;
+	}
+
+	cmd[0] = AT25_WREN;
+	status = spi_write(at25->spi, cmd, 1);
+	if (status < 0) {
+		dev_dbg(&at25->spi->dev, "WREN --> %d\n",
+				(int)status);
+		return status;
+	}
+
+	cmd[0] = AT25_WRSR;
+	cmd[1] = (u8)sr;
+	status = spi_write(at25->spi, cmd, 2);
+	if (status < 0) {
+		dev_dbg(&at25->spi->dev, "WRSR 0x%X --> %d\n",
+				sr, (int)status);
+		return status;
+	}
+	dev_dbg(&at25->spi->dev, "WRSR 0x%X --> OK\n", sr);
+
+	return count;
+}
+
+/*-------------------------------------------------------------------------*/
+
+                                                                                               
+ 
+                                                           
+		                                   
+			                                                          
+					                                           
+ 
+
+                                                                                                     
+                   
+ 
+	                  
+	                               
+	                               
+	                                    
+	                                                 
+	                              
+	                           
+	        
+	
+	                                                          
+	                         
+		                                        
+		                  
+		                   
+	 
+	
+	                                                   
+	                                                     
+                           
+		                                                         
+		                       
+	                           
+	 
+	
+                                                                  
+                              
+                                                                    
+                             
+	                                
+	 
+
+	                            
+	                             
+	                                     
+
+	                         
+                                
+
+                                                               
+		                                          
+                   
+	                     
+	 
+
+                                            
+                                      
+		                                                              
+	 
+	                                    
+                                                    
+	
+	                                                                      
+
+          
+	                              
+		                       
+	 
+	                  
+		                      
+	 
+	                    
+		                        
+	 
+	
+                        	
+ 
+
+                                                
+ 
+                                           
+	                                      
+
+	
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                               
+ 
+
+
+
+
+
+
+/*-------------------------------------------------------------------------*/
+
 static int at25_probe(struct spi_device *spi)
 {
 	struct at25_data	*at25 = NULL;
@@ -366,9 +591,21 @@
 	if (err)
 		goto fail;
 
+	sysfs_attr_init(&at25->sr.attr);
+	at25->sr.attr.name = "sr";
+	at25->sr.show = at25_sr_show;
+	at25->sr.store = at25_sr_store;
+	at25->sr.attr.mode = S_IRUGO | S_IWUSR;
+	err = sysfs_create_file(&spi->dev.kobj, &at25->sr.attr);
+	if (err) {
+		goto fail_sr_attr;
+	}
+
 	if (chip->setup)
 		chip->setup(&at25->mem, chip->context);
 
+	       
+	
 	dev_info(&spi->dev, "%Zd %s %s eeprom%s, pagesize %u\n",
 		(at25->bin.size < 1024)
 			? at25->bin.size
@@ -378,6 +615,9 @@
 		(chip->flags & EE_READONLY) ? " (readonly)" : "",
 		at25->chip.page_size);
 	return 0;
+
+fail_sr_attr:
+	sysfs_remove_bin_file(&spi->dev.kobj, &at25->bin);
 fail:
 	dev_dbg(&spi->dev, "probe err %d\n", err);
 	kfree(at25);
@@ -389,6 +629,8 @@
 	struct at25_data	*at25;
 
 	at25 = dev_get_drvdata(&spi->dev);
+	 
+	sysfs_remove_file(&spi->dev.kobj, &at25->sr.attr);
 	sysfs_remove_bin_file(&spi->dev.kobj, &at25->bin);
 	kfree(at25);
 	return 0;
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/flush.c linux-3.0.x-arm/drivers/misc/flush.c
--- linux-3.0.x-orig/drivers/misc/flush.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/flush.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,32 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/cacheflush.h>
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+int flush_module_read_procmem(char *page, char **start, off_t offset, int count, int *eof, void *data);
+
+int flush_module_read_procmem(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+  flush_cache_all();
+  return 0;
+}
+
+static int flush_init(void)
+{
+      printk("### Flush-Cache module - %s %s ###\n", __DATE__, __TIME__);
+      create_proc_read_entry("flush_module", 0, NULL, flush_module_read_procmem, NULL);
+          return 0;
+}
+
+static void flush_exit(void)
+{
+  remove_proc_entry("flush_module", NULL);
+  printk("Flush module unloaded\n");
+}
+
+module_init(flush_init);
+module_exit(flush_exit);
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_bus.c linux-3.0.x-arm/drivers/misc/hpr/hpr_bus.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_bus.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_bus.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,1922 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/completion.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+#include "hpr_bus.h"
+#include "hpr_scan.h"
+#include "hpr_pab.h"
+#include "hpr_frame.h"
+#include "hpr_uart.h"
+#include "hpr_serial.h"
+
+#include "hpr_bus_pvt.h"
+
+/* Uncomment this define to test #2713.
+ * With defined HPR_TEST_2713_1:
+ * - hpr_start_group_work() just set flag that work is started w/o real start nd return 0
+ * - stop_group_work(): only sleeps a milisecond, clears the flag and returns 0
+ * - mutual exclusions and error handling in both methods are preserved, except of
+ * runnig/ending a real work
+ */
+//#define HPR_TEST_2713_1
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+static int paddr_any = 0;
+module_param(paddr_any, int, S_IRUGO);
+MODULE_PARM_DESC(paddr_any, "Allow any module param address in set operation");
+#endif
+
+static int gwp = 0;
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+module_param(gwp, int, S_IRUGO);
+MODULE_PARM_DESC(gwp, "Allow get/set params(addr>10) with group work running, allow to start group work while getting param");
+#endif
+
+typedef struct {
+	int bus_count;
+	int nr_modules;
+	int nr_inputs;
+	int nr_outputs;
+	
+	hpr_bus *buses;
+} hpr_drv_context;
+
+static hpr_drv_context hpr_context;
+
+static inline void set_bus_info(hpr_bus *bus, hpr_bus_info *bus_info);
+static inline void clear_bus_flags(hpr_bus* bus, int flags, int *counter);
+static void init_modules(hpr_bus *bus);
+static inline void free_bus_work(hpr_bus *bus);
+static int stop_bus_work(hpr_bus *bus, int work_flag);
+static int stop_group_work(hpr_bus * bus);
+static int stop_scan_bus_work(hpr_bus *bus);
+static void update_module_data(hpr_module_info *mi, hpr_param_arg *param);
+static void check_module_used_pab_config(hpr_module *module);
+
+/***** Implementation *****/
+
+int get_bus_by_index(int index, hpr_bus **bus)
+{
+	if (unlikely(!hpr_context.buses)) {
+		pr_err("%s: buses are not initialized\n", __func__);
+		return -ENODEV;
+	}
+	if (unlikely(index < 0 || index >= hpr_context.bus_count)) {
+		pr_err("%s: invalid bus index %d\n", __func__, index);
+		return -EINVAL;
+	}
+
+	*bus = &hpr_context.buses[index];
+	return 0;
+}
+
+static inline void set_bus_info(hpr_bus *bus, hpr_bus_info *bus_info)
+{
+	bus_info->bus_index = bus->index;
+	bus_info->bus_id = bus->id;
+	bus_info->modules_count = bus->modules_count;
+}
+
+static inline void clear_bus_flags(hpr_bus* bus, int flags, int *counter)
+{
+	spin_lock(&bus->lock);
+
+	if (!counter || !*counter || !--(*counter)) {
+		bus->flags &= ~flags;
+	}
+	spin_unlock(&bus->lock);
+}
+
+static void init_modules(hpr_bus *bus) 
+{
+	int i;
+	memset(bus->modules, 0, sizeof(hpr_module_info) * hpr_context.nr_modules);
+	for (i = 0; i < hpr_context.nr_modules; i++) {
+		sema_init(&bus->modules[i].lock, 1);
+	}
+	bus->modules_count = 0;
+	bus->in_free_index = 0;
+	bus->out_free_index = 0;
+}
+
+/***** Init/uninit interface *****/
+
+int hpr_init_bus_data(int bus_count, int bus_ids[], int nr_modules, 
+	int nr_inputs, int nr_outputs)
+{
+	int i;
+	hpr_bus *bus;
+	
+	if (!bus_count || !bus_ids || !nr_modules || !nr_inputs || !nr_outputs) {
+		pr_err("%s: invalid module parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	hpr_context.bus_count = bus_count;
+	hpr_context.nr_modules = nr_modules;
+	hpr_context.nr_inputs = nr_inputs;
+	hpr_context.nr_outputs = nr_outputs;
+
+	hpr_context.buses = kmalloc(sizeof(hpr_bus) * bus_count, GFP_KERNEL);
+	if (!hpr_context.buses) {
+		pr_err("%s: failed to alloc memory for buses\n", __func__);
+		goto err_buses_mem;
+	}
+	pr_debug("%s: allocated mem for %d buses\n", __func__, bus_count);
+
+	memset(hpr_context.buses, 0, sizeof(hpr_bus) * bus_count);
+
+	for (i = 0; i < bus_count; i++) {
+		bus = &hpr_context.buses[i];
+
+		bus->id = bus_ids[i];
+		bus->index = i;
+		spin_lock_init(&bus->lock);
+		
+		bus->modules = kmalloc(sizeof(hpr_module_info) * nr_modules, GFP_KERNEL);
+		if (!bus->modules) {
+			pr_err("%s: failed to alloc memory for modules, bus=%d\n", __func__, bus->id);
+			goto err_bus;
+		}
+
+		bus->pab_in = kmalloc(sizeof(hpr_pab) * nr_inputs, GFP_KERNEL);
+		if (!bus->pab_in) {
+			pr_err("%s: failed to alloc memory for pab inputs, bus=%d\n", __func__, bus->id);
+			goto err_bus;
+		}
+
+		bus->pab_out = kmalloc(sizeof(hpr_pab) * nr_outputs, GFP_KERNEL);
+		if (!bus->pab_out) {
+			pr_err("%s: failed to alloc memory for pab outputs, bus=%d\n", __func__, bus->id);
+			goto err_bus;
+		}
+
+		bus->work.work_q = create_singlethread_workqueue("bus_work");
+		if (!bus->work.work_q) {
+			pr_err("%s: failed to create bus work queue, bus=%d\n", __func__, bus->id);
+			goto err_bus;
+		}
+
+		init_modules(bus);
+		set_bus_info(bus, &bus->work.bus_info);
+	}
+	pr_debug("%s: buses initialized\n", __func__);
+
+	return 0;
+
+err_bus:
+	hpr_free_bus_data();
+
+err_buses_mem:
+	return -ENOMEM;
+}
+
+static inline void free_bus_work(hpr_bus *bus)
+{
+	int bus_flags;
+	int r = 0, n = 3;
+
+	if (!bus->work.work_q) {
+		return;
+	}
+
+	spin_lock(&bus->lock);
+	bus->flags |= HPR_BF_SHUTDOWN;
+	bus_flags = bus->flags;
+	spin_unlock(&bus->lock);
+
+	if (bus_flags & (HPR_BF_GROUP_WORK | HPR_BF_SCAN)) {
+		while (n--) {
+			if (bus_flags & HPR_BF_GROUP_WORK) {
+				pr_debug("%s: signal to group work to stop, bus=%d..\n", 
+					__func__, bus->work.bus_info.bus_id);
+				r = stop_group_work(bus);
+			} else if (bus_flags & HPR_BF_SCAN) {
+				pr_debug("%s: signal to scan bus work to stop, bus=%d..\n", 
+					__func__, bus->work.bus_info.bus_id);
+				r = stop_scan_bus_work(bus);
+			}
+
+			if (r != -EAGAIN) {
+				if (r) {
+					pr_err("%s: unexpected error: %d, bus=%d\n", 
+						__func__, r, bus->work.bus_info.bus_id);
+				} /* otherwise done OK */
+				break;
+			} 
+
+			hpr_pab_sleep_poll_interval_half();
+		}
+	} else if (bus_flags & HPR_BF_QUICK_OPERATION_MASK) {
+		//TODO: wait until flag is cleared or just sleep for ~ ((HPR_RETRY_COUNT * write + 1 read) + X) time
+		// quick operation should finish within this time.
+	}
+
+	if (!r) {
+		destroy_workqueue(bus->work.work_q);
+		pr_debug("%s: work queue for bus=%d destroyed\n", 
+			__func__, bus->work.bus_info.bus_id);
+	}
+}
+
+void hpr_free_bus_data(void)
+{
+	hpr_bus *bus;
+	int i = hpr_context.bus_count;
+	
+	if (!hpr_context.bus_count || !hpr_context.buses) {
+		pr_debug("%s: nothing to free\n", __func__);
+		return;
+	}
+
+	while (--i >= 0) {
+		bus = &hpr_context.buses[i];
+		pr_debug("%s: freeing bus=%d, index=%d\n", __func__, bus->id, i);
+
+		/* free work queue first */
+		free_bus_work(bus);
+
+		/* free data containers */
+		if (bus->pab_out) {
+			kfree(bus->pab_out);
+		}
+		if (bus->pab_in) {
+			kfree(bus->pab_in);
+		}
+		if (bus->modules) {
+			kfree(bus->modules);
+		}
+		pr_debug("%s: bus index=%d freed\n", __func__, i);
+	}
+
+	kfree(hpr_context.buses);
+	hpr_context.buses = NULL;
+	pr_debug("%s: buses freed\n", __func__);
+}
+
+/***** Interface for scan, group work operations *****/
+
+/* Lock module's mutex and return pointer to module's data so it can be read/written 
+ * Assume that bus_index and module_index were verified previously
+ */
+void hpr_get_module(int bus_index, int module_index, 
+					hpr_module **module)
+{
+	hpr_bus *bus;
+	hpr_module_info *mi;
+
+	bus = &hpr_context.buses[bus_index];
+	mi = &bus->modules[module_index];
+
+	if (module) {
+		down(&mi->lock);
+
+		*module = &mi->module;
+
+		pr_debug("%s: module's (addr=%d, index=%d) data locked, bus=%d\n", 
+			__func__, mi->module.params.member.module_address, 
+			module_index, bus->id);
+	}
+}
+
+void hpr_put_module(hpr_module *module)
+{
+	hpr_module_info *mi;
+
+	if (unlikely(!module)) {
+		pr_err("%s: module should not be NULL\n", __func__);
+		return;
+	}
+
+	mi = module_to_info(module);
+	pr_debug("%s: module=%p => info=%p (locksz=%d)\n",
+		__func__, module, mi, sizeof(mi->lock));
+
+	up(&mi->lock);
+	pr_debug("%s: module (addr=%d) data unlocked, bus=%d\n", 
+		__func__, module->params.member.module_address, module->bus_id);
+}
+
+/*
+ * function is invoked from ScanBus in order to add new scanned module's info
+ * module - ptr to module config got from scan
+ * returns 0 if success, error otherwise
+ * NOTE: module locking does not seem to be required, becasue when scan bus 
+ *          is in progress no access to the modules are allowed by other procedures
+ */
+int hpr_add_module(int bus_index, hpr_module *new_module)
+{
+	hpr_bus *bus;
+	hpr_module_info *mi;
+	int module_address, module_index;
+	int in_count, out_count;
+
+	if (unlikely(!new_module)) {
+		pr_err("%s: module to add should not be NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	bus = &hpr_context.buses[bus_index];
+
+	module_address = (int)new_module->params.member.module_address;
+	module_index = module_address - 1;
+	pr_debug("%s: new module addr=%d, index=%d, bus=%d\n", 
+		__func__, module_address, module_index, bus->id);
+
+	if (unlikely(module_index < 0)) {
+		pr_err("%s: invalid module index got: %d\n", 
+			__func__, module_index);
+		return -EINVAL;
+	}
+	if (unlikely(module_index >= hpr_context.nr_modules)) {
+		pr_err("%s: max. modules count exceeded: module_index=%d (bus=%d)\n", 
+			__func__, module_index, bus->id);
+		return -EINVAL;
+	}
+
+	mi = &bus->modules[module_index];
+
+//	down(&mi->lock);
+
+	in_count = new_module->params.member.pab_in_max;
+	out_count = new_module->params.member.pab_out_max;
+
+	if (bus->in_free_index + in_count > hpr_context.nr_inputs ||
+		bus->out_free_index + out_count > hpr_context.nr_outputs) {
+//		up(&mi->lock);
+		pr_warning("%s: max. count of pab inputs or outputs exceeded: "
+			"module_index=%d (bus=%d), fi=%d, fo=%d, mi=%d, mo=%d\n",
+			__func__, module_index, bus->id, 
+			bus->in_free_index, bus->out_free_index, 
+			in_count, out_count);
+		pr_warning("%s: PAB exchange will be disabled for the module_index=%d (bus=%d)\n",
+			__func__, module_index, bus->id);
+	} else {
+		new_module->flags.pab_config_correct = 1;
+	}
+
+	/* check pab config and set respective flag, so pab exchange may be disabled for the module */
+	check_module_used_pab_config(new_module);
+
+	/* copy parsed and previously determined data */
+	memcpy(&mi->module, new_module, sizeof(hpr_module));
+
+	init_waitqueue_head(&mi->module.pab_async_wait_q);
+
+	if (mi->module.flags.pab_config_correct) {
+		/* init pab_in reference, zeroing pab data, or leave the reference to be NULL */
+		if (in_count > 0) {
+			mi->module.pab_in = &bus->pab_in[bus->in_free_index];
+			bus->in_free_index += in_count;
+			memset(mi->module.pab_in, 0, sizeof(hpr_pab) * in_count);
+		}
+		
+		/* init pab_out reference, zeroing pab data, or leave the reference to be NULL */
+		if (out_count > 0) {
+			mi->module.pab_out = &bus->pab_out[bus->out_free_index];
+			bus->out_free_index += out_count;
+			memset(mi->module.pab_out, 0, sizeof(hpr_pab) * out_count);
+		}
+	}
+	
+	mi->module.status.b = 0;
+	mi->module.bus_id = bus->id;
+
+//	up(&mi->lock);
+
+	/* note: this is correct only because sequence of addresses are controlled by scan work */
+	bus->modules_count = module_address;
+
+	return 0;
+}
+
+/* return: 0 - successfully marked that scan ended, 
+ *    err code - if somebody terminated/is terminating the work, 
+ *    so scan work may need to call complete() 
+ */
+int hpr_notify_bus_scan_completed(int bus_index)
+{
+	hpr_bus *bus;
+	int bus_flags;
+	
+	bus = &hpr_context.buses[bus_index];
+	
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if ((bus_flags & HPR_BF_SCAN) && !(bus_flags & HPR_BF_ENDING_OPERATION)) {
+		/* we said the work is terminated */
+		bus->flags &= ~HPR_BF_SCAN;
+		/* inc scan counter */
+		bus->scan_count++;
+		if (!bus->scan_count) {
+			bus->scan_count = 1;
+		}
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (!(bus_flags & HPR_BF_SCAN)) {
+		/* scan work should just exit - the case looks like impossible actually */
+		pr_err("%s: no scan operation on the bus=%d\n", __func__, bus->id);
+		return -EINVAL;
+	}
+	
+	if (bus_flags & HPR_BF_ENDING_OPERATION) {
+		/* the case when scan work SHOULD call complete() */
+		pr_warning("%s: scan on bus=%d is being ended by user\n", __func__, bus->id);
+		return -EPERM;
+	}
+
+	/* scan work should just exit */
+	return 0;
+}
+
+
+/***** IOCTL interface *****/
+
+int hpr_get_bus_count(void)
+{
+	return hpr_context.bus_count;
+}
+
+/* 
+ * return N >= 0 - number of modules on the bus, <0 - error code 
+ */
+int hpr_get_module_count(int bus_index) 
+{
+	int r;
+	hpr_bus *bus;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	spin_lock(&bus->lock);
+	if (bus->flags & HPR_BF_SCAN) {
+		r = -EPERM;
+	} else {
+		r = bus->modules_count;
+	}
+	spin_unlock(&bus->lock);
+
+	return r;
+}
+
+/* Copy data from module info to Module_Data structure 
+ * to return further to user space
+ */
+int hpr_get_module_data(int bus_index, int module_address, 
+			hpr_module_data *data)
+{
+	int r;
+	hpr_bus *bus;
+	hpr_module_info *mi;
+	hpr_module *m;
+	int bus_flags;
+
+	if (unlikely(!data)) {
+		pr_err("%s: output data pointer should not be NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+	
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN))) {
+		bus->flags |= HPR_BF_GET_MODULE_DATA;
+		bus->op_counter.get_module_data++;
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	/* if one of the flags was set we had not set own flag, so can exit immediately */ 
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't get module data on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't get module data on the bus=%d: scanning is in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+	
+	if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+		pr_err("%s: invalid module addr=%d, bus=%d\n", 
+			__func__, module_address, bus->id);
+		r = -EINVAL;
+		goto get_module_data_exit;
+	}
+
+	mi = &bus->modules[module_address - 1];
+
+	/* prevent from simultaneous writing param to the same module */
+	down(&mi->lock);
+
+	m = &mi->module;
+	 
+	pr_debug("%s: HWId=0x%x, module addr=%d, bus=%d\n", 
+		__func__, m->params.member.hardware_id, module_address, bus->id);
+
+	data->module_type = m->type;
+	data->module_status = m->status;
+	
+	data->hardware_id = m->params.member.hardware_id;
+	data->change_status = m->params.member.change_status;
+	data->inputs_count_max = m->params.member.pab_in_max;
+	data->outputs_count_max = m->params.member.pab_out_max;
+	data->params_count = m->params.member.params_count;
+	data->inputs_count = m->params.member.pab_in_used;
+	data->outputs_count = m->params.member.pab_out_used;
+	data->function_id = m->params.member.function_id;
+	data->group_params = m->params.member.group_params;
+
+	up(&mi->lock);
+	pr_debug("%s: module addr=%d data copied, bus=%d\n", 
+		__func__, module_address, bus->id);
+
+get_module_data_exit:
+	clear_bus_flags(bus, HPR_BF_GET_MODULE_DATA, 
+				&bus->op_counter.get_module_data);
+	return r;
+}
+
+int hpr_user_pab_data_exchange(int bus_index, int module_address, 
+			hpr_pv_query *pv_query)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+	hpr_module_info *mi;
+	hpr_module_params_set *p;
+	hpr_pab *pab_in;
+	hpr_pab *pab_out;
+	int in_count, out_count;
+
+	if (unlikely(!pv_query)) {
+		pr_err("%s: input data must not be NULL\n", __func__);
+		return -EINVAL;
+	}
+	
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+	
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN))) {
+		bus->flags |= HPR_BF_USER_PAB_EXCHANGE;
+		bus->op_counter.user_pab_exchange++;
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't perform user pab data exchange on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't perform user pab data exchange on the bus=%d: scanning is in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+
+	if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+		pr_err("%s: invalid module addr=%d, bus=%d\n", 
+			__func__, module_address, bus->id);
+		r = -EINVAL;
+		goto user_pab_exch_exit;
+	}
+
+	mi = &bus->modules[module_address - 1];
+	p = &mi->module.params.member;
+
+	if (mi->module.flags.pab_async_one_shot) {
+		pr_err("%s: bus=%d, module=%d: is one-shot module - async exchange's inapplicable\n", 
+			__func__, bus->id, module_address);
+		r = -EINVAL;
+		goto user_pab_exch_exit;
+	}
+
+	down(&mi->lock);
+
+	if (!mi->module.flags.pab_config_correct || !mi->module.flags.used_pab_config_correct) {
+		up(&mi->lock);
+		r = -EPERM;
+		pr_err("%s: bus=%d, module=%d: pab config incorrect: user exchange denied\n", 
+			__func__, bus->id, module_address);
+		goto user_pab_exch_exit;
+	}
+
+	if (mi->module.flags.pab_sync_in_progress) {
+		up(&mi->lock);
+		r = -EPERM;
+		pr_err("%s: synchronous pab exchange is already in progress\n", __func__);
+		goto user_pab_exch_exit;
+	}
+	mi->module.flags.pab_async_enabled = 1;
+
+	pab_in = mi->module.pab_in;
+	pab_out = mi->module.pab_out;
+	in_count = p->pab_in_used;
+	out_count = p->pab_out_used;
+	
+	pr_debug("%s: module addr=%d, bus=%d: type=%d, ins=%d, outs=%d, in_max=%d, out_max=%d\n",
+			__func__, module_address, bus->id, mi->module.type, 
+			in_count, out_count, p->pab_in_max, p->pab_out_max);
+
+	/* copy latest status to user (access is checked in ioctl handler) */
+	pv_query->status = mi->module.status;
+	/* return result code of most recent PV communication to user */
+	r = mi->module.last_pvc_rc;
+
+	/* copy input data from module */
+	if (pv_query->in_data) {
+		if (in_count > pv_query->in_count) {
+			in_count = pv_query->in_count;
+			pr_warning("%s: module addr=%d, bus=%d: count of in pabs reduced by count of provided pabs: %d\n",
+					__func__, module_address, bus->id, in_count);
+		}
+		if (in_count) {
+			/* access is checked in ioctl function */
+			memcpy(pv_query->in_data, pab_in, sizeof(hpr_pab) * in_count);
+		}
+	}
+	
+	/* copy output data to module (optional) */
+	if (pv_query->out_data) {
+		if (out_count > pv_query->out_count) {
+			out_count = pv_query->out_count;
+			pr_warning("%s: module addr=%d, bus=%d: count of out pabs reduced by count of provided pabs: %d\n",
+						__func__, module_address, bus->id, out_count);
+		}
+		if (out_count) {
+			/* access is checked in ioctl function */
+			memcpy(pab_out, pv_query->out_data, sizeof(hpr_pab) * out_count);
+		}
+	}
+
+	up(&mi->lock);
+
+user_pab_exch_exit:
+	clear_bus_flags(bus, HPR_BF_USER_PAB_EXCHANGE, 
+				&bus->op_counter.user_pab_exchange);
+	return r;
+}
+
+static int setup_sync_pvc(int bus_id, hpr_module *module, hpr_pv_query *pv_query)
+{
+	hpr_module_params_set *p;
+	int max_count, actual_count;
+	int channel = 0;
+
+	p = &module->params.member;
+
+	/* check channel arg and calc count of pabs to copy */
+
+	switch (module->type) {
+		/* pure input modules */
+		case HPR_MT_DI_1_BYTE:
+		case HPR_MT_DI_1_SHORT:
+		case HPR_MT_AI_X_SHORT:
+		case HPR_MT_AI_X_FLOAT:
+		case HPR_MT_AI_HART_X:
+			actual_count = 0;
+			break;
+
+		//TODO: DMS has control info to send, but does it have pab_out_used > 0 ??
+		/* output 1 channel */
+		case HPR_MT_DO_1_BYTE:
+		case HPR_MT_DO_1_SHORT:
+		case HPR_MT_DIDO_1_BYTE:
+		case HPR_MT_DIDO_1_SHORT:
+		case HPR_MT_IO16B_1: 
+			if (p->pab_out_used == 0) {
+				pr_err("%s: invalid count of used output pabs = %d\n",
+						__func__, p->pab_out_used);
+				return -EINVAL;
+			}
+			actual_count = 1;
+			break;
+
+		/* rest of modules I/O with X channels*/
+		default:
+			channel = pv_query->out_channel;
+			if (module->type == HPR_MT_COMPLEX_X_SHORT || 
+				module->type == HPR_MT_COMPLEX_X_FLOAT) {
+				max_count = 3;	/* 3 channels per communication */
+			} else {
+				max_count = 1;	/* 1 channel per communication */
+			}
+			actual_count = p->pab_out_used - channel;
+			if (actual_count <= 0) {
+				pr_err("%s: invalid channel %d or count of used output pabs = %d\n",
+						__func__, channel, p->pab_out_used);
+				return -EINVAL;
+			}
+			if (actual_count > max_count) {
+				actual_count = max_count;
+			}
+			break;
+	}
+
+	/* check whether all required PABs provided */
+	if (pv_query->out_count < actual_count) {
+			pr_err("%s: provided PAB count %d is less than required: %d\n",
+					__func__, pv_query->out_count, actual_count);
+			return -EINVAL;
+	}
+
+	/* copy data from arg to module's structures (for modules with a single channel this datum doesn't matter */
+	pr_debug("%s: channel=%d, count=%d\n", __func__, channel, actual_count);
+	module->tx_channel = channel;
+	if (actual_count > 0) {
+		memcpy(&module->pab_out[channel], &pv_query->out_data[0], sizeof(hpr_pab) * actual_count);
+	}
+	
+	return 0;
+}
+
+static int handle_sync_pvc_result(int bus_id, hpr_module *module, hpr_pv_query *pv_query)
+{
+	hpr_module_params_set *p;
+	int max_count, actual_count;
+	int channel = 0;
+
+	p = &module->params.member;
+
+	/* check channel arg and calc count of pabs to copy */
+
+	switch (module->type) {
+		/* pure output modules - status only*/
+		case HPR_MT_DO_1_BYTE:
+		case HPR_MT_DO_1_SHORT:
+		case HPR_MT_AO_X_SHORT:
+		case HPR_MT_AO_X_FLOAT:
+			actual_count = 0;
+			break;
+
+		/* input 1 channel */
+		case HPR_MT_DI_1_BYTE:
+		case HPR_MT_DI_1_SHORT:
+		case HPR_MT_DIDO_1_BYTE:
+		case HPR_MT_DIDO_1_SHORT:
+		case HPR_MT_IO16B_1: 
+			if (p->pab_in_used == 0) {
+				pr_err("%s: invalid count of used input pabs = %d\n",
+						__func__, p->pab_in_used);
+				return -EINVAL;
+			}
+			actual_count = 1;
+			break;
+
+		/* rest of modules I/O with X channels*/
+		default:
+			channel = module->rx_channel;
+			if (module->type == HPR_MT_COMPLEX_X_SHORT || 
+				module->type == HPR_MT_COMPLEX_X_FLOAT) {
+				max_count = 3;	/* 3 channels per communication */
+			} else {
+				max_count = 1;	/* 1 channel per communication */
+			}
+			actual_count = p->pab_in_used - channel;
+			if (actual_count <= 0) {
+				pr_err("%s: invalid channel got %d or count of used input pabs = %d\n",
+						__func__, channel, p->pab_out_used);
+				return -EINVAL;
+			}
+			if (actual_count > max_count) {
+				actual_count = max_count;
+			}
+			break;
+	}
+
+	/* check whether enough place for result PABs */
+	if (pv_query->in_count < actual_count) {
+			pr_err("%s: provided PAB count %d is less than required: %d\n",
+					__func__, pv_query->out_count, actual_count);
+			return -EINVAL;
+	}
+
+	/* copy data from arg to module's structures (for modules with a single channel this datum doesn't matter */
+	pr_debug("%s: channel=%d, count=%d\n", __func__, channel, actual_count);
+	pv_query->in_channel = channel;
+	if (actual_count > 0) {
+		memcpy(&pv_query->in_data[0], &module->pab_in[channel], sizeof(hpr_pab) * actual_count);
+	}
+	/* fill with 0 rest of result space */
+	if (pv_query->in_count > actual_count) {
+		memset(&pv_query->in_data[actual_count], 0, 
+				sizeof(hpr_pab) * (pv_query->in_count - actual_count));
+	}
+
+	/* copy latest status to user (access is checked in ioctl handler) */
+	pv_query->status = module->status;
+
+	return 0;
+}
+
+int hpr_sync_pab_data_exchange(int bus_index, int module_address, 
+			hpr_pv_query *pv_query)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+	hpr_module_info *mi;
+	hpr_bus_info bus_info;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN))) {
+		bus->flags |= HPR_BF_SYNC_PAB_EXCHANGE;
+		bus->op_counter.sync_pab_exchange++;	/* the operation can occur on different modules simultaneously */
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't do sync pab exchange on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't do sync pab exchange on the bus=%d: scanning of the bus is in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+
+	if (unlikely(!(bus->modules_count > 0))) {
+		pr_err("%s: can't do sync pab exchange on the bus=%d: there are no modules\n",
+			__func__, bus->id);
+		r = -EINVAL;
+		goto sync_pab_exch_exit;
+	}
+
+	if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+		pr_err("%s: invalid module addr=%d, bus=%d\n", 
+			__func__, module_address, bus->id);
+		r = -EINVAL;
+		goto sync_pab_exch_exit;
+	}
+
+	mi = &bus->modules[module_address - 1];
+
+	if (mi->module.flags.pab_async_one_shot) {
+		pr_err("%s: bus=%d, module=%d: is one-shot module - sync exchange's inapplicable\n", 
+			__func__, bus->id, module_address);
+		r = -EINVAL;
+		goto sync_pab_exch_exit;
+	}
+
+	/* syncronize with possible simultaneous async or sync exchanges with the same modules */
+
+	down(&mi->lock);
+
+	if (!mi->module.flags.pab_config_correct || !mi->module.flags.used_pab_config_correct) {
+		up(&mi->lock);
+		r = -EPERM;
+		pr_err("%s: bus=%d, module=%d: pab config incorrect: sync exchange denied\n", 
+			__func__, bus->id, module_address);
+		goto sync_pab_exch_exit;
+	}
+
+	if (mi->module.flags.pab_sync_in_progress) {
+		/* another sync pab exchange for the module is in progress - error */
+		up(&mi->lock);
+		r = -EAGAIN;
+		pr_err("%s: another sync pab exchange for the module: %d on bus=%d is in progress\n",
+			__func__, module_address, bus->id);
+		goto sync_pab_exch_exit;
+	}
+	mi->module.flags.pab_sync_in_progress = 1;
+	mi->module.flags.pab_async_enabled = 0;
+
+	if (mi->module.flags.pab_async_in_progress) {
+		mi->module.flags.pab_async_is_waited = 1;
+		/* note: groupwork is in progress, so any parameter change is disabled...
+		 */
+		up(&mi->lock);
+
+		/* wait for async exchange completion */
+		pr_debug("%s: wait until async exchange ends for the module: %d, bus: %d\n",
+			__func__, module_address, bus->id);
+		/* timeout ? does not seem to be needed */
+		wait_event(mi->module.pab_async_wait_q, !mi->module.flags.pab_async_is_waited);
+		pr_debug("%s: async exchange has finished for the module: %d, bus: %d\n",
+			__func__, module_address, bus->id);
+
+		/* .. so this code must asquire the semaphore first, before param setting may
+		 * become allowed. Therefore it seems we may check params for the
+		 * operation earlier.
+		 */
+		down(&mi->lock);
+		pr_debug("%s: module: %d, bus: %d - locked\n",
+			__func__, module_address, bus->id);
+	}
+
+	/* setup sync process value communication: check args and prepare data to send */
+	r = setup_sync_pvc(bus->id, &mi->module, pv_query);
+	if (r) {
+		mi->module.flags.pab_sync_in_progress = 0;
+		up(&mi->lock);
+		goto sync_pab_exch_exit;
+	}
+	up(&mi->lock);
+
+	/* pab exchange */
+	set_bus_info(bus, &bus_info);
+	r = hpr_pab_sync_exchange(&bus_info, module_address - 1);
+
+	down(&mi->lock);
+	if (r) {
+		mi->module.flags.pab_sync_in_progress = 0;
+		up(&mi->lock);
+		goto sync_pab_exch_exit;
+	}
+	
+	r = handle_sync_pvc_result(bus->id, &mi->module, pv_query);
+
+	mi->module.flags.pab_sync_in_progress = 0;
+	up(&mi->lock);
+
+sync_pab_exch_exit:
+	clear_bus_flags(bus, HPR_BF_SYNC_PAB_EXCHANGE, 
+				&bus->op_counter.sync_pab_exchange);
+	return r;
+}
+
+int hpr_one_shot_async_exchange(int bus_index, int module_address, hpr_pv_query *pv_query)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+	hpr_module_info *mi;
+	hpr_module_params_set *p;
+	hpr_pab *pab_in;
+	hpr_pab *pab_out;
+	int in_count, out_count;
+	int one_shot_enabled, need_wake_up = 0;
+
+	if (unlikely(!pv_query)) {
+		pr_err("%s: input data must not be NULL\n", __func__);
+		return -EINVAL;
+	}
+	
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+	
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	one_shot_enabled = (bus_flags & HPR_BF_GROUP_WORK) && 
+			!(bus_flags & (HPR_BF_STARTING_OPERATION | HPR_BF_ENDING_OPERATION));
+	if (likely(one_shot_enabled)) {
+		bus->op_counter.one_shot_exchange++;
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (unlikely(!one_shot_enabled)) {
+		pr_err("%s: one shot is disabled on the bus=%d\n", __func__, bus->id);
+		return -EPERM;
+	}
+
+	if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+		pr_err("%s: invalid module addr=%d, bus=%d\n", 
+			__func__, module_address, bus->id);
+		r = -EINVAL;
+		goto one_shot_exit;
+	}
+
+	mi = &bus->modules[module_address - 1];
+	p = &mi->module.params.member;
+
+	if (!mi->module.flags.pab_async_one_shot) {
+		pr_err("%s: bus=%d, module=%d: is not one-shot module - one shot exchange is not allowed\n", 
+			__func__, bus->id, module_address);
+		r = -EINVAL;	/* inval module specified */
+		goto one_shot_exit;
+	}
+
+	down(&mi->lock);
+
+	if (unlikely(!mi->module.flags.pab_config_correct || !mi->module.flags.used_pab_config_correct)) {
+		up(&mi->lock);
+		r = -EPERM;
+		pr_err("%s: bus=%d, module=%d: pab config incorrect: one shot exchange denied\n", 
+			__func__, bus->id, module_address);
+		goto one_shot_exit;
+	}
+
+	/* prevent from overwriting one-shot request data from another thread
+	 * while waiting for the exchange */
+	if (mi->module.flags.pab_one_shot_in_progress) {
+		/* another one-shot exchange for the module is in progress - error */
+		up(&mi->lock);
+		r = -EAGAIN;
+		pr_err("%s: another one-shot exchange for the module: %d on bus=%d is in progress\n",
+			__func__, module_address, bus->id);
+		goto one_shot_exit;
+	}
+	mi->module.flags.pab_one_shot_in_progress = 1;
+
+	pab_out = mi->module.pab_out;
+	out_count = p->pab_out_used;
+
+	/* copy output data to module (optional) */
+	if (pv_query->out_data) {
+		if (out_count > pv_query->out_count) {
+			out_count = pv_query->out_count;
+			pr_warning("%s: module addr=%d, bus=%d: count of out pabs reduced by count of provided pabs: %d\n",
+						__func__, module_address, bus->id, out_count);
+		}
+		if (out_count) {
+			memcpy(pab_out, pv_query->out_data, sizeof(hpr_pab) * out_count);
+		}
+	}
+
+	mi->module.flags.pab_async_enabled = 1;
+	mi->module.flags.pab_async_is_waited = 1;
+
+	/* set error code in order to return it in case async exchange is canceled 
+	 * (may be set in cancel procedure, but it is better to set it here if we'd like to
+	 * use timeout also later)
+	 */
+	mi->module.last_pvc_rc = -ENOASYNCEXCH;
+
+	up(&mi->lock);
+
+	/* wait for async exchange completion */
+	pr_debug("%s: wait until async exchange ends for the module: %d, bus: %d\n",
+		__func__, module_address, bus->id);
+	/* TODO: do we need timeout here? */
+	wait_event(mi->module.pab_async_wait_q, !mi->module.flags.pab_async_is_waited);
+	pr_debug("%s: async exchange has finished for the module: %d, bus: %d\n",
+		__func__, module_address, bus->id);
+	
+	/* exchanged, timed out or canceled */
+
+	down(&mi->lock);
+
+	/* copy latest status to user (access is checked in ioctl handler) */
+	pv_query->status = mi->module.status;
+	/* return result code of most recent PV communication or cencel code to user */
+	r = mi->module.last_pvc_rc;
+
+	/* copy input data from module */
+	pab_in = mi->module.pab_in;
+	in_count = p->pab_in_used;
+	if (pv_query->in_data) {
+		if (in_count > pv_query->in_count) {
+			in_count = pv_query->in_count;
+			pr_warning("%s: module addr=%d, bus=%d: count of in pabs reduced by count of provided pabs: %d\n",
+					__func__, module_address, bus->id, in_count);
+		}
+		if (in_count) {
+			/* access is checked in ioctl function */
+			memcpy(pv_query->in_data, pab_in, sizeof(hpr_pab) * in_count);
+		}
+	}
+
+	/* allow more one-shot exchanges for the module */
+	mi->module.flags.pab_one_shot_in_progress = 0;
+	up(&mi->lock);
+	
+one_shot_exit:
+
+	spin_lock(&bus->lock);
+	bus->op_counter.one_shot_exchange--;
+	if (!bus->op_counter.one_shot_exchange) {
+		need_wake_up = 1;
+	}
+	spin_unlock(&bus->lock);
+
+	if (need_wake_up) {
+		wake_up(&bus->one_shot_wait);
+		pr_debug("%s: bus=%d: waked up all waiting one-shot exchanges\n", __func__, bus->id);
+	}
+	
+	return r;
+}
+EXPORT_SYMBOL(hpr_one_shot_async_exchange);
+
+int hpr_start_group_work(int bus_index)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+	int check_flags = 0;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	check_flags = gwp ? 0 : HPR_BF_READ_MODULE_PARAM;
+
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_GROUP_WORK | HPR_BF_SCAN |
+			HPR_BF_WRITE_MODULE_PARAM | check_flags))) {
+		bus->flags |= (HPR_BF_GROUP_WORK | HPR_BF_STARTING_OPERATION);
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_GROUP_WORK | HPR_BF_SCAN |
+			HPR_BF_WRITE_MODULE_PARAM | check_flags)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't run group work on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't run group work on the bus=%d: scanning of the bus is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_GROUP_WORK) {
+			pr_err("%s: can't run group work on the bus=%d: the work is already in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & (check_flags & HPR_BF_READ_MODULE_PARAM)) {
+			pr_err("%s: can't run group work on the bus=%d: param read is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_WRITE_MODULE_PARAM) {
+			pr_err("%s: can't run group work on the bus=%d: param write is in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+
+	if (unlikely(!(bus->modules_count > 0))) {
+		pr_err("%s: can't run group work on the bus=%d: there are no modules\n",
+			__func__, bus->id);
+		clear_bus_flags(bus, HPR_BF_GROUP_WORK | HPR_BF_STARTING_OPERATION, NULL);
+		return -EINVAL;
+	}
+
+#ifdef HPR_TEST_2713_1
+	pr_debug("%s: HPR_TEST_2713_1: group_work MARKED as STARTED for bus=%d\n", 
+		__func__, bus->id);
+	clear_bus_flags(bus, HPR_BF_STARTING_OPERATION, NULL);
+	return 0;
+#else
+	/* start the work */
+	set_bus_info(bus, &bus->work.bus_info);
+	init_waitqueue_head(&bus->work.wait);
+	init_waitqueue_head(&bus->one_shot_wait);
+	init_completion(&bus->work.stopped);
+	r = hpr_pab_start_group_work(&bus->work);
+	pr_debug("%s: group_work started for bus=%d, r=%d\n", __func__, bus->id, r);
+	if (r) {
+		pr_err("%s: failed to start group work on bus=%d\n", __func__, bus->id);
+		clear_bus_flags(bus, HPR_BF_GROUP_WORK | HPR_BF_STARTING_OPERATION, NULL);
+	} else {
+		/* started */
+		clear_bus_flags(bus, HPR_BF_STARTING_OPERATION, NULL);
+	}
+
+	return r;
+#endif
+}
+
+static void stop_one_shot_async_exchanges(hpr_bus *bus)
+{
+	hpr_module *module;
+	int i;
+
+	/* first signal to every one-shot module which is in async exchange that exchange is done 
+	 * (which can't be done in natural way since group work is finished)
+	*/
+	pr_debug("%s: bus=%d: signaling to all modules that exchange finished\n",
+			__func__, bus->id);
+	for (i = 0; i < bus->modules_count; i++) {
+		module = &bus->modules[i].module;
+		if (module->flags.pab_async_one_shot &&
+			module->flags.pab_async_is_waited) {
+			/* here it is safe to not lock module */
+			module->flags.pab_async_is_waited = 0;
+			module->flags.pab_async_enabled = 0;	/* cancel HW exchange */
+			wake_up(&module->pab_async_wait_q);	/* cancel user one-shot exchange */
+			pr_debug("%s: bus=%d, module=%d signaled\n",
+					__func__, bus->id, i + 1);
+		}
+	}
+	/* second, wait until the end of all pending one shot exchanges */
+	pr_debug("%s: bus=%d: waiting until end of the all one-shot exchanges\n",
+			__func__, bus->id);
+	wait_event(bus->one_shot_wait, !bus->op_counter.one_shot_exchange);
+	pr_debug("%s: bus=%d: one shot exchanges stopped\n", __func__, bus->id);
+}
+
+/* work_flag is either HPR_BF_GROUP_WORK or HPR_BF_SCAN
+ */
+static int stop_bus_work(hpr_bus *bus, int work_flag)
+{
+	int bus_flags;
+
+	pr_debug("%s(%d): stop work(flag): %x on bus=%d\n",
+		__func__, (int)(current->pid), work_flag, bus->id);
+	
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if ((bus_flags & work_flag) && 
+		!(bus_flags & (HPR_BF_STARTING_OPERATION | HPR_BF_ENDING_OPERATION))) {
+		bus->flags |= HPR_BF_ENDING_OPERATION;
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s(%d): bus=%d flags=0x%04X\n", 
+		__func__, (int)(current->pid), bus->id, bus_flags);
+
+	if (!(bus_flags & work_flag)) {
+		pr_debug("%s: can't stop work %x(flag) on bus=%d: it is not running\n",
+			__func__, work_flag, bus->id);
+		return 0;
+	}
+	if (bus_flags & HPR_BF_STARTING_OPERATION) {
+		pr_warning("%s(%d): can't stop work %x(flag) on bus=%d: it's now starting..\n",
+			__func__, (int)(current->pid), work_flag, bus->id);
+		return -EAGAIN; /* call stop later, after work is completely started */
+	}
+	if (bus_flags & HPR_BF_ENDING_OPERATION) {
+		pr_warning("%s(%d): can't stop work %x(flag) on bus=%d: it's already ending..\n",
+			__func__, (int)(current->pid), work_flag, bus->id);
+		return -EAGAIN; /* this err code is used in bus free procedure to wait a bit until task is stopped */
+	}
+
+#ifdef HPR_TEST_2713_1
+	if (work_flag == HPR_BF_GROUP_WORK) {
+		pr_debug("%s(%d): HPR_TEST_2713_1: go to test sleep, bus=%d...\n", 
+			__func__, (int)(current->pid), bus->id);
+		msleep(1);	/* sleep miliseconds - try diff vals starting with 1ms */
+		pr_debug("%s(%d): HPR_TEST_2713_1: "
+			"waked up from test sleep and MARK group_work as done, bus=%d\n",
+			__func__, (int)(current->pid), bus->id);
+		clear_bus_flags(bus, work_flag | HPR_BF_ENDING_OPERATION, NULL);
+		return 0;
+	}
+#endif
+
+	bus->work.work_stop = 1;
+	wake_up(&bus->work.wait);
+	pr_debug("%s(%d): work %x(flag) stop flag is set and signaled for bus=%d\n", 
+		__func__, (int)(current->pid), work_flag, bus->id);
+
+	wait_for_completion(&bus->work.stopped);
+	pr_debug("%s(%d): work %x(flag) stopped, bus=%d\n", 
+		__func__, (int)(current->pid), work_flag, bus->id);
+
+	if (work_flag == HPR_BF_GROUP_WORK) {
+		stop_one_shot_async_exchanges(bus);
+	}
+	
+	clear_bus_flags(bus, work_flag | HPR_BF_ENDING_OPERATION, NULL);
+
+	return 0;
+}
+
+static int stop_group_work(hpr_bus * bus)
+{
+	return stop_bus_work(bus, HPR_BF_GROUP_WORK);
+}
+
+int hpr_stop_group_work(int bus_index)
+{
+	hpr_bus *bus;
+	int r;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+	
+	return stop_group_work(bus);
+}
+
+/* result codes used to be returned:
+ * SSB_NOW_SCANING | SSB_NOW_GROUPWORKS | SSB_BUS_ERROR | SSB_RUNS_OK
+ */
+int hpr_start_scan_bus_work(int bus_index)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_GROUP_WORK | 
+			HPR_BF_SCAN | HPR_BF_QUICK_OPERATION_MASK))) {
+		bus->flags |= (HPR_BF_SCAN | HPR_BF_STARTING_OPERATION);
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_GROUP_WORK | 
+			HPR_BF_SCAN | HPR_BF_QUICK_OPERATION_MASK)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't start scan on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't start scan on the bus=%d: scanning is in progress or already starting\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_GROUP_WORK) {
+			pr_err("%s: can't start scan on the bus=%d: group work is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_QUICK_OPERATION_MASK) {
+			pr_err("%s: can't start scan on the bus=%d: some operation is in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+	
+
+	/* clean bus modules:
+	 * NOTE: all access to modules SHOULD set one of HPR_BF_QUICK_OPERATION_MASK flags,
+	 * so this code won't be able to destroy modules info while it's being accessed. 
+	 * If none of the mentioned flags is set we surely CAN destroy modules info.
+	 */
+	init_modules(bus);
+	
+	/* start the work */
+	set_bus_info(bus, &bus->work.bus_info);
+	init_waitqueue_head(&bus->work.wait);
+	init_completion(&bus->work.stopped);
+	r = hpr_scan_start_work(&bus->work);
+	pr_debug("%s: scan work started for bus=%d, r=%d\n", __func__, bus->id, r);
+	if (r) {
+		pr_err("%s: failed to start scan work on bus=%d\n", __func__, bus->id);
+		clear_bus_flags(bus, HPR_BF_SCAN | HPR_BF_STARTING_OPERATION, NULL);
+	} else {
+		/* started: SCAN flag is set, STARTING removed */
+		clear_bus_flags(bus, HPR_BF_STARTING_OPERATION, NULL);
+	}
+
+	return r;
+}
+
+/* result code used to be STSB_OK */
+static int stop_scan_bus_work(hpr_bus *bus)
+{
+	return stop_bus_work(bus, HPR_BF_SCAN);
+}
+
+int hpr_stop_scan_bus_work(int bus_index)
+{
+	hpr_bus *bus;
+	int r;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+	
+	return stop_scan_bus_work(bus);
+}
+
+/*r < 0 - error, r == 0 - scan is in progress, 1 - scan is not in progress */
+int hpr_get_scan_bus_status(int bus_index)
+{
+	int r;
+	hpr_bus *bus;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	return (bus->flags & HPR_BF_SCAN) ? SBC_IN_PROGRESS : SBC_OK;
+}
+
+/* in_scan - flag that says the function is called after scanning but still in scan state */
+static int get_module_params(int bus_index, int module_address, 
+							hpr_param_arg *param, int in_scan)
+{
+	int r, i;
+	hpr_bus *bus;
+	int bus_flags;
+	int check_flags;
+	hpr_frame out_frame, in_frame;
+	hpr_param_frame_info info;
+	hpr_module_info *mi;
+	unsigned short param_address;
+	int count;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+
+	if (!in_scan) {
+		check_flags = gwp ? 0 : HPR_BF_GROUP_WORK;
+		
+		spin_lock(&bus->lock);
+		bus_flags = bus->flags;
+		if (!(bus_flags & (check_flags | HPR_BF_SHUTDOWN | HPR_BF_SCAN))) {
+			bus->flags |= HPR_BF_READ_MODULE_PARAM;
+			bus->op_counter.read_module_param++;
+		}
+		spin_unlock(&bus->lock);
+		pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+		if (bus_flags & (check_flags | HPR_BF_SHUTDOWN | HPR_BF_SCAN)) {
+			if (bus_flags & HPR_BF_SHUTDOWN) {
+				pr_err("%s: can't get param on the bus=%d: shut down is in progress\n",
+					__func__, bus->id);
+			} else if (bus_flags & HPR_BF_SCAN) {
+				pr_err("%s: can't get param on the bus=%d: scanning is already in progress\n",
+					__func__, bus->id);
+			} else if (bus_flags & (check_flags & HPR_BF_GROUP_WORK)) {
+				pr_err("%s: can't get param on the bus=%d: group work is in progress\n",
+					__func__, bus->id);
+			}
+			return -EPERM;
+		}
+		
+		if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+			pr_err("%s: invalid module addr=%d, bus=%d\n", 
+				__func__, module_address, bus->id);
+			r = -EINVAL;
+			goto get_module_param_exit;
+		}
+	}/* !in_scan */
+	
+	mi = &bus->modules[module_address - 1];
+	param_address = param->address;
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+	if (param->type == HPR_PT_INT) {	/* fix addressing for int params only */
+		pr_debug("%s: param_byte_addressing=%d\n", 
+			__func__, mi->module.flags.param_byte_addressing);
+		if (mi->module.flags.param_byte_addressing) {
+			param_address *= 2;
+		}
+	}
+#endif
+
+	create_rx_module_param_frame(module_address, param->count, 
+					param_address, &out_frame);
+
+//TODO: think of atomic loop using hpr_exchange_start().. hpr_exchange_iteration()...hpr_exchange_done()
+
+	/* a PV answer can be got for a set param request
+	 * handle a pssible case
+	 * req.param -> ack - OK, else (ProcessValue) - process PAB, repeat req.param (a number of times)
+	 */
+	count = HPR_RETRY_COUNT;
+	do {
+		param->ack = 0;
+		r = hpr_send_receive(bus->id, &out_frame, &in_frame);
+		if (r) {
+			/* all retries are done, so this is it */
+			pr_err("%s: param getting failed: r=%d, module=%d, bus=%d\n", 
+				__func__, r, module_address, bus->id);
+			break;
+		}
+
+		r = hpr_parse_module_params(&in_frame, &info);
+		if (r) {
+			if (r == -EBADMSG) {
+				if (info.function == HPR_FC_PAB_COM) {
+					/* handle PV */
+					pr_debug("%s: PV received ? for param get request: module=%d, bus=%d\n",
+						__func__, module_address, bus->id);
+
+					//TODO: test the case
+					down(&mi->lock);
+					/* here result is just for debugging */
+					r = parse_rx_pab_frame(&mi->module, &in_frame);
+					up(&mi->lock);
+					pr_debug("%s: parse_rx_pab_frame result=%d, module=%d, bus=%d "
+						"(attempts left=%d)\n",
+						__func__, r, module_address, bus->id, count - 1);
+				} else {
+					pr_debug("%s: wrong message got as an answer, try again..\n", __func__);
+				}
+				continue;
+			}
+
+			/* else (EINVAL):
+			 * It would be correct to break here and do not try again: we have the case when
+			 * either we formed bad request or module formed bad answer.
+			 * If we repeat request we'will get the same answer for sure.
+			 *
+			 * But try one request more in case uglies who answers to the previous request (like DO8):
+			 * ./hpr_test getparams  3 50 2 -- error
+			 * ./hpr_test getparams  3 5 2  - should get correct answer from the second attempt
+			 *
+			 * Return the error.
+			 */
+			param->ack = info.error;
+			pr_debug("%s: bus=%d, module=%d: return error in ACK=%d\n", 
+				__func__, bus->id, module_address, param->ack);
+
+			//TODO: think of this case more...
+//			if (--count) {
+//				count = 2;	/* reset count so just one more repetition is possible */
+				continue;
+//			}
+//			break;
+		} else {
+			if (unlikely(module_address != info.module_address ||
+				param_address != info.start_address ||
+				param->count !=  info.param_count)) {
+				pr_warning("%s: invalid answer for the param request got "
+					"(attempts left=%d), module=%d, bus=%d\n", 
+					__func__, count - 1, module_address, bus->id);
+				r = -EBADMSG;	/* try again instead of break with error, if no attempts left, then return the error */
+				continue;
+			}
+
+			pr_debug("%s: bus=%d, module=%d: params got OK\n", 
+				__func__, bus->id, module_address);
+
+			/* extract param values */
+			if (param->type == HPR_PT_INT) {
+				for (i = 0; i < param->count; i++) {
+					param->values.s[i] = ((short*)info.params)[i];
+				}
+			} else { /* FLOAT 'cause only these two types are passed to the function from IOCTL handler */
+				for (i = 0; i < param->count; i++) {
+					param->values.f[i] = ((float*)info.params)[i];
+				}
+			}
+
+			/* r=0 - success */
+			break;
+		}
+	} while (--count > 0);
+
+get_module_param_exit:
+	if (!in_scan) {
+		clear_bus_flags(bus, HPR_BF_READ_MODULE_PARAM, 
+					&bus->op_counter.read_module_param);
+	}
+	return r;
+}
+
+int hpr_get_module_params(int bus_index, int module_address, 
+							hpr_param_arg *param)
+{
+	return get_module_params(bus_index, module_address, param, 0);
+}
+EXPORT_SYMBOL(hpr_get_module_params);
+
+int hpr_get_module_params_in_scan(int bus_index, int module_address, 
+							hpr_param_arg *param)
+{
+	return get_module_params(bus_index, module_address, param, 1);
+}
+
+static void update_module_data(hpr_module_info *mi, hpr_param_arg *param)
+{
+	int end_address;
+
+	end_address = param->address + param->count - 1;
+
+	if (param->address < 7 || end_address > 10) {
+		pr_warning("%s: only values of parameters 7,8,9,10 will be updated in module data\n", 
+			__func__);
+	}
+
+	/* check if updated params are from 7, 8, 9, 10 (addr 14 - 20) */
+	if (param->address <= 10 && end_address >= 7) {
+		int src_index, dst_index;
+		unsigned short *src, *dst;
+		int diff_count, update_count;
+		int i;
+		
+		if (param->address < 7) {
+			diff_count = 7 - param->address;
+			src_index = diff_count;
+			update_count = param->count - diff_count;
+			if (update_count > 4) {
+				update_count = 4;	/* update max 4 params */
+			}
+			dst_index = 1 + 7;
+		} else {
+			diff_count = param->address - 7;
+			src_index = 0;
+			update_count = 4 - diff_count; /* update max 4 params */
+			if (update_count > param->count) { /* but not more than provided */
+				update_count = param->count;
+			}
+			dst_index = 1 + 7 + diff_count;
+		}
+		src = &((unsigned short*)param->values.s)[src_index];
+		dst = &((unsigned short*)mi->module.params.data)[dst_index];
+
+		/* user may get old or new scandata but never half-updated */
+		down(&mi->lock);
+		for (i = 0; i < update_count; i++) {
+			pr_debug("%s: update: p%d := v[%d]: 0x%x ==> 0x%x\n",
+				__func__, dst_index + i - 1, src_index + i, dst[i], src[i]);
+			
+			dst[i] = src[i];
+			
+			/* #2493 suggestions are implemented, but may be removed later according to the comment 1 */
+			if (dst_index + i - 1 == 7) {	/* in_used */
+				if (mi->module.type == HPR_MT_DI_1_SHORT || 
+					mi->module.type == HPR_MT_DIDO_1_SHORT) {
+					if (dst[i]) {	/* vals 1 or 2 become 1, 0 - left 0 */
+						dst[i] = 1;
+					}
+				}
+			}
+			if (dst_index + i - 1 == 8) {	/* out_used */
+				if (mi->module.type == HPR_MT_DO_1_SHORT || 
+					mi->module.type == HPR_MT_DIDO_1_SHORT) {
+					if (dst[i]) {	/* vals 1 or 2 become 1, 0 - left 0 */
+						dst[i] = 1;
+					}
+				}
+			}
+			/* #2493 end */
+		}
+		if (param->address <= 8 && end_address >= 8) {
+			mi->module.tx_channel = 0; /* reset current transmitted pab index */
+		}
+		check_module_used_pab_config(&mi->module);
+		up(&mi->lock);
+	}
+}
+
+static void check_module_used_pab_config(hpr_module *module)
+{
+	int correct = 1;
+	
+	switch (module->type) {
+		/* O-modules */
+		case HPR_MT_DO_1_BYTE:
+		case HPR_MT_DO_1_SHORT:
+		case HPR_MT_AO_X_SHORT:
+		case HPR_MT_AO_X_FLOAT:
+			if (!module->params.member.pab_out_used) {
+				correct = 0;
+			}
+			break;
+			
+		/* I-modules */
+		case HPR_MT_DI_1_BYTE:
+		case HPR_MT_DI_1_SHORT:
+		case HPR_MT_AI_X_SHORT:
+		case HPR_MT_AI_X_FLOAT:
+		case HPR_MT_AI_HART_X:
+			if (!module->params.member.pab_in_used) {
+				correct = 0;
+			}
+			break;
+
+		/* IO-modules */
+		case HPR_MT_DIDO_1_BYTE:
+		case HPR_MT_DIDO_1_SHORT:
+		case HPR_MT_AIAO_X_SHORT:
+		case HPR_MT_AIAO_X_FLOAT:
+		case HPR_MT_DMS_X_SHORT:
+		case HPR_MT_DMS_X_FLOAT:
+		case HPR_MT_COMPLEX_X_SHORT:
+		case HPR_MT_COMPLEX_X_FLOAT:
+		case HPR_MT_IO16B_1:
+			if (!module->params.member.pab_in_used ||
+				!module->params.member.pab_out_used) {
+				correct = 0;
+			}
+			break;
+			
+		default:
+			correct = 0;
+			break;
+	}
+	module->flags.used_pab_config_correct = correct;
+	pr_debug("%s: bus=%d, module=%d, used_pab_config_correct=%d\n",
+			__func__, module->bus_id, 
+			module->params.member.module_address, 
+			module->flags.used_pab_config_correct);
+}
+
+int hpr_set_module_params(int bus_index, int module_address, 
+				hpr_param_arg *param)
+{
+	int r;
+	hpr_bus *bus;
+	int bus_flags;
+	hpr_frame out_frame, in_frame;
+	hpr_param_frame_info info;
+	hpr_module_info *mi;
+	unsigned short param_address;
+	int count;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return r;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+	spin_lock(&bus->lock);
+	bus_flags = bus->flags;
+	if (!(bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN))) {
+		if (!(bus_flags & HPR_BF_GROUP_WORK) || (gwp && (param->address > 10))) {
+			bus->flags |= HPR_BF_WRITE_MODULE_PARAM;
+			bus->op_counter.write_module_param++;
+		}
+	}
+	spin_unlock(&bus->lock);
+	pr_debug("%s: bus=%d flags=0x%04X\n", __func__, bus->id, bus_flags);
+
+	if (bus_flags & (HPR_BF_SHUTDOWN | HPR_BF_SCAN)) {
+		if (bus_flags & HPR_BF_SHUTDOWN) {
+			pr_err("%s: can't set param on the bus=%d: shut down is in progress\n",
+				__func__, bus->id);
+		} else if (bus_flags & HPR_BF_SCAN) {
+			pr_err("%s: can't set param on the bus=%d: scanning is already in progress\n",
+				__func__, bus->id);
+		}
+		return -EPERM;
+	}
+	if ((bus_flags & HPR_BF_GROUP_WORK) && (!gwp || !(param->address > 10))) {
+		pr_err("%s: can't set param%s on the bus=%d while group work is in progress\n",
+			__func__, gwp ? " (addr:0-10)" : "", bus->id);
+		return -EPERM;
+	}
+	
+	if (unlikely(module_address < 1 || module_address > bus->modules_count)) {
+		pr_err("%s: invalid module=%d, bus=%d\n", 
+			__func__, module_address, bus->id);
+		r = -EINVAL;
+		goto set_module_param_exit;
+	}
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+	if (!paddr_any) {
+#endif
+		/* normally, params 7, 8, 9, 10,...19.... are writable */
+		if (param->address >= 0 && param->address < 7) {
+			pr_err("%s: param address %u is read-only\n",
+				__func__, param->address);
+			r = -EPERM;
+			goto set_module_param_exit;
+		}
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+	}
+#endif
+
+	mi = &bus->modules[module_address - 1];
+	param_address = param->address;
+
+	/* simultaneous writes are prohibited for the same module in order 
+	 * to ensure that updated scandata reflects the actual module configuration
+	 */
+	down(&mi->lock);
+	if (mi->module.flags.param_write_in_progress) {
+		up(&mi->lock);
+		pr_err("%s: param write for module=%d, bus=%d is in progress\n",
+			__func__, module_address, bus->id);
+		r = -EAGAIN;
+		goto set_module_param_exit;
+	}
+	mi->module.flags.param_write_in_progress = 1;
+	up(&mi->lock);
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+	if (param->type == HPR_PT_INT) {	/* fix addressing for int params only */
+		pr_debug("%s: param_byte_addressing=%d\n", 
+			__func__, mi->module.flags.param_byte_addressing);
+		if (mi->module.flags.param_byte_addressing) {
+			param_address *= 2;
+		}
+	}
+#endif
+
+	create_tx_module_param_frame(module_address, param->type, param->count, 
+					param_address, (char*)(param->values.s), &out_frame);
+
+//TODO: think of atomic loop using hpr_exchange_start().. hpr_exchange_iteration()...hpr_exchange_done()
+
+	/* a PV answer can be got for a set param request
+	 * handle a pssible case
+	 * req.param -> ack - OK, else (ProcessValue) - process PAB, repeat req.param (a number of times)
+	 */
+	count = HPR_RETRY_COUNT;
+	do {
+		param->ack = 0;
+		
+		/* change params 
+		 * NOTE: NO locking: for now only user is responsible for stopping any activity using the
+		 *                             changed parameters
+		 */
+		r = hpr_send_receive(bus->id, &out_frame, &in_frame);
+		if (r) {
+			/* all retries are done, so this is it */
+			pr_err("%s: param setting failed: ACK r=%d, module=%d, bus=%d\n", 
+				__func__, r, module_address, bus->id);
+			break;
+		}
+
+		r = hpr_parse_module_param_ack(&in_frame, &info);
+		if (r) {
+			if (r == -EBADMSG) {
+				if (info.function == HPR_FC_PAB_COM) {
+					/* handle PV */
+					pr_debug("%s: PV received ? for param set request: module=%d, bus=%d\n",
+						__func__, module_address, bus->id);
+
+					//TODO: test the case
+					down(&mi->lock);
+					/* here result is just for debugging */
+					r = parse_rx_pab_frame(&mi->module, &in_frame);
+					up(&mi->lock);
+					pr_debug("%s: parse_rx_pab_frame result=%d, module=%d, bus=%d "
+						"(attempts left=%d)\n",
+						__func__, r, module_address, bus->id, count - 1);
+				} else {
+					pr_debug("%s: wrong message got as an answer, try again..\n", __func__);
+				}
+				continue;
+			}
+
+			/* else (EINVAL) - see comments for _get_params 
+			 *
+			 * NOTE: wrong correct answer may still be accepted!
+			 * ./hpr_test setparams  3 20 2
+			 * ->OK
+			 * ./hpr_test setparams  3 48 2
+			 * ->OK (incorrect, it's just answer for previous correct param setting)
+			 */
+			param->ack = info.error;
+			pr_debug("%s: bus=%d, module=%d: return error in ACK=%d\n", 
+				__func__, bus->id, module_address, param->ack);
+
+			//TODO: think of this case more...
+//			if (--count) {
+//				count = 2;	/* reset count so just one more repetition is possible */
+				continue;
+//			}
+//			break;
+		} else {
+			if (info.module_address != module_address) {
+				pr_warning("%s: param writing error: bad address in response=%d "
+					"(attempts left=%d), expected=%d, bus=%d\n",
+					__func__, info.module_address, count - 1, 
+					module_address, bus->id);
+				r = -EBADMSG;		/* try again instead of break with error, if no attempts left, then return the error */
+				continue;
+			}
+
+			pr_debug("%s: bus=%d, module=%d: set params acknowledged OK\n", 
+				__func__, bus->id, module_address);
+			
+			/* assume setting of params was successful - adjust module data as need */
+			update_module_data(mi, param);
+
+			if (mi->module.serial_port_data) {
+				hpr_serial_update_port_config(mi->module.serial_port_data, param);
+			}
+			/* ret 0 - success */
+			break;
+		}
+	} while (--count > 0);
+
+	down(&mi->lock);
+	mi->module.flags.param_write_in_progress = 0;
+	up(&mi->lock);
+	
+set_module_param_exit:
+	clear_bus_flags(bus, HPR_BF_WRITE_MODULE_PARAM, 
+				&bus->op_counter.write_module_param);
+	return r;
+}
+EXPORT_SYMBOL(hpr_set_module_params);
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_bus.h linux-3.0.x-arm/drivers/misc/hpr/hpr_bus.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_bus.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_bus.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,285 @@
+#ifndef _HPR_BUS_H
+#define _HPR_BUS_H
+
+#include <linux/semaphore.h>
+#include <linux/timer.h>
+
+#include <linux/hpr/hpr_serial.h>
+#include <linux/hpr/hpr.h>
+#include "hpr_errno.h"
+
+#define HPR_MAX_BUS_COUNT	3
+#define HPR_MAX_MODULE_ADDRESS	62
+
+// definitions for parametric command
+#define PK_BLOCK_SCHREIBEN	0x00
+#define PK_BLOCK_LESEN		0x01
+#define PK_RESET_TO_DEFAULT	0x02
+#define PK_DIREKT_SCHREIBEN	0x80
+#define PK_DIREKT_LESEN		0x81
+
+/* retry counts */
+#define HPR_RETRY_COUNT		3
+/* count of request repetitions if timeout occurs */
+#define HPR_RETRY_COUNT_TO	3
+/* count of request repetitions if other RX error occurs */
+#define HPR_RETRY_COUNT_RX	10
+
+// definitions of code functions in byte FC/Address HPR Bus
+#define HPR_FC_PARAM_COM		0x00
+#define HPR_FC_PAB_COM		0x40
+#define HPR_FC_BRODCAST_SINGLE_COM	0x80		// Broadcast message to one module
+
+#define FC_BRODCAST		0xFF
+#define ADDRESS_MASK		0x3F
+#define FUNCTION_MASK		0xC0
+
+#define BCK_START		0x00	// All OK -> Start
+#define BCK_START_SCAN		0x01	// zapusk skanirovanija
+#define BCK_FREEZE		0x02	// Zamorozit vihodi
+#define BCK_SAVE_STATE		0x03	// Postavit vihodi v bezopasnoe sostojanie
+#define BCK_OPEN_RELAIS		0x10	// Otkrit rele
+#define BCK_CLOSE_RELAIS	0x40	// Zakrit rele
+//#define BCK_  		0x03-0xFF	// net spetsifikatsij
+
+#define QB_ERROR_MASK		0xC0
+#define QB_BYTECOUNT_MASK	0x07
+
+// definitions for access to parameters
+#define HPR_PA_FLOAT	0x4000	// address from which the data are in the format of Float (4 byte access)
+#define HPR_PA_TEXT1	0x0168	// (360) address from which are text data. data can't be turn
+#define HPR_PC_TEXT1	20	// amount of text data Block 1
+#define HPR_PA_TEXT2	0x0384	// (900) address from which are text data. data can't be turn
+#define HPR_PC_TEXT2	20	// amount of text data Block 2
+#define HPR_PA_FU_MSG	0x1FFF	// address of FU-message. data can't be turn
+
+// definitions for Module_type Parameter 6
+#define HPR_STANDARD_MODULE	0
+#define HPR_COMPLEX_MODULE	1
+#define HPR_DMS_MODULE		2
+#define HPR_IO16B_MODULE		3
+#define HPR_AI_HART_MODULE	4
+
+#define HPR_PDF_MASK		0x00C0
+#define HPR_PDF_BYTE		0x0000
+#define HPR_PDF_SHORT		0x0040
+#define HPR_PDF_FLOAT		0x0080
+#define HPR_PDF_ARRAY		0x00C0
+
+enum {
+	SBC_IN_PROGRESS = 0,
+	SBC_OK = 1,	// skanirovanie shini ostanovleno
+	SBC_ERROR = 2,	// oshibka skanirovanija
+};
+
+/*
+ * The naming is following: prefix_type(param6)_max-channels_data-format
+ */
+typedef enum {
+	HPR_MT_UNKNOWN = 0,
+	HPR_MT_DO_1_BYTE,
+	HPR_MT_DO_1_SHORT,
+	HPR_MT_DI_1_BYTE,
+	HPR_MT_DI_1_SHORT,
+	HPR_MT_DIDO_1_BYTE,
+	HPR_MT_DIDO_1_SHORT,
+
+	HPR_MT_AO_X_SHORT,
+	HPR_MT_AO_X_FLOAT,
+	HPR_MT_AI_X_SHORT,
+	HPR_MT_AI_X_FLOAT,
+	HPR_MT_AIAO_X_SHORT,
+	HPR_MT_AIAO_X_FLOAT,
+
+	HPR_MT_DMS_X_SHORT,
+	HPR_MT_DMS_X_FLOAT,
+
+	HPR_MT_COMPLEX_X_SHORT,
+	HPR_MT_COMPLEX_X_FLOAT,
+
+	HPR_MT_IO16B_1,	/* data format(s) is unclear from the specification */
+
+	HPR_MT_AI_HART_X,	/* data format(s) is unclear form the specification */
+
+	HPR_MT_INVALID,	/* use to check type < HPR_MT_INVALID */
+} hpr_module_type;
+
+/* 
+ * module_type, module_status, and 
+ * other properties in the same order as they appear in module params
+ */
+typedef struct {
+	hpr_module_type module_type;
+	hpr_module_status module_status;	/* the most recent status value */
+
+	unsigned short hardware_id;
+	unsigned short change_status;
+	unsigned char inputs_count_max;		/* max number of input channels/pabs? */
+	unsigned char outputs_count_max;	/* max number of output channels/pabs? */
+	unsigned short params_count;		/* общее количество параметров (включая пропуски между параметрами)*/
+	/* skip module type param */
+	unsigned char inputs_count;		/* количество input channels/pabs used */
+	unsigned char outputs_count;		/* количество output channels/pabs used */
+	unsigned short function_id;
+	unsigned short group_params;
+} hpr_module_data;
+
+typedef struct hpr_module_params_set {
+	unsigned short crc;
+	unsigned short module_address;	// Parameter 0
+	unsigned short hardware_id;	// Parameter 1
+	unsigned short change_status;	// Parameter 2
+	unsigned short pab_in_max;	// Parameter 3
+	unsigned short pab_out_max;	// Parameter 4
+	unsigned short params_count;	// Parameter 5
+	unsigned short module_type;	// Parameter 6
+	unsigned short pab_in_used;	// Parameter 7    ab hier R/W-Parameter  (??????? ?????? ????????? ???? R/W)
+	unsigned short pab_out_used;	// Parameter 8
+	unsigned short function_id;		// Parameter 9
+	unsigned short group_params;	// Parameter 10
+	unsigned short reserved[9];	// Parameter 11 -19
+} hpr_module_params_set;
+
+typedef union hpr_module_params {
+	char data[sizeof(hpr_module_params_set)];
+	hpr_module_params_set member;
+} hpr_module_params;
+
+typedef struct hpr_module {
+	int bus_id;			/* id of the bus the module connected to - is used for debug only */
+
+//	unsigned char		Action;
+	hpr_module_status status;		/* module status received during PV exchange (PAB) */
+	hpr_module_type type;			// module type
+	int last_pvc_rc;				/* last PV communication result code (IO exchange + frame parsing result) */
+
+	unsigned char		rx_channel;		// kakoj kanal bil priniat
+	unsigned char		tx_channel;		// kakoj kanal bil peredan
+//	unsigned char		Para_received;		// priniati li novie parametralnie dannie
+//	unsigned char		Para_Channel_active;	// parametralnaja kommutikatsija aktivna
+//	unsigned char		Para_Channel_owner;	// vladelets parametralnoj kommunikatsii
+//	unsigned char		Para_Local_Update;	// parametralnie kommunikatsii s modulem iz-za flaga
+
+//	unsigned short	error_count;		// S4et4il dlia neotve4ennih soobwenij
+//	unsigned short	status;			// status dlia modula na shine
+//	unsigned short	OldStatus;		// Merker dlia statusa modulia, kotorij uge peredan v polevuju shinu
+//	unsigned short	Para_Channel_timeout;	// dlia nadzora za parametralnoj kommunikatsiej
+//	unsigned short	PAB_OUT_Startpos;	// Na4alnaja pozitsija vihodov PAB
+//	unsigned short	PAB_IN_Startpos;	// Na4alnaja pozitsija vhodov PAB
+
+	hpr_module_params params;
+//	UNION_MODULE_PARA	Newpara;
+//	UNION_MODULE_PARA	Profipara;
+
+	wait_queue_head_t pab_async_wait_q;		/* wait aysnc exchange completion (while pab_async_is_waited==1) */
+	struct {
+		/* module configuration flags set after scan, or after param setting */
+		
+		unsigned pab_config_correct: 1;		/* set if PAB holders can't be configured for the module e.g. due to wrong params or lack of resources */
+		unsigned used_pab_config_correct: 1;	/* set if 'used PAB' configuration is correct */
+		/* 
+		 * - at start pab_async_enabled:=0, so HW exchange is disabled and user exchange enabled
+		 *  -user performs exchange with driver - pab_async_enabled:=1, wait for HW exchange..
+		 *  -any further parallel user exchange fails due to pab_async_enabled==1 (enabled HW, disabled user)
+		 *  -exchange to HW takes place (GW) and so pab_async_enabled:=0 (disabled HW, enabled user), signaled to waiting function..
+		 *  -any further attempt to exchange with HW refused due to pab_async_enabled==0
+		 *  -exchange with user waked up, answer returned to the user
+		 * - new exchange with user takes place due to pab_async_enabled==0 
+		 *       new data from user are accepted, pab_async_enabled:=1 (enabled HW, disabled user), start waiting for HW exchange..
+		 *  -and so on...
+		 *
+		 * needs no locking because it doesn't depend on actions on the bus, except SCAN
+		 */
+		unsigned pab_async_one_shot: 1;			/* async one shot mode (logic and interface); sync exchange not permitted at all */
+		unsigned pab_one_shot_in_progress: 1;	/* prevent simultaneous one-shot requests for a module */
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+		unsigned param_byte_addressing: 1;	/* whether params addressed by byte instead of param index */
+#endif
+
+		/* flags for mutual exclusion of async and sync PAB exchange and writing params */
+
+		/* whether or not the module participates in the group pab exchange (async pab exchange).
+		 * - when rdquery is called successfully for a module, the flag is set.
+		 * Note: for IN-modules user should call rdquery too (with NULL out data)
+		 * - when sync pab exchange is requested the flag is reset
+		 * TODO: May it be useful to have a method to exclude a modue from group work 
+		 *            without requesting for a sync exchage?
+		 */
+		unsigned pab_async_enabled: 1;		/* the module participate in async pab exchange */
+		unsigned pab_async_in_progress: 1;	/* async pab exchange for module is in progress - sync exchange request should wait */
+		unsigned pab_async_is_waited: 1;		/* somebody waits while async exchange with module finishes */
+		unsigned pab_sync_in_progress: 1;	/* sync pab exchange is in progress: simultaneous sync exchange or param setting is not allowed */
+
+		unsigned param_write_in_progress: 1; /* simultaneous param modifications for the same module are not allowed */
+	} flags;
+
+	hpr_pab *pab_in;		/* reference to the first of the module's inputs in the bus common array */
+	hpr_pab *pab_out;	/* reference to the first of the module's outputs in the bus common array */
+
+	struct hpr_serial_port_data *serial_port_data;	/* for hpr serial modules: reference to the port's data (ptr may be changed only during scan)  */
+} hpr_module;
+
+typedef struct hpr_ioctl_arg {
+	int bus_index;	/* addresses buses by their index in bus_ids list */
+
+	int module_address;	/* address of a module to send request to */
+	union {
+		hpr_module_data *module_data;
+		hpr_pv_query *pv_query;
+		hpr_param_arg param;
+	} u;
+} hpr_ioctl_arg;
+
+typedef struct hpr_bus_info {
+	int bus_id;		/* id of the bus */
+	int bus_index;		/* index of the bus - to speed up internal calls (always assumed to be correct) */
+	int modules_count;	/* count of modules on the bus after scan completed */
+} hpr_bus_info;
+
+/* either scan or poll work */
+typedef struct hpr_bus_work {
+	hpr_bus_info bus_info;
+
+	struct workqueue_struct *work_q;
+	struct work_struct work;
+	int work_stop;				/* set the flag to 1 to stop the work function */
+	wait_queue_head_t wait;			/* use this 'wait' with work_stop to delay work execution(next exchange) which may be stopped */
+	struct timer_list sync_timer;		/* to provide poll period instead of poll delay */
+	int sync;						/* flag to show that sync timer fired */
+
+	struct completion stopped;		/* wait the work completion using this */
+} hpr_bus_work;
+
+#define to_hpr_bus_work(pwork) container_of(pwork, hpr_bus_work, work)
+
+/* init/uninit interface */
+extern int hpr_init_bus_data(int bus_count, int bus_ids[], int nr_modules, 
+				int nr_inputs, int nr_outputs);
+extern void hpr_free_bus_data(void);
+
+/* interface for scan, group work operations */
+extern void hpr_get_module(int bus_index, int module_index, hpr_module **module);
+extern void hpr_put_module(hpr_module *module);
+extern int hpr_add_module(int bus_index, hpr_module *new_module);
+extern int hpr_notify_bus_scan_completed(int bus_index);
+
+/* interface for IOCTL calls */
+extern int hpr_get_bus_count(void);
+extern int hpr_get_module_count(int bus_index);
+extern int hpr_get_module_data(int bus_index, int module_address, 
+				hpr_module_data *data);
+extern int hpr_user_pab_data_exchange(int bus_index, int module_address, 
+					hpr_pv_query *pv_query);
+extern int hpr_sync_pab_data_exchange(int bus_index, int module_address, 
+					hpr_pv_query *pv_query);
+extern int hpr_start_group_work(int bus_index);
+extern int hpr_stop_group_work(int bus_index);
+extern int hpr_start_scan_bus_work(int bus_index);
+extern int hpr_stop_scan_bus_work(int bus_index);
+extern int hpr_get_scan_bus_status(int bus_index);
+
+extern int hpr_get_module_params_in_scan(int bus_index, int module_address, 
+							hpr_param_arg *param);
+
+#endif /*_HPR_BUS_H*/
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_bus_pvt.h linux-3.0.x-arm/drivers/misc/hpr/hpr_bus_pvt.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_bus_pvt.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_bus_pvt.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,69 @@
+#ifndef _HPR_BUS_PVT_H_
+#define _HPR_BUS_PVT_H_
+
+/* acessed from hpr_bus and hpr_serial */
+
+typedef struct hpr_module_info {
+	struct semaphore lock;	//TODO: think of changing it for spinlock???
+	//spinlock_t lock;
+
+	hpr_module module;
+} hpr_module_info;
+
+#define module_to_info(pmodule) container_of(pmodule, hpr_module_info, module)
+
+/* set to signal that no works can run */
+#define HPR_BF_SHUTDOWN			0x0001
+/* scan bus is in progress */
+#define HPR_BF_SCAN			0x0002
+/* group work is in progress on the bus */
+#define HPR_BF_GROUP_WORK		0x0004
+
+/* starting of a work (scan or poll) - protect 'start' from simultaneous ending */
+#define HPR_BF_STARTING_OPERATION	0x1000
+/* ending of a work (scan or poll) - protect 'end' from simultaneous ending */
+#define HPR_BF_ENDING_OPERATION	0x2000
+
+/* some quick operations which should not occur when scanning but can be simultaneous */
+#define HPR_BF_QUICK_OPERATION_MASK	0x0FF0
+
+#define HPR_BF_USER_PAB_EXCHANGE		0x0010
+#define HPR_BF_GET_MODULE_DATA		0x0020
+#define HPR_BF_READ_MODULE_PARAM		0x0040
+#define HPR_BF_WRITE_MODULE_PARAM	0x0080
+#define HPR_BF_SYNC_PAB_EXCHANGE		0x0100
+
+typedef struct {
+	int id;				/* bus id, used to access to hardware and to access to buses from user side */
+	int index;			/* bus index to speed up access to bus data in internal calls (always assumed to be correct) */
+	int scan_count;		/* =0 only once at driver start, then inrements, when overflow set to 1 and so on: used for 'once' configuration */
+
+	spinlock_t lock;		/* protects state flags and op counters */
+	int flags;			/* HPR_BF_* */
+	/* counters for operations which can be run in multiple quantity simultaneously */
+	struct {
+		int user_pab_exchange;
+		int get_module_data;
+		int read_module_param;
+		int write_module_param;
+		int sync_pab_exchange;
+		
+		int one_shot_exchange;		/* one shot exchanges on the bus */
+	} op_counter;
+
+	wait_queue_head_t one_shot_wait;	/* for waiting while all one-shot exchanges on the bus completed (counter is 0) */
+
+	hpr_bus_work work;		/* scan or poll (group work) work and exchange PABs */
+
+	int modules_count;		/* actual count of detected modules on the bus */
+	hpr_module_info *modules;		/* array of pre-allocated nr_modules hpr_module_info structures */
+	hpr_pab *pab_in;		/* array of pre-allocated nr_inputs input PAB structures for all modules on the bus */
+	int in_free_index;		/* index of the next free pab_in element in pab_in array */
+	hpr_pab *pab_out;		/* array of pre-allocated nr_outputs output PAB structures for all modules on the bus */
+	int out_free_index;		/* index of the next free pab_out element in pab_out array */
+} hpr_bus;
+
+extern int get_bus_by_index(int index, hpr_bus **bus);
+
+#endif /*_HPR_BUS_PVT_H_*/
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_crc.c linux-3.0.x-arm/drivers/misc/hpr/hpr_crc.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_crc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_crc.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,65 @@
+#include "hpr_crc.h"
+
+const unsigned char table_crc_hi[] = {
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
+	0x00, 0xC1, 0x81, 0x40
+};
+
+const unsigned char table_crc_lo[] = {
+	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
+	0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
+	0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
+	0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
+	0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
+	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
+	0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
+	0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
+	0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
+	0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
+	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
+	0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
+	0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
+	0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
+	0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
+	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
+	0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
+	0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
+	0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
+	0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
+	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
+	0x41, 0x81, 0x80, 0x40
+};
+
+unsigned char calculate_low_crc16(unsigned char *frame, unsigned short length)
+{
+	unsigned char crc_hi = 0xFF;
+	unsigned char crc_lo = 0xFF;
+	unsigned short index;
+
+	while (length--) {
+		index = crc_hi ^ *frame++;
+		crc_hi = crc_lo ^ table_crc_hi[index];
+		crc_lo = table_crc_lo[index];
+	}
+	return crc_lo;
+}
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_crc.h linux-3.0.x-arm/drivers/misc/hpr/hpr_crc.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_crc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_crc.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef _HPR_CRC_H
+#define _HPR_CRC_H
+
+extern unsigned char calculate_low_crc16(unsigned char *frame, unsigned short length);
+
+/* for receive optimization */
+extern const unsigned char table_crc_hi[];
+extern const unsigned char table_crc_lo[];
+
+#endif
\ No newline at end of file
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_errno.h linux-3.0.x-arm/drivers/misc/hpr/hpr_errno.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_errno.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_errno.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _HPR_ERRNO_H_
+#define _HPR_ERRNO_H_
+
+#define ETIMEOUT			701		/* timeout of receiving whole frame; UART RX timeout => OK or EHPRCRC */
+#define EHPRFRAME			702		/* HPR frame is bad: received length is  greater than max allowed */
+#define EUARTRX				703		/* UART RX error: ATMEL_US_ (OVRE | FRAME | PARE |RXBRK) */
+
+#define ENOASYNCEXCH		704		/* async exchange for the module is not allowed => skip the module */
+
+#define EHPRCRC				705		/* HPR frame RX error: timeout got, data got but CRC is wrong */
+
+#endif /* _HPR_ERRNO_H_ */
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_frame.c linux-3.0.x-arm/drivers/misc/hpr/hpr_frame.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_frame.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_frame.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,549 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+
+#include "hpr_bus.h"
+#include "hpr_crc.h"
+#include "hpr_frame.h"
+
+#if defined(DEBUG) || defined(CONFIG_ATMEL_HPR_DEBUG_FRAMES)
+/* +256 - for short title, bus id, length, terminating zero */
+static char hpr_frame_debug_buf[HPR_MAX_FRAME_SIZE * 3 + 256];
+void dump_frame(const char *title, int bus_id, const char *frame, int length)
+{
+	int i, size;
+
+	size = sprintf(hpr_frame_debug_buf, "%s/%d: len=%d, frame:", title, bus_id, length);
+	for (i = 0; i < length; i++) {
+		size += sprintf(&hpr_frame_debug_buf[size], " %02X", frame[i]);
+//		printk("0x%02X, ", frame[i]); /* use line like this to get output ready for crc_test tool */
+	}
+	pr_info("%s\n", hpr_frame_debug_buf);
+}
+#endif
+
+#define SWAP_BYTES	1
+//#undef SWAP_BYTES
+
+static inline unsigned short swap_short(unsigned short s)
+{
+#ifdef SWAP_BYTES
+	unsigned char b0, b1;
+	b0 = s & 0xFF;
+	b1 = (unsigned char)((s >> 8) & 0xFF);
+	return (b0 << 8) | b1;
+#else
+	return s;
+#endif
+}
+
+static inline unsigned long swap_long(unsigned long l)
+{
+#ifdef SWAP_BYTES
+	unsigned char b0, b1, b2, b3;
+	b0 = l & 0xFF;
+	b1 = (unsigned char)((l >> 8) & 0xFF);
+	b2 = (unsigned char)((l >> 16) & 0xFF);
+	b3 = (unsigned char)((l >> 24) & 0xFF);
+	return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
+#else
+	return l;
+#endif
+}
+
+void create_tx_pab_frame(hpr_module *module, hpr_frame *frame)
+{
+	unsigned char len;
+	unsigned char *data;
+	int i;
+
+	data = frame->data;
+	*data++ = (unsigned char)module->params.member.module_address | HPR_FC_PAB_COM;
+
+	switch (module->type) {
+		case HPR_MT_DO_1_BYTE:	// 0 bytes Kanalinfo, 1 bytes Data
+		case HPR_MT_DIDO_1_BYTE:	// 0 bytes Kanalinfo, 1 bytes Data
+			*data++ = module->pab_out[0].dido.pv.b;
+			break;
+		case HPR_MT_DI_1_BYTE:	// 0 bytes Kanalinfo, 0 bytes Data
+			break;
+
+		/* #2493 suggestions are implemented, but may be removed later according to the comment 1 */
+		case HPR_MT_DO_1_SHORT:	// 0 bytes Kanalinfo, 2 bytes Data
+		case HPR_MT_DIDO_1_SHORT:	// 0 bytes Kanalinfo, 2 bytes Data
+			*(unsigned short*)data = module->pab_out[0].dido.pv.w;
+			data += 2;
+			break;
+		case HPR_MT_DI_1_SHORT:
+			break;
+		/* #2493 end */
+
+		case HPR_MT_AO_X_SHORT:	// 1 byte Kanalinfo, 2 bytes Data
+		case HPR_MT_AIAO_X_SHORT:    // 1 byte Kanalinfo, 2 bytes Data
+			*data++ = module->tx_channel;
+			*(unsigned short*)data = module->pab_out[module->tx_channel].aiao.pv.w;
+			data += 2;
+			if (++module->tx_channel >= module->params.member.pab_out_used) {
+				module->tx_channel = 0;
+			}
+ 			break;
+
+		case HPR_MT_AO_X_FLOAT:    // 1 byte Kanalinfo, 4 bytes data
+		case HPR_MT_AIAO_X_FLOAT:    // 1 byte Kanalinfo, 4 bytes Data
+			*data++ = module->tx_channel;
+			*(unsigned long*)data = module->pab_out[module->tx_channel].aiao.pv.dw;
+			data += 4;
+			if (++module->tx_channel >= module->params.member.pab_out_used) {
+				module->tx_channel = 0;
+			}
+			break;
+
+		case HPR_MT_AI_X_SHORT:    // 0 bytes Kanalinfo, 0 bytes Data
+		case HPR_MT_AI_X_FLOAT:
+			break;
+
+		case HPR_MT_DMS_X_SHORT:		// 1 byte Kanalinfo, 1 byte Controlinfo
+		case HPR_MT_DMS_X_FLOAT:
+			*data++ = module->tx_channel;
+			*data++ = module->pab_out[module->tx_channel].dms.ci.b;
+			if (++module->tx_channel >= module->params.member.pab_out_used) {
+				module->tx_channel = 0;
+			}
+			break;
+
+		case HPR_MT_COMPLEX_X_SHORT:	// 1 byte Kanalinfo, 3 * 2 bytes Data (3 channels)
+		case HPR_MT_COMPLEX_X_FLOAT:	// 1 byte Kanalinfo, 3 * 4 bytes Data
+			*data++ = module->tx_channel;
+
+			/* when next channel becomes invalid, pass 0 values */
+			for (i = 0; i < 3; i++) {
+				if (module->type == HPR_MT_COMPLEX_X_SHORT) {
+					if (module->tx_channel < module->params.member.pab_out_used) {
+						*(unsigned short*)data = module->pab_out[module->tx_channel].complex.pv.w;
+					} else {
+						*(unsigned short*)data = 0;
+					}
+					data += 2;
+				} else {
+					if (module->tx_channel < module->params.member.pab_out_used) {
+						*(unsigned long*)data = module->pab_out[module->tx_channel].complex.pv.dw;
+					} else {
+						*(unsigned long*)data = 0;
+					}
+					data += 4;
+				}
+				module->tx_channel++;
+			}
+			
+			if (module->tx_channel >= module->params.member.pab_out_used) {
+				module->tx_channel = 0;
+			}
+			break;
+
+		case HPR_MT_IO16B_1:	// 0 bytes Kanalinfo, 16 bytes Data
+			memcpy(data, module->pab_out[0].io16b.pv, 16);
+			data += 16;
+			break;
+
+		case HPR_MT_AI_HART_X:	// 0 bytes Kanalinfo, 0 bytes Data
+			break;
+
+		default:
+			break;
+	}
+
+	len = data - frame->data;
+	*data = calculate_low_crc16(frame->data, len);
+	frame->length = len + 1;
+}
+
+static char in_pab_payload_length[] = {
+	[HPR_MT_UNKNOWN] = 0,
+	[HPR_MT_DO_1_BYTE] = 1,		/* 1 byte status */
+	[HPR_MT_DO_1_SHORT] = 1,	/* 1 byte status */
+	[HPR_MT_DI_1_BYTE] = 2,		/* 1 byte PV + 1 byte status */
+	[HPR_MT_DI_1_SHORT] = 3,		/* TODO: 2bytes PV? assume:yes + 1 byte status - uncler for now */
+	[HPR_MT_DIDO_1_BYTE] = 2,	/* paytload = 1 byte PV + 1 byte status */
+	[HPR_MT_DIDO_1_SHORT] = 3,	/* TODO: 2bytes PV? assume:yes + 1 byte status - uncler for now */
+
+	[HPR_MT_AO_X_SHORT] = 1,	/* 1 byte status */
+	[HPR_MT_AO_X_FLOAT] = 1,		/* 1 byte status */
+	[HPR_MT_AI_X_SHORT] = 4,		/* 1 byte channel info + 2 bytes PV + 1 byte status */
+	[HPR_MT_AI_X_FLOAT] = 6,		/* 1 byte channel info + 4 bytes PV + 1 byte status */
+	[HPR_MT_AIAO_X_SHORT] = 4,	/* 1 byte channel info + 2 bytes PV + 1 byte status */
+	[HPR_MT_AIAO_X_FLOAT] = 6,	/* 1 byte channel info + 4 bytes PV + 1 byte status */
+
+	[HPR_MT_DMS_X_SHORT] = 5,	/* 1 byte channel info + 2 bytes PV + 1 byte control info + 1 byte status */
+	[HPR_MT_DMS_X_FLOAT] = 7,	/* 1 byte channel info + 4 bytes PV + 1 byte control info + 1 byte status */
+
+	[HPR_MT_COMPLEX_X_SHORT] = 8,	/* 1 byte channel info + 3 * 2 bytes PV + 1 byte status */
+	[HPR_MT_COMPLEX_X_FLOAT] = 14,	/* 1 byte channel info + 3 * 4 bytes PV + 1 byte status */
+
+	//TODO: specification is still needed
+	[HPR_MT_IO16B_1] = 17,			/* 16 byte PV + 1 byte status */
+
+	[HPR_MT_AI_HART_X] = 10,			/* 1 byte channel info + 4 * 2 bytes PV + 1 byte status */
+};
+
+int parse_rx_pab_frame(hpr_module *module, hpr_frame *frame)
+{
+	unsigned short address;
+	int fc;
+	unsigned char *data;
+	int i;
+
+	if (unlikely(module->type == HPR_MT_UNKNOWN ||
+		module->type >= HPR_MT_INVALID)) {
+		pr_err("%s: can't parse pab frame for unknown module\n", __func__);
+		return -EINVAL;
+	}
+
+	if ((in_pab_payload_length[module->type] != 0xff) &&
+		(in_pab_payload_length[module->type] + 2 != frame->length)) {
+		pr_warning("%s: can't parse pab frame, length=%d is not as expected=%d for module type=%d\n",
+				__func__, frame->length, 
+				in_pab_payload_length[module->type] + 2, module->type);
+		return -EBADMSG;
+	}
+
+	data = frame->data;
+	fc = *data & FUNCTION_MASK;
+	address = *data++ & ADDRESS_MASK;
+	pr_debug("%s: parsing frame for module=%u: address=%d, fc=0x%02x\n", 
+			__func__, module->params.member.module_address, address, fc);
+
+	/* saving info to structures by real address */
+	if (fc != HPR_FC_PAB_COM ||
+		module->params.member.module_address != address) {
+		pr_warning("%s: fc/address in received frame: 0x%02x/%u while expected: 0x%02x/%u\n",
+			__func__, fc, address, HPR_FC_PAB_COM, module->params.member.module_address);
+		return -EBADMSG;
+	}
+
+//	module->error_count = 0;	// obnuliaem s4et4ik owibok
+
+	switch (module->type) {
+		case HPR_MT_DI_1_BYTE:	// 1 byte Data, 1 byte status
+		case HPR_MT_DIDO_1_BYTE:	// 1 byte Data, 1 byte status
+			module->pab_in[0].dido.pv.b = *data++;
+		case HPR_MT_DO_1_BYTE:	// 1 byte status
+			module->status.b = *data;
+			break;
+
+		/* #2493 suggestions are implemented, but may be removed later according to the comment 1 */
+		case HPR_MT_DI_1_SHORT:	// 1 byte Data, 1 byte status
+		case HPR_MT_DIDO_1_SHORT:	// 1 byte Data, 1 byte status
+			module->pab_in[0].dido.pv.w = *(unsigned short*)data;
+			data += 2;
+		case HPR_MT_DO_1_SHORT:	// 1 byte status
+			module->status.b = *data;
+			break;
+		/* #2493 end */
+
+		case HPR_MT_AI_X_SHORT:		// 1 byte kanalinfo, 2 byte dannih, 1 byte status
+		case HPR_MT_AIAO_X_SHORT:	// 1 byte kanalinfo, 2 bytes dannih, 1 byte status
+			module->rx_channel = *data++;
+			module->pab_in[module->rx_channel].aiao.pv.w = *(unsigned short*)data;
+			data += 2;
+		case HPR_MT_AO_X_SHORT:		// 0 byte kanalinfo, 0 byte dannih, 1 byte status
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_AI_X_FLOAT:		// 1 byte kanalinfo, 4 byte dannih, 1 byte status
+		case HPR_MT_AIAO_X_FLOAT:	// 1 byte kanalinfo, 4 bytes dannih, 1 byte status
+			module->rx_channel = *data++;
+			module->pab_in[module->rx_channel].aiao.pv.dw = *(unsigned long*)data;
+			data += 4;
+		case HPR_MT_AO_X_FLOAT:		// 0 byte kanalinfo, 0 byte dannih, 1 byte status
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_DMS_X_SHORT:		// 1 byte kanalinfo, 2 byte data, 1 byte control info
+			module->rx_channel = *data++;
+			module->pab_in[module->rx_channel].dms.pv.w = *(unsigned short*)data;
+			data += 2;
+			module->pab_in[module->rx_channel].dms.ci.b = *data++;
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_DMS_X_FLOAT:		// 1 byte kanalinfo, 4 byte data, 1 byte control info
+			module->rx_channel = *data++;
+			module->pab_in[module->rx_channel].dms.pv.dw = *(unsigned long*)data;
+			data += 4;
+			module->pab_in[module->rx_channel].dms.ci.b = *data++;
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_COMPLEX_X_SHORT:    // 1 byte kanalinfo, 3 * 2 bytes dannih, 1 byte status
+		case HPR_MT_COMPLEX_X_FLOAT:    // 1 byte kanalinfo, 3 * 4 bytes dannih, 1 byte status
+			module->rx_channel = *data++;
+			for (i =0; i < 3; i++) {
+				if (module->type == HPR_MT_COMPLEX_X_SHORT) {
+					if (module->rx_channel < module->params.member.pab_in_used) {
+						module->pab_in[module->rx_channel].complex.pv.w = *(unsigned short*)data;
+					} // else ignore data
+					data += 2;
+				} else {
+					if (module->rx_channel < module->params.member.pab_in_used) {
+						module->pab_in[module->rx_channel].complex.pv.dw = *(unsigned long*)data;
+					} // else ignore data
+					data += 4;
+				}
+			}
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_IO16B_1:    // 0 byte kanalinfo, 16 bytes data, 1 byte status 
+			memcpy(module->pab_in[0].io16b.pv, data, 16);
+			data += 16;
+			module->status.b = *data;
+			break;
+
+		case HPR_MT_AI_HART_X:    // 1 byte kanalinfo, 4 * 2 bytes data, 1 byte status
+			module->rx_channel = *data++;
+			module->pab_in[module->rx_channel].ai_hart.pv = *(unsigned short*)data;
+			data += 2;
+			module->pab_in[module->rx_channel].ai_hart.sv = *(unsigned short*)data;
+			data += 2;
+			module->pab_in[module->rx_channel].ai_hart.tv = *(unsigned short*)data;
+			data += 2;
+			module->pab_in[module->rx_channel].ai_hart.qv = *(unsigned short*)data;
+			data += 2;
+			module->status.b = *data;
+			break;
+
+		default:
+			break;
+	}
+
+//	module->status &= ~MODUL_STATE_MASK;
+//	module->status |= (module->state & MODUL_STATE_MASK);
+
+	return 0;
+}
+
+void create_broadcast_frame(unsigned char command, hpr_frame *frame)
+{
+	unsigned char *data;
+	unsigned char len;
+
+	data = frame->data;
+
+	*data++ = FC_BRODCAST;
+	*data++ = command;
+
+	len = data - frame->data;
+	*data = calculate_low_crc16(frame->data, len);
+	frame->length = len + 1;
+}
+
+void create_rx_module_param_frame(int module_address, int count, 
+	unsigned short start_address, hpr_frame *frame)
+{
+	unsigned char *data;
+	unsigned char len;
+
+	data = frame->data;
+
+	*data++ = module_address | HPR_FC_PARAM_COM;
+	*data++ = PK_DIREKT_LESEN;	// 0x81
+	*data++ = count;		// koli4estvo parametrov
+	*(unsigned short*)data = swap_short(start_address);
+	data += 2;
+
+	len = data - frame->data;
+	*data = calculate_low_crc16(frame->data, len);
+	frame->length = len + 1;
+}
+
+/* frame - received frame
+ * op_set - 1 - expected answer for PARAM SET, 0 - for PARAM GET
+ * info - parsed info
+ * Parse received frame collecting info in 'info' param. 
+ */
+static int parse_module_param_frame(hpr_frame *frame, int op_set, hpr_param_frame_info *info)
+{
+	unsigned char *data;
+	unsigned char len;
+
+	data = frame->data;
+
+	info->module_address = *data & ADDRESS_MASK;
+	info->function = *data++ & FUNCTION_MASK;
+
+	if (info->function != HPR_FC_PARAM_COM) {
+		pr_warning("%s: answer is not param communication: FC=%d\n", 
+			__func__, info->function);
+		return -EBADMSG;	/* may happen, so check FC for other code */
+	}
+
+	if ((frame->length <  3) || 
+		(op_set && (frame->length != 3))) { /* exact 3 bytes for ACK only */
+		pr_err("%s: wrong param frame length: %d\n", __func__, frame->length);
+		return -EBADMSG;	/* in normal way should not happen */
+	}
+
+	info->error = *data & QB_ERROR_MASK;
+	info->bpp = *data++ & QB_BYTECOUNT_MASK;
+
+	if (info->error) {
+		pr_err("%s: param comm ACK error: wrong inqury: %d, wrong data: %d\n", 
+			__func__, !!(info->error & 0x40), !!(info->error & 0x80));
+		return -EINVAL;
+	}
+
+	if (op_set) {
+		/* param set answer parsed OK */
+		info->param_count = 0;
+		info->start_address = 0;
+		info->params = NULL;
+		return 0;
+	}
+
+	info->param_count = *data++;
+
+	info->start_address = swap_short(*(unsigned short*)data);
+	data += 2;
+	pr_debug("%s: param frame info: address=%d, function=%d, error=0x%x, "
+		"bytes per param=%d, param count=%d, start_address=0x%x(%d)\n",
+		__func__, info->module_address, info->function, info->error, info->bpp, 
+		info->param_count, info->start_address, info->start_address);
+
+	len = data - frame->data + info->param_count * info->bpp + 1;
+	if (frame->length != len) {
+		pr_err("%s: wrong param frame length: %d, expected: %d\n",
+			__func__, frame->length, len);
+		return -EBADMSG; /* in normal way should not happen */
+	}
+
+	info->params = data;
+
+	/* param get answer parsed OK */
+	return 0;
+}
+
+/* call method to parse param frame and then
+ * swap parameter bytes in source frame's param area
+ */
+int hpr_parse_module_params(hpr_frame *frame, hpr_param_frame_info *info)
+{
+	int r;
+	int i;
+
+	r = parse_module_param_frame(frame, 0, info);
+	if (r) {
+		return r;
+	}
+
+	switch (info->bpp) {
+		case 2:
+			{
+				unsigned short *frame_params = (unsigned short*)info->params;
+				for (i = 0; i < info->param_count; i++) {
+					*frame_params = swap_short(*frame_params);
+					pr_debug("%s: i=%d, param_int=0x%x", 
+							__func__, i, *frame_params);
+					frame_params++;
+				}
+			}
+			break;
+		case 4:
+			{
+				unsigned long *frame_params = (unsigned long*)info->params;
+				for (i = 0; i < info->param_count; i++) {
+					*frame_params = swap_long(*frame_params);
+					pr_debug("%s: i=%d, param_float=0x%lx", 
+							__func__, i, *frame_params);
+					frame_params++;
+				}
+			}
+			break;
+		default:
+			pr_err("%s: can't parse module params: unsupported bpp=%d\n", 
+				__func__, info->bpp);
+			return -EBADMSG; /* in normal way should not happen */
+			break;
+	}
+	
+	return 0;
+}
+
+int hpr_parse_module_config(hpr_frame *frame, hpr_module *module)
+{
+	int r;
+	hpr_param_frame_info info;
+	unsigned short *params;
+	unsigned short *frame_params;
+	int i;
+
+	r = parse_module_param_frame(frame, 0, &info);
+	if (r) {
+		return r;
+	}
+
+	if (info.module_address) {
+		pr_err("%s: wrong module address: %d, expected: 0\n", 
+			__func__, info.module_address);
+		return -EBADMSG; /* in normal way should not happen */
+	}
+
+	if (info.bpp != 2) {
+		pr_err("%s: unsupported bytes_per_param=%d for module params\n", 
+			__func__, info.bpp);
+		return -EBADMSG;
+	}
+
+	params = (unsigned short *)&module->params.data[(info.start_address + 1) * 2];
+	frame_params = (unsigned short*)info.params;
+	for (i = 0; i < info.param_count; i++) {
+		*params = swap_short(*frame_params++);
+		pr_debug("%s: i=%d, param=0x%x", 
+			__func__, i, *params);
+		params++;
+	}
+
+	return 0;
+}
+
+int hpr_parse_module_param_ack(hpr_frame *frame, hpr_param_frame_info *info)
+{
+	return parse_module_param_frame(frame, 1, info);
+}
+
+void create_tx_module_param_frame(int module_address, unsigned char type, 
+			int count, unsigned short start_address, char *src_data, hpr_frame *frame)
+{
+	unsigned char *data;
+	unsigned char len;
+	int i;
+
+	data = frame->data;
+
+	*data++ = module_address | HPR_FC_PARAM_COM;
+	*data++ = PK_DIREKT_SCHREIBEN;
+	*data++ = count;
+	*(unsigned short*)data = swap_short(start_address);
+	data += 2;
+
+	for (i = 0; i < count; i++) {
+		if (type == HPR_PT_FLOAT) {	// 4-bytes access /* was: start_address >= HPR_PA_FLOAT, now it is not true */
+			*(unsigned long*)data = swap_long(((unsigned long*)src_data)[i]);
+			pr_debug("%s: create_tx: %i => 0x%lx\n", 
+				__func__, i, *(unsigned long*)data);
+			data += sizeof(unsigned long);
+		} else {	// 2-bytes access
+			*(unsigned short*)data = swap_short(((unsigned short*)src_data)[i]);
+			pr_debug("%s: create_tx: %i => 0x%x\n", 
+				__func__, i, *(unsigned short*)data);
+			data += sizeof(unsigned short);
+		}
+	}
+
+	len = data - frame->data;
+	*data = calculate_low_crc16(frame->data, len);
+	frame->length = len + 1;
+}
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_frame.h linux-3.0.x-arm/drivers/misc/hpr/hpr_frame.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_frame.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_frame.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef _HPR_FRAME_H
+#define _HPR_FRAME_H
+
+#define HPR_MAX_FRAME_SIZE	255
+
+typedef struct {
+	unsigned char length;
+	unsigned char data[HPR_MAX_FRAME_SIZE];
+} hpr_frame;
+/* parsed info on param frame */
+typedef struct {
+	unsigned char module_address;
+	unsigned char function;
+	unsigned char error;
+	unsigned char bpp;
+	unsigned char param_count;
+	unsigned short start_address;
+	unsigned char *params; /* pointer to params area in hpr_frame, params may be already swapped after parsing */
+} hpr_param_frame_info;
+
+#if defined(DEBUG) || defined(CONFIG_ATMEL_HPR_DEBUG_FRAMES)
+extern void dump_frame(const char *title, int bus_id, const char *frame, int length);
+#else
+#define dump_frame(title, bus_id, frame, length)
+#endif
+
+extern void create_tx_pab_frame(hpr_module *module, hpr_frame *frame);
+extern int parse_rx_pab_frame(hpr_module *module, hpr_frame *frame);
+
+extern void create_broadcast_frame(unsigned char command, hpr_frame *frame);
+extern void create_rx_module_param_frame(int module_address, int count,
+		unsigned short start_address, hpr_frame *frame);
+extern int hpr_parse_module_param_ack(hpr_frame *frame, hpr_param_frame_info *info);
+extern int hpr_parse_module_params(hpr_frame *frame, hpr_param_frame_info *info);
+extern int hpr_parse_module_config(hpr_frame *frame, hpr_module *module);
+extern void create_tx_module_param_frame(int module_address, unsigned char type, 
+			int count, unsigned short start_address, char *src_data, hpr_frame *frame);
+
+#endif
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_ioctl.h linux-3.0.x-arm/drivers/misc/hpr/hpr_ioctl.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_ioctl.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_ioctl.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef _HPR_IOCTL_H
+#define _HPR_IOCTL_H
+
+/*
+    0x48 is 'H'
+*/
+#define HPR_GET_BUS_NUMBER		0x4800
+#define HPR_GET_BUS_STATUS		0x4801
+#define HPR_START_SCAN_BUS		0x4802
+#define HPR_GET_SCAN_BUS_COMPLETE	0x4803
+#define HPR_STOP_SCAN_BUS			0x4804
+#define HPR_GET_MODULES_NUMBER		0x4805
+#define HPR_GET_MODULE_DATA		0x4806
+#define HPR_START_GROUP_COMM		0x4807
+#define HPR_STOP_GROUP_COMM		0x4808
+#define HPR_RD_QUERY_SET		0x4809
+
+#define HPR_GET_MODULE_PARAMS		0x480A
+#define HPR_SET_MODULE_PARAMS		0x480B
+
+/* test for one shot PV communication */
+#define HPR_ONE_SHOT_PVC		0x480C
+
+#endif /*_HPR_IOCTL_H*/
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_pab.c linux-3.0.x-arm/drivers/misc/hpr/hpr_pab.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_pab.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_pab.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,402 @@
+/*
+ * PAB data processing interface
+ */
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+
+#include "hpr_bus.h"
+#include "hpr_frame.h"
+#include "hpr_uart.h"
+#include "hpr_pab.h"
+
+/* Poll interval or period.
+ *	CONFIG_HZ=100
+ *		default:
+ *			poll_usec = 1000 usec (1 ms)
+ *			poll_period_ms = 10 ms (1jiffy)
+ *			method: "poll_interval" (because poll_usec > 0)
+ *		switch to method "poll_period": specify poll_usec=0
+ *	CONFIG_HZ=1000
+ *		default:
+ *			poll_usec = 0 usec
+ *			poll_period_ms = 2 ms (2jiffy)
+ *			method: "poll_period" (because poll_usec=0)
+ *		switch to method "poll_interval": specify poll_usec>0
+ *
+ * So if
+ *	poll_usec=0, poll_period_ms>0 - used method: poll_period(poll_period_ms)
+ *	poll_usec>0, poll_period_ms>0 - used method: poll_interval(poll_usec)
+ */
+
+
+/* default val for CONFIG_HZ==100 is 1ms, 1000 usec, otherwise 0 - functionality is off */
+static int poll_usec = CONFIG_HZ == 100 ? 1000 : 0;
+module_param(poll_usec, int, S_IRUGO);
+MODULE_PARM_DESC(poll_usec, "PAB poll interval in microseconds (time between polls)");
+
+static void (*wait_method)(hpr_bus_work *bus_work);
+static int wait_time = 0;
+
+/* default value: 10ms(1jiffy) for _HZ=100, 2ms(2jiffy) for _HZ=1000 */
+static int poll_period_ms = CONFIG_HZ == 100 ? 10: 2;
+module_param(poll_period_ms, int, S_IRUGO);
+MODULE_PARM_DESC(poll_period_ms, "PAB poll period in miliseconds (period of polls)");
+static unsigned long poll_period_jiffies;
+
+
+static void wait_jiffies(hpr_bus_work *bus_work)
+{
+	wait_event_timeout(bus_work->wait, bus_work->work_stop, wait_time);
+}
+static void wait_ms(hpr_bus_work *bus_work)
+{
+/* hangs if any sleep is used and codesys sends STOP_GROUP from two threads (when rootfs is on NFS) */
+/*	int r;
+	r = msleep_interruptible(wait_time);
+	if (r != 0) {
+		pr_info("!sleep was interrupted: left=%d ms\n", r);
+	}*/
+	msleep_interruptible(wait_time);
+//	mdelay(wait_time);
+//	msleep(wait_time);
+}
+static void wait_us(hpr_bus_work *bus_work)
+{
+	udelay(wait_time);
+}
+
+int hpr_pab_setup_poll_interval(void)
+{
+	/* poll_period_ms is default functionality now, but poll_usec has higher priority */
+
+	poll_period_jiffies = poll_period_ms * CONFIG_HZ / 1000;
+	if (poll_period_jiffies <= 0) {
+		pr_err("invalid poll_period_ms value %d (number of ms should result in positive jiffies value)\n",
+			poll_period_ms);
+		return -EINVAL;
+	}
+	
+	/* poll_usec by default is 0 - the functionality is off 
+	 * If specified value > 0 then it takes over poll_period_ms
+	 */
+	if (poll_usec < 0) {
+		pr_err("invalid poll_usec value %d (should be > 0)\n",
+			poll_usec);
+		return -EINVAL;
+	}
+
+	if (poll_usec > 0) {
+		/* use poll_usec */
+
+		if (poll_usec >= 1000) {
+			wait_time = CONFIG_HZ  * (poll_usec / 1000) / 1000;
+			if (wait_time > 0) {
+				wait_method = &wait_jiffies;
+				pr_info("  Poll interval: %d ms (%d jiffies), method: wait_jiffies\n",
+						1000 * wait_time / CONFIG_HZ, wait_time);
+			} else {
+				wait_time = poll_usec / 1000;	/* when CONFIG_HZ=100, 1..9 ms delays via wait_ms */
+				wait_method = &wait_ms;
+				pr_info("  Poll interval: %d ms, method: wait_ms\n", wait_time);
+			}
+			
+		} else {
+			wait_time = poll_usec;
+			wait_method = &wait_us;
+			pr_info("  Poll interval: %d us, method: wait_us\n", wait_time);
+		}
+
+		/* so wait_time > 0 - use it to identify the method to apply */
+	} else {
+		/* use poll_period_ms (default) */
+
+		/* if we use this method, then override delay-related functionality 
+		 * so hpr_pab_sleep_poll_interval_half() will work as usual
+		 */
+		poll_usec = poll_period_ms * 1000;
+		pr_info("  Poll period: %d ms (jiffies=%lu, sleep half interval - ms/2)\n", 
+				poll_period_ms, poll_period_jiffies);
+
+		/* so wait_time == 0 - use it to identify the method to apply */
+	}
+
+	return 0;
+}
+
+void hpr_pab_sleep_poll_interval_half(void)
+{
+	int time_ms, time_s;
+	/* half of the interval in miliseconds */
+	time_ms = (poll_usec / 1000) / 2;
+	time_s = time_ms / 1000;
+	if (time_s) {
+		ssleep(time_s);
+	} else {
+		if (!time_ms) {
+			time_ms = 1;
+		}
+		msleep(time_ms);
+	}
+}
+
+static int exchange_pab_data(hpr_bus_info *bus_info, int module_index, int sync)
+{
+	int r;
+	hpr_frame out_frame, in_frame;
+	hpr_module *module;
+
+	hpr_get_module(bus_info->bus_index, module_index, &module);
+	if (!sync) {
+		/* check if async pab exchange is allowed for the module */
+		if (!module->flags.pab_async_enabled) {
+			hpr_put_module(module);
+			pr_debug("%s(%d): async pab exchange disabled for module=%d, bus=%d\n",
+					__func__, (int)(current->pid), module_index + 1, bus_info->bus_id);
+			return -ENOASYNCEXCH;
+		}
+
+		module->flags.pab_async_in_progress = 1;	/* protect from simultaneous sync exchange */
+	}
+	create_tx_pab_frame(module, &out_frame);
+	hpr_put_module(module);
+
+	r = hpr_send_receive(bus_info->bus_id, &out_frame, &in_frame);
+	
+	hpr_get_module(bus_info->bus_index, module_index, &module);
+	if (r) {
+		pr_err("%s: failed exchange for module addr=%d (index=%d), bus=%d, sync=%d\n", 
+			__func__, module_index + 1, module_index, bus_info->bus_id, sync);
+	} else {
+		/* process incoming frame, here result code is significant */
+		r = parse_rx_pab_frame(module, &in_frame);
+		if (r) {
+			pr_err("%s: failed to parse result for module addr=%d (index=%d), bus=%d, sync=%d\n", 
+				__func__, module_index + 1, module_index, bus_info->bus_id, sync);
+		}
+	}
+
+	/* save last result of the PV communication */
+	module->last_pvc_rc = r;
+	
+	if (!sync) {
+		/* process pab exchange flags */
+		if (module->flags.pab_async_one_shot) {
+			/* disable HW async exchange so user exchange is enabled */
+			module->flags.pab_async_enabled = 0;
+		}
+		
+		module->flags.pab_async_in_progress = 0;
+		if (module->flags.pab_async_is_waited) {
+			module->flags.pab_async_is_waited = 0;
+			hpr_put_module(module);
+			/* signal that async exchange for the module is complete */
+			wake_up(&module->pab_async_wait_q);
+			return r;
+		}
+	}
+	hpr_put_module(module);
+
+	return r;
+}
+
+static void pab_data_exchange_work(struct work_struct *work)
+{
+	int module_index = 0;
+	hpr_bus_work *bus_work = to_hpr_bus_work(work);
+	int r;
+	int exchanged_counter = 0;
+
+	pr_debug("%s: group work run: bus=%d, work=%p, bus_work=%p\n",
+		__func__, bus_work->bus_info.bus_id, work, bus_work);
+
+	while (!bus_work->work_stop) {
+		r = exchange_pab_data(&bus_work->bus_info, module_index++, 0);
+		if (module_index >= bus_work->bus_info.modules_count) {
+			module_index = 0;
+			if (!exchanged_counter) {
+				msleep(1);	/* give some time to other processes */
+			} else {
+				exchanged_counter = 0;
+			}
+		}
+		if (r == -ENOASYNCEXCH) {
+			continue;
+		}
+		pr_debug("%s(%d): enter to wait/sleep..\n", __func__, (int)(current->pid));
+		wait_method(bus_work);
+		pr_debug("%s(%d): next iteration..\n", __func__, (int)(current->pid));
+		exchanged_counter++;
+	}
+
+	pr_debug("%s(%d): group work ending..: bus=%d, work=%p, bus_work=%p\n",
+		__func__, (int)(current->pid), bus_work->bus_info.bus_id, work, bus_work);
+
+	/* signal that work is terminated */
+	complete(&bus_work->stopped);
+}
+
+/*
+ * Define ATMEL_HPR_DEBUG_SPEED to measure and display
+ * statistics on async exchange speed.
+ * Works if used pab_data_exchange_work_synced() is used, which is
+ * selected by default when poll_usec is not specified
+ */
+//#define ATMEL_HPR_DEBUG_SPEED
+#undef ATMEL_HPR_DEBUG_SPEED
+
+#ifdef ATMEL_HPR_DEBUG_SPEED
+#define HPR_TIMER_START 0
+#define HPR_TIMER_DONE 1
+#define HPR_TIMER_WAIT 2
+#define HPR_LOG_COUNT 15
+static char hpr_log[3 * HPR_LOG_COUNT][2];	/* [0] - action code, [1]- jiffies value */
+atomic_t hpr_log_index = ATOMIC_INIT(-1);
+#endif /*ATMEL_HPR_DEBUG_SPEED*/
+
+static void sync_timer_function(unsigned long data)
+{
+	hpr_bus_work *bus_work = (hpr_bus_work *)data;
+	bus_work->sync = 1;
+	wake_up(&bus_work->wait);
+//	pr_debug("  %s: timer %p done\n", __func__, &bus_work->sync_timer);
+#ifdef ATMEL_HPR_DEBUG_SPEED
+	{
+		int index = atomic_inc_return(&hpr_log_index);
+		hpr_log[index][0] = HPR_TIMER_DONE;
+		hpr_log[index][1] = jiffies;
+	}
+#endif /* ATMEL_HPR_DEBUG_SPEED */
+}
+
+/* Note: 
+ *  -timer is re-scheduled by work loop after previous timer fired, so we don't need to del timer when
+ *   exit the loop by work_stop flag
+ * - if work's job takes more time than the timer is set to the next iteration starts immediately, so
+ *   periodicity of exchanges will not be met.
+ */
+static void pab_data_exchange_work_synced(struct work_struct *work)
+{
+	int module_index = 0;
+	hpr_bus_work *bus_work = to_hpr_bus_work(work);
+	int r;
+	int exchanged_counter = 0;
+
+	pr_debug("%s: group work run: bus=%d, work=%p, bus_work=%p\n",
+		__func__, bus_work->bus_info.bus_id, work, bus_work);
+
+	init_timer(&bus_work->sync_timer);
+	bus_work->sync_timer.function = sync_timer_function;
+	bus_work->sync_timer.data = (unsigned long)bus_work;
+
+	while (!bus_work->work_stop) {
+#ifdef ATMEL_HPR_DEBUG_SPEED
+		{
+			int index = atomic_inc_return(&hpr_log_index);
+			if (index >= HPR_LOG_COUNT * 3) {
+				/* print statistics and re-init index */
+				int i;
+				pr_notice("\n\n---- STATISTICS----\n");
+				for (i = 0; i < HPR_LOG_COUNT * 3; i++) {
+					pr_notice("-- %03d: %s\n", hpr_log[i][1],
+						hpr_log[i][0] == HPR_TIMER_START ? "timer start" :
+						hpr_log[i][0] == HPR_TIMER_DONE ? "timer done" :
+						hpr_log[i][0] == HPR_TIMER_WAIT ? "timer wait" : "unk");
+				}
+				atomic_set(&hpr_log_index, 0);
+				index = 0;
+			}
+			hpr_log[index][0] = HPR_TIMER_START;
+			hpr_log[index][1] = jiffies;
+		}
+#endif
+		/* start/re-start timer */
+		bus_work->sync_timer.expires = jiffies + poll_period_jiffies;
+		bus_work->sync = 0;
+		pr_debug("  %s(%d): timer %p started\n", 
+			__func__, (int)(current->pid), &bus_work->sync_timer);
+		add_timer(&bus_work->sync_timer);
+
+		/* perform work */
+		r = exchange_pab_data(&bus_work->bus_info, module_index++, 0);
+		if (r == -ENOASYNCEXCH) {
+			del_timer(&bus_work->sync_timer);
+#ifdef ATMEL_HPR_DEBUG_SPEED
+			atomic_dec(&hpr_log_index); /* may not work as expected if timer fires earlier than it cancelled */
+#endif
+			pr_debug("  %s(%d): timer %p cancelled\n", 
+				__func__, (int)(current->pid), &bus_work->sync_timer);
+		}
+		if (module_index >= bus_work->bus_info.modules_count) {
+			module_index = 0;
+			if (!exchanged_counter) {
+				msleep(1);	/* give some time to other processes */
+				pr_debug(" %s(%d): sleep done\n", __func__, (int)(current->pid));
+			} else {
+				exchanged_counter = 0;
+			}
+		}
+		if (r == -ENOASYNCEXCH) {
+			continue;
+		}
+
+		/* wait until timer fiires */
+		pr_debug(" %s(%d): enter to wait/sleep until sync..\n", __func__, (int)(current->pid));
+#ifdef ATMEL_HPR_DEBUG_SPEED
+		{
+			int index = atomic_inc_return(&hpr_log_index);
+			hpr_log[index][0] = HPR_TIMER_WAIT;
+			hpr_log[index][1] = jiffies;
+		}
+#endif /* ATMEL_HPR_DEBUG_SPEED */
+		wait_event(bus_work->wait, bus_work->sync || bus_work->work_stop);
+		if (!bus_work->sync) {
+			/* exit by work_stop */
+			del_timer(&bus_work->sync_timer);
+			pr_debug("%s(%d): work_stop got..next iteration..\n", __func__, (int)(current->pid));
+		} else {
+			pr_debug("%s(%d): sync got..next iteration..\n", __func__, (int)(current->pid));
+		}
+		exchanged_counter++;
+	}
+
+	pr_debug("%s(%d): group work ending..: bus=%d, work=%p, bus_work=%p\n",
+		__func__, (int)(current->pid), bus_work->bus_info.bus_id, work, bus_work);
+
+	/* signal that work is terminated */
+	complete(&bus_work->stopped);
+}
+
+int hpr_pab_start_group_work(hpr_bus_work *bus_work)
+{
+	int r;
+
+	bus_work->work_stop = 0;
+
+	if (wait_time > 0) {
+		INIT_WORK(&bus_work->work,  &pab_data_exchange_work);
+		pr_debug("%s: use: pab_data_exchange_work\n", __func__);
+	} else {
+		INIT_WORK(&bus_work->work,  &pab_data_exchange_work_synced);
+		pr_debug("%s: use: pab_data_exchange_work2\n", __func__);
+	}
+
+	r = queue_work(bus_work->work_q, &bus_work->work);
+	if (!r) {
+		pr_err("%s: failed to enqueue poll_work: %d, bus=%d\n", 
+			__func__, r, bus_work->bus_info.bus_id);
+		return -EPERM;
+	}
+	pr_debug("%s: group work enqueued, bus=%d\n", 
+		__func__, bus_work->bus_info.bus_id);
+	return 0;
+}
+
+int hpr_pab_sync_exchange(hpr_bus_info *bus_info, int module_index)
+{
+	return exchange_pab_data(bus_info, module_index, 1);
+}
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_pab.h linux-3.0.x-arm/drivers/misc/hpr/hpr_pab.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_pab.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_pab.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _HPR_PAB_H
+#define _HPR_PAB_H
+
+extern int hpr_pab_setup_poll_interval(void);
+extern int hpr_pab_start_group_work(hpr_bus_work *bus_work);
+
+extern int hpr_pab_sync_exchange(hpr_bus_info *bus_info, int module_index);
+
+/* used for waiting signaled work termination */
+extern void hpr_pab_sleep_poll_interval_half(void);
+
+#endif /*_HPR_PAB_H*/
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_scan.c linux-3.0.x-arm/drivers/misc/hpr/hpr_scan.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_scan.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_scan.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,378 @@
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+
+#include "hpr_bus.h"
+#include "hpr_serial.h"
+#include "hpr_frame.h"
+#include "hpr_uart.h"
+#include "hpr_scan.h"
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+static int paddr_auto = 0;
+module_param(paddr_auto, int, S_IRUGO);
+MODULE_PARM_DESC(paddr_auto, "Automatically detect param addressing");
+#endif
+
+static void determine_module_type(hpr_module *module)
+{
+	unsigned short in_max;
+	unsigned short out_max;
+	unsigned short pd_format;
+
+	pd_format = module->params.member.function_id & HPR_PDF_MASK;
+	
+	in_max = module->params.member.pab_in_max;
+	out_max = module->params.member.pab_out_max;
+
+	module->type = HPR_MT_UNKNOWN;
+	
+	switch (module->params.member.module_type) {
+	case HPR_STANDARD_MODULE:
+		/* DI/DO/DIDO/AI/AO/AIAO */
+		switch (pd_format) {
+			case HPR_PDF_BYTE:
+				/* DI/DO/DIDO only */
+				if (in_max && out_max) {
+					if (in_max == 1 && out_max == 1) {
+						module->type = HPR_MT_DIDO_1_BYTE;
+					} else if (in_max == 2 && out_max == 2) {
+						/* #2462#note-3 has made it unclear how to process DI/DO 16 byte modules*/
+						module->type = HPR_MT_DIDO_1_SHORT;
+					}
+				} else if (out_max) {
+					if (out_max == 1) {
+						module->type = HPR_MT_DO_1_BYTE;
+					} else if (out_max == 2) {
+						/* #2462#note-3 has made it unclear how to process DI/DO 16 byte modules*/
+						module->type = HPR_MT_DO_1_SHORT;
+					}
+				} else if (in_max) {
+					if (in_max == 1) {
+						module->type = HPR_MT_DI_1_BYTE;
+					} else if (in_max == 2) {
+						/* #2462#note-3 has made it unclear how to process DI/DO 16 byte modules*/
+						module->type = HPR_MT_DI_1_SHORT;
+					}
+				} 
+				break;
+			case HPR_PDF_SHORT:
+				/* AI/AO/AIAO only */
+				if (in_max && out_max) {
+					module->type = HPR_MT_AIAO_X_SHORT;
+				} else if (out_max) {
+					module->type = HPR_MT_AO_X_SHORT;
+				} else if (in_max) {
+					module->type = HPR_MT_AI_X_SHORT;
+				} 
+				break;
+			case HPR_PDF_FLOAT:
+				/* AI/AO/AIAO only */
+				if (in_max && out_max) {
+					module->type = HPR_MT_AIAO_X_FLOAT;
+				} else if (out_max) {
+					module->type = HPR_MT_AO_X_FLOAT;
+				} else if (in_max) {
+					module->type = HPR_MT_AI_X_FLOAT;
+				} 
+				break;
+
+			case HPR_PDF_ARRAY:
+			default:
+				break;
+		}
+		break;
+
+	case HPR_COMPLEX_MODULE:
+		if (in_max && out_max) {
+			if (pd_format == HPR_PDF_SHORT) {
+				module->type = HPR_MT_COMPLEX_X_SHORT;
+			} else if (pd_format == HPR_PDF_FLOAT) {
+				module->type = HPR_MT_COMPLEX_X_FLOAT;
+			}
+		}
+		break;
+
+	case HPR_DMS_MODULE:
+//TODO: out_max should not be 0 in order to keep in output PABs outgoing control info!?
+//		if (in_max && !out_max) {
+			if (pd_format == HPR_PDF_SHORT) {
+				module->type = HPR_MT_DMS_X_SHORT;
+			} else if (pd_format == HPR_PDF_FLOAT) {
+				module->type = HPR_MT_DMS_X_FLOAT;
+			}
+//		}
+		break;
+
+	case HPR_IO16B_MODULE:
+		if (in_max && out_max) {
+		/* Koppler.c expects format SHORT, why, if we have array of 16 _BYTES_ ? */
+//			if (pd_format == HPR_PD_SHORT) {
+				module->type = HPR_MT_IO16B_1;
+//			} 
+		}
+		pr_debug("%s: IO16B: need to specify possible types!\n", __func__);
+		break;
+
+	case HPR_AI_HART_MODULE:
+		if (in_max && !out_max) {
+//			if (pd_format == HPR_PDF_SHORT) {	/* by Koppler.c, in the Specification it's absent */
+				module->type = HPR_MT_AI_HART_X;
+//			} 
+		}
+		pr_debug("%s: AI_HART: need to specify possible types!\n", __func__);
+		break;
+
+	default:
+		break;
+	}
+
+	/* #2493 suggestions are implemented, but may be removed later according to the comment 1 */
+	if (module->type == HPR_MT_DI_1_SHORT || module->type == HPR_MT_DO_1_SHORT ||
+		module->type == HPR_MT_DIDO_1_SHORT) {
+		if (module->params.member.pab_in_max == 2) {
+			module->params.member.pab_in_max = 1;
+			if (module->params.member.pab_in_used) {
+				module->params.member.pab_in_used = 1;
+			}
+		}
+		if (module->params.member.pab_out_max == 2) {
+			module->params.member.pab_out_max = 1;
+			if (module->params.member.pab_out_used) {
+				module->params.member.pab_out_used = 1;
+			}
+		}
+		pr_debug("%s: 16bit DI/DO module params fixed\n", __func__);
+	}
+	/* #2493 end */
+	
+	if (module->type == HPR_MT_UNKNOWN) {
+		pr_err("%s: unknown type of module=%d\n"
+			"p6(module type)=%d, p9(format of data)=0x%02X, pab_in_max=%d, pab_out_max=%d\n",
+			__func__, module->params.member.module_address,
+			module->params.member.module_type,
+			module->params.member.function_id & HPR_PDF_MASK,
+			in_max, out_max);
+	}
+	pr_debug("%s: detected  module addr=%d, type=%d\n", 
+		__func__, module->params.member.module_address, module->type);
+}
+
+static int hpr_send_broadcast(int bus_id, unsigned char command, int count)
+{
+	int r;
+	hpr_frame frame;
+
+	pr_debug("%s: bus=%d, command=%d\n", __func__, bus_id, command);
+	create_broadcast_frame(command, &frame);
+	r = hpr_send(bus_id, &frame, count);
+	pr_debug("%s: bus=%d, command=%d => r=%d\n", 
+		__func__, bus_id, command, r);
+	if (r) {
+		pr_err("%s: bus=%d, command=%d failed: r=%d\n",
+			__func__, bus_id, command, r);
+	}
+	return r;
+}
+
+static int setup_module_address(int bus_id, int address, int *stop_flag)
+{
+	int r;
+	hpr_frame frame;
+
+	create_tx_module_param_frame(0, HPR_PT_INT, 1, 0, (char*)&address, &frame);
+
+	if (stop_flag && *stop_flag) {
+		return -EINTR;
+	}
+	
+	//TODO: pass stop_flag into low-level send function?
+	r = hpr_send(bus_id, &frame, 2);
+
+	return r;
+}
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+static void detect_module_param_addressing(int bus_id, hpr_module *module)
+{
+	hpr_frame out_frame, in_frame;
+	hpr_param_frame_info info;
+	unsigned short p1, p2;
+	
+	module->flags.param_byte_addressing = 0;
+
+	p1 = module->params.member.hardware_id;
+	p2 = module->params.member.change_status;
+	
+	if (p1 == p2) {
+		pr_warning("%s: module param addressing detection is not applicable for module=%d\n",
+			__func__, module->params.member.module_address);
+		return;
+	}
+	
+	create_rx_module_param_frame(0, 1, 2, &out_frame);
+
+	if (hpr_send_receive(bus_id, &out_frame, &in_frame) == 0 &&
+		hpr_parse_module_params(&in_frame, &info) == 0) {
+		if (module->params.member.hardware_id == ((unsigned short*)info.params)[0]) {
+			pr_debug("%s: module param addressing detection: %d - by byte(incorrect)\n", 
+				__func__, module->params.member.module_address);
+			module->flags.param_byte_addressing = 1;
+		} else {
+			pr_debug("%s: module param addressing detection: %d - by index(correct)\n", 
+				__func__, module->params.member.module_address);
+		}
+	} else {
+		pr_err("%s: failed to detect module param addressing, module=%d\n",
+			__func__, module->params.member.module_address);
+	}
+}
+#endif
+
+static void scan_bus_work(struct work_struct *work)
+{
+	int r, attempts;
+
+	int module_address = 1;
+	hpr_frame request, answer;
+	hpr_module module;
+
+	hpr_bus_work *bus_work;
+	int bus_id, bus_index;
+
+	bus_work = to_hpr_bus_work(work);
+	bus_id = bus_work->bus_info.bus_id;
+	bus_index = bus_work->bus_info.bus_index;
+
+	pr_debug("%s: scanbus work started, bus=%d\n", __func__, bus_id);
+
+	hpr_set_bus_timing(bus_id, &hpr_timing_scan);
+
+	daisy_chain_high(bus_id);
+	hpr_send_broadcast(bus_id, BCK_START_SCAN, 2);
+	hpr_send_broadcast(bus_id, BCK_CLOSE_RELAIS, 2);
+
+	//create request for params from module address 0;
+	create_rx_module_param_frame(0, 11, 0, &request);
+	memset(&module, 0, sizeof(module));
+
+	/* attempts are used for retry on module config parsing error, 
+	 * e.g. when an answer for a previous param request is received 
+	 */
+	attempts = HPR_RETRY_COUNT;
+	while (attempts) {
+		/* check termination flag first */
+		if (bus_work->work_stop) {
+			pr_debug("%s: bus=%d stop_flag is set, exiting..\n", __func__, bus_id);
+			r = -EINTR;
+			break;
+		}
+		
+		pr_debug("%s: scan loop: bus=%d attempts=%d\n", __func__, bus_id, attempts);
+
+		r = hpr_send_receive(bus_id, &request, &answer);
+		pr_debug("%s: bus=%d: frame processed, r=%d\n", __func__, bus_id, r);
+
+		/* repetitions have been done already by hpr_send_receive, so here stop on an error */
+		if (r) {
+			pr_err("%s: bus=%d: param request failed: r=%d, stop scanning\n", 
+				__func__, bus_id, r);
+			break;
+		}
+
+		/* check termination flag again */
+		if (bus_work->work_stop) {
+			pr_debug("%s: bus=%d stop_flag is set, exiting..\n", __func__, bus_id);
+			r = -EINTR;
+			break;
+		}
+
+		r = hpr_parse_module_config(&answer, &module);
+		if (r) {
+			attempts--;
+			pr_warning("%s: bus=%d: failed to parse module config: %d; left attempts=%d\n", 
+				__func__, bus_id, r, attempts);
+			continue;
+		}
+		
+		/* check if internal address stored in the module is the same as local address enumerator */
+		if (module.params.member.module_address != module_address) {
+			pr_debug("%s: bus=%d, current expected address=%d, read module address=%d\n", 
+				__func__, bus_id, module_address, module.params.member.module_address);
+			pr_debug("%s: module address renewal: bus=%d, HWId=0x%x\n", 
+				__func__, bus_id,  module.params.member.hardware_id);
+			r = setup_module_address(bus_id, module_address, &bus_work->work_stop);
+			if (r) {
+				/* -EINTR or any other */
+				break; /* can't setup address, so can't continue scanning */
+			}
+			/* repeat the module request */
+		} else {
+			determine_module_type(&module);
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+			if (paddr_auto) {
+				detect_module_param_addressing(bus_id, &module);
+			} else {
+				module.flags.param_byte_addressing = 0;
+			}
+#endif
+			r = hpr_add_module(bus_index, &module);
+			if (r < 0) {
+				break;
+			}
+			memset(&module, 0, sizeof(module));
+			
+			/* prepare next module request */
+			hpr_send_broadcast(bus_id, BCK_OPEN_RELAIS, 1);
+
+			/* increment local module address enumerator */
+			module_address++;
+			/* check whether we can stop scanning because of having come up to the address limit */
+			if (module_address > HPR_MAX_MODULE_ADDRESS) {
+				pr_debug("%s: stopping scanning: max. allowed number of modules already detected on the bus=%d\n",
+					__func__, bus_id);
+				break;
+			}
+		}
+		attempts = HPR_RETRY_COUNT;
+	}
+
+/*scan_bus_work_cleanup:*/
+
+	hpr_send_broadcast(bus_id, BCK_START, 2);
+//	daisy_chain_low(bus_id);
+
+	/* if r== -EINTR - interrupted by stop_flag */
+
+	/* go through all modules on the bus, look for serial ports, create as found */
+	hpr_serial_add_or_update_ports(bus_index);
+
+	pr_debug("%s: work cleanup, bus=%d...\n", __func__, bus_id);
+
+	hpr_set_bus_timing(bus_id, NULL);
+
+	r = hpr_notify_bus_scan_completed(bus_index);
+	if (r == -EPERM) {
+		complete(&bus_work->stopped);
+	}
+}
+
+int hpr_scan_start_work(hpr_bus_work *bus_work)
+{
+	int r;
+
+	bus_work->work_stop = 0;
+
+	INIT_WORK(&bus_work->work,  &scan_bus_work);
+	r = queue_work(bus_work->work_q, &bus_work->work);
+	if (!r) {
+		pr_err("%s: failed to enqueue scan bus work: %d, bus=%d\n", 
+			__func__, r, bus_work->bus_info.bus_id);
+		return -EPERM;
+	}
+	pr_debug("%s: scan bus work enqueued, bus=%d\n", 
+		__func__, bus_work->bus_info.bus_id);
+	return 0;
+}
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_scan.h linux-3.0.x-arm/drivers/misc/hpr/hpr_scan.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_scan.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_scan.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef _HPR_SCAN_H
+#define _HPR_SCAN_H
+
+extern int hpr_scan_start_work(hpr_bus_work *bus_work);
+
+#endif /* _HPR_SCAN_H_ */
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_serial.c linux-3.0.x-arm/drivers/misc/hpr/hpr_serial.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_serial.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_serial.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,326 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/completion.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+
+#include "hpr_serial.h"
+#include "hpr_bus.h"
+#include "hpr_bus_pvt.h"
+
+//#define HPR_SERIAL_TEST1
+//#define HPR_SERIAL_TEST2
+
+/* 0x2700 -HE5670 (EnOcean) - for first development testing
+ * 0x2720 -HE5672
+*/
+static int serial_hw_count = 1;
+static int serial_hw[4] = { HPR_HWID_HE5672, };		/* max number of types of serial modules = 4 */
+module_param_array(serial_hw, int, &serial_hw_count, S_IRUGO);
+MODULE_PARM_DESC(serial_hw, "HW IDs of HPR serial modules (max. 4 types)");
+
+static struct list_head hpr_serial_ports = LIST_HEAD_INIT(hpr_serial_ports);
+static int hpr_serial_dev_id = 0;
+
+typedef struct hpr_serial_port hpr_serial_port;
+struct hpr_serial_port {
+	struct list_head list;
+	struct platform_device pdev;
+	hpr_serial_port_data data;
+	int (*set_config)(hpr_serial_port *port);
+	void (*update_config)(hpr_serial_port *port, hpr_param_arg *param);
+};
+
+#define hpr_serial_data_to_port(pdata) container_of(pdata, hpr_serial_port, data)
+
+static int is_hpr_serial_module(unsigned short hw_id)
+{
+	int i;
+	for (i = 0; i < serial_hw_count; i++) {
+		if ((unsigned short)serial_hw[i] == hw_id) {
+			return 1; /* true */
+		}
+	}
+	return 0; /* false */
+}
+
+static void dev_release(struct device *dev)
+{
+}
+
+static void he5672_update_config(hpr_serial_port *port, hpr_param_arg *param)
+{
+	int end_address;
+	int src_index, dst_index,  start_address, count;
+	
+	end_address = param->address + param->count - 1;
+
+	if (end_address < HPR_HE5672_PARAMS_ADDR ||
+		param->address > HPR_HE5672_PARAMS_ADDR + HPR_HE5672_PARAMS_COUNT - 1) {
+		pr_debug("%s: bus_index=%d, module=%d: updated addr=0x%04X, count=%d - ignore\n",
+				__func__, port->data.bus_index, port->data.module_addr,
+				param->address, param->count);
+		return;
+	}
+
+	/* cut count by end position */
+	if (end_address > HPR_HE5672_PARAMS_ADDR + HPR_HE5672_PARAMS_COUNT - 1) {
+		count = HPR_HE5672_PARAMS_COUNT - (param->address - HPR_HE5672_PARAMS_ADDR);
+	} else {
+		count = param->count;
+	}
+
+	/* calc start addr and index */
+	if (param->address < HPR_HE5672_PARAMS_ADDR) {
+		start_address = HPR_HE5672_PARAMS_ADDR;
+		src_index = HPR_HE5672_PARAMS_ADDR - param->address;
+	} else {
+		start_address = param->address;
+		src_index = 0;
+	}
+	dst_index = start_address - HPR_HE5672_PARAMS_ADDR;
+
+	/* update values */
+	while (src_index < count) {
+		pr_debug("%s: updating param %d: 0x%04x(old) --> 0x%04x(new)\n",
+				__func__, dst_index, 
+				port->data.priv.he5672.params[dst_index],
+				param->values.s[src_index]);
+		port->data.priv.he5672.params[dst_index++] = param->values.s[src_index++];
+	}
+
+	/* validate */
+	if (port->data.priv.he5672.params[HPR_HE5672_PIDX_UART_CONN] == HPR_HE5672_UART_DIRECT) {
+		port->data.flags.invalid = 1;
+		pr_debug("%s: port (bus_index=%d, module=%d) is set to 'direct UART'\n",
+			__func__, port->data.bus_index, port->data.module_addr);
+	} else {
+		port->data.flags.invalid = 0;
+	}
+	pr_debug("%s: port (bus_index=%d, module=%d) 'direct UART' value=%d, invalid=%d\n",
+		__func__, port->data.bus_index, port->data.module_addr, 
+		port->data.priv.he5672.params[HPR_HE5672_PIDX_UART_CONN], port->data.flags.invalid);
+}
+
+#ifdef HPR_SERIAL_TEST2
+static void test_update_config(hpr_serial_port *port, hpr_param_arg *param)
+{
+	int real_addr = param->address;
+	param->address = param->address -13 + HPR_HE5672_PARAMS_ADDR;
+	he5672_update_config(port, param);
+	param->address = real_addr;
+}
+#endif
+
+static int he5672_set_port_config(hpr_serial_port *port)
+{
+	int r;
+	hpr_param_arg param;
+	unsigned short pv[HPR_HE5672_PARAMS_COUNT];
+
+	param.count = HPR_HE5672_PARAMS_COUNT;
+	param.address = HPR_HE5672_PARAMS_ADDR;
+	param.values.s = pv;
+	param.type = HPR_PT_INT;
+
+#ifdef HPR_SERIAL_TEST2
+	if (port->data.hw_id !=  HPR_HWID_HE5672) {
+		param.address = 13;
+	}
+#endif
+
+	r = hpr_get_module_params_in_scan(port->data.bus_index, port->data.module_addr, &param);
+	if (r) {
+		port->data.flags.invalid = 1;
+		pr_warning("%s: failed to get port config - invalidate port (bus_index=%d, module=%d)\n",
+				__func__, port->data.bus_index, port->data.module_addr);
+		return r;
+	}
+
+	/* translate config */
+#ifdef HPR_SERIAL_TEST2
+	if (port->data.hw_id !=  HPR_HWID_HE5672) {
+		test_update_config(port, &param);
+	} else {
+		he5672_update_config(port, &param);
+	}
+#else
+	he5672_update_config(port, &param);
+#endif
+	
+	return 0;
+}
+
+static int hpr_serial_register_port(hpr_bus *bus, hpr_module *module)
+{
+	int r;
+	hpr_serial_port *port;
+
+	port = kzalloc(sizeof(hpr_serial_port), GFP_KERNEL);
+	if (!port) {
+		pr_err("%s: failed to alloc hpr serial port for bus_index=%d, module=%d\n",
+			__func__, bus->index, module->params.member.module_address);
+		return -ENOMEM;
+	}
+
+	port->data.bus_index = bus->index;
+	port->data.module_addr = module->params.member.module_address;
+	port->data.hw_id = module->params.member.hardware_id;
+
+	switch (port->data.hw_id) {
+		case HPR_HWID_HE5672:
+			port->set_config = he5672_set_port_config;
+			port->update_config = he5672_update_config;
+			break;
+		default:
+			pr_warning("%s: registering UNKNOWN serial port, hw_id=0x%04x\n",
+					__func__, port->data.hw_id);
+
+#ifdef HPR_SERIAL_TEST1
+			port->set_config = he5672_set_port_config;
+#ifdef HPR_SERIAL_TEST2
+			port->update_config = test_update_config;
+#else
+			port->update_config = he5672_update_config;
+#endif
+#endif
+			break;
+	}
+
+	/* ignore rc */ 
+	if (port->set_config) {
+		r = port->set_config(port);
+	}
+
+	port->pdev.name = HPR_SERIAL_DRIVER_NAME;
+	port->pdev.id = hpr_serial_dev_id++;
+	port->pdev.dev.platform_data = &port->data;
+	port->pdev.dev.release = dev_release;
+
+	r = platform_device_register(&port->pdev);
+	if (r) {
+		pr_err("%s: failed to register hpr serial port platform device: id=%d, r=%d\n", 
+			__func__, port->pdev.id, r);
+		hpr_serial_dev_id--;
+		kfree(port);
+		return r;
+	}
+
+	list_add_tail(&port->list, &hpr_serial_ports);
+	module->serial_port_data = &port->data;
+
+	pr_debug("%s: registerd port=%d (bus_index=%d, module=%d)\n", 
+		__func__, port->pdev.id, port->data.bus_index, port->data.module_addr);
+	return 0;
+}
+
+static void hpr_serial_unregister_port(hpr_serial_port *port)
+{
+	pr_debug("%s: unregistering port=%d (bus_index=%d, module=%d)\n", 
+		__func__, port->pdev.id, port->data.bus_index, port->data.module_addr);
+	list_del(&port->list);
+	platform_device_unregister(&port->pdev);
+	kfree(port);
+}
+
+static void hpr_serial_validate_ports(hpr_bus *bus)
+{
+	hpr_module *m;
+	hpr_serial_port *port;
+	
+	list_for_each_entry(port, &hpr_serial_ports, list) {
+		if (port->data.bus_index != bus->index) {
+			continue;
+		}
+
+		/* can't be < 1: see register port function, but can be > count after incomplete rescan */
+		if (unlikely(port->data.module_addr > bus->modules_count)) {
+			port->data.flags.invalid = 1;
+			pr_debug("%s: bus_index=%d: port=%d made INVALID (addr=%d > count=%d)\n", 
+				__func__, port->data.bus_index, port->pdev.id, 
+				port->data.module_addr, bus->modules_count);
+			continue;
+		}
+		
+		m = &bus->modules[port->data.module_addr - 1].module;
+		if (port->data.hw_id != m->params.member.hardware_id) {
+			port->data.flags.invalid = 1;
+			pr_debug("%s: bus_index=%d, module=%d: port=%d made INVALID (hw:old=0x%04X, current=0x%04X)\n", 
+					__func__, port->data.bus_index, port->data.module_addr,
+					port->pdev.id, port->data.hw_id, m->params.member.hardware_id);
+			continue;
+		}
+
+		m->flags.pab_async_one_shot = 1;
+		m->serial_port_data = &port->data;
+		pr_debug("%s: bus_index=%d, module=%d: set as 'oneshot', port data linked\n",
+				__func__, port->data.bus_index, port->data.module_addr);
+
+		/* set config including direct UART(valid/invalid) */
+		if (port->set_config) {
+			port->set_config(port);
+		}
+
+		pr_debug("%s: bus_index=%d, module=%d: set invalid=%d\n",
+				__func__, port->data.bus_index, port->data.module_addr, 
+				port->data.flags.invalid);
+	}
+}
+
+/* Interface methods */
+
+void hpr_serial_add_or_update_ports(int bus_index)
+{
+	int r;
+	hpr_bus *bus;
+	hpr_module *m;
+	int i;
+
+	r = get_bus_by_index(bus_index, &bus);
+	if (r) {
+		return;
+	}
+	pr_debug("%s: bus index=%d got => bus=%d\n", __func__, bus_index, bus->id);
+
+//	if (!bus->scan_count) {
+	if (list_empty(&hpr_serial_ports)) {
+		/* like a first scan - create serial devices */
+		for (i = 0; i < bus->modules_count; i++) {
+			m = &bus->modules[i].module;
+			if (is_hpr_serial_module(m->params.member.hardware_id)) {
+				m->flags.pab_async_one_shot = 1;
+				r = hpr_serial_register_port(bus, m);
+			}
+		}
+	} else {
+		/* NOT fist scan - check serial devices and invalidate as need */
+		hpr_serial_validate_ports(bus);
+	}
+}
+
+void hpr_serial_free_ports(void)
+{
+	hpr_serial_port *port, *n;
+	
+	list_for_each_entry_safe(port, n, &hpr_serial_ports, list) {
+		hpr_serial_unregister_port(port);
+	}
+}
+
+void hpr_serial_update_port_config(hpr_serial_port_data *data, 
+										hpr_param_arg *param)
+{
+	hpr_serial_port *port = hpr_serial_data_to_port(data);
+	
+	if (port->update_config) {
+		port->update_config(port, param);
+	}
+}
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_serial.h linux-3.0.x-arm/drivers/misc/hpr/hpr_serial.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_serial.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_serial.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,14 @@
+#ifndef _HPR_SERIAL_H_
+#define _HPR_SERIAL_H_
+
+#include <linux/list.h>
+#include <linux/hpr/hpr_serial.h>
+#include <linux/hpr/hpr.h>
+
+extern void hpr_serial_add_or_update_ports(int bus_index);
+extern void hpr_serial_free_ports(void);
+
+extern void hpr_serial_update_port_config(hpr_serial_port_data *data, 
+										hpr_param_arg *param);
+
+#endif /*_HPR_SERIAL_H_*/
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_uart.c linux-3.0.x-arm/drivers/misc/hpr/hpr_uart.c
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_uart.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_uart.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,1208 @@
+/*
+ *  HPR UART Driver for AT91 processor family
+ *
+ *  Copyright (C) 2010 Softerra LLC
+ *
+ */
+
+/* linux headers */
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+/* at91-specific headers */
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/at91_pmc.h>
+
+#include <linux/atmel_serial.h>
+
+/* hpr drv headers */
+#include "hpr_bus.h"
+#include "hpr_pab.h"
+#include "hpr_ioctl.h"
+#include "hpr_frame.h"
+#include "hpr_crc.h"
+#include "hpr_uart.h"
+#include "hpr_serial.h"
+
+/* dma */
+#include <linux/dma-mapping.h>
+#include <linux/atmel_pdc.h>
+#include <linux/mm.h>
+
+#define HPR_DRV_VERSION "1.12.1/lx30"
+
+#define HPR_UART_BPS 500000
+
+static int bus_count = 1;
+static int bus_ids[HPR_MAX_BUS_COUNT] = { 1, };
+module_param_array(bus_ids, int, &bus_count, S_IRUGO);
+MODULE_PARM_DESC(bus_ids, "IDs of HPR buses (UARTs) to use (0-" __MODULE_STRING(HPR_MAX_BUS_COUNT) ")");
+
+/* specify default modules count by max possible address */
+static int nr_modules = HPR_MAX_MODULE_ADDRESS;
+module_param(nr_modules, int, S_IRUGO);
+MODULE_PARM_DESC(nr_modules, "Modules count per bus");
+
+static int nr_inputs = 500;
+module_param(nr_inputs, int, S_IRUGO);
+MODULE_PARM_DESC(nr_inputs, "PAB inputs count per bus");
+
+static int nr_outputs = 500;
+module_param(nr_outputs, int, S_IRUGO);
+MODULE_PARM_DESC(nr_outputs, "PAB outputs count per bus");
+
+static int tv_count = 0;
+static int tv[3];
+module_param_array(tv, int, &tv_count, S_IRUGO);
+MODULE_PARM_DESC(tv, "Default timing values: trto(ms),rxto(usec),exi(ms)");
+
+static int tvscan_count = 0;
+static int tvscan[3];
+module_param_array(tvscan, int, &tvscan_count, S_IRUGO);
+MODULE_PARM_DESC(tvscan, "Scan timing values: trto(ms),rxto(usec),exi(ms)");
+
+static u64 uart_dmamask = DMA_BIT_MASK(32);
+
+/* 
+ * Timeout for 1st char when getting 20 params has the next values: 
+ * HE5675 (0x2750) - to=125
+ * EnOcean(0x2700) & DALI (0x2710) - to=100
+ * DO8 (0x6000) - to=75 or less ?
+ */
+hpr_timing hpr_timing_default = {
+	.trto = CONFIG_HZ == 100 ? 2 : 3, 	/* restrict time for complete send-receive transfer: Ttx + Ttxirq + Treaction - 20ms(2jiffies for CONFIG_HZ=100, 3ms(3jiffies) for CONFIG_HZ=1000 */
+	/* timeout of receiving any next char after 1st char received: 
+	 * for 1 char = time of (1 start + 9 data + 1 stop bits = 11 bits) = 11 ticks
+	 * so we may use 11 or 12 here
+	 * Actually use value of Tsilence to ensure the last: "..3byte times" = 3 * 11 = 33 ticks * 2usec = 66 usec 
+	 */
+	.rxto = 33,
+	.exi = 0, 							/* 0 for usual exchange (rxto is waited to provide Tsilence) */
+};
+hpr_timing hpr_timing_scan = {
+	.trto = CONFIG_HZ == 100 ? 2 : 3,
+	.rxto = 33,
+	.exi = 10, 						/* 10ms */
+};
+
+typedef struct {
+	int bus_id;			/* No. of USART */
+	unsigned int periph_id;		/* ID of peripheral device for getting irq or setting up clock */
+	unsigned int pin_dsychain;	/* PIO used for DSYHCOUT line */
+
+	unsigned char* membase; 	/* USART registers */
+	struct clk *clk;
+	unsigned int clk_rate;
+
+	/* transfer stuff */
+	hpr_timing timing;					/* current timing settings for the bus*/
+
+	unsigned short *tx_dma_buf;
+	unsigned short *rx_dma_buf;
+
+	wait_queue_head_t tr_wait;			/* transfer wait queue */
+	void *tr_wake_task;				/* transfer thread ptr - used for wake_up_process() from irq handler */
+
+	int tr_status;
+	unsigned int rx_err_status;		/* if RX ends by some of error IRQs - the value of status */
+	struct {
+		unsigned tr_complete;
+		unsigned rx_requested;
+	} flags;
+
+	struct semaphore access_mutex;	/* bus hw access mutex */
+
+	struct miscdevice miscdev;	/* bus misc device for IOCTL interface */
+} hpr_uart_device;
+
+static int hpr_uart_open(struct inode *inode, struct file *file)
+{
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int hpr_uart_close(struct inode *inode, struct file *file)
+{
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+/* NOTE: for now we accept 
+ * - bus index starting with 0
+ * - module index starting with 0
+ */
+static long hpr_uart_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int r = 0;
+	hpr_ioctl_arg *parg;
+
+	switch (cmd) {
+		/*	arg: IOCTL structure pointer
+			return: result code + fill the structure pointed
+			requirements: scan bus excluded
+		*/
+		case HPR_GET_MODULE_DATA:
+			parg = (hpr_ioctl_arg *)arg;
+			if (!access_ok(VERIFY_READ, parg, sizeof(*parg))) {
+				pr_err("IOCTL: HPR_GET_MODULE_DATA: failed to get argument\n");
+				return -EFAULT;
+			}
+			if (!access_ok(VERIFY_WRITE, parg->u.module_data, sizeof(*parg->u.module_data))) {
+				pr_err("IOCTL: HPR_GET_MODULE_DATA: can't write to result structure\n");
+				return -EFAULT;
+			}
+
+			pr_debug("IOCTL: HPR_GET_MODULE_DATA: bus index=%d, module addr=%d\n", 
+				parg->bus_index, parg->module_address);
+			
+			r = hpr_get_module_data(parg->bus_index, parg->module_address, parg->u.module_data);
+			break;
+
+		/*	arg: IOCTL structure pointer
+			return: result code 
+			requirements: scan bus excluded
+			EXT MODE: HPR_ONE_SHOT_PVC: almost the same but firts module is set to one_shot mode
+		*/
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+		case HPR_ONE_SHOT_PVC:
+#endif
+		case HPR_RD_QUERY_SET:
+			parg = (hpr_ioctl_arg *)arg;
+			if (!access_ok(VERIFY_READ, parg, sizeof(*parg)) ||
+			    !access_ok(VERIFY_READ, parg->u.pv_query, sizeof(*(parg->u.pv_query)))) {
+				pr_err("IOCTL: HPR_RD_QUERY_SET: failed to get argument\n");
+				return -EFAULT;
+			}
+			if (!access_ok(VERIFY_WRITE, &parg->u.pv_query->status, 
+							sizeof(parg->u.pv_query->status)) ||
+			    !access_ok(VERIFY_WRITE, &parg->u.pv_query->in_channel, 
+							sizeof(parg->u.pv_query->in_channel))) {
+				pr_err("IOCTL: HPR_RD_QUERY_SET: can't write to result status/channel\n");
+				return -EFAULT;
+			}
+			
+			if (!access_ok(VERIFY_READ, parg->u.pv_query->out_data,
+							parg->u.pv_query->out_count * sizeof(hpr_pab))) {
+				pr_err("IOCTL: HPR_RD_QUERY_SET: can't read OUT data buffer\n");
+				return -EFAULT;
+			}
+			if (!access_ok(VERIFY_WRITE, parg->u.pv_query->in_data,
+							parg->u.pv_query->in_count * sizeof(hpr_pab))) {
+				pr_err("IOCTL: HPR_RD_QUERY_SET: can't write to IN data buffer\n");
+				return -EFAULT;
+			}
+
+			pr_debug("IOCTL: HPR_RD_QUERY_SET: bus index=%d, module addr=%d, sync=%d\n", 
+				parg->bus_index, parg->module_address, parg->u.pv_query->sync);
+
+#ifdef CONFIG_ATMEL_HPR_EXT_MODE
+			if (cmd == HPR_ONE_SHOT_PVC) {
+				/* should fail or perform one shot exchange */
+				r = hpr_one_shot_async_exchange(parg->bus_index, 
+						parg->module_address, parg->u.pv_query);
+				break;
+			}
+#endif
+
+			if (parg->u.pv_query->sync) {
+				r = hpr_sync_pab_data_exchange(parg->bus_index, 
+						parg->module_address, parg->u.pv_query);
+			} else {
+				r = hpr_user_pab_data_exchange(parg->bus_index, 
+						parg->module_address, parg->u.pv_query);
+			}
+			break;
+
+		/* 	arg: no arg
+			return: bus count value itself 
+			requirements: no req.
+		*/
+		case HPR_GET_BUS_NUMBER:
+			r = hpr_get_bus_count();
+			pr_debug("IOCTL: HPR_GET_BUS_NUMBER: return bus count=%d\n", r);
+			break;
+
+		/*	arg: bus index constant 
+			return: result code
+			requirements: exclusions implemented inside
+		*/
+		case HPR_START_GROUP_COMM:
+			r = hpr_start_group_work((int)arg);
+			pr_debug("IOCTL: HPR_START_GROUP_COMM: r=%d\n", r);
+			break;
+			
+		/*	arg: bus index constant (one of specified by module's bus_ids param)
+			return: result code
+			requirements: exclusions implemented inside
+		*/
+		case HPR_STOP_GROUP_COMM:
+			r = hpr_stop_group_work((int)arg);
+			pr_debug("IOCTL: HPR_STOP_GROUP_COMM: r=%d\n", r);
+			break;
+
+		/*	arg: bus index constant 
+			return: result code (0 - success, < 0 - error)
+			requirements: exclusions implemented inside
+		*/
+		case HPR_START_SCAN_BUS:
+			r = hpr_start_scan_bus_work((int)arg);
+			pr_debug("IOCTL: HPR_START_SCAN_BUS: r=%d\n", r);
+			break;
+			
+		/*	arg: bus index constant (one of specified by module's bus_ids param)
+			return: result code (0 - success, < 0 - error)
+			requirements: exclusions implemented inside
+		*/
+		case HPR_STOP_SCAN_BUS:
+			r = hpr_stop_scan_bus_work((int)arg);
+			pr_debug("IOCTL: HPR_STOP_SCAN_BUS: r=%d\n", r);
+			break;
+
+		/*	arg: bus index constant
+			return: result code >= 0 (SBC_*)
+			requirements: exclusions implemented inside
+		*/
+		case HPR_GET_SCAN_BUS_COMPLETE:
+			r = hpr_get_scan_bus_status((int)arg);
+			pr_debug("IOCTL: HPR_GET_SCAN_BUS_COMPLETE: r=%d\n", r);
+			break;
+
+		/*	arg: bus index constant (one of specified by module's bus_ids param)
+			return: module count value itself >= 0 or error code < 0
+			requirements: scan bus excluded
+		*/
+		case HPR_GET_MODULES_NUMBER:
+			r = hpr_get_module_count((int)arg);
+			pr_debug("IOCTL: HPR_GET_MODULES_NUMBER: r=%d\n", r);
+			break;
+
+		case HPR_GET_MODULE_PARAMS:
+		case HPR_SET_MODULE_PARAMS:
+			{
+				size_t value_size;
+				int values_verify;
+
+				parg = (hpr_ioctl_arg *)arg;
+				if (!access_ok(VERIFY_READ, parg, sizeof(*parg))) {
+					pr_err("IOCTL: HPR_GET/SET_MODULE_PARAMS: failed to get argument\n");
+					return -EFAULT;
+				}
+				if (!access_ok(VERIFY_WRITE, parg->u.param.ack, sizeof(parg->u.param.ack))) {
+					pr_err("IOCTL: HPR_GET/SET_MODULE_PARAMS: wrong buffer for ack code\n");
+					return -EFAULT;
+				}
+
+				/* type */
+				switch (parg->u.param.type) {
+					case HPR_PT_INT:
+						value_size = sizeof(short);
+						/* do not check address for HPR_PA_FLOAT 'cause there is at least one module with
+						 * float param at address 0x402 */
+#if 0
+						if (parg->u.param.address >= HPR_PA_FLOAT) {
+							pr_err("IOCTL: HPR_GET/SET_MODULE_PARAMS: invalid param address for int: 0x%x\n", 
+								parg->u.param.address);
+							return -EINVAL;
+						}
+#endif
+						break;
+					case HPR_PT_FLOAT:
+						value_size = sizeof(float);
+						/* do not check address for HPR_PA_FLOAT 'cause there is at least one module with
+						 * float param at address 0x402 */
+						break;
+					default:
+						pr_err("IOCTL: HPR_GET/SET_MODULE_PARAMS: invalid param type arg\n");
+						return -EINVAL;
+						break;
+				}
+
+				/* get/set */
+				if (cmd == HPR_GET_MODULE_PARAMS) {
+					values_verify = VERIFY_WRITE;
+				} else {
+					values_verify = VERIFY_READ;
+					if (!parg->u.param.count || !parg->u.param.values.v) {
+						pr_err("IOCTL: HPR_SET_MODULE_PARAMS_INT: provided no values to set\n");
+						return -EINVAL;
+					}
+				}
+			
+				/* check userspace source/result buffer */
+				if (!access_ok(values_verify, parg->u.param.values.v, 
+							parg->u.param.count * value_size)) {
+					pr_err("IOCTL: HPR_GET/SET_MODULE_PARAMS: wrong source/result value buffer\n");
+					return -EFAULT;
+				}
+
+				if (cmd == HPR_GET_MODULE_PARAMS) {
+					r = hpr_get_module_params(parg->bus_index, 
+									parg->module_address, 
+									&parg->u.param);
+					pr_debug("IOCTL: HPR_GET_MODULE_PARAMS: r=%d\n", r);
+				} else {
+					r = hpr_set_module_params(parg->bus_index, 
+									parg->module_address, 
+									&parg->u.param);
+					pr_debug("IOCTL: HPR_SET_MODULE_PARAMS: r=%d\n", r);
+				}
+				
+			} /* end case of get/set params */
+			break;
+
+		default:
+			r = -EINVAL;
+			break;
+	}
+
+	return r;
+}
+
+static ssize_t hpr_uart_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
+{
+	return -EPERM;
+}
+
+static ssize_t hpr_uart_write(struct file *file, const char __user *buffer, size_t count, loff_t *offset)
+{
+	return -EPERM;
+}
+
+static struct file_operations hpr_uart_fops =
+{
+	owner:			THIS_MODULE,
+	open:			hpr_uart_open,
+	release:			hpr_uart_close,
+	unlocked_ioctl:	hpr_uart_ioctl,
+	read:			hpr_uart_read,
+	write:			hpr_uart_write,
+};
+
+/* specify here all supported HPR UART devices */
+static hpr_uart_device hpr_uart_devices[] = 
+{
+	/* our current bus at UART 1 */
+	{
+		.bus_id = 1,
+		.periph_id = AT91SAM9263_ID_US1,
+		.pin_dsychain = AT91_PIN_PB26,
+	
+		.miscdev={
+			.minor = MISC_DYNAMIC_MINOR,
+			.name = "hpr_uart",
+			.fops = &hpr_uart_fops,
+		},
+	},
+};
+const int hpr_uart_count = sizeof(hpr_uart_devices) / sizeof(hpr_uart_device);
+
+static inline hpr_uart_device *get_device_by_bus_id(int bus_id)
+{
+	int i;
+	for (i = 0; i < hpr_uart_count; i++) {
+		if (hpr_uart_devices[i].bus_id == bus_id) {
+			pr_debug("%s: found device for bus=%d\n", __func__, bus_id);
+			return &hpr_uart_devices[i];
+		}
+	}
+	pr_debug("%s: device for bus=%d not found\n", __func__, bus_id);
+	return NULL;
+}
+
+void hpr_set_bus_timing(int bus_id, hpr_timing *timing)
+{
+	hpr_uart_device *uart_dev;
+
+	uart_dev = get_device_by_bus_id(bus_id);
+	if (!uart_dev) {
+		pr_err("%s: invalid bus=%d\n", __func__, bus_id);
+		return;
+	}
+
+	if (timing) {
+		uart_dev->timing = *timing;
+	} else {
+		uart_dev->timing = hpr_timing_default;
+	}
+}
+
+/* IRQ handling */
+
+/* Define ATMEL_HPR_DEBUG_IRQ to count and display
+ * statistics on interrupts handled by the driver.
+ */
+//#define ATMEL_HPR_DEBUG_IRQ
+#undef ATMEL_HPR_DEBUG_IRQ
+
+#ifdef ATMEL_HPR_DEBUG_IRQ
+/* debug counters and values */
+static int irq_total_count = 0;
+static int irq_timeout_count = 0;
+static int irq_tx_count = 0;
+static int irq_rx_count = 0;
+static int irq_unknown_count = 0;
+static int irq_error_count = 0;
+#endif
+
+/* called from IRQ handler */
+static inline void tr_done(hpr_uart_device *uart_dev, int tr_status)
+{
+	/* disable all previously enabled RX interrupts */
+	__raw_writel(ATMEL_US_ENDRX | ATMEL_US_RXBUFF | ATMEL_US_TIMEOUT |
+				ATMEL_US_OVRE | ATMEL_US_FRAME | ATMEL_US_PARE | ATMEL_US_RXBRK, 
+				uart_dev->membase + ATMEL_US_IDR);
+
+	/* set status to return */
+	uart_dev->tr_status = tr_status;
+
+	/* signal that reception is completed */
+	uart_dev->flags.tr_complete = 1;
+	wake_up_process(uart_dev->tr_wake_task);
+}
+
+/*  - don't accumulate CRC, 
+ * - read char ASAP, then process other interrupts, 
+ * - stop reading on timeout only
+ */
+static irqreturn_t hpr_uart_interrupt(int irq, void *dev_id)
+{
+	unsigned int status;
+	unsigned int pending;
+	hpr_uart_device *uart_dev = (hpr_uart_device *)dev_id;
+
+#ifdef ATMEL_HPR_DEBUG_IRQ
+	irq_total_count++;
+#endif
+
+	/* read channel status */
+	status = __raw_readl(uart_dev->membase + ATMEL_US_CSR);
+	/* get interrupt mask */
+	pending = status & (__raw_readl(uart_dev->membase + ATMEL_US_IMR));
+
+	if (pending & (ATMEL_US_OVRE | ATMEL_US_FRAME | ATMEL_US_PARE | ATMEL_US_RXBRK)) {
+#ifdef ATMEL_HPR_DEBUG_IRQ
+		irq_error_count++;
+#endif
+		uart_dev->rx_err_status = status;	/* save status code for err report */
+		tr_done(uart_dev, -EUARTRX);
+		return IRQ_HANDLED;
+	}
+
+	if (pending & ATMEL_US_TIMEOUT) {
+#ifdef ATMEL_HPR_DEBUG_IRQ
+		irq_timeout_count++;
+#endif
+		/* need check CRC later to determine: timeout or correct frame got */
+		tr_done(uart_dev, -ETIMEOUT);
+		return IRQ_HANDLED;
+	}
+
+	/* PDC transimt complete? */
+	if (pending & (ATMEL_US_ENDTX | ATMEL_US_TXBUFE)) {
+#ifdef ATMEL_HPR_DEBUG_IRQ
+		irq_tx_count++;
+#endif
+		if (uart_dev->flags.rx_requested) {
+			/* start RX with TO still off - wait the 1st char */
+			__raw_writel(ATMEL_US_RXEN, uart_dev->membase + ATMEL_US_CR);
+		}
+
+		/* disable TX interrupts, PDC for TX, transmitter */	
+		__raw_writel(ATMEL_US_ENDTX | ATMEL_US_TXBUFE, uart_dev->membase + ATMEL_US_IDR);
+
+		if (!uart_dev->flags.rx_requested) {
+			/* like tr_done(), but status will be set later to 0 (OK) */
+			uart_dev->flags.tr_complete = 1;
+			wake_up_process(uart_dev->tr_wake_task);
+		}
+		return IRQ_HANDLED;
+	}
+
+	/* PDC receive complete - frame is bigger than allowed */
+	if (pending & (ATMEL_US_ENDRX | ATMEL_US_RXBUFF)) {
+#ifdef ATMEL_HPR_DEBUG_IRQ
+		irq_rx_count++;
+#endif
+		tr_done(uart_dev, -EHPRFRAME);
+		return IRQ_HANDLED;
+	}
+
+	/* unknown irq */
+#ifdef ATMEL_HPR_DEBUG_IRQ
+		irq_unknown_count++;
+#endif
+	return IRQ_HANDLED;
+}
+
+static void uart_process_transfer_result(hpr_uart_device *uart_dev,
+						unsigned char *in_frame, unsigned char *in_length)
+{
+	int i;
+	int len;
+	int rx_count;
+
+	if (in_length) {
+		*in_length = 0;
+	}
+
+	if (!uart_dev->flags.tr_complete) {
+		uart_dev->tr_status = -ETIMEOUT;
+		/* this is pretty normal if no more modules left on the bus when scanning */
+		pr_notice("%s: transfer timed out (try another 'trto' timing value)\n", __func__);
+		return;
+	}
+
+	/* flag tr_complete=1 */
+
+	if (!uart_dev->flags.rx_requested) {
+		pr_debug("%s: TX only done OK\n", __func__);
+		uart_dev->tr_status = 0;
+		return;
+	}
+
+	if (uart_dev->tr_status != -ETIMEOUT) {
+		/* other bad error */
+		if (uart_dev->tr_status == -EUARTRX) {
+			pr_err("%s: transfer failed: %d (EUARTRX): status=0x%08X\n", 
+				__func__, uart_dev->tr_status, uart_dev->rx_err_status);
+		} else {
+			/* must be -EHPRFRAME */
+			pr_err("%s: transfer failed: %d\n", __func__, uart_dev->tr_status);
+		}
+		return;
+	}
+
+	/* further is the case of ETIMEOUT =>
+	  *    check if anything received and then check CRC => OK or EHPRCRC 
+	  */
+	rx_count = 0;
+	len = __raw_readl(uart_dev->membase + ATMEL_PDC_RCR);
+	len = HPR_MAX_FRAME_SIZE + 1 - len;
+	for (i = 0; i < len; i++) {
+		in_frame[rx_count++] = uart_dev->rx_dma_buf[i] & 0x1ff;
+	}
+	pr_debug("%s: received: %d chars\n", __func__, rx_count);
+
+	/* need check CRC to determine: timeout or correct frame got */
+	if (rx_count > 1) { /* it is not possible HPR frame contained only CRC - it must contain at least FC/Address */
+		unsigned char crc_lo;
+		crc_lo = calculate_low_crc16(in_frame, rx_count - 1);
+		if (crc_lo == in_frame[rx_count - 1]) {
+			/* correct frame got */
+			uart_dev->tr_status = 0;
+		}
+		pr_debug("%s: RECV status: count=%d, crc_lo=0x%02x, last byte=0x%02x, status=%d\n",
+				__func__, rx_count, crc_lo, rx_count ? in_frame[rx_count - 1] : 0xff,
+				uart_dev->tr_status);
+	}
+	
+	/* TIMEOUT is left => EHPRCRC (wrong or incomplete frame got) */
+	if (uart_dev->tr_status) {
+		uart_dev->tr_status = -EHPRCRC;
+		pr_err("%s: transfer failed: wrong len/CRC (or try another 'rxto' timing value)\n", __func__);
+	}
+
+	*in_length = rx_count;
+}
+
+/* ret HPR_RC_* */
+static int uart_send_receive(hpr_uart_device *uart_dev, unsigned char *in_frame, 
+				unsigned char *in_length, unsigned char *out_frame, 
+				unsigned char out_length)
+{
+	unsigned char i;
+	dma_addr_t tx_dma_addr = 0, rx_dma_addr = 0;
+	int ticks = 0;
+	int uc_ier = 0, pdc_ptcr = 0;
+
+	/* assume out frame is present always */
+	dump_frame("OUT", uart_dev->bus_id, out_frame, out_length);
+
+	pr_debug("Current timing: trto=%d ms (%d jiffies), rxto=%d usec (%d ticks), exi=%d ms\n",
+		uart_dev->timing.trto * 1000 / CONFIG_HZ, uart_dev->timing.trto,
+		uart_dev->timing.rxto * (1000000 / HPR_UART_BPS), uart_dev->timing.rxto,
+		uart_dev->timing.exi);
+
+	ticks = jiffies;
+
+	uart_dev->flags.rx_requested = (in_frame != NULL) && (in_length != NULL);
+	uart_dev->flags.tr_complete = 0;
+	uart_dev->tr_wake_task = current;
+
+	/* copy packet to DMA specific buffer (each element is 2 bytes) */
+	uart_dev->tx_dma_buf[0] = out_frame[0] | 0x100L;
+	for (i = 1; i < out_length; i++) {
+		uart_dev->tx_dma_buf[i] = out_frame[i];
+	}
+
+	/* reset status, receiver and trasmitter */
+	__raw_writel(ATMEL_US_RSTSTA | ATMEL_US_RSTRX | ATMEL_US_RSTTX, uart_dev->membase + ATMEL_US_CR);
+	/* disable PDC for TX and RX */
+	__raw_writel(ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS, uart_dev->membase + ATMEL_PDC_PTCR);
+
+	/* map DMA buffer */
+	tx_dma_addr = dma_map_single(uart_dev->miscdev.this_device, 
+			uart_dev->tx_dma_buf, sizeof(unsigned short) * out_length, DMA_TO_DEVICE);
+	BUG_ON(!tx_dma_addr);
+	/* writing TX buffer's pointer to PDC */
+	__raw_writel(tx_dma_addr, uart_dev->membase + ATMEL_PDC_TPR);
+	/* writing count of bytes to translate to PDC */
+	__raw_writel(out_length, uart_dev->membase + ATMEL_PDC_TCR);
+
+
+	/* prepare receive stuff if incoming frame is expected */
+	if (uart_dev->flags.rx_requested) {
+		*in_length = 0;
+		
+		/* map DMA buffer */
+		rx_dma_addr = dma_map_single(uart_dev->miscdev.this_device, 
+				uart_dev->rx_dma_buf, sizeof(unsigned short) * (HPR_MAX_FRAME_SIZE + 1), DMA_FROM_DEVICE);
+		BUG_ON(!rx_dma_addr);
+		/* writing RX buffer's pointer to PDC */
+		__raw_writel(rx_dma_addr, uart_dev->membase + ATMEL_PDC_RPR);
+		/* writing count of bytes to receive to PDC */
+		__raw_writel(HPR_MAX_FRAME_SIZE + 1, uart_dev->membase + ATMEL_PDC_RCR);
+
+
+		/* setup receive timeout value */
+		__raw_writel(uart_dev->timing.rxto, uart_dev->membase + ATMEL_US_RTOR);
+		/* wait TO after 1st char received */
+		__raw_writel(ATMEL_US_STTTO, uart_dev->membase + ATMEL_US_CR);
+
+		uc_ier |= ATMEL_US_ENDRX | ATMEL_US_RXBUFF | ATMEL_US_TIMEOUT |
+					ATMEL_US_OVRE | ATMEL_US_FRAME | ATMEL_US_PARE | ATMEL_US_RXBRK;
+		pdc_ptcr |= ATMEL_PDC_RXTEN;
+	}
+
+	/* setup ALL interrupts */
+	__raw_writel(uc_ier | ATMEL_US_ENDTX | ATMEL_US_TXBUFE, uart_dev->membase + ATMEL_US_IER);
+	/* enable transmitter only */
+	__raw_writel(ATMEL_US_TXEN, uart_dev->membase + ATMEL_US_CR);
+	/* enable PDC TX (and RX optionally) */
+	__raw_writel(pdc_ptcr | ATMEL_PDC_TXTEN, uart_dev->membase + ATMEL_PDC_PTCR);
+
+	/* wait until frame is transmitted and optionally received or until time is out
+	 * (receiving is started by the interrupt handler right after transmit is completed)
+	 */
+	wait_event_timeout(uart_dev->tr_wait, uart_dev->flags.tr_complete, uart_dev->timing.trto);
+
+	/* disable all interrupts in case we finished by timeout */
+	__raw_writel(0xffffffff, uart_dev->membase + ATMEL_US_IDR);
+
+	/* so interrupt handler or timer waked us up, no more interrupts assumed.
+	 * The worst case (is it possible? in RT-patch irq handler is called after real HW irq occurs):
+	 * 	TX irq handler is called here - but it may only: 
+	 *  		- enable US RX - which is safe - we'll disable PDC(RX,TX) in the next steps
+	 *  		- wake up this process - seems to be safe also - it just continue running
+	 */
+
+	/* disable US(TX, RX), PDC(TX, RX) */
+	__raw_writel(ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS, uart_dev->membase + ATMEL_PDC_PTCR);
+	__raw_writel(ATMEL_US_RXDIS | ATMEL_US_TXDIS, uart_dev->membase + ATMEL_US_CR);
+
+	/* cleanup after DMA transfer: unmap TX DMA buffer */
+	dma_unmap_single(uart_dev->miscdev.this_device, tx_dma_addr, 
+				sizeof(unsigned short) * out_length, DMA_TO_DEVICE);
+	if (uart_dev->flags.rx_requested) {
+		/* cleanup after DMA transfer: unmap RX DMA buffer */
+		dma_unmap_single(uart_dev->miscdev.this_device, rx_dma_addr, 
+					sizeof(unsigned short) * (HPR_MAX_FRAME_SIZE + 1), DMA_FROM_DEVICE);
+		/* reset timeout counter */	
+		__raw_writel(0x0, uart_dev->membase + ATMEL_US_RTOR);	
+	}
+
+	/* process results */
+	uart_process_transfer_result(uart_dev, in_frame, in_length);
+
+	ticks = jiffies - ticks;
+	pr_debug("%s: tranfer's taken %d ticks (%d - %d ms)\n", 
+			__func__, ticks, ticks * 1000 / CONFIG_HZ, (ticks + 1) * 1000 / CONFIG_HZ);
+
+#ifdef ATMEL_HPR_DEBUG_IRQ
+	pr_info("HPR IRQ INFO: "
+		"total=%d: timeout=%d, tx=%d, rx(bad frame)=%d, unknown=%d, error=%d, error_status=0x%08x\n", 
+		irq_total_count, irq_timeout_count,
+		irq_tx_count, irq_rx_count,
+		irq_unknown_count, irq_error_count, uart_dev->rx_err_status);
+#endif
+
+	if (uart_dev->flags.rx_requested) {
+		dump_frame("IN", uart_dev->bus_id, in_frame, *in_length);
+	}
+
+	/* some delay may be required between frames*/
+	if (uart_dev->timing.exi > 0) {
+		msleep(uart_dev->timing.exi);
+	}
+
+	return uart_dev->tr_status;
+}
+
+static int uart_send_receive_retry(hpr_uart_device *uart_dev, 
+					hpr_frame *out_frame, hpr_frame *in_frame)
+{
+	int r;
+	int retry_count_to = HPR_RETRY_COUNT_TO;
+	int retry_count_rx = HPR_RETRY_COUNT_RX;
+	int rx_retry = 0;
+
+	do {
+		r = uart_send_receive(uart_dev, in_frame->data, &in_frame->length,
+						out_frame->data, out_frame->length);
+		if (r) {
+			if (r == -ETIMEOUT) {
+				if (rx_retry) {
+					rx_retry = 0;
+					retry_count_to = HPR_RETRY_COUNT_TO;
+				}
+				if (--retry_count_to <= 0) {
+					break;
+				}
+			} else {
+				rx_retry = 1;
+				if (--retry_count_rx <= 0) {
+					break;
+				}
+			}
+		}
+	} while(r);
+
+	return r;
+}
+
+/* return -E* or OK or TIMEOUT, so TIMEOUT can be handled separately */
+int hpr_send(int bus_id, hpr_frame *frame, int count)
+{
+	int r;
+	hpr_uart_device *uart_dev;
+
+	uart_dev = get_device_by_bus_id(bus_id);
+	if (!uart_dev) {
+		pr_err("%s: invalid bus=%d\n", __func__, bus_id);
+		return -EINVAL;
+	}
+	if (!frame || !frame->length) {
+		pr_err("%s: invalid out frame or length, bus=%d\n", __func__, bus_id);
+		return -EINVAL;
+	}
+
+	down(&uart_dev->access_mutex);
+
+	do {
+		r = uart_send_receive(uart_dev, NULL, 0, frame->data, frame->length);
+		if (r) {
+			break;
+		}
+	} while (--count > 0);
+
+	up(&uart_dev->access_mutex);
+
+	return r;
+}
+
+/* return -E* or OK or TIMEOUT, so TIMEOUT can be handled separately */
+int hpr_send_receive(int bus_id, hpr_frame *out_frame, hpr_frame *in_frame)
+{
+	int r;
+	hpr_uart_device *uart_dev;
+
+	uart_dev = get_device_by_bus_id(bus_id);
+	if (!uart_dev) {
+		pr_err("%s: invalid bus=%d\n", __func__, bus_id);
+		return -EINVAL;
+	}
+
+	if (unlikely(!out_frame || !out_frame->length || !in_frame)) {
+		pr_err("%s: wrong out=%p or in=%p frame param(s), bus=%d\n", 
+			__func__, out_frame, in_frame, bus_id);
+		return -EINVAL;
+	}
+
+	down(&uart_dev->access_mutex);
+	r = uart_send_receive_retry(uart_dev, out_frame, in_frame);
+	up(&uart_dev->access_mutex);
+
+	return r;
+}
+
+void daisy_chain_low(int bus_id)
+{
+	hpr_uart_device *uart_dev;
+	uart_dev = get_device_by_bus_id(bus_id);
+	if (!uart_dev) {
+		pr_err("%s: invalid bus=%d\n", __func__, bus_id);
+		return;
+	}
+	at91_set_gpio_value(uart_dev->pin_dsychain, 0);
+}
+
+void daisy_chain_high(int bus_id)
+{
+	hpr_uart_device *uart_dev;
+	uart_dev = get_device_by_bus_id(bus_id);
+	if (!uart_dev) {
+		pr_err("%s: invalid bus=%d\n", __func__, bus_id);
+		return;
+	}
+	at91_set_gpio_value(uart_dev->pin_dsychain, 1);
+}
+
+static inline int set_uart_baudrate(hpr_uart_device *uart_dev, unsigned int baudrate)
+{
+	unsigned int quot;
+
+	if (baudrate != 0) {
+		//quot = ((uartclk + (8 * baud)) / (16 * baud)) / 8;
+		//quot = ((uartclk + (8 * baud)) / (16 * baud));
+		quot = ((uart_dev->clk_rate + (8 * baudrate)) / (8 * baudrate)); //bit OVER is set
+	} else {
+		return -EINVAL;
+	}
+
+	__raw_writel(quot, uart_dev->membase + ATMEL_US_BRGR);
+
+	return 0;
+}
+
+static int register_uart_bus(hpr_uart_device *uart_dev)
+{
+	int r;
+	unsigned int base;
+	unsigned int pin_rx, pin_tx, pin_rts;
+	const char *clk_name;
+	unsigned int mode;
+
+	switch (uart_dev->bus_id) {
+	case 0:
+		base = AT91SAM9263_BASE_US0;
+		pin_rx = AT91_PIN_PA27;
+		pin_tx = AT91_PIN_PA26;
+		pin_rts = AT91_PIN_PA28; /* A */
+		clk_name = "usart0_clk";
+		mode = ATMEL_US_PAR_NONE | ATMEL_US_NBSTOP_1 | ATMEL_US_MODE9;
+		break;
+	case 1:
+		base = AT91SAM9263_BASE_US1;
+		pin_rx = AT91_PIN_PD1;
+		pin_tx = AT91_PIN_PD0;
+		pin_rts = AT91_PIN_PD7; /* B */
+		clk_name = "usart1_clk";
+		mode = ATMEL_US_PAR_NONE | ATMEL_US_NBSTOP_1 | ATMEL_US_MODE9 | ATMEL_US_OVER | ATMEL_US_USMODE_RS485;
+		break;
+	case 2:
+		base = AT91SAM9263_BASE_US2;
+		pin_rx = AT91_PIN_PD3;
+		pin_tx = AT91_PIN_PD2;
+		pin_rts = AT91_PIN_PD5; /* B */
+		clk_name = "usart2_clk";
+		mode = ATMEL_US_PAR_NONE | ATMEL_US_NBSTOP_1 | ATMEL_US_MODE9 | ATMEL_US_USMODE_RS485;
+		break;
+	default:
+		pr_err("%s: invalid bus=%d\n", __func__, uart_dev->bus_id);
+		return -EINVAL;
+	}
+
+	/* first map uart memory */
+	uart_dev->membase = ioremap(base, 1024);
+	if (!uart_dev->membase) {
+		pr_err("%s: failed to map bus=%d IO memory\n", __func__, uart_dev->bus_id);
+		return -ENOMEM;
+	}
+
+	/* then setup uart */
+
+	/* reset transmitter, receiver, so they stop any activity and become disabled */
+	__raw_writel(ATMEL_US_RSTRX | ATMEL_US_RSTTX, uart_dev->membase + ATMEL_US_CR);
+
+	/* setup rx, tx, rts, dsychain pins w/o pullup */
+	at91_set_A_periph(pin_rx, 0);
+	at91_set_A_periph(pin_tx, 0);
+	if (uart_dev->bus_id == 0) {
+		at91_set_A_periph(pin_rts, 0);
+	} else {
+		at91_set_B_periph(pin_rts, 0);
+	}
+	if (uart_dev->pin_dsychain) {
+		at91_set_gpio_output(uart_dev->pin_dsychain, 0);
+	}
+
+	/* setup clock */
+	uart_dev->clk = clk_get(0, clk_name);
+	if (IS_ERR(uart_dev->clk)) {
+		pr_err("%s: failed to get uart clock '%s', bus=%d\n", 
+			__func__, clk_name, uart_dev->bus_id);
+		r = (int)uart_dev->clk;
+		goto err_clk;
+	}
+	clk_enable(uart_dev->clk);
+	uart_dev->clk_rate= clk_get_rate(uart_dev->clk);
+	/* enable periperal clock for UART */
+	at91_sys_write(AT91_PMC_PCER, uart_dev->periph_id);
+
+	/* set mode */
+	__raw_writel(mode, uart_dev->membase + ATMEL_US_MR);	// set 9 bit N1 mode
+
+	r = set_uart_baudrate(uart_dev, HPR_UART_BPS);
+	if (r) {
+		pr_err("%s: failed to set baudrate, bus=%d\n", __func__, uart_dev->bus_id);
+		goto err_baudrate;
+	}
+
+	/* register isr */
+#ifdef CONFIG_PREEMPT_RT
+	r = request_irq(uart_dev->periph_id, &hpr_uart_interrupt, IRQF_NODELAY, "hpr_uart", uart_dev);
+#else
+	r = request_irq(uart_dev->periph_id, &hpr_uart_interrupt, 0, "hpr_uart", uart_dev);
+#endif
+
+	if (r) {
+		pr_err("%s: failed to register isr for bus=%d, err=%d\n", 
+			__func__, uart_dev->bus_id, r);
+		goto err_irq;
+	}
+
+	/* init TX DMA buffer */
+	uart_dev->tx_dma_buf = kmalloc(sizeof(unsigned short) * HPR_MAX_FRAME_SIZE, GFP_KERNEL);
+	if (!uart_dev->tx_dma_buf) {
+		pr_err("%s: failed to alloc TX dma buffer\n", __func__);
+		r = -ENOMEM;
+		goto err_tx_buf;
+	}
+
+	/* init RX DMA buffer: max frame size + 1 char to be sure HPR frame has correct length */
+	uart_dev->rx_dma_buf = kmalloc(sizeof(unsigned short) * (HPR_MAX_FRAME_SIZE + 1), GFP_KERNEL);
+	if (!uart_dev->rx_dma_buf) {
+		pr_err("%s: failed to alloc RX dma buffer\n", __func__);
+		r = -ENOMEM;
+		goto err_rx_buf;
+	}
+
+	/* finally register misc device */
+	r = misc_register(&uart_dev->miscdev);
+	if (r) {
+		pr_err("%s: failed to register misc device for bus=%d, err=%d\n", 
+			__func__, uart_dev->bus_id, r);
+		goto err_misc;
+	}
+
+	/* set DMA params */
+	uart_dev->miscdev.this_device->dma_mask = &uart_dmamask;
+	uart_dev->miscdev.this_device->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	sema_init(&uart_dev->access_mutex, 1);
+
+	uart_dev->timing = hpr_timing_default;
+	init_waitqueue_head(&uart_dev->tr_wait);
+
+	return 0;
+
+err_misc:
+	kfree(uart_dev->rx_dma_buf);
+	uart_dev->rx_dma_buf = NULL;
+
+err_rx_buf:
+	kfree(uart_dev->tx_dma_buf);
+	uart_dev->tx_dma_buf = NULL;
+	
+err_tx_buf:
+	free_irq(uart_dev->periph_id, uart_dev);
+	
+err_irq:
+err_baudrate:
+	clk_disable(uart_dev->clk);
+	clk_put(uart_dev->clk);
+	uart_dev->clk = ERR_PTR(-ENOENT);
+	
+err_clk:
+	iounmap(uart_dev->membase);
+	uart_dev->membase = NULL;
+	return r;
+}
+
+static void unregister_uart_bus(hpr_uart_device *uart_dev)
+{
+	misc_deregister(&uart_dev->miscdev);
+
+	if (uart_dev->rx_dma_buf) {
+		kfree(uart_dev->rx_dma_buf);
+		uart_dev->rx_dma_buf = NULL;
+	}
+
+	if (uart_dev->tx_dma_buf) {
+		kfree(uart_dev->tx_dma_buf);
+		uart_dev->tx_dma_buf = NULL;
+	}
+
+	free_irq(uart_dev->periph_id, uart_dev);
+
+	if (!IS_ERR(uart_dev->clk)) {
+		clk_disable(uart_dev->clk);
+		clk_put(uart_dev->clk);
+		uart_dev->clk = ERR_PTR(-ENOENT);
+	}
+
+	if (uart_dev->membase) {
+		iounmap(uart_dev->membase);
+		uart_dev->membase = NULL;
+	}
+}
+
+static int parse_timing_param(const char* name, int count, int param[], hpr_timing *timing)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (param[i] == -1) {
+			/* leave default value */
+			continue;
+		}
+		switch (i) {
+			case 0:
+				/* trto, ms => jiffies */
+				if (param[i] < 1 || param[i] > 1000) {
+					pr_err("invalid %s trto value: 1...1000 ms\n", name);
+					return -1;
+				}
+				/* convert to jiffies */
+				timing->trto = param[i] * CONFIG_HZ / 1000;
+				if (!timing->trto) {
+					timing->trto = 1; /* at least 1 jiffy in any case */
+				}
+				break;
+				
+			case 1:
+				/* rxto, usec => ticks */
+				if (param[i] < 2 || param[i] > 131070) {
+					pr_err("invalid %s rxto value: 2...131070 usec\n", name);
+					return -1;
+				}
+				timing->rxto = param[i] * (HPR_UART_BPS / 1000) / 1000;
+				break;
+
+			case 2:
+				/* exi, ms */
+				if (param[i] < 0 || param[i] > 100) {
+					pr_err("invalid %s exi value: 0...100 ms\n", name);
+					return -1;
+				}
+				timing->exi = param[i];
+				break;
+		}
+	}
+	pr_info("  %s timing: trto=%d ms (%d jiffies), rxto=%d usec (%d ticks), exi=%d ms\n",
+		name,
+		timing->trto * 1000 / CONFIG_HZ, timing->trto,
+		timing->rxto * (1000000 / HPR_UART_BPS), timing->rxto,
+		timing->exi);
+	return 0;
+}
+
+static int __init hpr_uart_init(void)
+{
+	int r = 0;
+	int i;
+	int count = 0;		/* count of registered buses */
+
+	pr_info("HPR UART driver v.%s\n", HPR_DRV_VERSION);
+
+	r = parse_timing_param("Default", tv_count, tv, &hpr_timing_default);
+	if (r) {
+		return -EINVAL;
+	}
+
+	r = parse_timing_param("Scan", tvscan_count, tvscan, &hpr_timing_scan);
+	if (r) {
+		return -EINVAL;
+	}
+
+	r = hpr_pab_setup_poll_interval();
+	if (r) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < bus_count; i++) {
+		hpr_uart_device *uart_dev = get_device_by_bus_id(bus_ids[i]);
+		if (!uart_dev) {
+			pr_warning("  * bus=%d is not registered: device is not specified\n", bus_ids[i]);
+			break;
+		}
+
+		r = register_uart_bus(uart_dev);
+		if (r) {
+			pr_warning("  * bus=%d is not registered: err=%d\n", bus_ids[i], r);
+			break;
+		}
+
+		pr_info("  * bus=%d registered (index=%d)\n", bus_ids[i], i);
+		count++;
+	}
+
+	if (!count) {
+		pr_err("  * no hpr uart device is registered\n");
+		return -EPERM;
+	}
+	bus_count = count;	/* override count of actually registered buses - i.e. allow partial functionality */
+
+	/* allocate data for only those buses which were successfully registered */
+	r = hpr_init_bus_data(bus_count, bus_ids, nr_modules, nr_inputs, nr_outputs);
+	if (r) {
+		/* cleanup */
+		for (i = 0; i < bus_count; i++) {
+			hpr_uart_device *uart_dev = get_device_by_bus_id(bus_ids[i]);
+			if (uart_dev) {
+				unregister_uart_bus(uart_dev);
+			}
+		}
+		return r;
+	}
+
+	pr_info("  Bus count=%d, buses: ", bus_count);
+	for (i = 0; i < bus_count; i++) {
+		if (i > 0) {
+			printk(", ");
+		}
+		printk("%d (index=%d)", bus_ids[i], i);
+	}
+	printk("\n");
+	pr_info("  Allocated per bus: modules=%d, inputs=%d, outputs=%d\n",
+		nr_modules, nr_inputs, nr_outputs);
+
+	return 0;
+}
+
+static void __exit hpr_uart_exit(void)
+{
+	int i;
+
+	pr_info("HPR UART driver unloading..\n");
+	for (i = 0; i < bus_count; i++) {
+		hpr_uart_device *uart_dev = get_device_by_bus_id(bus_ids[i]);
+		if (likely(uart_dev)) {
+			unregister_uart_bus(uart_dev);
+			pr_info("  * bus=%d (index=%d) unregistered\n", bus_ids[i], i);
+		}
+	}
+
+	/* free serial ports if such present */
+	hpr_serial_free_ports();
+
+	/* free buses data only after all buses unregistered */
+	hpr_free_bus_data();
+	pr_info("  Done.\n");
+}
+
+module_init(hpr_uart_init);
+module_exit(hpr_uart_exit);
+
+MODULE_AUTHOR("Alex Dsugan");
+MODULE_DESCRIPTION("AT91 HPR UART Driver");
+MODULE_LICENSE("GPL");
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/hpr_uart.h linux-3.0.x-arm/drivers/misc/hpr/hpr_uart.h
--- linux-3.0.x-orig/drivers/misc/hpr/hpr_uart.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/hpr_uart.h	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,21 @@
+#ifndef _HPR_UART_H
+#define _HPR_UART_H
+
+typedef struct hpr_timing {
+	int trto;			/* transfer(send-receive) timeout in jiffies >= 1, got from param in ms >= 1 <= 1000  */
+	int rxto;			/* timeout of receiving any next char after 1st char received: RX timeout in UART clock ticks 1 -65535, got from param in usec 2 - 131070 */
+	int exi;			/* exchange interval in ms 0 - 100 - delay after each send-receive, got from param in ms */
+} hpr_timing;
+
+extern void hpr_set_bus_timing(int bus_id, hpr_timing *timing);
+
+extern int hpr_send(int bus_id, hpr_frame *frame, int count);
+extern int hpr_send_receive(int bus_id, hpr_frame *out_frame, hpr_frame *in_frame);
+
+extern hpr_timing hpr_timing_default;
+extern hpr_timing hpr_timing_scan;
+
+extern void daisy_chain_low(int bus_id);
+extern void daisy_chain_high(int bus_id);
+
+#endif
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/Kconfig linux-3.0.x-arm/drivers/misc/hpr/Kconfig
--- linux-3.0.x-orig/drivers/misc/hpr/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/Kconfig	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,38 @@
+menuconfig ATMEL_HPR
+	tristate "HPR protocol support for Atmel"
+	depends on ARCH_AT91 && ATMEL_TCLIB
+	help
+	  This option enables device driver support for HPR protocol
+
+if ATMEL_HPR
+
+config ATMEL_HPR_EXT_MODE
+	bool "Enable extra functionality"
+	depends on ATMEL_HPR
+	default n
+	help
+	  This is an option for use by developers; for production one
+	  should say N here. This enables extra functioinality which
+	  is not safe but can be used for development (e.g. setting any
+	  parameters but without ensuring data integrity).
+
+config ATMEL_HPR_DEBUG
+	bool "Enable driver debugging"
+	depends on ATMEL_HPR
+	default n
+	help
+	  This is an option for use by developers; most people should
+	  say N here. This adds a lot of debugging output to dmesg.
+
+if !ATMEL_HPR_DEBUG
+config ATMEL_HPR_DEBUG_FRAMES
+	bool "Enable debugging sent/received frames only"
+	depends on !ATMEL_HPR_DEBUG
+	default n
+	help
+	  This is an option for use by developers; most people should
+	  say N here. If debug is not enabled, this allows to dump only 
+	  frames sent/received.
+endif
+
+endif # ATMEL_HPR
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/hpr/Makefile linux-3.0.x-arm/drivers/misc/hpr/Makefile
--- linux-3.0.x-orig/drivers/misc/hpr/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/hpr/Makefile	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,6 @@
+ifeq ($(CONFIG_ATMEL_HPR_DEBUG),y)
+	EXTRA_CFLAGS		+= -DDEBUG
+endif
+
+obj-$(CONFIG_ATMEL_HPR) := hpr.o
+hpr-objs := hpr_uart.o hpr_crc.o hpr_frame.o hpr_serial.o hpr_scan.o hpr_pab.o hpr_bus.o
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/Kconfig linux-3.0.x-arm/drivers/misc/Kconfig
--- linux-3.0.x-orig/drivers/misc/Kconfig	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/Kconfig	2012-12-19 11:27:21.000000000 +0200
@@ -527,6 +527,22 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called pch_phub.
 
+config OWEN_PLC
+	tristate "OWEN's supervisor driver"
+	help
+	  If you use Owen's PLC110/110 devices this module is necessity. 
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called owen_plc.
+
+config OWEN_FLUSH
+	tristate "OWEN's flush driver"
+	help
+	  If you use Owen's devices this module is necessity. 
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called owen_plc.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -534,5 +550,6 @@
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
+source "drivers/misc/hpr/Kconfig"
 
 endif # MISC_DEVICES
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/Makefile linux-3.0.x-arm/drivers/misc/Makefile
--- linux-3.0.x-orig/drivers/misc/Makefile	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/Makefile	2012-12-19 11:27:21.000000000 +0200
@@ -34,6 +34,8 @@
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
 obj-$(CONFIG_C2PORT)		+= c2port/
+obj-$(CONFIG_OWEN_PLC)		+= owen_plc.o
+obj-$(CONFIG_OWEN_FLUSH)	+= flush.o
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
 obj-y				+= eeprom/
@@ -47,3 +49,4 @@
 obj-y				+= lis3lv02d/
 obj-y				+= carma/
 obj-$(CONFIG_HWLAT_DETECTOR)	+= hwlat_detector.o
+obj-y				+= hpr/
diff -x .svn -Nru linux-3.0.x-orig/drivers/misc/owen_plc.c linux-3.0.x-arm/drivers/misc/owen_plc.c
--- linux-3.0.x-orig/drivers/misc/owen_plc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/misc/owen_plc.c	2012-12-19 11:27:21.000000000 +0200
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2010 Softerra LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/completion.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+#define OWENPIC_DRV_NAME "owen_plc"
+
+#define PLC_MINOR  240
+
+#define PLC_IOCTL_BASE          'P'
+
+#define PLC_IOCTL_GET_TARGET_ID _IOR(PLC_IOCTL_BASE, 0, unsigned int)
+#define PLC_IOCTL_GET_USE_COUNT _IOR(PLC_IOCTL_BASE, 1, unsigned int)
+#define PLC_IOCTL_SV_CHECK      _IO(PLC_IOCTL_BASE, 2)
+#define PLC_IOCTL_SV_REGISTER   _IOW(PLC_IOCTL_BASE, 3, unsigned int)
+#define PLC_IOCTL_SV_UNREGISTER _IO(PLC_IOCTL_BASE, 4)
+#define PLC_IOCTL_SET_STARTUP   _IOW(PLC_IOCTL_BASE, 5, unsigned int)
+#define PLC_IOCTL_GET_STARTUP   _IOR(PLC_IOCTL_BASE, 6, unsigned int)
+
+static atomic_t use_count = ATOMIC_INIT(0);
+static u_int target_id = 0;
+static u_int startup_time = 0;
+static struct file *sv_file = 0;
+
+static int plc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int plc_open(struct inode *inode, struct file *file);
+static int plc_release(struct inode *inode, struct file *file);
+static int plc_lock(struct file *file, int, struct file_lock *lock);
+
+struct plc_private {
+  u_int is_locked;
+  u_int is_supervisor;
+};
+
+static int plc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+  u_int data;
+  int ret;
+  struct plc_private *priv = (struct plc_private *)file->private_data;
+
+  if (!priv->is_locked) {
+    return -EACCES;
+  }
+
+  switch (cmd) {
+    case PLC_IOCTL_GET_TARGET_ID:
+      return copy_to_user((u_int *)arg, &target_id, sizeof(target_id));
+    case PLC_IOCTL_GET_USE_COUNT:
+      data = atomic_read(&use_count);
+      return copy_to_user((u_int *)arg, &data, sizeof(data));
+    case PLC_IOCTL_SV_CHECK:
+      if (sv_file) {
+        return 0;
+      } else {
+        return -ENOENT;
+      }
+    case PLC_IOCTL_SV_REGISTER:
+      if (sv_file) {
+        return -EBUSY;
+      }
+      ret = copy_from_user(&data, (u_int *)arg, sizeof(data));
+      if (ret < 0) {
+        return ret;
+      }
+      sv_file = file;
+      priv->is_supervisor = 1;
+      if (target_id == 0) {
+        target_id = data;
+      }
+      return 0;
+    case PLC_IOCTL_SV_UNREGISTER:
+      if (file != sv_file) {
+        return -ENOENT;
+      }
+      sv_file = 0;
+      priv->is_supervisor = 0;
+      return 0;
+    case PLC_IOCTL_SET_STARTUP:
+      if (file != sv_file) {
+        return -EACCES;
+      }
+      if (startup_time != 0) {
+        return -EBUSY;
+      }
+      ret = copy_from_user(&data, (u_int *)arg, sizeof(data));
+      if (ret < 0) {
+        return ret;
+      }
+      startup_time = data;
+      return 0;
+    case PLC_IOCTL_GET_STARTUP:
+      return copy_to_user((u_int *)arg, &startup_time, sizeof(data));
+  }
+  return -EINVAL;
+}
+
+static int plc_lock(struct file *file, int cmd, struct file_lock *lock)
+{
+  struct plc_private *priv = (struct plc_private *)file->private_data;
+  if (cmd == F_SETLK || cmd == F_SETLKW) {
+    priv->is_locked = 1;
+  } else if (cmd == F_GETLK) {
+    priv->is_locked = 0;
+  }
+  return 0;
+}
+
+static int plc_open(struct inode *inode, struct file *file)
+{
+  struct plc_private *priv = kmalloc(sizeof(struct plc_private), GFP_KERNEL);
+  if (priv == 0) {
+    return -ENOMEM;
+  }
+  memset(priv, 0, sizeof(struct plc_private));
+  file->private_data = priv;
+  atomic_inc(&use_count);
+  return 0;
+}
+
+static int plc_release(struct inode *inode, struct file *file)
+{
+  struct plc_private *priv = (struct plc_private *)file->private_data;
+  if (priv->is_supervisor != 0) {
+    sv_file = 0;
+  }
+  kfree(file->private_data);
+  file->private_data = 0;
+  atomic_dec(&use_count);
+  return 0;
+}
+
+static struct file_operations fops = {
+  owner: THIS_MODULE,
+  ioctl: plc_ioctl,
+  open:  plc_open,
+  release: plc_release,
+  lock: plc_lock,
+};
+
+static struct miscdevice plcdev = {
+  PLC_MINOR,
+  "plc",
+  &fops
+};
+
+static int __init owen_plc_init(void)
+{
+	int ret;
+
+	ret = misc_register(&plcdev);
+	if (ret < 0)
+	{
+	   printk(KERN_ERR "plc: can't misc_register on minor=%d (errno=%d)\n", PLC_MINOR, ret);
+	   return ret;
+	}
+
+	return 0;
+}
+
+static void owen_plc_exit(void)
+{
+	misc_deregister(&plcdev);
+}
+
+
+MODULE_AUTHOR("Mikhail Lodigin, Softerra LLC");
+MODULE_DESCRIPTION("OWEN's supervisor driver for OWEN's PLC100/110 boards");
+MODULE_LICENSE("GPL");
+
+module_init(owen_plc_init);
+module_exit(owen_plc_exit);
diff -x .svn -Nru linux-3.0.x-orig/drivers/mmc/host/omap_hsmmc.c linux-3.0.x-arm/drivers/mmc/host/omap_hsmmc.c
--- linux-3.0.x-orig/drivers/mmc/host/omap_hsmmc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mmc/host/omap_hsmmc.c	2012-12-21 19:17:32.000000000 +0200
@@ -192,8 +192,7 @@
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
 
-	/* NOTE: assumes card detect signal is active-low */
-	return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+	return gpio_get_value_cansleep(mmc->slots[0].switch_pin) == mmc->slots[0].switch_level;
 }
 
 static int omap_hsmmc_get_wp(struct device *dev, int slot)
@@ -1257,6 +1256,7 @@
 	if (carddetect)
 		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
 	else
+/*TODO: SPK210VAR: what's up to the SD card rider? Should we use bigger delay, e.g. >=1sec? */
 		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
 }
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/chips/cfi_cmdset_0001.c linux-3.0.x-arm/drivers/mtd/chips/cfi_cmdset_0001.c
--- linux-3.0.x-orig/drivers/mtd/chips/cfi_cmdset_0001.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/chips/cfi_cmdset_0001.c	2013-09-20 18:29:46.000000000 +0300
@@ -2536,6 +2536,67 @@
 	}
 }
 
+#if defined(CONFIG_OWEN_FLASH_SETUP_ON_WATCHDOG)
+static void print_word(const char *prefix, struct map_info *map, map_word word)
+{
+	int i;
+	pr_info("%s", prefix);
+	for (i = 0; i < map_words(map); i++) {
+		printk(" %08lX", word.x[i]);
+	}
+	printk("\n");
+}
+void cfi_setup_for_reset(struct map_info *map, unsigned long ofs)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	map_word status, status_READY = CMD(0x80);
+	map_word status_SUSPEND = CMD(0x44);
+
+#if 0
+	{
+		struct flchip *chip;
+		int i;
+
+		pr_info("%s: map_words=%d, numchips=%d\n", __func__, map_words(map), cfi->numchips);
+		for (i = 0; i < cfi->numchips; i++) {
+			chip = &cfi->chips[i];
+			pr_info("%s: chip %d: state=%d\n", __func__, i, chip->state);
+		}
+	}
+#endif
+	
+	/* force reading status register */
+	map_write(map, CMD(0x70), ofs);
+	status = map_read(map, ofs);
+	print_word("current flash status:", map, status);
+
+	/* wait for finish of the current op if busy */
+	while (!map_word_andequal(map, status, status_READY, status_READY)) {
+		status = map_read(map, ofs);
+	}
+	print_word("flash is ready, status:", map, status);
+
+	while (map_word_bitsset(map, status, status_SUSPEND)) {
+		pr_info("resume suspended activity\n");
+		map_write(map, CMD(0xD0), ofs);
+		udelay(50);
+		/* wait while it finishes */
+		do {
+			status = map_read(map, ofs);
+		} while (!map_word_andequal(map, status, status_READY, status_READY));
+		print_word("suspended activity done, status:", map, status);
+	}
+
+	/* clear status */
+	map_write(map, CMD(0x50), ofs);
+	pr_info("status register cleared (0x50)\n");
+
+	/* switch into Read Array mode */
+	map_write(map, CMD(0xFF), ofs);
+	pr_info("flash switched into Read Array mode (0xFF)\n");
+}
+#endif
+
 static void cfi_intelext_resume(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/maps/physmap.c linux-3.0.x-arm/drivers/mtd/maps/physmap.c
--- linux-3.0.x-orig/drivers/mtd/maps/physmap.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/maps/physmap.c	2013-09-20 18:29:46.000000000 +0300
@@ -84,6 +84,29 @@
 static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", "afs",
 					  NULL };
 
+#if defined(CONFIG_OWEN_FLASH_SETUP_ON_WATCHDOG)
+extern void cfi_setup_for_reset(struct map_info *map, unsigned long ofs);
+
+void physmap_flash_setup_for_reset(void *data)
+{
+	struct platform_device *dev = (struct platform_device *)data;
+	struct physmap_flash_info *info;
+	int i;
+
+	if (!dev)
+		return;
+	
+	info = (struct physmap_flash_info *)platform_get_drvdata(dev);
+
+	for (i = 0; i < dev->num_resources; i++) {
+		if (info->mtd[i] != NULL) {
+			pr_info("complete flash operations and set physmap-flash into Read Array mode (map %d)\n", i);
+			cfi_setup_for_reset(&info->map[i], 0);
+		}
+	}
+}
+#endif
+
 static int physmap_flash_probe(struct platform_device *dev)
 {
 	struct physmap_flash_data *physmap_data;
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/atmel_nand.c linux-3.0.x-arm/drivers/mtd/nand/atmel_nand.c
--- linux-3.0.x-orig/drivers/mtd/nand/atmel_nand.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/atmel_nand.c	2012-12-19 11:26:59.000000000 +0200
@@ -485,6 +485,17 @@
 #endif
 
 /*
+ * Mode strings for various ECC types
+ * (This should correspond to nand_ecc_modes_t enum in include/linux/mtd/nand.h)
+ */
+static const char *ecc_modes[] __initdata = {
+	"No",
+	"Software",
+	"Hardware",
+	"Hardware with Syndrome"
+};
+
+/*
  * Probe for the NAND device.
  */
 static int __init atmel_nand_probe(struct platform_device *pdev)
@@ -553,6 +564,7 @@
 			res = -EIO;
 			goto err_ecc_ioremap;
 		}
+
 		nand_chip->ecc.mode = NAND_ECC_HW;
 		nand_chip->ecc.calculate = atmel_nand_calculate;
 		nand_chip->ecc.correct = atmel_nand_correct;
@@ -648,6 +660,11 @@
 		}
 	}
 
+	printk(KERN_INFO "AT91 NAND: %i-bit, %s ECC\n",
+		(nand_chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
+		ecc_modes[nand_chip->ecc.mode]
+	);
+
 	/* second phase scan */
 	if (nand_scan_tail(mtd)) {
 		res = -ENXIO;
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/Kconfig linux-3.0.x-arm/drivers/mtd/nand/Kconfig
--- linux-3.0.x-orig/drivers/mtd/nand/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/Kconfig	2012-12-19 11:26:59.000000000 +0200
@@ -355,9 +355,18 @@
 	prompt "ECC management for NAND Flash / SmartMedia on AT91 / AVR32"
 	depends on MTD_NAND_ATMEL
 
+config MTD_NAND_ATMEL_ECC_SOFT
+	bool "Software ECC"
+	help
+	  Use software ECC.
+
+	  NB : hardware and software ECC schemes are incompatible.
+	  If you switch from one to another, you'll have to erase your
+	  mtd partition.
+
 config MTD_NAND_ATMEL_ECC_HW
 	bool "Hardware ECC"
-	depends on ARCH_AT91SAM9263 || ARCH_AT91SAM9260 || AVR32
+	depends on ARCH_AT91SAM9263 || ARCH_AT91SAM9260 || ARCH_AT91SAM9G20 || ARCH_AT91SAM9RL || ARCH_AT91CAP9 || AVR32
 	help
 	  Use hardware ECC instead of software ECC when the chip
 	  supports it.
@@ -371,15 +380,6 @@
 
 	  If unsure, say Y
 
-config MTD_NAND_ATMEL_ECC_SOFT
-	bool "Software ECC"
-	help
-	  Use software ECC.
-
-	  NB : hardware and software ECC schemes are incompatible.
-	  If you switch from one to another, you'll have to erase your
-	  mtd partition.
-
 config MTD_NAND_ATMEL_ECC_NONE
 	bool "No ECC (testing only, DANGEROUS)"
 	depends on DEBUG_KERNEL
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/Makefile linux-3.0.x-arm/drivers/mtd/nand/Makefile
--- linux-3.0.x-orig/drivers/mtd/nand/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/Makefile	2012-12-19 11:26:59.000000000 +0200
@@ -29,7 +29,7 @@
 obj-$(CONFIG_MTD_NAND_NDFC)		+= ndfc.o
 obj-$(CONFIG_MTD_NAND_ATMEL)		+= atmel_nand.o
 obj-$(CONFIG_MTD_NAND_GPIO)		+= gpio.o
-obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o
+obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o omap_bch_decoder.o
 obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/nand_base.c linux-3.0.x-arm/drivers/mtd/nand/nand_base.c
--- linux-3.0.x-orig/drivers/mtd/nand/nand_base.c	2013-09-19 17:39:49.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/nand_base.c	2012-12-19 11:26:59.000000000 +0200
@@ -735,6 +735,8 @@
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
 			       NAND_NCE | NAND_CTRL_CHANGE);
 
+		dmb();
+
 		/* This applies to read commands */
 	default:
 		/*
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/omap2.c linux-3.0.x-arm/drivers/mtd/nand/omap2.c
--- linux-3.0.x-orig/drivers/mtd/nand/omap2.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/omap2.c	2012-12-19 11:26:59.000000000 +0200
@@ -96,6 +96,8 @@
 
 static const char *part_probes[] = { "cmdlinepart", NULL };
 
+int decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc);
+
 /* oob info generated runtime depending on ecc algorithm and layout selected */
 static struct nand_ecclayout omap_oobinfo;
 /* Define some generic bad / good block scan pattern which are used
@@ -128,7 +130,8 @@
 		OMAP_NAND_IO_WRITE,	/* write */
 	} iomode;
 	u_char				*buf;
-	int					buf_len;
+	int				buf_len;
+	int				ecc_opt;
 };
 
 /**
@@ -525,7 +528,6 @@
 	struct omap_nand_info *info = container_of(mtd,
 						struct omap_nand_info, mtd);
 	int ret = 0;
-
 	if (len <= mtd->oobsize) {
 		omap_read_buf_pref(mtd, buf, len);
 		return;
@@ -805,6 +807,8 @@
 							mtd);
 	int blockCnt = 0, i = 0, ret = 0;
 	int stat = 0;
+	int j, eccsize, eccflag, count;
+	unsigned int err_loc[8];
 
 	/* Ex NAND_ECC_HW12_2048 */
 	if ((info->nand.ecc.mode == NAND_ECC_HW) &&
@@ -813,18 +817,61 @@
 	else
 		blockCnt = 1;
 
-	for (i = 0; i < blockCnt; i++) {
-		if (memcmp(read_ecc, calc_ecc, 3) != 0) {
-			ret = omap_compare_ecc(read_ecc, calc_ecc, dat);
-			if (ret < 0)
-				return ret;
-			/* keep track of the number of corrected errors */
-			stat += ret;
-		}
-		read_ecc += 3;
-		calc_ecc += 3;
-		dat      += 512;
+	switch (info->ecc_opt) {
+	case OMAP_ECC_HAMMING_CODE_HW:
+	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
+		for (i = 0; i < blockCnt; i++) {
+			if (memcmp(read_ecc, calc_ecc, 3) != 0) {
+				ret = omap_compare_ecc(read_ecc, calc_ecc, dat);
+				if (ret < 0)
+					return ret;
+				/* keep track of the number of corrected errors */
+				stat += ret;
+			}
+			read_ecc += 3;
+			calc_ecc += 3;
+			dat      += 512;
+		}
+		break;
+
+	case OMAP_ECC_BCH4_CODE_HW:
+		eccsize = 7;
+		gpmc_calculate_ecc(info->ecc_opt, info->gpmc_cs, dat, calc_ecc);
+		for (i = 0; i < blockCnt; i++) {
+			/* check if any ecc error */
+			eccflag = 0;
+			for (j = 0; (j < eccsize) && (eccflag == 0); j++)
+				if (calc_ecc[j] != 0)
+					eccflag = 1;
+
+			if (eccflag == 1) {
+				eccflag = 0;
+				for (j = 0; (j < eccsize) &&
+						(eccflag == 0); j++)
+					if (read_ecc[j] != 0xFF)
+						eccflag = 1;
+			}
+
+			count = 0;
+			if (eccflag == 1) {
+				count = decode_bch(0, calc_ecc, err_loc);
+				stat += count;
+			}
+
+			for (j = 0; j < count; j++) {
+				if (err_loc[j] < 4096)
+					dat[err_loc[j] >> 3] ^=
+							1 << (err_loc[j] & 7);
+				/* else, not interested to correct ecc */
+			}
+
+			calc_ecc = calc_ecc + eccsize;
+			read_ecc = read_ecc + eccsize;
+			dat += 512;
+		}
+		break;
 	}
+
 	return stat;
 }
 
@@ -845,7 +892,7 @@
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 							mtd);
-	return gpmc_calculate_ecc(info->gpmc_cs, dat, ecc_code);
+	return gpmc_calculate_ecc(info->ecc_opt, info->gpmc_cs, dat, ecc_code);
 }
 
 /**
@@ -860,7 +907,8 @@
 	struct nand_chip *chip = mtd->priv;
 	unsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;
 
-	gpmc_enable_hwecc(info->gpmc_cs, mode, dev_width, info->nand.ecc.size);
+	gpmc_enable_hwecc(info->ecc_opt, info->gpmc_cs, mode,
+				dev_width, info->nand.ecc.size);
 }
 
 /**
@@ -957,10 +1005,14 @@
 	info->mtd.priv		= &info->nand;
 	info->mtd.name		= dev_name(&pdev->dev);
 	info->mtd.owner		= THIS_MODULE;
+	pdata->ecc_opt		= OMAP_ECC_BCH4_CODE_HW;
+	info->ecc_opt		= pdata->ecc_opt;
 
 	info->nand.options	= pdata->devsize;
 	info->nand.options	|= NAND_SKIP_BBTSCAN;
 
+	info->nand.badblockbits = 8;
+
 	/* NAND write protect off */
 	gpmc_cs_configure(info->gpmc_cs, GPMC_CONFIG_WP, 0);
 
@@ -995,7 +1047,6 @@
 		info->nand.waitfunc = omap_wait;
 		info->nand.chip_delay = 50;
 	}
-
 	switch (pdata->xfer_type) {
 	case NAND_OMAP_PREFETCH_POLLED:
 		info->nand.read_buf   = omap_read_buf_pref;
@@ -1056,10 +1107,17 @@
 	/* selsect the ecc type */
 	if (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_DEFAULT)
 		info->nand.ecc.mode = NAND_ECC_SOFT;
-	else if ((pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW) ||
-		(pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE)) {
-		info->nand.ecc.bytes            = 3;
-		info->nand.ecc.size             = 512;
+	else {
+		if (pdata->ecc_opt == OMAP_ECC_BCH4_CODE_HW) {
+			info->nand.ecc.bytes    = 4*7;
+			info->nand.ecc.size     = 4*512;
+		} else if (pdata->ecc_opt == OMAP_ECC_BCH8_CODE_HW) {
+			info->nand.ecc.bytes    = 13;
+			info->nand.ecc.size     = 4*512;
+		} else {
+			info->nand.ecc.bytes    = 3;
+			info->nand.ecc.size     = 512;
+		}
 		info->nand.ecc.calculate        = omap_calculate_ecc;
 		info->nand.ecc.hwctl            = omap_enable_hwecc;
 		info->nand.ecc.correct          = omap_correct_data;
@@ -1077,8 +1135,8 @@
 		}
 	}
 
-	/* rom code layout */
-	if (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE) {
+	/* select ecc lyout */
+	if (info->nand.ecc.mode != NAND_ECC_SOFT) {
 
 		if (info->nand.options & NAND_BUSWIDTH_16)
 			offset = 2;
@@ -1086,15 +1144,31 @@
 			offset = 1;
 			info->nand.badblock_pattern = &bb_descrip_flashbased;
 		}
-		omap_oobinfo.eccbytes = 3 * (info->mtd.oobsize/16);
-		for (i = 0; i < omap_oobinfo.eccbytes; i++)
-			omap_oobinfo.eccpos[i] = i+offset;
-
-		omap_oobinfo.oobfree->offset = offset + omap_oobinfo.eccbytes;
-		omap_oobinfo.oobfree->length = info->mtd.oobsize -
-					(offset + omap_oobinfo.eccbytes);
 
+		if (info->mtd.oobsize == 64)
+			omap_oobinfo.eccbytes = info->nand.ecc.bytes *
+						2048/info->nand.ecc.size;
+		else
+			omap_oobinfo.eccbytes = info->nand.ecc.bytes;
+
+		if (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE) {
+			for (i = 0; i < omap_oobinfo.eccbytes; i++)
+				omap_oobinfo.eccpos[i] = i + offset;
+			omap_oobinfo.oobfree->offset =
+						offset + omap_oobinfo.eccbytes;
+			omap_oobinfo.oobfree->length = info->mtd.oobsize -
+						offset - omap_oobinfo.eccbytes;
+		} else {
+
+			omap_oobinfo.oobfree->offset = offset;
+			omap_oobinfo.oobfree->length = info->mtd.oobsize -
+						offset - omap_oobinfo.eccbytes;
+			offset = info->mtd.oobsize - omap_oobinfo.eccbytes;
+			for (i = 0; i < omap_oobinfo.eccbytes; i++)
+				omap_oobinfo.eccpos[i] = i + offset;
+		}
 		info->nand.ecc.layout = &omap_oobinfo;
+
 	}
 
 	/* second phase scan */
diff -x .svn -Nru linux-3.0.x-orig/drivers/mtd/nand/omap_bch_decoder.c linux-3.0.x-arm/drivers/mtd/nand/omap_bch_decoder.c
--- linux-3.0.x-orig/drivers/mtd/nand/omap_bch_decoder.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/mtd/nand/omap_bch_decoder.c	2012-12-19 11:26:59.000000000 +0200
@@ -0,0 +1,393 @@
+/*
+ * drivers/mtd/nand/omap_omap_bch_decoder.c
+ *
+ * Whole BCH ECC Decoder (Post hardware generated syndrome decoding)
+ *
+ * Copyright (c) 2007 Texas Instruments
+ *
+ * Author: Sukumar Ghorai <s-ghorai@ti.com
+ *		   Michael Fillinger <m-fillinger@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#undef DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#define mm		13
+#define kk_shorten	4096
+#define nn		8191	/* Length of codeword, n = 2**mm - 1 */
+
+#define PPP	0x201B	/* Primary Polynomial : x^13 + x^4 + x^3 + x + 1 */
+#define P	0x001B	/* With omitted x^13 */
+#define POLY	12	/* degree of the primary Polynomial less one */
+
+/**
+ * mpy_mod_gf - GALOIS field multiplier
+ * Input  : A(x), B(x)
+ * Output : A(x)*B(x) mod P(x)
+ */
+static unsigned int mpy_mod_gf(unsigned int a, unsigned int b)
+{
+	unsigned int R = 0;
+	unsigned int R1 = 0;
+	unsigned int k = 0;
+
+	for (k = 0; k < mm; k++) {
+
+		R = (R << 1) & 0x1FFE;
+		if (R1 == 1)
+			R ^= P;
+
+		if (((a >> (POLY - k)) & 1) == 1)
+			R ^= b;
+
+		if (k < POLY)
+			R1 = (R >> POLY) & 1;
+	}
+	return R;
+}
+
+/**
+ * chien - CHIEN search
+ *
+ * @location - Error location vector pointer
+ *
+ * Inputs  : ELP(z)
+ *	     No. of found errors
+ *	     Size of input codeword
+ * Outputs : Up to 8 locations
+ *	     No. of errors
+ */
+static int chien(unsigned int select_4_8, int err_nums,
+				unsigned int err[], unsigned int *location)
+{
+	int i, count; /* Number of dectected errors */
+	/* Contains accumulation of evaluation at x^i (i:1->8) */
+	unsigned int gammas[8] = {0};
+	unsigned int alpha;
+	unsigned int bit, ecc_bits;
+	unsigned int elp_sum;
+
+	ecc_bits = (select_4_8 == 0) ? 52 : 104;
+
+	/* Start evaluation at Alpha**8192 and decreasing */
+	for (i = 0; i < 8; i++)
+		gammas[i] = err[i];
+
+	count = 0;
+	for (i = 1; (i <= nn) && (count < err_nums); i++) {
+
+		/* Result of evaluation at root */
+		elp_sum = 1 ^ gammas[0] ^ gammas[1] ^
+				gammas[2] ^ gammas[3] ^
+				gammas[4] ^ gammas[5] ^
+				gammas[6] ^ gammas[7];
+
+		alpha = PPP >> 1;
+		gammas[0] = mpy_mod_gf(gammas[0], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-2 */
+		gammas[1] = mpy_mod_gf(gammas[1], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-2 */
+		gammas[2] = mpy_mod_gf(gammas[2], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-3 */
+		gammas[3] = mpy_mod_gf(gammas[3], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-4 */
+		gammas[4] = mpy_mod_gf(gammas[4], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-5 */
+		gammas[5] = mpy_mod_gf(gammas[5], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-6 */
+		gammas[6] = mpy_mod_gf(gammas[6], alpha);
+		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-7 */
+		gammas[7] = mpy_mod_gf(gammas[7], alpha);
+
+		if (elp_sum == 0) {
+			/* calculate bit position in main data area */
+			bit = ((i-1) & ~7)|(7-((i-1) & 7));
+			if (i >= 2 * ecc_bits)
+				location[count++] =
+					kk_shorten - (bit - 2 * ecc_bits) - 1;
+		}
+	}
+
+	/* Failure: No. of detected errors != No. or corrected errors */
+	if (count != err_nums) {
+		count = -1;
+		printk(KERN_ERR "BCH decoding failed\n");
+	}
+	for (i = 0; i < count; i++)
+		pr_debug("%d ", location[i]);
+
+	return count;
+}
+
+/* synd : 16 Syndromes
+ * return: gamaas - Coefficients to the error polynomial
+ * return: : Number of detected errors
+*/
+static unsigned int berlekamp(unsigned int select_4_8,
+			unsigned int synd[], unsigned int err[])
+{
+	int loop, iteration;
+	unsigned int LL = 0;		/* Detected errors */
+	unsigned int d = 0;	/* Distance between Syndromes and ELP[n](z) */
+	unsigned int invd = 0;		/* Inverse of d */
+	/* Intermediate ELP[n](z).
+	 * Final ELP[n](z) is Error Location Polynomial
+	 */
+	unsigned int gammas[16] = {0};
+	/* Intermediate normalized ELP[n](z) : D[n](z) */
+	unsigned int D[16] = {0};
+	/* Temporary value that holds an ELP[n](z) coefficient */
+	unsigned int next_gamma = 0;
+
+	int e = 0;
+	unsigned int sign = 0;
+	unsigned int u = 0;
+	unsigned int v = 0;
+	unsigned int C1 = 0, C2 = 0;
+	unsigned int ss = 0;
+	unsigned int tmp_v = 0, tmp_s = 0;
+	unsigned int tmp_poly;
+
+	/*-------------- Step 0 ------------------*/
+	for (loop = 0; loop < 16; loop++)
+		gammas[loop] = 0;
+	gammas[0] = 1;
+	D[1] = 1;
+
+	iteration = 0;
+	LL = 0;
+	while ((iteration < ((select_4_8+1)*2*4)) &&
+			(LL <= ((select_4_8+1)*4))) {
+
+		pr_debug("\nIteration.............%d\n", iteration);
+		d = 0;
+		/* Step: 0 */
+		for (loop = 0; loop <= LL; loop++) {
+			tmp_poly = mpy_mod_gf(
+					gammas[loop], synd[iteration - loop]);
+			d ^= tmp_poly;
+			pr_debug("%02d. s=0 LL=%x poly %x\n",
+					loop, LL, tmp_poly);
+		}
+
+		/* Step 1: 1 cycle only to perform inversion */
+		v = d << 1;
+		e = -1;
+		sign = 1;
+		ss = 0x2000;
+		invd = 0;
+		u = PPP;
+		for (loop = 0; (d != 0) && (loop <= (2 * POLY)); loop++) {
+			pr_debug("%02d. s=1 LL=%x poly NULL\n",
+						loop, LL);
+			C1 = (v >> 13) & 1;
+			C2 = C1 & sign;
+
+			sign ^= C2 ^ (e == 0);
+
+			tmp_v = v;
+			tmp_s = ss;
+
+			if (C1 == 1) {
+				v ^= u;
+				ss ^= invd;
+			}
+			v = (v << 1) & 0x3FFF;
+			if (C2 == 1) {
+				u = tmp_v;
+				invd = tmp_s;
+				e = -e;
+			}
+			invd >>= 1;
+			e--;
+		}
+
+		for (loop = 0; (d != 0) && (loop <= (iteration + 1)); loop++) {
+			/* Step 2
+			 * Interleaved with Step 3, if L<(n-k)
+			 * invd: Update of ELP[n](z) = ELP[n-1](z) - d.D[n-1](z)
+			 */
+
+			/* Holds value of ELP coefficient until precedent
+			 * value does not have to be used anymore
+			 */
+			tmp_poly = mpy_mod_gf(d, D[loop]);
+			pr_debug("%02d. s=2 LL=%x poly %x\n",
+						loop, LL, tmp_poly);
+
+			next_gamma = gammas[loop] ^ tmp_poly;
+			if ((2 * LL) < (iteration + 1)) {
+				/* Interleaving with Step 3
+				 * for parallelized update of ELP(z) and D(z)
+				 */
+			} else {
+				/* Update of ELP(z) only -> stay in Step 2 */
+				gammas[loop] = next_gamma;
+				if (loop == (iteration + 1)) {
+					/* to step 4 */
+					break;
+				}
+			}
+
+			/* Step 3
+			 * Always interleaved with Step 2 (case when L<(n-k))
+			 * Update of D[n-1](z) = ELP[n-1](z)/d
+			 */
+			D[loop] = mpy_mod_gf(gammas[loop], invd);
+			pr_debug("%02d. s=3 LL=%x poly %x\n",
+					loop, LL, D[loop]);
+
+			/* Can safely update ELP[n](z) */
+			gammas[loop] = next_gamma;
+
+			if (loop == (iteration + 1)) {
+				/* If update finished */
+				LL = iteration - LL + 1;
+				/* to step 4 */
+				break;
+			}
+			/* Else, interleaving to step 2*/
+		}
+
+		/* Step 4: Update D(z): i:0->L */
+		/* Final update of D[n](z) = D[n](z).z*/
+		for (loop = 0; loop < 15; loop++) /* Left Shift */
+			D[15 - loop] = D[14 - loop];
+
+		D[0] = 0;
+
+		iteration++;
+	} /* while */
+
+	/* Processing finished, copy ELP to final registers : 0->2t-1*/
+	for (loop = 0; loop < 8; loop++)
+		err[loop] = gammas[loop+1];
+
+	pr_debug("\n Err poly:");
+	for (loop = 0; loop < 8; loop++)
+		pr_debug("0x%x ", err[loop]);
+
+	return LL;
+}
+
+/*
+ * syndrome - Generate syndrome components from hw generate syndrome
+ * r(x) = c(x) + e(x)
+ * s(x) = c(x) mod g(x) + e(x) mod g(x) =  e(x) mod g(x)
+ * so receiver checks if the syndrome s(x) = r(x) mod g(x) is equal to zero.
+ * unsigned int s[16]; - Syndromes
+ */
+static void syndrome(unsigned int select_4_8,
+					unsigned char *ecc, unsigned int syn[])
+{
+	unsigned int k, l, t;
+	unsigned int alpha_bit, R_bit;
+	int ecc_pos, ecc_min;
+
+	/* 2t-1 = 15 (for t=8) minimal polynomials of the first 15 powers of a
+	 * primitive elemmants of GF(m); Even powers minimal polynomials are
+	 * duplicate of odd powers' minimal polynomials.
+	 * Odd powers of alpha (1 to 15)
+	 */
+	unsigned int pow_alpha[8] = {0x0002, 0x0008, 0x0020, 0x0080,
+				 0x0200, 0x0800, 0x001B, 0x006C};
+
+	pr_debug("\n ECC[0..n]: ");
+	for (k = 0; k < 13; k++)
+		pr_debug("0x%x ", ecc[k]);
+
+	if (select_4_8 == 0) {
+		t = 4;
+		ecc_pos = 55; /* bits(52-bits): 55->4 */
+		ecc_min = 4;
+	} else {
+		t = 8;
+		ecc_pos = 103; /* bits: 103->0 */
+		ecc_min = 0;
+	}
+
+	/* total numbber of syndrom to be used is 2t */
+	/* Step1: calculate the odd syndrome(s) */
+	R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);
+	ecc_pos--;
+	for (k = 0; k < t; k++)
+		syn[2 * k] = R_bit;
+
+	while (ecc_pos >= ecc_min) {
+		R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);
+		ecc_pos--;
+
+		for (k = 0; k < t; k++) {
+			/* Accumulate value of x^i at alpha^(2k+1) */
+			if (R_bit == 1)
+				syn[2*k] ^= pow_alpha[k];
+
+			/* Compute a**(2k+1), using LSFR */
+			for (l = 0; l < (2 * k + 1); l++) {
+				alpha_bit = (pow_alpha[k] >> POLY) & 1;
+				pow_alpha[k] = (pow_alpha[k] << 1) & 0x1FFF;
+				if (alpha_bit == 1)
+					pow_alpha[k] ^= P;
+			}
+		}
+	}
+
+	/* Step2: calculate the even syndrome(s)
+	 * Compute S(a), where a is an even power of alpha
+	 * Evenry even power of primitive element has the same minimal
+	 * polynomial as some odd power of elemets.
+	 * And based on S(a^2) = S^2(a)
+	 */
+	for (k = 0; k < t; k++)
+		syn[2*k+1] = mpy_mod_gf(syn[k], syn[k]);
+
+	pr_debug("\n Syndromes: ");
+	for (k = 0; k < 16; k++)
+		pr_debug("0x%x ", syn[k]);
+}
+
+/**
+ * decode_bch - BCH decoder for 4- and 8-bit error correction
+ *
+ * @ecc - ECC syndrome generated by hw BCH engine
+ * @err_loc - pointer to error location array
+ *
+ * This function does post sydrome generation (hw generated) decoding
+ * for:-
+ * Dimension of Galoise Field: m = 13
+ * Length of codeword: n = 2**m - 1
+ * Number of errors that can be corrected: 4- or 8-bits
+ * Length of information bit: kk = nn - rr
+ */
+int decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc)
+{
+	int no_of_err;
+	unsigned int syn[16] = {0,};	/* 16 Syndromes */
+	unsigned int err_poly[8] = {0,};
+	/* Coefficients to the error polynomial
+	 * ELP(x) = 1 + err0.x + err1.x^2 + ... + err7.x^8
+	 */
+
+	/* Decoting involes three steps
+	 * 1. Compute the syndrom from teh received codeword,
+	 * 2. Find the error location polynomial from a set of equations
+	 *     derived from the syndrome,
+	 * 3. Use the error location polynomial to identify errants bits,
+	 *
+	 * And correcttion done by bit flips using error locaiton and expected
+	 * to be outseide of this implementation.
+	 */
+	syndrome(select_4_8, ecc, syn);
+	no_of_err = berlekamp(select_4_8, syn, err_poly);
+	if (no_of_err <= (4 << select_4_8))
+		no_of_err = chien(select_4_8, no_of_err, err_poly, err_loc);
+
+	return no_of_err;
+}
+EXPORT_SYMBOL(decode_bch);
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/arm/at91_ether.c linux-3.0.x-arm/drivers/net/arm/at91_ether.c
--- linux-3.0.x-orig/drivers/net/arm/at91_ether.c	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/arm/at91_ether.c	2013-08-23 18:09:53.000000000 +0300
@@ -28,6 +28,7 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/gfp.h>
+#include <linux/moduleparam.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -44,6 +45,12 @@
 
 #define LINK_POLL_INTERVAL	(HZ)
 
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+static int wdt_timeout = CONFIG_OWEN_PHY_WATCHDOG_TIMEOUT;
+module_param(wdt_timeout, int, 0);
+MODULE_PARM_DESC(wdt_timeout, "PHY hangup detection watchdog timeout");
+#endif
+
 /* ..................................................................... */
 
 /*
@@ -223,7 +230,7 @@
 		if (!(phy & (1 << 0)))
 			goto done;
 	}
-	else if (lp->phy_type == MII_KS8721_ID) {
+	else if ((lp->phy_type == MII_KS8721_ID) || (lp->phy_type == MII_KSZ8041_ID)) {
 		read_phy(lp->phy_address, MII_TPISTATUS, &phy);		/* ack interrupt in Micrel PHY */
 		if (!(phy & ((1 << 2) | 1)))
 			goto done;
@@ -238,6 +245,11 @@
 		if (!(phy & (1 << 7)))
 			goto done;
 	}
+	else if (lp->phy_type == MII_STE100P_ID) {			/* ack interrupt in STE100P PHY */
+		read_phy(lp->phy_address, MII_STE100P_XCSIIS_REG, &phy);
+		if (!(phy & 0x007F))
+			goto done;
+	}
 
 	update_linkspeed(dev, 0);
 
@@ -251,11 +263,10 @@
 /*
  * Initialize and enable the PHY interrupt for link-state changes
  */
-static void enable_phyirq(struct net_device *dev)
+static void enable_phyirq_req(struct net_device *dev, int req)
 {
 	struct at91_private *lp = netdev_priv(dev);
 	unsigned int dsintr, irq_number;
-	int status;
 
 	irq_number = lp->board_data.phy_irq_pin;
 	if (!irq_number) {
@@ -267,10 +278,13 @@
 		return;
 	}
 
-	status = request_irq(irq_number, at91ether_phy_interrupt, 0, dev->name, dev);
-	if (status) {
-		printk(KERN_ERR "at91_ether: PHY IRQ %d request failed - status %d!\n", irq_number, status);
-		return;
+	if (req) {
+		int status;
+		status = request_irq(irq_number, at91ether_phy_interrupt, 0, dev->name, dev);
+		if (status) {
+			printk(KERN_ERR "at91_ether: PHY IRQ %d request failed - status %d!\n", irq_number, status);
+			return;
+		}
 	}
 
 	spin_lock_irq(&lp->lock);
@@ -290,7 +304,7 @@
 		dsintr = (1 << 15) | ( 1 << 14);
 		write_phy(lp->phy_address, MII_BCMINTR_REG, dsintr);
 	}
-	else if (lp->phy_type == MII_KS8721_ID) {	/* for Micrel PHY */
+	else if ((lp->phy_type == MII_KS8721_ID) || (lp->phy_type == MII_KSZ8041_ID)) {	/* for Micrel PHY */
 		dsintr = (1 << 10) | ( 1 << 8);
 		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
 	}
@@ -307,11 +321,21 @@
 		dsintr = dsintr | 0x3;			/* set bits 0,1 */
 		write_phy(lp->phy_address, MII_DPMICR_REG, dsintr);
 	}
+	else if (lp->phy_type == MII_STE100P_ID) {	/* for STE100P PHY */
+		read_phy(lp->phy_address, MII_STE100P_XIE_REG, &dsintr);
+		dsintr |= 0x7f;
+		write_phy(lp->phy_address, MII_STE100P_XIE_REG, dsintr);
+	}
 
 	disable_mdi();
 	spin_unlock_irq(&lp->lock);
 }
 
+static void enable_phyirq(struct net_device *dev)
+{
+	enable_phyirq_req(dev, 1);
+}
+
 /*
  * Disable the PHY interrupt
  */
@@ -345,7 +369,7 @@
 		dsintr = ~(1 << 14);
 		write_phy(lp->phy_address, MII_BCMINTR_REG, dsintr);
 	}
-	else if (lp->phy_type == MII_KS8721_ID) {	/* for Micrel PHY */
+	else if ((lp->phy_type == MII_KS8721_ID) || (lp->phy_type == MII_KSZ8041_ID)) {	/* for Micrel PHY */
 		read_phy(lp->phy_address, MII_TPISTATUS, &dsintr);
 		dsintr = ~((1 << 10) | (1 << 8));
 		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
@@ -363,6 +387,11 @@
 		dsintr = dsintr & ~0x3c;			/* clear bits 2..5 */
 		write_phy(lp->phy_address, MII_DPMISR_REG, dsintr);
 	}
+	else if (lp->phy_type == MII_STE100P_ID) {	/* for STE100P PHY */
+		read_phy(lp->phy_address, MII_STE100P_XIE_REG, &dsintr);
+		dsintr = dsintr & ~0x7f;
+		write_phy(lp->phy_address, MII_STE100P_XIE_REG, dsintr);
+	}
 
 	disable_mdi();
 	spin_unlock_irq(&lp->lock);
@@ -395,6 +424,52 @@
 }
 #endif
 
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+static void reset_phy_hard(struct net_device *dev)
+{
+	struct at91_private *lp = netdev_priv(dev);
+
+	gpio_set_value(lp->board_data.phy_rst_pin, 0);
+	udelay(500); /* Datasheet says 50 us is enough but it doesn't work */
+	gpio_set_value(lp->board_data.phy_rst_pin, 1);
+
+	/* re-enable PHY irq config
+	* delay before using MII: testing showed that MII is not operable yet after even mdelay(10) */
+	mdelay(50);
+	enable_phyirq_req(dev, 0);
+}
+
+static void at91ether_feed_watchdog(struct at91_private *lp)
+{
+	mod_timer(&lp->watchdog_timer, jiffies + (HZ) * wdt_timeout);
+}
+
+static void at91ether_watchdog(unsigned long dev_id)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct at91_private *lp = netdev_priv(dev);
+
+	if (netif_running(dev))
+	{
+		/* Perform reset */
+		printk(KERN_INFO DRV_NAME " %s: PHY hang up detected, performing reset\n", dev->name);
+		reset_phy_hard(dev);
+	}
+        at91ether_feed_watchdog(lp);
+}
+
+/* echo "1" > /sys/class/../ethX/phy_reset  (used in rc.net while configuring IP dynamically)*/
+static ssize_t reset_phy_write(struct device *dev, struct device_attribute *attr,
+								const char *buf, size_t count)
+{
+	if (count > 1 && buf[0] == '1' && buf[1] == '\n') {
+		reset_phy_hard(to_net_dev(dev));
+	}
+	return count;
+}
+static DEVICE_ATTR(reset_phy, S_IWUSR, NULL, reset_phy_write);
+#endif /* CONFIG_OWEN_PHY_WATCHDOG */
+
 static void at91ether_check_link(unsigned long dev_id)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
@@ -778,6 +853,10 @@
 
 	at91ether_start(dev);
 	netif_start_queue(dev);
+
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	at91ether_feed_watchdog(lp);
+#endif /* CONFIG_OWEN_PHY_WATCHDOG */
 	return 0;
 }
 
@@ -789,6 +868,11 @@
 	struct at91_private *lp = netdev_priv(dev);
 	unsigned long ctl;
 
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	/* Disable watchdog timer */
+	del_timer_sync(&lp->watchdog_timer);
+#endif
+
 	/* Disable Receiver and Transmitter */
 	ctl = at91_emac_read(AT91_EMAC_CTL);
 	at91_emac_write(AT91_EMAC_CTL, ctl & ~(AT91_EMAC_TE | AT91_EMAC_RE));
@@ -844,7 +928,7 @@
  */
 static struct net_device_stats *at91ether_stats(struct net_device *dev)
 {
-	int ale, lenerr, seqe, lcol, ecol;
+	int ale, lenerr, seqe, ecol;
 
 	if (netif_running(dev)) {
 		dev->stats.rx_packets += at91_emac_read(AT91_EMAC_OK);		/* Good frames received */
@@ -863,12 +947,11 @@
 		dev->stats.tx_carrier_errors += at91_emac_read(AT91_EMAC_CSE);	/* Carrier Sense errors */
 		dev->stats.tx_heartbeat_errors += at91_emac_read(AT91_EMAC_SQEE);/* Heartbeat error */
 
-		lcol = at91_emac_read(AT91_EMAC_LCOL);
+		dev->stats.tx_window_errors += at91_emac_read(AT91_EMAC_LCOL);	/* Late collisions */
 		ecol = at91_emac_read(AT91_EMAC_ECOL);
-		dev->stats.tx_window_errors += lcol;			/* Late collisions */
-		dev->stats.tx_aborted_errors += ecol;			/* 16 collisions */
+		dev->stats.tx_aborted_errors += ecol;				/* 16 collisions */
 
-		dev->stats.collisions += (at91_emac_read(AT91_EMAC_SCOL) + at91_emac_read(AT91_EMAC_MCOL) + lcol + ecol);
+		dev->stats.collisions += (at91_emac_read(AT91_EMAC_SCOL) + at91_emac_read(AT91_EMAC_MCOL) + ecol);
 	}
 	return &dev->stats;
 }
@@ -889,6 +972,7 @@
 	while (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {
 		p_recv = dlist->recv_buf[lp->rxBuffIndex];
 		pktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;	/* Length of frame including FCS */
+		pktlen = pktlen - 4;		/* omit 4-byte checksum */
 		skb = dev_alloc_skb(pktlen + 2);
 		if (skb != NULL) {
 			skb_reserve(skb, 2);
@@ -928,9 +1012,17 @@
 	intstatus = at91_emac_read(AT91_EMAC_ISR);
 
 	if (intstatus & AT91_EMAC_RCOM)		/* Receive complete */
+	{
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+		at91ether_feed_watchdog(lp);
+#endif
 		at91ether_rx(dev);
+	}
 
 	if (intstatus & AT91_EMAC_TCOM) {	/* Transmit complete */
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+		at91ether_feed_watchdog(lp);
+#endif
 		/* The TCOM bit is set even if the transmission failed. */
 		if (intstatus & (AT91_EMAC_TUND | AT91_EMAC_RTRY))
 			dev->stats.tx_errors += 1;
@@ -982,6 +1074,37 @@
 #endif
 };
 
+#ifdef CONFIG_OWEN_PHY_DUMP_REGISTERS
+static ssize_t at91ether_show_regs(struct device *d, struct device_attribute *attr, char *buf)
+{
+	struct at91_private *lp = netdev_priv(to_net_dev(d));
+	unsigned int regs[32];
+	unsigned int i;
+	int len;
+
+	spin_lock_irq(&lp->lock);
+	enable_mdi();
+
+	for (i=0; i<ARRAY_SIZE(regs); ++i)
+	{
+		read_phy(lp->phy_address, i, &regs[i]);
+	}
+
+	disable_mdi();
+	spin_unlock_irq(&lp->lock);
+
+	len = 0;
+	for (i=0; i<ARRAY_SIZE(regs); ++i)
+	{
+		len += sprintf(buf + len, "%02X: %04X\n", i, regs[i]);
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(at91_phy_registers, S_IRUGO, at91ether_show_regs, NULL);
+#endif /* CONFIG_OWEN_PHY_DUMP_REGISTERS */
+
 /*
  * Initialize the ethernet interface
  */
@@ -992,14 +1115,21 @@
 	struct net_device *dev;
 	struct at91_private *lp;
 	unsigned int val;
-	int res;
+	struct resource *res;
+	int ret;
 
 	dev = alloc_etherdev(sizeof(struct at91_private));
 	if (!dev)
 		return -ENOMEM;
 
-	dev->base_addr = AT91_VA_BASE_EMAC;
-	dev->irq = AT91RM9200_ID_EMAC;
+	/* Get I/O base address and IRQ */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		free_netdev(dev);
+		return -ENODEV;
+	}
+	dev->base_addr = res->start;
+	dev->irq = platform_get_irq(pdev, 0);
 
 	/* Install the interrupt handler */
 	if (request_irq(dev->irq, at91ether_interrupt, 0, dev->name, dev)) {
@@ -1064,12 +1194,12 @@
 	lp->phy_address = phy_address;	/* MDI address of PHY */
 
 	/* Register the network interface */
-	res = register_netdev(dev);
-	if (res) {
+	ret = register_netdev(dev);
+	if (ret) {
 		free_irq(dev->irq, dev);
 		free_netdev(dev);
 		dma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);
-		return res;
+		return ret;
 	}
 
 	/* Determine current link speed */
@@ -1085,9 +1215,30 @@
 		init_timer(&lp->check_timer);
 		lp->check_timer.data = (unsigned long)dev;
 		lp->check_timer.function = at91ether_check_link;
-	} else if (lp->board_data.phy_irq_pin >= 32)
+	} else if (lp->board_data.phy_irq_pin >= NR_AIC_IRQS)
 		gpio_request(lp->board_data.phy_irq_pin, "ethernet_phy");
 
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	/* Use a timer to watch for ISOLATE mode indicating hang-up state */
+	init_timer(&lp->watchdog_timer);
+	lp->watchdog_timer.data = (unsigned long)dev;
+	lp->watchdog_timer.function = at91ether_watchdog;
+
+	gpio_request(lp->board_data.phy_rst_pin, "ethernet_phy");
+	gpio_direction_output(lp->board_data.phy_rst_pin, 1);
+
+	if (sysfs_create_file(&dev->dev.kobj, &dev_attr_reset_phy.attr)) {
+		dev_warn(&dev->dev, "failed to register PHY reset interface\n");
+	}
+#endif /* CONFIG_OWEN_PHY_WATCHDOG */
+
+#ifdef CONFIG_OWEN_PHY_DUMP_REGISTERS
+	if (sysfs_create_file(&dev->dev.kobj, &dev_attr_at91_phy_registers.attr))
+	{
+		printk(KERN_WARNING DRV_NAME " %s: failed to register sysfs PHY registers file\n", dev->name);
+	}
+#endif /* CONFIG_OWEN_PHY_DUMP_REGISTERS */
+
 	/* Display ethernet banner */
 	printk(KERN_INFO "%s: AT91 ethernet at 0x%08x int=%d %s%s (%pM)\n",
 	       dev->name, (uint) dev->base_addr, dev->irq,
@@ -1108,12 +1259,16 @@
 		printk(KERN_INFO "%s: National Semiconductor DP83848 PHY\n", dev->name);
 	else if (phy_type == MII_AC101L_ID)
 		printk(KERN_INFO "%s: Altima AC101L PHY\n", dev->name);
+	else if (phy_type == MII_KSZ8041_ID)
+		printk(KERN_INFO "%s: Micrel KSZ8041 PHY\n", dev->name);
 	else if (phy_type == MII_KS8721_ID)
 		printk(KERN_INFO "%s: Micrel KS8721 PHY\n", dev->name);
 	else if (phy_type == MII_T78Q21x3_ID)
 		printk(KERN_INFO "%s: Teridian 78Q21x3 PHY\n", dev->name);
 	else if (phy_type == MII_LAN83C185_ID)
 		printk(KERN_INFO "%s: SMSC LAN83C185 PHY\n", dev->name);
+	else if (phy_type == MII_STE100P_ID)
+		printk(KERN_INFO "%s: STE100P PHY\n", dev->name);
 
 	return 0;
 }
@@ -1153,9 +1308,11 @@
 			case MII_DP83847_ID:		/* National Semiconductor DP83847:  */
 			case MII_DP83848_ID:		/* National Semiconductor DP83848:  */
 			case MII_AC101L_ID:		/* Altima AC101L: PHY_ID1 = 0x22, PHY_ID2 = 0x5520 */
+			case MII_KSZ8041_ID:		/* Micrel KSZ8041: PHY_ID1 = 0x22, PHY_ID2 = 0x1512 */
 			case MII_KS8721_ID:		/* Micrel KS8721: PHY_ID1 = 0x22, PHY_ID2 = 0x1610 */
 			case MII_T78Q21x3_ID:		/* Teridian 78Q21x3: PHY_ID1 = 0x0E, PHY_ID2 = 7237 */
 			case MII_LAN83C185_ID:		/* SMSC LAN83C185: PHY_ID1 = 0x0007, PHY_ID2 = 0xC0A1 */
+			case MII_STE100P_ID:		/* STE100P: PHY_ID1 = 0x1C04, PHY_ID2 = 0x0000 */
 				detected = at91ether_setup(phy_id, phy_address, pdev, ether_clk);
 				break;
 		}
@@ -1173,7 +1330,16 @@
 	struct net_device *dev = platform_get_drvdata(pdev);
 	struct at91_private *lp = netdev_priv(dev);
 
-	if (lp->board_data.phy_irq_pin >= 32)
+#ifdef CONFIG_OWEN_PHY_DUMP_REGISTERS
+	sysfs_remove_file(&dev->dev.kobj, &dev_attr_at91_phy_registers.attr);
+#endif /* CONFIG_OWEN_PHY_DUMP_REGISTERS */
+
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	sysfs_remove_file(&dev->dev.kobj, &dev_attr_reset_phy.attr);
+	gpio_free(lp->board_data.phy_rst_pin);
+#endif
+
+	if (lp->board_data.phy_irq_pin >= NR_AIC_IRQS)
 		gpio_free(lp->board_data.phy_irq_pin);
 
 	unregister_netdev(dev);
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/arm/at91_ether.h linux-3.0.x-arm/drivers/net/arm/at91_ether.h
--- linux-3.0.x-orig/drivers/net/arm/at91_ether.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/arm/at91_ether.h	2013-08-22 15:43:09.000000000 +0300
@@ -45,9 +45,17 @@
 #define MII_DPMICR_REG		17
 #define MII_DPMISR_REG		18
 
+/* STE100P specific registers */
+#define MII_STE100P_ID		0x1c040010
+#define MII_STE100P_XCSIIS_REG	0x11
+#define MII_STE100P_XIE_REG	0x12
+
 /* Altima AC101L PHY */
 #define MII_AC101L_ID		0x00225520
 
+/* Micrel KSZ8041 PHY */
+#define MII_KSZ8041_ID		0x00221510
+
 /* Micrel KS8721 PHY */
 #define MII_KS8721_ID		0x00221610
 
@@ -94,6 +102,9 @@
 	short phy_media;			/* media interface type */
 	unsigned short phy_address;		/* 5-bit MDI address of PHY (0..31) */
 	struct timer_list check_timer;		/* Poll link status */
+#ifdef CONFIG_OWEN_PHY_WATCHDOG
+	struct timer_list watchdog_timer;	/* Watchdog timer for resetting PHY hangup */
+#endif /* CONFIG_OWEN_PHY_WATCHDOG */
 
 	/* Transmit */
 	struct sk_buff *skb;			/* holds skb until xmit interrupt completes */
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/arm/Kconfig linux-3.0.x-arm/drivers/net/arm/Kconfig
--- linux-3.0.x-orig/drivers/net/arm/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/arm/Kconfig	2013-08-22 15:43:09.000000000 +0300
@@ -40,6 +40,36 @@
 	  If you wish to compile a kernel for the AT91RM9200 and enable
 	  ethernet support, then you should always answer Y to this.
 
+menu "Additional Owen-specific options"
+	depends on ARM_AT91_ETHER && (MACH_OWEN_PLC304 || MACH_OWEN_PLC323)
+
+config OWEN_PHY_WATCHDOG
+	bool "PHY hangup detection watchdog"
+	depends on ARM_AT91_ETHER && (MACH_OWEN_PLC304 || MACH_OWEN_PLC323)
+	default y if MACH_OWEN_PLC304 || MACH_OWEN_PLC323
+	default n
+	help
+	  This option enables watchdog functionality. Watchdog resets PHY
+	  interface in case of absence rx/tx activity for specified interval.
+
+config OWEN_PHY_WATCHDOG_TIMEOUT
+	int "Default watchdog timeout, seconds"
+	default 10
+	depends on OWEN_PHY_WATCHDOG
+	help
+	  This option sets default watchdog timeout for PHY hangup detection.
+	  The value can be overrided by `wdt_timeout' module parameter.
+
+config OWEN_PHY_DUMP_REGISTERS
+	bool "Dump PHY registers via sysfs"
+	depends on ARM_AT91_ETHER && (MACH_OWEN_PLC304 || MACH_OWEN_PLC323)
+	default n
+	help
+	  This option allows to get PHY registers dump via 
+	  /sys/class/net/ethX/at91_phy_registers
+
+endmenu
+
 config ARM_KS8695_ETHER
 	tristate "KS8695 Ethernet support"
 	depends on ARM && ARCH_KS8695
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/can/Makefile linux-3.0.x-arm/drivers/net/can/Makefile
--- linux-3.0.x-orig/drivers/net/can/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/can/Makefile	2012-12-19 11:28:07.000000000 +0200
@@ -11,6 +11,7 @@
 obj-y				+= usb/
 obj-y				+= softing/
 
+obj-$(CONFIG_CAN_AT91)		+= at91_can.o
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
 obj-$(CONFIG_CAN_C_CAN)		+= c_can/
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/can/mcp251x.c linux-3.0.x-arm/drivers/net/can/mcp251x.c
--- linux-3.0.x-orig/drivers/net/can/mcp251x.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/can/mcp251x.c	2012-12-19 11:28:07.000000000 +0200
@@ -612,7 +612,7 @@
 	unsigned long timeout;
 
 	priv->spi_tx_buf[0] = INSTRUCTION_RESET;
-	ret = spi_write(spi, priv->spi_tx_buf, 1);
+	ret = mcp251x_spi_trans(spi, 1);
 	if (ret) {
 		dev_err(&spi->dev, "reset failed: ret = %d\n", ret);
 		return -EIO;
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/can/ti_hecc.c linux-3.0.x-arm/drivers/net/can/ti_hecc.c
--- linux-3.0.x-orig/drivers/net/can/ti_hecc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/can/ti_hecc.c	2013-01-15 16:31:15.000000000 +0200
@@ -483,7 +483,7 @@
 {
 	struct ti_hecc_priv *priv = netdev_priv(ndev);
 	struct can_frame *cf = (struct can_frame *)skb->data;
-	u32 mbxno, mbx_mask, data;
+	u32 mbxno, mbx_mask, data = 0;
 	unsigned long flags;
 
 	if (can_dropped_invalid_skb(ndev, skb))
@@ -506,6 +506,7 @@
 	if (cf->can_id & CAN_RTR_FLAG) /* Remote transmission request */
 		data |= HECC_CANMCF_RTR;
 	data |= get_tx_head_prio(priv) << 8;
+	data |= cf->can_dlc & 0x0F;
 	hecc_write_mbx(priv, mbxno, HECC_CANMCF, data);
 
 	if (cf->can_id & CAN_EFF_FLAG) /* Extended frame format */
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/davinci_cpdma.c linux-3.0.x-arm/drivers/net/davinci_cpdma.c
--- linux-3.0.x-orig/drivers/net/davinci_cpdma.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/davinci_cpdma.c	2012-12-19 11:28:26.000000000 +0200
@@ -824,6 +824,8 @@
 	/* trigger teardown */
 	dma_reg_write(ctlr, chan->td, chan->chan_num);
 
+	spin_unlock_irqrestore(&chan->lock, flags);
+
 	/* wait for teardown complete */
 	timeout = jiffies + HZ/10;	/* 100 msec */
 	while (time_before(jiffies, timeout)) {
@@ -843,6 +845,7 @@
 	} while ((ret & CPDMA_DESC_TD_COMPLETE) == 0);
 
 	/* remaining packets haven't been tx/rx'ed, clean them up */
+	spin_lock_irqsave(&chan->lock, flags);
 	while (chan->head) {
 		struct cpdma_desc __iomem *desc = chan->head;
 		dma_addr_t next_dma;
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/davinci_emac.c linux-3.0.x-arm/drivers/net/davinci_emac.c
--- linux-3.0.x-orig/drivers/net/davinci_emac.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/davinci_emac.c	2012-12-19 11:28:25.000000000 +0200
@@ -1037,7 +1037,7 @@
 recycle:
 	ret = cpdma_chan_submit(priv->rxchan, skb, skb->data,
 			skb_tailroom(skb), GFP_KERNEL);
-	if (WARN_ON(ret < 0))
+	if (ret < 0)
 		dev_kfree_skb_any(skb);
 }
 
@@ -1822,12 +1822,13 @@
 
 	priv->emac_base_phys = res->start + pdata->ctrl_reg_offset;
 	size = res->end - res->start + 1;
+#if 0
 	if (!request_mem_region(res->start, size, ndev->name)) {
 		dev_err(&pdev->dev, "failed request_mem_region() for regs\n");
 		rc = -ENXIO;
 		goto probe_quit;
 	}
-
+#endif
 	priv->remap_addr = ioremap(res->start, size);
 	if (!priv->remap_addr) {
 		dev_err(&pdev->dev, "unable to map IO\n");
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/Kconfig linux-3.0.x-arm/drivers/net/Kconfig
--- linux-3.0.x-orig/drivers/net/Kconfig	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/Kconfig	2012-12-19 11:28:25.000000000 +0200
@@ -233,6 +233,24 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config MACB_TX_SRAM
+	bool "Atmel MACB TX buffers in internal SRAM"
+	depends on NET_ETHERNET && MACB && (ARCH_AT91SAM9260 || ARCH_AT91SAM9263)
+	help
+	  Use internal SRAM for TX buffers.
+
+config MACB_BB
+	bool "Bitbang MIIM/SMI instead of MAC_MAN"
+	depends on MACB && GENERIC_GPIO
+	select MDIO_BITBANG
+	select MDIO_GPIO
+	help
+	  Use bitbang MIIM bus instead of hardware MIIM interface accessible 
+	  via processor's register e.g. MAC_MAN. This allows use of 
+	  SMI along with MIIM interface for ethernet switches like KSZ8873.
+	  The order of loading the drivers is important: 
+	  first mdio-gpio then macb.
+
 source "drivers/net/arm/Kconfig"
 
 config AX88796
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/macb.c linux-3.0.x-arm/drivers/net/macb.c
--- linux-3.0.x-orig/drivers/net/macb.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/macb.c	2012-12-19 11:28:25.000000000 +0200
@@ -2,10 +2,13 @@
  * Atmel MACB Ethernet Controller driver
  *
  * Copyright (C) 2004-2006 Atmel Corporation
+ * Copyright (C) 2010 Softerra LLC
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ * 
+ * 2010-10-26  Support for MIIM/SMI via bitbang MDIO
  */
 
 #include <linux/clk.h>
@@ -21,6 +24,10 @@
 #include <linux/platform_device.h>
 #include <linux/phy.h>
 
+#ifdef CONFIG_MACB_BB
+#include <linux/mdio-gpio.h>
+#endif
+
 #include <mach/board.h>
 #include <mach/cpu.h>
 
@@ -33,9 +40,23 @@
 /* Make the IP header word-aligned (the ethernet header is 14 bytes) */
 #define RX_OFFSET		2
 
-#define TX_RING_SIZE		128
+#if defined(CONFIG_MACB_TX_SRAM)
+	#if defined(CONFIG_ARCH_AT91SAM9260)
+		#define TX_RING_SIZE       2
+	#elif defined(CONFIG_ARCH_AT91SAM9263)
+		#define TX_RING_SIZE       32
+	#else
+	#error "unsupported ARCH for MACB_TX_SRAM"
+	#endif
+	#define TX_BUFFER_SIZE       1536
+	#define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+	#define TX_DMA_SIZE      ((TX_RING_BYTES) + (TX_RING_SIZE) * (TX_BUFFER_SIZE))
+#else
+	#define TX_RING_SIZE     128
+	#define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+#endif
+
 #define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
-#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
 
 #define TX_RING_GAP(bp)						\
 	(TX_RING_SIZE - (bp)->tx_pending)
@@ -88,6 +109,7 @@
 	}
 }
 
+#if !defined(CONFIG_MACB_BB)
 static int macb_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 {
 	struct macb *bp = bus->priv;
@@ -131,6 +153,7 @@
 {
 	return 0;
 }
+#endif
 
 static void macb_handle_link_change(struct net_device *dev)
 {
@@ -193,14 +216,30 @@
 	struct eth_platform_data *pdata;
 	int ret;
 
-	phydev = phy_find_first(bp->mii_bus);
+	pdata = bp->pdev->dev.platform_data;
+
+	/* use pre-defined PHY at address other than 0
+	 * (in which case the search procedure will find it) 
+	 */
+	if (pdata->phy_addr > 0 && pdata->phy_addr < PHY_MAX_ADDR &&
+		bp->mii_bus->phy_map[pdata->phy_addr] != NULL) {
+		phydev = bp->mii_bus->phy_map[pdata->phy_addr];
+	} else {
+		phydev = phy_find_first(bp->mii_bus);
+	}
+
 	if (!phydev) {
 		printk (KERN_ERR "%s: no PHY found\n", dev->name);
 		return -1;
 	}
 
-	pdata = bp->pdev->dev.platform_data;
-	/* TODO : add pin_irq */
+	/* add pin_irq */
+	if (pdata->phy_irq_pin > 0 && bp->mii_bus->irq != NULL) {
+		phydev->irq = pdata->phy_irq_pin;
+		bp->mii_bus->irq[phydev->addr] = pdata->phy_irq_pin;
+		pr_info("%s: set irq %d for phydev (addr) %d\n", 
+			dev->name, pdata->phy_irq_pin, phydev->addr);
+	}
 
 	/* attach the mac to the phy */
 	ret = phy_connect_direct(dev, phydev, &macb_handle_link_change, 0,
@@ -225,6 +264,7 @@
 	return 0;
 }
 
+#if !defined(CONFIG_MACB_BB)
 static int macb_mii_init(struct macb *bp)
 {
 	struct eth_platform_data *pdata;
@@ -281,6 +321,39 @@
 	return err;
 }
 
+#else /* defined(CONFIG_MACB_BB) */
+
+static int macb_mii_init(struct macb *bp)
+{
+	struct eth_platform_data *pdata;
+	int err = -ENXIO;
+
+	pdata = bp->pdev->dev.platform_data;
+
+	bp->mii_bus = platform_get_drvdata((struct platform_device *)(pdata->mii_bus_pdev));
+	if (!bp->mii_bus) {
+		dev_err(&bp->pdev->dev, "Couldn't get bitbang mii_bus.\n");
+		err = -ENODEV;
+		goto err_out;
+	}
+
+	/* TODO: 1) data connections
+	 *       2) err handling
+	 */
+	dev_set_drvdata(&bp->dev->dev, bp->mii_bus);
+
+	if (macb_mii_probe(bp->dev) != 0) {
+		goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	return err;
+}
+
+#endif
+
 static void macb_update_stats(struct macb *bp)
 {
 	u32 __iomem *reg = bp->regs + MACB_PFR;
@@ -330,8 +403,10 @@
 
 			rmb();
 
+#if !defined(CONFIG_MACB_TX_SRAM)
 			dma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,
 							 DMA_TO_DEVICE);
+#endif
 			rp->skb = NULL;
 			dev_kfree_skb_irq(skb);
 		}
@@ -367,8 +442,10 @@
 
 		dev_dbg(&bp->pdev->dev, "skb %u (data %p) TX complete\n",
 			tail, skb->data);
+#if !defined(CONFIG_MACB_TX_SRAM)
 		dma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,
 				 DMA_TO_DEVICE);
+#endif
 		bp->stats.tx_packets++;
 		bp->stats.tx_bytes += skb->len;
 		rp->skb = NULL;
@@ -650,8 +727,13 @@
 
 	entry = bp->tx_head;
 	dev_dbg(&bp->pdev->dev, "Allocated ring entry %u\n", entry);
+#if defined(CONFIG_MACB_TX_SRAM)
+	mapping = bp->tx_ring[entry].addr;
+	memcpy(bp->tx_buffers + entry * TX_BUFFER_SIZE, skb->data, len);
+#else
 	mapping = dma_map_single(&bp->pdev->dev, skb->data,
 				 len, DMA_TO_DEVICE);
+#endif
 	bp->tx_skb[entry].skb = skb;
 	bp->tx_skb[entry].mapping = mapping;
 	dev_dbg(&bp->pdev->dev, "Mapped skb data %p to DMA addr %08lx\n",
@@ -662,7 +744,9 @@
 	if (entry == (TX_RING_SIZE - 1))
 		ctrl |= MACB_BIT(TX_WRAP);
 
+#if !defined(CONFIG_MACB_TX_SRAM)
 	bp->tx_ring[entry].addr = mapping;
+#endif
 	bp->tx_ring[entry].ctrl = ctrl;
 	wmb();
 
@@ -691,8 +775,12 @@
 		bp->rx_ring = NULL;
 	}
 	if (bp->tx_ring) {
+#if defined(CONFIG_MACB_TX_SRAM)
+		iounmap((void *)bp->tx_ring);
+#else
 		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
 				  bp->tx_ring, bp->tx_ring_dma);
+#endif
 		bp->tx_ring = NULL;
 	}
 	if (bp->rx_buffers) {
@@ -701,6 +789,11 @@
 				  bp->rx_buffers, bp->rx_buffers_dma);
 		bp->rx_buffers = NULL;
 	}
+
+#if defined(CONFIG_MACB_TX_SRAM)
+	if (bp->tx_ring_dma)
+		release_mem_region(bp->tx_ring_dma, TX_DMA_SIZE);
+#endif
 }
 
 static int macb_alloc_consistent(struct macb *bp)
@@ -721,6 +814,35 @@
 		"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->rx_ring_dma, bp->rx_ring);
 
+#if defined(CONFIG_MACB_TX_SRAM)
+#if defined(CONFIG_ARCH_AT91SAM9260)
+	if (!cpu_is_at91sam9xe()
+	&& request_mem_region(AT91SAM9260_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+		bp->tx_ring_dma = AT91SAM9260_SRAM0_BASE;
+	} else {
+		if (request_mem_region(AT91SAM9260_SRAM1_BASE, TX_DMA_SIZE, "macb")) {
+			bp->tx_ring_dma = AT91SAM9260_SRAM1_BASE;
+		} else {
+			printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+			return -EBUSY;
+		}
+	}
+#elif defined(CONFIG_ARCH_AT91SAM9263)
+	if (request_mem_region(AT91SAM9263_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+		bp->tx_ring_dma = AT91SAM9263_SRAM0_BASE;
+	} else {
+		printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+		return -EBUSY;
+	}
+#endif
+
+	bp->tx_ring = ioremap(bp->tx_ring_dma, TX_DMA_SIZE);
+	if (!bp->tx_ring)
+		return -ENOMEM;
+
+	bp->tx_buffers_dma = bp->tx_ring_dma + TX_RING_BYTES;
+	bp->tx_buffers = (char *) bp->tx_ring + TX_RING_BYTES;
+#else
 	size = TX_RING_BYTES;
 	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
 					 &bp->tx_ring_dma, GFP_KERNEL);
@@ -729,6 +851,7 @@
 	dev_dbg(&bp->pdev->dev,
 		"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->tx_ring_dma, bp->tx_ring);
+#endif
 
 	size = RX_RING_SIZE * RX_BUFFER_SIZE;
 	bp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,
@@ -759,10 +882,18 @@
 	}
 	bp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);
 
+#if defined(CONFIG_MACB_TX_SRAM)
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		bp->tx_ring[i].addr = bp->tx_buffers_dma + i * TX_BUFFER_SIZE;
+		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
+	}
+#else
 	for (i = 0; i < TX_RING_SIZE; i++) {
 		bp->tx_ring[i].addr = 0;
 		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
 	}
+#endif
+
 	bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 	bp->rx_tail = bp->tx_head = bp->tx_tail = 0;
@@ -1118,9 +1249,11 @@
 	struct net_device *dev;
 	struct macb *bp;
 	struct phy_device *phydev;
+	int err = -ENXIO;
+#if !defined(CONFIG_MACB_BB)
 	unsigned long pclk_hz;
 	u32 config;
-	int err = -ENXIO;
+#endif
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs) {
@@ -1191,6 +1324,7 @@
 
 	dev->base_addr = regs->start;
 
+#if !defined(CONFIG_MACB_BB)
 	/* Set MII management clock divider */
 	pclk_hz = clk_get_rate(bp->pclk);
 	if (pclk_hz <= 20000000)
@@ -1202,6 +1336,7 @@
 	else
 		config = MACB_BF(CLK, MACB_CLK_DIV64);
 	macb_writel(bp, NCFGR, config);
+#endif
 
 	macb_get_hwaddr(bp);
 	pdata = pdev->dev.platform_data;
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/macb.h linux-3.0.x-arm/drivers/net/macb.h
--- linux-3.0.x-orig/drivers/net/macb.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/macb.h	2012-12-19 11:28:25.000000000 +0200
@@ -369,6 +369,10 @@
 	struct dma_desc		*tx_ring;
 	struct ring_info	*tx_skb;
 
+#if defined(CONFIG_ARCH_AT91)
+	void            *tx_buffers;
+#endif
+
 	spinlock_t		lock;
 	struct platform_device	*pdev;
 	struct clk		*pclk;
@@ -382,6 +386,10 @@
 	dma_addr_t		tx_ring_dma;
 	dma_addr_t		rx_buffers_dma;
 
+#if defined(CONFIG_ARCH_AT91)
+	dma_addr_t      tx_buffers_dma;
+#endif
+
 	unsigned int		rx_pending, tx_pending;
 
 	struct mii_bus		*mii_bus;
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/Kconfig linux-3.0.x-arm/drivers/net/phy/Kconfig
--- linux-3.0.x-orig/drivers/net/phy/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/Kconfig	2012-12-19 11:28:12.000000000 +0200
@@ -92,6 +92,14 @@
 	---help---
 	  Supports the KSZ9021, VSC8201, KS8001 PHYs.
 
+config MICREL_KSZ8873_PHY
+	tristate "Driver for Micrel KSZ8873 PHYs used by Owen"
+	depends on MDIO_BITBANG_MICREL_SMI
+	---help---
+	  Handles PHY INT using SMI on Owen's HE5684 
+	  Note: drivers' load order is important: first micrel, 
+	  then mdio-gpio, then macb+bb
+
 config FIXED_PHY
 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB=y
@@ -110,6 +118,16 @@
 
 	  If in doubt, say N.
 
+config MDIO_BITBANG_MICREL_SMI
+	bool "Support Micrel KSZ8873 SMI via MDIO bitbang"
+	depends on MDIO_BITBANG
+	---help---
+	  Allows to use Micrel SMI interface along with MIIM through
+	  the same MDIO lines (use the same calls but specify
+	  phy=-1 to access to registers via SMI)
+
+	  Select if you have KSZ8873 switch with slected MIIM/SMI interface.
+
 config MDIO_GPIO
 	tristate "Support for GPIO lib-based bitbanged MDIO buses"
 	depends on MDIO_BITBANG && GENERIC_GPIO
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/Makefile linux-3.0.x-arm/drivers/net/phy/Makefile
--- linux-3.0.x-orig/drivers/net/phy/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/Makefile	2012-12-19 11:28:12.000000000 +0200
@@ -22,4 +22,5 @@
 obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
 obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+obj-$(CONFIG_MICREL_KSZ8873_PHY)	+= micrel_ksz8873.o
 obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/mdio-bitbang.c linux-3.0.x-arm/drivers/net/phy/mdio-bitbang.c
--- linux-3.0.x-orig/drivers/net/phy/mdio-bitbang.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/mdio-bitbang.c	2012-12-19 11:28:12.000000000 +0200
@@ -17,6 +17,7 @@
  * kind, whether express or implied.
  */
 
+#define DEBUG
 #include <linux/module.h>
 #include <linux/mdio-bitbang.h>
 #include <linux/types.h>
@@ -113,7 +114,7 @@
 	for (i = 0; i < 32; i++)
 		mdiobb_send_bit(ctrl, 1);
 
-	/* send the start bit (01) and the read opcode (10) or write (10).
+	/* send the start bit (01) and the read opcode (10) or write (01).
 	   Clause 45 operation uses 00 for the start and 11, 10 for
 	   read/write */
 	mdiobb_send_bit(ctrl, 0);
@@ -152,17 +153,63 @@
 	return dev_addr;
 }
 
+#ifdef CONFIG_MDIO_BITBANG_MICREL_SMI
+/* Utility to send the preamble, address, and
+ * register (common to read and write).
+ * e.g. SMI on Micrel KSZ8873 SMI interface
+ */
+static void mdiobb_smi_cmd(struct mdiobb_ctrl *ctrl, int op, u8 reg)
+{
+	const struct mdiobb_ops *ops = ctrl->ops;
+	int i;
+
+	ops->set_mdio_dir(ctrl, 1);
+
+	/*
+	 * Send a 32 bit preamble ('1's) with an extra '1' bit for good
+	 * measure, as for MIIM 
+	 */
+
+	for (i = 0; i < 32; i++)
+		mdiobb_send_bit(ctrl, 1);
+ 
+	/* send the start bit (01) */
+	mdiobb_send_bit(ctrl, 0);
+	mdiobb_send_bit(ctrl, 1);
+	/* send SMI code 00 */
+	mdiobb_send_bit(ctrl, 0);
+	mdiobb_send_bit(ctrl, 0);
+	/* send the read opcode (1x) or write (0x) */
+	mdiobb_send_bit(ctrl, (op >> 1) & 1);
+	mdiobb_send_bit(ctrl, 0);
+
+	/* send 8 bits reg num */
+	mdiobb_send_num(ctrl, reg, 8);
+}
+#endif
+
+/* READ a PHY reg from a PHY on phy address. 
+ * If phy == -1 - means read a non-PHY register reg via SMI.
+ */
 static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
 	int ret, i;
 
+	pr_debug("%s: READ phy=%d, reg=%d\n", __func__, phy, reg);
+#ifdef CONFIG_MDIO_BITBANG_MICREL_SMI
+	if (phy == -1) {
+		mdiobb_smi_cmd(ctrl, MDIO_READ, reg);
+	} else {
+		mdiobb_cmd(ctrl, MDIO_READ, phy, reg);
+	}
+#else
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
 	} else
 		mdiobb_cmd(ctrl, MDIO_READ, phy, reg);
-
+#endif
 	ctrl->ops->set_mdio_dir(ctrl, 0);
 
 	/* check the turnaround bit: the PHY should be driving it to zero */
@@ -178,18 +225,32 @@
 
 	ret = mdiobb_get_num(ctrl, 16);
 	mdiobb_get_bit(ctrl);
+
+	pr_debug("%s: READ val=0x%04x\n", __func__, (unsigned)ret);
 	return ret;
 }
 
+/* WRITE to a reg of a PHY on phy address. 
+ * If phy == -1 - means write to a non-PHY register reg via SMI.
+ */
 static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
 
+	pr_debug("%s: WRITE phy=%d, reg=%d, val=0x%04x\n", __func__, phy, reg, val);
+#ifdef CONFIG_MDIO_BITBANG_MICREL_SMI
+	if (phy == -1) {
+		mdiobb_smi_cmd(ctrl, MDIO_WRITE, reg);
+	} else {
+		mdiobb_cmd(ctrl, MDIO_WRITE, phy, reg);
+	}
+#else
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
 	} else
 		mdiobb_cmd(ctrl, MDIO_WRITE, phy, reg);
+#endif
 
 	/* send the turnaround (10) */
 	mdiobb_send_bit(ctrl, 1);
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/mdio-gpio.c linux-3.0.x-arm/drivers/net/phy/mdio-gpio.c
--- linux-3.0.x-orig/drivers/net/phy/mdio-gpio.c	2013-09-19 17:39:49.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/mdio-gpio.c	2012-12-19 11:28:12.000000000 +0200
@@ -142,7 +142,7 @@
 static void mdio_gpio_bus_deinit(struct device *dev)
 {
 	struct mii_bus *bus = dev_get_drvdata(dev);
-	struct mdio_gpio_info *bitbang = bus->priv;
+	struct mdio_gpio_info *bitbang = bus->priv; /*TODO:!!! bus->priv == ctl - see bitbang module..*/
 
 	dev_set_drvdata(dev, NULL);
 	gpio_free(bitbang->mdio);
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/micrel.c linux-3.0.x-arm/drivers/net/phy/micrel.c
--- linux-3.0.x-orig/drivers/net/phy/micrel.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/micrel.c	2012-12-19 11:28:12.000000000 +0200
@@ -130,7 +130,7 @@
 
 static struct phy_driver ks8041_driver = {
 	.phy_id		= PHY_ID_KS8041,
-	.phy_id_mask	= 0x00fffff0,
+	.phy_id_mask	= 0x00ffff00,
 	.name		= "Micrel KS8041",
 	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
 				| SUPPORTED_Asym_Pause),
diff -x .svn -Nru linux-3.0.x-orig/drivers/net/phy/micrel_ksz8873.c linux-3.0.x-arm/drivers/net/phy/micrel_ksz8873.c
--- linux-3.0.x-orig/drivers/net/phy/micrel_ksz8873.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/net/phy/micrel_ksz8873.c	2012-12-19 11:28:12.000000000 +0200
@@ -0,0 +1,152 @@
+/*
+ * drivers/net/phy/micrel_ksz8873.c
+ *
+ * Driver for Micrel KSZ8873 PHYs
+ *
+ * Author: Alexander Dsugan
+ *
+ * Copyright (c) 2010 Softerra LLC
+ *
+ * Based on micrel.c by David J. Choi (from linux 2.6.34)
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+
+#define	PHY_ID_KSZ8873		0x00221430
+
+#define KSZ8873_REG_INT_ENABLE		187
+#define KSZ8873_REG_LINK_CHANGE_INT	188
+#define INT_P1_P2_ANALOG	0x80
+#define INT_P3_MII		0x04
+#define INT_P2_ANALOG		0x02
+#define INT_ANALOG_MII		0x01
+#define INT_ANY			0x87
+#define INT_NONE		0x00
+
+static int kszphy_config_init(struct phy_device *phydev)
+{
+	return 0;
+}
+
+static int ksz8873_config_aneg(struct phy_device *phydev)
+{
+	int result = 0;
+	/* by default PORT3 phy addr is 3 and we don't change it, so use this constant directly */
+	if (phydev->addr != 3) {
+		result = genphy_config_aneg(phydev);
+	} else {
+		/* disable autonegotiation, setup and set 100/Full for PHY3 */
+
+		phy_write(phydev, MII_BMCR, BMCR_SPEED100 | BMCR_FULLDPLX);
+		
+		phydev->speed = SPEED_100;
+		phydev->duplex = DUPLEX_FULL;
+		phydev->autoneg = AUTONEG_DISABLE;
+		phydev->supported &= ~SUPPORTED_Autoneg;
+		phydev->advertising &= ~SUPPORTED_Autoneg;
+
+		pr_debug("%s: autonegotiation refused, set 100/Full for PHY3\n", __func__);	
+	}
+
+	return result;
+}
+
+static int ksz8873_probe(struct phy_device *phydev)
+{
+	pr_info("Micrel KSZ8873 PHY\n");
+	return 0;
+}
+
+static void ksz8873_remove(struct phy_device *phydev)
+{
+	pr_info("KSZ8873 removed\n");
+}
+
+#ifdef CONFIG_MDIO_BITBANG_MICREL_SMI
+static int ksz8873_config_intr(struct phy_device *phydev)
+{
+	int en;
+	struct mii_bus *bus = phydev->bus;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+		bus->write(bus, -1, KSZ8873_REG_INT_ENABLE, INT_ANY); // enable any possible int
+		en = bus->read(bus, -1, KSZ8873_REG_INT_ENABLE);
+		pr_debug("%s: ENABLE: en = 0x%02X\n", __func__, en);
+	} else {
+		bus->write(bus, -1, KSZ8873_REG_INT_ENABLE, INT_NONE); // disable all
+		en = bus->read(bus, -1, KSZ8873_REG_INT_ENABLE);
+		pr_debug("%s: DISABLE: en = 0x%02X\n", __func__, en);
+	}
+
+	return 0;
+}
+
+static int ksz8873_did_interrupt(struct phy_device *phydev)
+{
+	int lc;
+	struct mii_bus *bus = phydev->bus;
+
+	lc = bus->read(bus, -1, KSZ8873_REG_LINK_CHANGE_INT);
+	pr_debug("%s: lc = 0x%02X\n", __func__, lc);
+
+	return (lc & INT_ANY) ? 1 : 0;
+}
+static int ksz8873_ack_interrupt(struct phy_device *phydev)
+{
+	struct mii_bus *bus = phydev->bus;
+
+	bus->write(bus, -1, KSZ8873_REG_LINK_CHANGE_INT, INT_ANY); // ack all
+
+	pr_debug("%s: lc = 0x%02X\n", __func__, 
+		bus->read(bus, -1, KSZ8873_REG_LINK_CHANGE_INT));
+	
+	return 0;
+}
+#endif /* CONFIG_MDIO_BITBANG_MICREL_SMI */
+
+static struct phy_driver ksz8873_driver = {
+	.phy_id		= PHY_ID_KSZ8873,
+	.name		= "Micrel KSZ8873",
+	.phy_id_mask	= 0x00ffffff,
+	.features	= PHY_BASIC_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= ksz8873_config_aneg,
+	.read_status	= genphy_read_status,
+	.driver		= { .owner = THIS_MODULE,},
+	.probe		= ksz8873_probe,
+	.remove		= ksz8873_remove,
+#ifdef CONFIG_MDIO_BITBANG_MICREL_SMI
+	.config_intr	= ksz8873_config_intr,
+	.did_interrupt	= ksz8873_did_interrupt,
+	.ack_interrupt	= ksz8873_ack_interrupt,
+#endif
+};
+
+static int __init ksphy_ksz8873_init(void)
+{
+	int ret;
+	ret = phy_driver_register(&ksz8873_driver);
+	return ret;
+}
+
+static void __exit ksphy_ksz8873_exit(void)
+{
+	phy_driver_unregister(&ksz8873_driver);
+}
+
+module_init(ksphy_ksz8873_init);
+module_exit(ksphy_ksz8873_exit);
+
+MODULE_DESCRIPTION("Micrel PHY driver (Owen)");
+MODULE_AUTHOR("Alexander Dsugan, Softerra LLC");
+MODULE_LICENSE("GPL");
+
+static struct mdio_device_id __maybe_unused micrel_ksz8873_tbl[] = {
+	{ PHY_ID_KSZ8873, 0x00ffffff },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, micrel_ksz8873_tbl);
diff -x .svn -Nru linux-3.0.x-orig/drivers/pcmcia/at91_cf.c linux-3.0.x-arm/drivers/pcmcia/at91_cf.c
--- linux-3.0.x-orig/drivers/pcmcia/at91_cf.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/pcmcia/at91_cf.c	2012-12-19 11:27:23.000000000 +0200
@@ -25,8 +25,12 @@
 #include <asm/gpio.h>
 
 #include <mach/board.h>
-#include <mach/at91rm9200_mc.h>
 
+#if defined(CONFIG_ARCH_AT91RM9200)
+#include <mach/at91rm9200_mc.h>
+#else
+#include <mach/at91sam9_smc.h>
+#endif
 
 /*
  * A0..A10 work in each range; A23 indicates I/O space;  A25 is CFRNW;
@@ -156,7 +160,11 @@
 	/*
 	 * Use 16 bit accesses unless/until we need 8-bit i/o space.
 	 */
+#if defined(CONFIG_ARCH_AT91RM9200)
 	csr = at91_sys_read(AT91_SMC_CSR(cf->board->chipselect)) & ~AT91_SMC_DBW;
+#else
+	csr = at91_sys_read(AT91_SMC_MODE(cf->board->chipselect)) & ~AT91_SMC_DBW;
+#endif
 
 	/*
 	 * NOTE: this CF controller ignores IOIS16, so we can't really do
@@ -175,7 +183,11 @@
 		csr |= AT91_SMC_DBW_16;
 		pr_debug("%s: 16bit i/o bus\n", driver_name);
 	}
+#if defined(CONFIG_ARCH_AT91RM9200)
 	at91_sys_write(AT91_SMC_CSR(cf->board->chipselect), csr);
+#else
+	at91_sys_write(AT91_SMC_MODE(cf->board->chipselect), csr);
+#endif
 
 	io->start = cf->socket.io_offset;
 	io->stop = io->start + SZ_2K - 1;
diff -x .svn -Nru linux-3.0.x-orig/drivers/pcmcia/Kconfig linux-3.0.x-arm/drivers/pcmcia/Kconfig
--- linux-3.0.x-orig/drivers/pcmcia/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/pcmcia/Kconfig	2012-12-19 11:27:23.000000000 +0200
@@ -286,7 +286,7 @@
 
 config AT91_CF
 	tristate "AT91 CompactFlash Controller"
-	depends on PCMCIA && ARCH_AT91RM9200
+	depends on PCMCIA && (ARCH_AT91RM9200 || ARCH_AT91SAM9260 || ARCH_AT91SAM9G20)
 	help
 	  Say Y here to support the CompactFlash controller on AT91 chips.
 	  Or choose M to compile the driver as a module named "at91_cf".
diff -x .svn -Nru linux-3.0.x-orig/drivers/rtc/rtc-at91rm9200.c linux-3.0.x-arm/drivers/rtc/rtc-at91rm9200.c
--- linux-3.0.x-orig/drivers/rtc/rtc-at91rm9200.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/rtc/rtc-at91rm9200.c	2012-12-19 11:27:36.000000000 +0200
@@ -275,12 +275,6 @@
 		return ret;
 	}
 
-	/* cpu init code should really have flagged this device as
-	 * being wake-capable; if it didn't, do that here.
-	 */
-	if (!device_can_wakeup(&pdev->dev))
-		device_init_wakeup(&pdev->dev, 1);
-
 	rtc = rtc_device_register(pdev->name, &pdev->dev,
 				&at91_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc)) {
@@ -288,6 +282,7 @@
 		return PTR_ERR(rtc);
 	}
 	platform_set_drvdata(pdev, rtc);
+	device_init_wakeup(&pdev->dev, 1);
 
 	printk(KERN_INFO "AT91 Real Time Clock driver.\n");
 	return 0;
@@ -300,6 +295,8 @@
 {
 	struct rtc_device *rtc = platform_get_drvdata(pdev);
 
+	device_init_wakeup(&pdev->dev, 0);
+
 	/* Disable all interrupts */
 	at91_sys_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM |
 					AT91_RTC_SECEV | AT91_RTC_TIMEV |
diff -x .svn -Nru linux-3.0.x-orig/drivers/rtc/rtc-at91sam9.c linux-3.0.x-arm/drivers/rtc/rtc-at91sam9.c
--- linux-3.0.x-orig/drivers/rtc/rtc-at91sam9.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/rtc/rtc-at91sam9.c	2012-12-19 11:27:36.000000000 +0200
@@ -151,6 +151,9 @@
 	return 0;
 }
 
+/*
+ * Read alarm time and date in RTC
+ */
 static int at91_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 {
 	struct sam9_rtc *rtc = dev_get_drvdata(dev);
@@ -177,6 +180,9 @@
 	return 0;
 }
 
+/*
+ * Set alarm time and date in RTC
+ */
 static int at91_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
 {
 	struct sam9_rtc *rtc = dev_get_drvdata(dev);
@@ -302,10 +308,6 @@
 	if (!rtc)
 		return -ENOMEM;
 
-	/* platform setup code should have handled this; sigh */
-	if (!device_can_wakeup(&pdev->dev))
-		device_init_wakeup(&pdev->dev, 1);
-
 	platform_set_drvdata(pdev, rtc);
 	rtc->rtt = (void __force __iomem *) (AT91_VA_BASE_SYS - AT91_BASE_SYS);
 	rtc->rtt += r->start;
@@ -339,6 +341,8 @@
 		goto fail;
 	}
 
+	device_init_wakeup(&pdev->dev, 1);
+
 	/* NOTE:  sam9260 rev A silicon has a ROM bug which resets the
 	 * RTT on at least some reboots.  If you have that chip, you must
 	 * initialize the time from some external source like a GPS, wall
@@ -369,6 +373,7 @@
 	rtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));
 	free_irq(AT91_ID_SYS, rtc);
 
+	device_init_wakeup(&pdev->dev, 0);
 	rtc_device_unregister(rtc->rtcdev);
 
 	platform_set_drvdata(pdev, NULL);
diff -x .svn -Nru linux-3.0.x-orig/drivers/spi/atmel_spi.c linux-3.0.x-arm/drivers/spi/atmel_spi.c
--- linux-3.0.x-orig/drivers/spi/atmel_spi.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/spi/atmel_spi.c	2012-12-19 11:27:00.000000000 +0200
@@ -27,6 +27,10 @@
 
 #include "atmel_spi.h"
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+#include <linux/timer.h>
+#endif
+
 /*
  * The core SPI transfer engine just talks to a register bank to set up
  * DMA transfers; transfer queue progress is driven by IRQs.  The clock
@@ -50,12 +54,37 @@
 
 	void			*buffer;
 	dma_addr_t		buffer_dma;
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	struct timer_list msg_timer;	/* timeout */
+	struct {	/* protected by common spi lock as->lock */
+		unsigned timeout: 1;		/* 1 - if timeout happend before ISR */
+		unsigned isr: 1;			/* 1 - if ISR happend before timeout */
+	} flags;
+	u32 msg_usecs;				/* calculated time for message in usecs > 0 */
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+	u32 start_counter;			/* how many times timer was started */
+	u32 cancel_counter;			/* how many times timer was canceled */
+	u32 fault_counter;			/* how many times the bug occurred */
+	u32 to_counter;				/* timeouts which don't seem to be the failure */
+	u32 success_recover_counter;	/* how many faults were recovered with success code */
+
+	/* try finding a possible driver short off-on which could cause the bug: count strange cases */
+	u32 xfer_cur_no_next_counter; 	/* cases when cur xfer is present bu no next */
+	u32 xfer_cs_change_counter;		/* CS change after a xfer completed, but another xfer may be in progress??? */
+#endif
+#endif
 };
 
 /* Controller-specific per-slave state */
 struct atmel_spi_device {
 	unsigned int		npcs_pin;
 	u32			csr;
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	u32 clk_rate;				/* real clock rate for the device */
+#endif
 };
 
 #define BUFFER_SIZE		PAGE_SIZE
@@ -110,6 +139,9 @@
 	u32 mr;
 
 	if (atmel_spi_is_v2()) {
+		/* Always use channel 0: real or fake spi->chip_select - doesn't matter,
+		 * use CSR0 and CS0 pin is controlled via specified GPIO pin in board info
+		 */
 		/*
 		 * Always use CSR0. This ensures that the clock
 		 * switches to the correct idle polarity before we
@@ -122,6 +154,9 @@
 		gpio_set_value(asd->npcs_pin, active);
 	} else {
 		u32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;
+
+#if !(CONFIG_SPI_ATMEL_CS_COUNT > 4)
+		/* old behavior for !v2 - really configure selected channel with CSx controlled by GPIO (except CS0) */
 		int i;
 		u32 csr;
 
@@ -138,6 +173,28 @@
 		if (spi->chip_select != 0)
 			gpio_set_value(asd->npcs_pin, active);
 		spi_writel(as, MR, mr);
+#else
+		/* CS may be not real, so use behavior like for V2 branch, but we can't use CSR0, so use CSR1 */
+		/* for CS 0 - still use hw config - old behavior */
+		if (spi->chip_select == 0) {
+			u32 csr;
+			/* for this case CSR is written by atmel_spi_setup() */
+			csr = spi_readl(as, CSR0);
+			if ((csr ^ cpol) & SPI_BIT(CPOL))
+				spi_writel(as, CSR0, csr ^ SPI_BIT(CPOL));
+
+			mr = spi_readl(as, MR);
+			mr = SPI_BFINS(PCS, 0x0e, mr); /* 1110 */
+			spi_writel(as, MR, mr);	
+		} else {
+			/* always use CSR1, like CSR0 for v2 branch above */
+			spi_writel(as, CSR1, asd->csr);
+			mr = spi_readl(as, MR);
+			mr = SPI_BFINS(PCS, 0x0d, mr); /* 1101 */
+			gpio_set_value(asd->npcs_pin, active);
+			spi_writel(as, MR, mr);
+		}
+#endif
 	}
 
 	dev_dbg(&spi->dev, "activate %u%s, mr %08x\n",
@@ -155,10 +212,22 @@
 	 * another device may be active when this routine is called.
 	 */
 	mr = spi_readl(as, MR);
+	
+#if !(CONFIG_SPI_ATMEL_CS_COUNT > 4)
 	if (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {
-		mr = SPI_BFINS(PCS, 0xf, mr);
+		mr = SPI_BFINS(PCS, 0xf, mr);	/* TODO: actually it seems to disable ALL peripheral ?? */
 		spi_writel(as, MR, mr);
 	}
+#else
+	{
+		/* if CS can be fake calc really used CS channel */
+		u8 cs = (atmel_spi_is_v2() || spi->chip_select == 0) ? 0 : 1;
+		if (~SPI_BFEXT(PCS, mr) & (1 << cs)) {
+			mr = SPI_BFINS(PCS, SPI_BFEXT(PCS, mr) | (1 << cs), mr);
+			spi_writel(as, MR, mr);
+		}
+	}
+#endif
 
 	dev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",
 			asd->npcs_pin, active ? " (low)" : "",
@@ -223,12 +292,22 @@
 	u32			ieval;
 	dma_addr_t		tx_dma, rx_dma;
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	struct spi_device *spi = msg->spi;
+	struct atmel_spi_device *asd = (struct atmel_spi_device *)spi->controller_state;
+	u32 wait_len;
+#endif
+
 	if (!as->current_transfer)
 		xfer = list_entry(msg->transfers.next,
 				struct spi_transfer, transfer_list);
-	else if (!as->next_transfer)
+	else if (!as->next_transfer) {
 		xfer = list_entry(as->current_transfer->transfer_list.next,
 				struct spi_transfer, transfer_list);
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+		as->xfer_cur_no_next_counter++;
+#endif
+	}
 	else
 		xfer = NULL;
 
@@ -297,6 +376,23 @@
 		ieval = SPI_BIT(RXBUFF) | SPI_BIT(ENDRX) | SPI_BIT(OVRES);
 	}
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	/* the 'worst case is both RCR != 0 and RNCR != 0, so the max delay
+	 * is (RCR + RNCR) * rate 
+	 * - start timer for time > this delay.
+	 * - delete timer in interrupt handler, then restart timer for the works case again from here
+	 */
+	wait_len = spi_readl(as, RCR);
+	as->msg_usecs = wait_len * 8 * 1000 / (asd->clk_rate / 1000);
+	as->msg_timer.data = (unsigned long)master;
+	as->msg_timer.expires = jiffies + (as->msg_usecs * CONFIG_HZ / 1000000) + 1;
+	as->msg_timer.expires += 2; /* let irq handler be first if it fires */
+	as->flags.timeout = 0;
+	as->flags.isr = 0;
+//	pr_debug("timer for %u bytes = %u usecs => jiffies: %lu -> %lu (asd=%p: clk=%u)\n", 
+//		wait_len, as->msg_usecs, jiffies, as->msg_timer.expires, asd, asd->clk_rate);
+#endif
+
 	/* REVISIT: We're waiting for ENDRX before we start the next
 	 * transfer because we need to handle some difficult timing
 	 * issues otherwise. If we wait for ENDTX in one transfer and
@@ -309,6 +405,13 @@
 	 */
 	spi_writel(as, IER, ieval);
 	spi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	add_timer(&as->msg_timer);
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+	as->start_counter++;
+#endif
+#endif
 }
 
 static void atmel_spi_next_message(struct spi_master *master)
@@ -437,6 +540,23 @@
 	status = spi_readl(as, SR);
 	pending = status & imr;
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	if (pending & (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX) | SPI_BIT(OVRES))) {
+		if (as->flags.timeout) {
+			/* do nothing - timer handler already done */
+			spin_unlock(&as->lock);
+			return IRQ_HANDLED;
+		}
+
+		/* otherwise we'll do it */
+		as->flags.isr = 1;
+		del_timer(&as->msg_timer);
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS		
+		as->cancel_counter++;
+#endif
+	}
+#endif
+
 	if (pending & SPI_BIT(OVRES)) {
 		int timeout;
 
@@ -509,6 +629,9 @@
 						xfer->cs_change);
 			} else {
 				if (xfer->cs_change) {
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+					as->xfer_cs_change_counter++;
+#endif
 					cs_deactivate(as, msg->spi);
 					udelay(1);
 					cs_activate(as, msg->spi);
@@ -535,6 +658,226 @@
 	return ret;
 }
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+static void dump_cs(struct spi_device *spi)
+{
+	struct atmel_spi_device *asd = spi->controller_state;
+	unsigned active = spi->mode & SPI_CS_HIGH;
+	int cs;
+	cs = gpio_get_value(asd->npcs_pin);
+	pr_notice("CS (%s): %sactive\n", dev_name(&spi->dev), cs != active ? "not " : "");
+}
+static void dump_regs(struct atmel_spi *as)
+{
+	u32 cr, mr, sr, imr, csr1;
+	u32 rcr, tcr, rncr, tncr, ptsr;
+
+	cr = spi_readl(as, CR);
+	mr = spi_readl(as, MR);
+	sr = spi_readl(as, SR);
+	imr = spi_readl(as, IMR);
+	csr1 = spi_readl(as, CSR1);
+	
+	rcr = spi_readl(as, RCR);
+	tcr = spi_readl(as, TCR);
+	rncr = spi_readl(as, RNCR);
+	tncr = spi_readl(as, TNCR);
+	ptsr = spi_readl(as, PTSR);
+
+	pr_notice(
+		"SPI:     CR   = %08X    MR   = %08X    SR   = %08X    IMR  = %08X    CSR1 = %08X\n"
+		"SPI PDC: TCR  = %08X    TNCR = %08X    RCR  = %08X    RNCR = %08X    PTSR = %08X\n",
+		cr, mr, sr, imr, csr1,
+		tcr, tncr, rcr, rncr, ptsr);
+}
+#endif /* CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS */
+
+/** recover_mode - bit field, where bits
+ * 0: 1 - print state, 0 - do not print
+ * 1: 1 - recover, 0 - do not recover
+ */
+int atmel_spi_handle_hangup(struct spi_master *master, int mode)
+{
+	struct atmel_spi *as;
+	struct spi_message *rmsg = NULL;
+	struct spi_transfer	*xfer;
+	int r = 0;
+	
+	as = spi_master_get_devdata(master);
+	if (!as) {
+		pr_err("failed to get dev data for master\n");
+		return -1;
+	}
+
+	if (likely(mode & 0x0002)) {
+		if (likely(!list_empty(&as->queue))) {
+			/* disable ints and transfers */
+			spi_writel(as, IDR, (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX)
+					     | SPI_BIT(OVRES)));
+			spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
+
+			rmsg = list_entry(as->queue.next, struct spi_message, queue);
+			as->flags.timeout = 1;
+		} else {
+			pr_err("failed to recover - no messages\n");
+			r = -1;
+		}
+	}
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+	if (mode & 0x0001) {
+		xfer = as->current_transfer;
+		pr_notice("Current xfer: %p\n", xfer);
+		if (xfer) {
+			pr_notice(" len %u %s%s\n", xfer->len,
+				xfer->tx_buf ? "TX" : "", xfer->rx_buf ? "RX": "");
+		}
+		pr_notice("Current remaining bytes: %lu\n", as->current_remaining_bytes);
+
+		pr_notice("Message queue: ");
+		if (unlikely(list_empty(&as->queue))) {
+			printk("empty\n");
+		} else {
+			struct spi_message *msg;
+			printk("\n");
+			list_for_each_entry(msg, &as->queue, queue) {
+				pr_notice(" msg: %p\n", msg);
+
+				list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+					pr_notice("    xfer: %p, len %u %s%s\n", xfer, xfer->len,
+						xfer->tx_buf ? "TX" : "", xfer->rx_buf ? "RX": "");
+				}
+			}
+
+			msg = list_entry(as->queue.next, struct spi_message, queue);
+			dump_cs(msg->spi);
+		}
+		dump_regs(as);
+	}
+#endif /* CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS */
+
+	if (rmsg) {
+		int rcode = -EIO;
+		u32 rcr, tcr;
+
+		/* current hanged transfer */
+		xfer = as->current_transfer;
+
+		/* determine which problem we have and result code */ 
+		rcr = spi_readl(as, RCR);
+		tcr = spi_readl(as, TCR);
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+		if ((rcr == 1) && !tcr) {
+			/* the bug case */
+			as->fault_counter++;
+		} else {
+			/* just timeout or other bug? */
+			as->to_counter++;
+		}
+#endif
+
+		/* Try returning success for the cases:
+		 * - problem xfer is the last 
+		 *    AND
+		 *    - it's a pure TX request (no RX buf) AND all data sent - 
+		 *                  don't pay attention to the kind of the timeout 
+		 * NOTE: the assumption that receptioni is correct failed. So, for RX case - return error
+		 */
+		if (atmel_spi_xfer_is_last(rmsg, xfer) && 
+			(xfer->tx_buf && !xfer->rx_buf) && !tcr) {
+			rcode = 0;
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+			as->success_recover_counter++;
+#endif
+		}
+
+		/* unmap buffers as need */
+		if (!rmsg->is_dma_mapped)
+			atmel_spi_dma_unmap_xfer(master, xfer);
+
+		/* clean regs */
+		spi_writel(as, RNCR, 0);
+		spi_writel(as, TNCR, 0);
+		spi_writel(as, RCR, 0);
+		spi_writel(as, TCR, 0);
+
+		while (spi_readl(as, SR) & SPI_BIT(RDRF))
+			spi_readl(as, RDR);
+
+		/* Clear any overrun happening while cleaning up */
+		spi_readl(as, SR);
+
+		/* done */
+		pr_notice("Recovering, msg: %p for %s, rc=%d\n", 
+				rmsg, dev_name(&rmsg->spi->dev), rcode);
+		atmel_spi_msg_done(master, as, rmsg, rcode, 0);
+	}
+
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS
+	if (mode & 0x0001) {
+		pr_notice("Timer:\n"
+				" starts:       %u\n"
+				" cancels:      %u\n"
+				" faults:       %u\n"
+				" time-outs:    %u\n"
+				"   successes: %u\n",
+				as->start_counter, as->cancel_counter, 
+				as->fault_counter, as->to_counter,
+				as->success_recover_counter);
+		pr_notice("OTHER:\n"
+				" xfer_cur_no_next=%u\n"
+				" xfer_cs_change_counter=%u\n", 
+				as->xfer_cur_no_next_counter, as->xfer_cs_change_counter);
+	}
+#endif
+	return r;
+}
+EXPORT_SYMBOL_GPL(atmel_spi_handle_hangup);
+
+static void handle_msg_timeout(unsigned long data)
+{
+	struct spi_master	*master = (struct spi_master *)data;
+	struct atmel_spi *as;
+	int locked;
+	int mode = 0x0002; /* only recover by default */
+
+	if (!master) {
+		pr_err("%s: bad data\n", __func__);
+		return;
+	}
+	as = spi_master_get_devdata(master);
+	if (!as) {
+		pr_err("failed to get data\n");
+		return;
+	}
+
+	locked = spin_trylock(&as->lock);
+	if (!locked) {
+		pr_err("failed to acquire lock - irq fired?\n");
+		return;
+	}
+
+	/* check if ISR already done the work */
+	if (as->flags.isr) {
+		/* do nothing - ISR already done */
+		spin_unlock(&as->lock);
+		return;
+	}
+
+	/* otherwise: print state and recover */
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER_STATS	
+	pr_notice("==MSG TIMEOUT==\n");
+	mode |= 0x0001;
+#endif
+
+	atmel_spi_handle_hangup(master, mode);
+
+	spin_unlock(&as->lock);
+}
+#endif /* CONFIG_SPI_ATMEL_XFER_GUARD_TIMER */
+
 static int atmel_spi_setup(struct spi_device *spi)
 {
 	struct atmel_spi	*as;
@@ -550,7 +893,7 @@
 	if (as->stopping)
 		return -ESHUTDOWN;
 
-	if (spi->chip_select > spi->master->num_chipselect) {
+	if (spi->chip_select >= spi->master->num_chipselect) {
 		dev_dbg(&spi->dev,
 				"setup: invalid chipselect %u (%u defined)\n",
 				spi->chip_select, spi->master->num_chipselect);
@@ -598,6 +941,11 @@
 		/* speed zero means "as slow as possible" */
 		scbr = 0xff;
 
+	/* correct SBCR for !v2 processors: value is 2..255, 0 & 1 turn SPI clock off */
+	if (!atmel_spi_is_v2() && (scbr == 1)) {
+		scbr = 2;
+	}
+
 	csr = SPI_BF(SCBR, scbr) | SPI_BF(BITS, bits - 8);
 	if (spi->mode & SPI_CPOL)
 		csr |= SPI_BIT(CPOL);
@@ -610,8 +958,32 @@
 	 * It could potentially be useful to cope with DMA bottlenecks, but
 	 * in those cases it's probably best to just use a lower bitrate.
 	 */
+#if defined(CONFIG_MACH_OWEN_PLC240)
+	if (2 == spi->chip_select)
+	{
+	    csr |= SPI_BF(DLYBS, 0xFF);
+	    csr |= SPI_BF(DLYBCT,0xFF);
+        }
+        else
+        {
+	    csr |= SPI_BF(DLYBS, 0);
+	    csr |= SPI_BF(DLYBCT, 0);
+	}
+#elif defined(CONFIG_MACH_OWEN_PLC323)
+	if (5 == spi->chip_select)
+	{
+	    csr |= SPI_BF(DLYBS, 0xFF);
+	    csr |= SPI_BF(DLYBCT,0xFF);
+        }
+        else
+        {
+	    csr |= SPI_BF(DLYBS, 0);
+	    csr |= SPI_BF(DLYBCT, 0);
+	}
+#else
 	csr |= SPI_BF(DLYBS, 0);
 	csr |= SPI_BF(DLYBCT, 0);
+#endif
 
 	/* chipselect must have been muxed as GPIO (e.g. in board setup) */
 	npcs_pin = (unsigned int)spi->controller_data;
@@ -641,13 +1013,24 @@
 	}
 
 	asd->csr = csr;
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	asd->clk_rate = bus_hz / scbr;
+#endif
 
 	dev_dbg(&spi->dev,
 		"setup: %lu Hz bpw %u mode 0x%x -> csr%d %08x\n",
 		bus_hz / scbr, bits, spi->mode, spi->chip_select, csr);
 
-	if (!atmel_spi_is_v2())
+	/* old behaviour for CS_COUNT=4 or (CS_COUNT>4 and CS0) */
+	if (!atmel_spi_is_v2()) {
+#if !(CONFIG_SPI_ATMEL_CS_COUNT > 4)
 		spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
+#else
+		if (spi->chip_select == 0)
+			spi_writel(as, CSR0, csr);
+		/* for the rest CSx - use V2 behavour with CSR1 */
+#endif
+	}
 
 	return 0;
 }
@@ -726,7 +1109,6 @@
 	if (!as->current_transfer)
 		atmel_spi_next_message(spi->master);
 	spin_unlock_irqrestore(&as->lock, flags);
-
 	return 0;
 }
 
@@ -785,7 +1167,11 @@
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
 
 	master->bus_num = pdev->id;
+#if (CONFIG_SPI_ATMEL_CS_COUNT > 4)
+	master->num_chipselect = CONFIG_SPI_ATMEL_CS_COUNT;
+#else
 	master->num_chipselect = 4;
+#endif /*CONFIG_SPI_ATMEL_CS_COUNT > 4*/
 	master->setup = atmel_spi_setup;
 	master->transfer = atmel_spi_transfer;
 	master->cleanup = atmel_spi_cleanup;
@@ -824,6 +1210,11 @@
 	spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
 	spi_writel(as, CR, SPI_BIT(SPIEN));
 
+#ifdef CONFIG_SPI_ATMEL_XFER_GUARD_TIMER
+	init_timer(&as->msg_timer);
+	as->msg_timer.function = handle_msg_timeout;
+#endif
+
 	/* go! */
 	dev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",
 			(unsigned long)regs->start, irq);
diff -x .svn -Nru linux-3.0.x-orig/drivers/spi/Kconfig linux-3.0.x-arm/drivers/spi/Kconfig
--- linux-3.0.x-orig/drivers/spi/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/spi/Kconfig	2012-12-19 11:27:00.000000000 +0200
@@ -74,6 +74,43 @@
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
 
+config SPI_ATMEL_CS_COUNT
+	int "Number of max chip selects supported (EXPERIMENTAL)"
+	depends on (SPI_ATMEL && EXPERIMENTAL)
+	range 4 16 if (ARCH_AT91RM9200 || ARCH_AT91SAM9263)
+	range 4 4 if !(ARCH_AT91RM9200 || ARCH_AT91SAM9263)
+	default 4
+	help
+	  Specify max. number of supported Chip Selects: from 4(0-3) up to 16 (0-15) for
+	  ARCH_AT91RM9200 || ARCH_AT91SAM9263, 4 - for rest archs (until they tested).
+	  Actually the max number of chipselects can be as many as count of free GPIOs on
+	  your system because atmel_spi controls CSs as GPIOs.
+
+config SPI_ATMEL_XFER_GUARD_TIMER
+	bool "Use transfer guard timer"
+	depends on (SPI_ATMEL && EXPERIMENTAL)
+	default n
+	help
+	  Use guard timer for every xfer. 
+	  It was noticed on Owen's PLC323 based on AT91RM9200 that data transfers 
+	  of 4096 bytes (or smaller) blocks sometimes hang. PDC loses 1 byte while
+	  reading data, so transfer can't be completed and waiting thread is blocked.
+	  The timer unblocks waiting threads by performing required actions and 
+	  calling atmel_spi_msg_done(). If transfer was a TX-only and TCR=0 
+	  (all user's data successfully transfered), then 
+	  success is returned to the user, otherwise -EIO error returned.
+
+config SPI_ATMEL_XFER_GUARD_TIMER_STATS
+	bool "Display as notice guard timer's statistics on timeout"
+	depends on SPI_ATMEL_XFER_GUARD_TIMER
+	default n
+	help
+	  When guard timer fires the handler displays some information:
+	  SPI registers state, CS line state, current message queue,
+	  timer counters: how many times it was started, canceled, 
+	  fired (faults and other timeouts), how many times it recovered with
+	  success code, current recovering code.
+
 config SPI_BFIN
 	tristate "SPI controller driver for ADI Blackfin5xx"
 	depends on BLACKFIN
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/atmel_serial.c linux-3.0.x-arm/drivers/tty/serial/atmel_serial.c
--- linux-3.0.x-orig/drivers/tty/serial/atmel_serial.c	2013-09-19 17:39:50.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/atmel_serial.c	2012-12-19 11:28:05.000000000 +0200
@@ -37,6 +37,11 @@
 #include <linux/atmel_pdc.h>
 #include <linux/atmel_serial.h>
 #include <linux/uaccess.h>
+#include <linux/gpio.h>
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+#include <linux/timer.h>
+#include <linux/device.h>
+#endif
 
 #include <asm/io.h>
 #include <asm/ioctls.h>
@@ -53,6 +58,11 @@
 /* Revisit: We should calculate this based on the actual port settings */
 #define PDC_RX_TIMEOUT		(3 * 10)		/* 3 bytes */
 
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+/* in jiffies */
+static int dbgu_dma_rx_to = (100 * CONFIG_HZ /1000);
+#endif
+
 #if defined(CONFIG_SERIAL_ATMEL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
@@ -154,6 +164,22 @@
 
 	struct serial_rs485	rs485;		/* rs485 settings */
 	unsigned int		tx_done_mask;
+
+	/* rs485 Owen-specific settings */
+	unsigned int		rs485_switch_pin;	/* PIN switching the output circuit between rs485 and rs232 lines. If not speicified, switching is disabled */
+	unsigned char		rs485_active_level;	/* which level (0 or 1) is used to activate RS485 mode */
+
+	/* Owen-specific addition: pins implementing full-modem UART (see PLC240-SPK207) */
+	unsigned int		pin_DCD;	/* signal DCD input */
+	unsigned int		pin_DTR;	/* signal DTR output */
+	unsigned int		pin_DSR;	/* signal DSR input */
+	unsigned int		pin_RI;		/* signal RI input */
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	struct timer_list	dbgu_dma_rx_timer;	/* RX timer for DBGU DMA RX */
+	struct device_attribute dbgu_timeout;	/* timeout value for DBGU DMA RX */
+	int dbgu_timeout_configured;
+#endif
 };
 
 static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
@@ -194,13 +220,64 @@
 }
 #endif
 
-/* Enable or disable the rs485 support */
-void atmel_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+static ssize_t dbgu_timeout_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ms = dbgu_dma_rx_to * 1000 / CONFIG_HZ;
+	return sprintf(buf, "%d ms\n", ms);
+}
+
+static ssize_t dbgu_timeout_store(struct device *dev, struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	int ms;
+	ms = simple_strtol(buf, NULL, 0);
+	/* check for acceptable values 1-1000 ms */
+	if (ms < 1 || ms > 1000) {
+		/* set default 100 ms */
+		ms = 100;
+	}
+	dbgu_dma_rx_to = (ms * CONFIG_HZ /1000);
+	if (!dbgu_dma_rx_to) {
+		dbgu_dma_rx_to = 1;
+	}
+	return count;
+}
+
+static bool atmel_is_dbgu_with_rx_dma(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+
+	if (atmel_port->use_dma_rx && 
+		(port->mapbase == AT91_VA_BASE_SYS + AT91_DBGU)) {
+		return true;
+	}
+	return false;
+}
+#endif
+
+/* Enable or disable the rs485 support 
+* NOTE: other flags should be passed also because the whole structure is copied to the kernel
+*/
+int atmel_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 	unsigned int mode;
 	unsigned long flags;
 
+	if (!atmel_port->rs485_switch_pin) {
+		dev_dbg(port->dev, "port=%d: skip RS485 configuration - not allowed\n", port->line);
+
+		/* if requested mode is used - return success, otherwise - error */
+		if (!memcmp(&atmel_port->rs485, rs485conf, sizeof(atmel_port->rs485))) {
+			/* nothing to do - requested mode is already set */
+			dev_dbg(port->dev, "port=%d: but requested RS485 configuration is already set - OK\n", port->line);
+			return 0;
+		}
+		
+		return -EPERM; /* otherwise it's error - RS485/232 should be configured once at startup and never changed */
+	}
+
 	spin_lock_irqsave(&port->lock, flags);
 
 	/* Disable interrupts */
@@ -213,6 +290,12 @@
 
 	atmel_port->rs485 = *rs485conf;
 
+	/* switch output circuit */
+	at91_set_gpio_value(atmel_port->rs485_switch_pin, 
+		(rs485conf->flags & SER_RS485_ENABLED) ? 
+			atmel_port->rs485_active_level : !atmel_port->rs485_active_level);
+
+	/* switch UART */
 	if (rs485conf->flags & SER_RS485_ENABLED) {
 		dev_dbg(port->dev, "Setting UART to RS485\n");
 		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
@@ -234,6 +317,8 @@
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
+	/*pr_info("%s: port=%d, MR set=0x%08X\n", __func__, port->line, mode);*/
+	return 0;
 }
 
 /*
@@ -273,10 +358,20 @@
 	else
 		control |= ATMEL_US_RTSDIS;
 
-	if (mctrl & TIOCM_DTR)
-		control |= ATMEL_US_DTREN;
-	else
-		control |= ATMEL_US_DTRDIS;
+	if (atmel_port->pin_DTR) {
+		if (mctrl & TIOCM_DTR) {
+			at91_set_gpio_value(atmel_port->pin_DTR, 0);
+			control |= ATMEL_US_DTREN;
+		} else {
+			at91_set_gpio_value(atmel_port->pin_DTR, 1);
+			control |= ATMEL_US_DTRDIS;
+		}
+	} else {
+		if (mctrl & TIOCM_DTR)
+			control |= ATMEL_US_DTREN;
+		else
+			control |= ATMEL_US_DTRDIS;
+	}
 
 	UART_PUT_CR(port, control);
 
@@ -287,6 +382,11 @@
 	else
 		mode |= ATMEL_US_CHMODE_NORMAL;
 
+/* do not reset USMODE 'cause we can damage HW flow control settings here:
+ *	switching RS485/232 is done by IOCTL or when initializing the port,
+ *    here just keep this field unchanged
+ */
+#if 0
 	/* Resetting serial mode to RS232 (0x0) */
 	mode &= ~ATMEL_US_USMODE;
 
@@ -299,7 +399,11 @@
 	} else {
 		dev_dbg(port->dev, "Setting UART to RS232\n");
 	}
+#endif
+
 	UART_PUT_MR(port, mode);
+
+	/*pr_info("%s: port=%d, MR set=0x%08X\n", __func__, port->line, mode);*/
 }
 
 /*
@@ -308,20 +412,41 @@
 static u_int atmel_get_mctrl(struct uart_port *port)
 {
 	unsigned int status, ret = 0;
+	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
 	status = UART_GET_CSR(port);
 
 	/*
 	 * The control signals are active low.
 	 */
-	if (!(status & ATMEL_US_DCD))
-		ret |= TIOCM_CD;
+	atmel_port = (struct atmel_uart_port *)port;
+
+	if (atmel_port->pin_DCD) {
+		if (!at91_get_gpio_value(atmel_port->pin_DCD))
+			ret |= TIOCM_CD;
+	} else {
+		if (!(status & ATMEL_US_DCD))
+			ret |= TIOCM_CD;
+	}
+
 	if (!(status & ATMEL_US_CTS))
 		ret |= TIOCM_CTS;
-	if (!(status & ATMEL_US_DSR))
-		ret |= TIOCM_DSR;
-	if (!(status & ATMEL_US_RI))
-		ret |= TIOCM_RI;
+
+	if (atmel_port->pin_DSR) {
+		if (!at91_get_gpio_value(atmel_port->pin_DSR))
+			ret |= TIOCM_DSR;
+	} else {
+		if (!(status & ATMEL_US_DSR))
+			ret |= TIOCM_DSR;
+	}
+
+	if (atmel_port->pin_RI) {
+		if (!at91_get_gpio_value(atmel_port->pin_RI))
+			ret |= TIOCM_RI;
+	} else {
+		if (!(status & ATMEL_US_RI))
+			ret |= TIOCM_RI;
+	}
 
 	return ret;
 }
@@ -565,6 +690,7 @@
 		if (pending & (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT)) {
 			UART_PUT_IDR(port, (ATMEL_US_ENDRX
 						| ATMEL_US_TIMEOUT));
+
 			tasklet_schedule(&atmel_port->tasklet);
 		}
 
@@ -845,6 +971,12 @@
 	unsigned int status;
 	unsigned int status_change;
 
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	if (atmel_is_dbgu_with_rx_dma(port)) {
+		del_timer(&atmel_port->dbgu_dma_rx_timer);
+	}
+#endif
+
 	/* The interrupt handler does not take the lock */
 	spin_lock(&port->lock);
 
@@ -879,6 +1011,12 @@
 		atmel_rx_from_ring(port);
 
 	spin_unlock(&port->lock);
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	if (atmel_is_dbgu_with_rx_dma(port)) {
+		mod_timer(&atmel_port->dbgu_dma_rx_timer, jiffies + dbgu_dma_rx_to);
+	}
+#endif
 }
 
 /*
@@ -988,6 +1126,12 @@
 		UART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);
 		/* enable PDC controller */
 		UART_PUT_PTCR(port, ATMEL_PDC_RXTEN);
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+		if (atmel_is_dbgu_with_rx_dma(port)) {
+			mod_timer(&atmel_port->dbgu_dma_rx_timer, jiffies + dbgu_dma_rx_to);
+		}
+#endif
 	} else {
 		/* enable receive only */
 		UART_PUT_IER(port, ATMEL_US_RXRDY);
@@ -1002,6 +1146,13 @@
 static void atmel_shutdown(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	if (atmel_is_dbgu_with_rx_dma(port)) {
+		del_timer_sync(&atmel_port->dbgu_dma_rx_timer);
+	}
+#endif
+
 	/*
 	 * Ensure everything is stopped.
 	 */
@@ -1159,11 +1310,21 @@
 	} else
 		mode |= ATMEL_US_PAR_NONE;
 
-	/* hardware handshake (RTS/CTS) */
-	if (termios->c_cflag & CRTSCTS)
-		mode |= ATMEL_US_USMODE_HWHS;
-	else
-		mode |= ATMEL_US_USMODE_NORMAL;
+	if (atmel_port->rs485.flags & SER_RS485_ENABLED) {
+		dev_dbg(port->dev, "Setting UART to RS485\n");
+		if (atmel_port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+			UART_PUT_TTGR(port,
+					atmel_port->rs485.delay_rts_after_send);
+		mode |= ATMEL_US_USMODE_RS485;
+	} else {
+		dev_dbg(port->dev, "Setting UART to RS232\n");
+
+		/* hardware handshake (RTS/CTS) */
+		if (termios->c_cflag & CRTSCTS)
+			mode |= ATMEL_US_USMODE_HWHS;
+		else
+			mode |= ATMEL_US_USMODE_NORMAL;
+	}
 
 	spin_lock_irqsave(&port->lock, flags);
 
@@ -1208,19 +1369,6 @@
 	/* disable receiver and transmitter */
 	UART_PUT_CR(port, ATMEL_US_TXDIS | ATMEL_US_RXDIS);
 
-	/* Resetting serial mode to RS232 (0x0) */
-	mode &= ~ATMEL_US_USMODE;
-
-	if (atmel_port->rs485.flags & SER_RS485_ENABLED) {
-		dev_dbg(port->dev, "Setting UART to RS485\n");
-		if (atmel_port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
-			UART_PUT_TTGR(port,
-					atmel_port->rs485.delay_rts_after_send);
-		mode |= ATMEL_US_USMODE_RS485;
-	} else {
-		dev_dbg(port->dev, "Setting UART to RS232\n");
-	}
-
 	/* set the parity, stop bits and data size */
 	UART_PUT_MR(port, mode);
 
@@ -1237,6 +1385,8 @@
 		port->ops->enable_ms(port);
 
 	spin_unlock_irqrestore(&port->lock, flags);
+
+	/*pr_info("%s: port=%d, MR set=0x%08X\n", __func__, port->line, mode);*/
 }
 
 static void atmel_set_ldisc(struct uart_port *port, int new)
@@ -1363,7 +1513,7 @@
 					sizeof(rs485conf)))
 			return -EFAULT;
 
-		atmel_config_rs485(port, &rs485conf);
+		return atmel_config_rs485(port, &rs485conf);
 		break;
 
 	case TIOCGRS485:
@@ -1408,6 +1558,14 @@
 #endif
 };
 
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+void dbgu_dma_rx_timeout(unsigned long arg)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *)arg;
+	tasklet_schedule(&atmel_port->tasklet);
+}
+#endif
+
 /*
  * Configure the port from the platform device resource info.
  */
@@ -1451,15 +1609,48 @@
 	atmel_port->use_dma_rx = data->use_dma_rx;
 	atmel_port->use_dma_tx = data->use_dma_tx;
 	atmel_port->rs485	= data->rs485;
+
+	atmel_port->rs485_switch_pin = data->rs485_switch_pin;
+	atmel_port->rs485_active_level = data->rs485_active_level;
+
+	atmel_port->pin_DCD = data->pin_DCD;
+	atmel_port->pin_DTR = data->pin_DTR;
+	atmel_port->pin_DSR = data->pin_DSR;
+	atmel_port->pin_RI = data->pin_RI;
+
+	if (atmel_use_dma_tx(port)) {
+		port->fifosize = PDC_BUFFER_SIZE;
+	}
+
 	/* Use TXEMPTY for interrupt when rs485 else TXRDY or ENDTX|TXBUFE */
 	if (atmel_port->rs485.flags & SER_RS485_ENABLED)
 		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
 	else if (atmel_use_dma_tx(port)) {
-		port->fifosize = PDC_BUFFER_SIZE;
 		atmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;
 	} else {
 		atmel_port->tx_done_mask = ATMEL_US_TXRDY;
 	}
+
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	if (atmel_is_dbgu_with_rx_dma(port)) {
+		int r;
+		
+		/* setup timer */
+		atmel_port->dbgu_dma_rx_timer.data = (unsigned long)atmel_port;
+		atmel_port->dbgu_dma_rx_timer.function = dbgu_dma_rx_timeout;
+		init_timer(&atmel_port->dbgu_dma_rx_timer);
+
+		/* setup timeout attribute */
+		atmel_port->dbgu_timeout.attr.name = "dbgu_timeout";
+		atmel_port->dbgu_timeout.show = dbgu_timeout_show;
+		atmel_port->dbgu_timeout.store = dbgu_timeout_store;
+		atmel_port->dbgu_timeout.attr.mode = S_IRUGO | S_IWUSR;
+		r = sysfs_create_file(&pdev->dev.kobj, &atmel_port->dbgu_timeout.attr);
+		if (!r) {
+			atmel_port->dbgu_timeout_configured = 1;
+		}
+	}
+#endif
 }
 
 /*
@@ -1707,6 +1898,42 @@
 #define atmel_serial_resume NULL
 #endif
 
+#ifdef CONFIG_DEBUG_FS
+#define pin_name(name,n) (n==0?name ".0":(n==1?name ".1":(n==2?name ".2":(n==3?name ".3":name))))
+#else
+#define pin_name(name,n) NULL
+#endif
+
+static void __devinit atmel_port_gpio_request(struct atmel_uart_port *port, 
+						struct platform_device *pdev)
+{
+	if (port->pin_DCD) 
+		gpio_request(port->pin_DCD, pin_name("DCD", pdev->id));
+	if (port->pin_DTR) 
+		gpio_request(port->pin_DTR, pin_name("DTR", pdev->id));
+	if (port->pin_DSR) 
+		gpio_request(port->pin_DSR, pin_name("DSR", pdev->id));
+	if (port->pin_RI) 
+		gpio_request(port->pin_RI, pin_name("RI", pdev->id));
+	if (port->rs485_switch_pin) 
+		gpio_request(port->rs485_switch_pin, pin_name("rs485_sw", pdev->id));
+}
+
+static void __devexit atmel_port_gpio_free(struct atmel_uart_port *port, 
+						struct platform_device *pdev)
+{
+	if (port->pin_DCD) 
+		gpio_free(port->pin_DCD);
+	if (port->pin_DTR) 
+		gpio_free(port->pin_DTR);
+	if (port->pin_DSR) 
+		gpio_free(port->pin_DSR);
+	if (port->pin_RI) 
+		gpio_free(port->pin_RI);
+	if (port->rs485_switch_pin) 
+		gpio_free(port->rs485_switch_pin);
+}
+
 static int __devinit atmel_serial_probe(struct platform_device *pdev)
 {
 	struct atmel_uart_port *port;
@@ -1720,6 +1947,7 @@
 	port->backup_imr = 0;
 
 	atmel_init_port(port, pdev);
+	atmel_port_gpio_request(port, pdev);
 
 	if (!atmel_use_dma_rx(&port->uart)) {
 		ret = -ENOMEM;
@@ -1748,9 +1976,20 @@
 	device_init_wakeup(&pdev->dev, 1);
 	platform_set_drvdata(pdev, port);
 
+	/* initialize port in pre-set mode */
+	if (port->rs485_switch_pin) {
+		at91_set_gpio_value(port->rs485_switch_pin, 
+			(port->rs485.flags & SER_RS485_ENABLED) ? 
+				port->rs485_active_level : !port->rs485_active_level);
+	}
 	if (port->rs485.flags & SER_RS485_ENABLED) {
-		UART_PUT_MR(&port->uart, ATMEL_US_USMODE_NORMAL);
+		UART_PUT_MR(&port->uart, ATMEL_US_USMODE_RS485);
+		if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+			UART_PUT_TTGR(&port->uart, port->rs485.delay_rts_after_send);
+		/*pr_info("%s: port=%d, MR set=0x%08X\n", __func__, pdata->num, ATMEL_US_USMODE_RS485);*/
 		UART_PUT_CR(&port->uart, ATMEL_US_RTSEN);
+	} else {
+		UART_PUT_MR(&port->uart, ATMEL_US_USMODE_NORMAL);
 	}
 
 	return 0;
@@ -1773,6 +2012,15 @@
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 	int ret = 0;
 
+#ifdef CONFIG_SERIAL_ATMEL_DBGU_DMA_RX
+	if (atmel_is_dbgu_with_rx_dma(port)) {
+		/* remove timeout attribute */
+		if (atmel_port->dbgu_timeout_configured) {
+			sysfs_remove_file(&pdev->dev.kobj, &atmel_port->dbgu_timeout.attr);
+		}
+	}
+#endif
+
 	device_init_wakeup(&pdev->dev, 0);
 	platform_set_drvdata(pdev, NULL);
 
@@ -1785,6 +2033,8 @@
 
 	clk_put(atmel_port->clk);
 
+	atmel_port_gpio_free(atmel_port, pdev);
+
 	return ret;
 }
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/hpr_serial/hpr_serial.c linux-3.0.x-arm/drivers/tty/serial/hpr_serial/hpr_serial.c
--- linux-3.0.x-orig/drivers/tty/serial/hpr_serial/hpr_serial.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/hpr_serial/hpr_serial.c	2012-12-19 11:28:05.000000000 +0200
@@ -0,0 +1,1252 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/circ_buf.h>
+#include <linux/slab.h>
+
+#include <linux/hpr/hpr.h>
+#include <linux/hpr/hpr_serial.h>
+
+#define HPR_SERIAL_DRV_VERSION "1.5.1/lx30"
+
+/* in order to prevent infinite loop when sending data:
+ * max HPR speed - 2ms - 1 exchange(15 bytes) - 60000 bit/s
+ * if port is  set for 1200 bit/s, we'll need in the worst case 50 repeats */
+#define HPR_SERIAL_OVR_REPEAT_COUNT	51
+
+//#define HPR_SERIAL_TEST
+
+/* TODO: find the source of the problem:
+ * if hpr_one_shot_exchange() failes with an error sleep for some time,
+ * otherwise, if some output occurs in this moment we get into infinte loop.
+ * For, now it is still not clear why this happens. 
+ * For testing we may disable any output by re-defining pr_ macroses.
+ * For working version, as a workaround, we use msleep(10) - which
+ * seems solves the problem as testing on _HZ=1000 showed.
+ */
+//#define HPR_SERIAL_SILENT
+#ifdef HPR_SERIAL_SILENT
+#ifdef pr_debug
+#undef pr_debug
+#define pr_debug(fmt,...)
+#endif
+#ifdef pr_err
+#undef pr_err
+#define pr_err(fmt,...)
+#endif
+#ifdef pr_warning
+#undef pr_warning
+#define pr_warning(fmt,...)
+#endif
+#endif
+
+static int base_num = 2;
+module_param(base_num, int, S_IRUGO);
+MODULE_PARM_DESC(base_num, "Base number of device id");
+
+static int ports_num = 8;
+module_param(ports_num, int, S_IRUGO);
+MODULE_PARM_DESC(ports_num, "Max number of ports allowed");
+
+/* Size of internal circ buffer for writing */
+static int wsize = 512;
+module_param(wsize, int, S_IRUGO);
+MODULE_PARM_DESC(wsize, "Size in bytes of internal write buffer (power of 2)");
+
+static int do_st = 0;
+module_param(do_st, int, S_IRUGO);
+MODULE_PARM_DESC(do_st, "Apply termios settings(1) or ignore(0 - default)");
+
+/* SEND flags policy. 
+ * SEND is SET:
+ * - never	- never. 
+ *				Data may not be sent at all; OVERs are possible
+ * - always	- always. 
+ *				OVER are possible only if speed of exchange with module is greater than speed of
+ *                         the module's external port
+ * - nodata	- (default) if only no more data are present in xmit buffer. 
+ *				OVERs are possible.
+ * - exactly:N	- if sending the last chunk for exactly N bytes chain. 
+ *				May never set the flag (if N > size of module's internal buffer) - OVERs are possible.
+ *				Data may not be sent at all.
+ *				No OVERs if N <= size of module's internal buffer
+ * - nomore:N	- if no more data are present in xmit buffer or if sending the last chunk of N bytes chain. 
+ *				No OVERs if N <= size of module's internal buffer.
+ */
+static char send[24] = "nodata";
+module_param_string(send, send, sizeof(send), 0);
+MODULE_PARM_DESC(send, "Send mode: nodata(default), always, never, exactly:N, nomore:N");
+
+#define HPR_SERIAL_SEND_NEVER			0
+#define HPR_SERIAL_SEND_ALWAYS		1
+#define HPR_SERIAL_SEND_NODATA		2
+#define HPR_SERIAL_SEND_EXACTLY		3
+#define HPR_SERIAL_SEND_NOMORE		4
+
+struct hpr_tty_port;
+
+struct hpr_tty_driver {
+	const char *driver_name;
+	const char *dev_name;	/* port dev name */
+	int name_base;			/* base number for dev_name id */
+	int nr;					/* number of ports allowed */
+	int send;					/* send policy */
+	int send_chunk;			/* send chunk value for 'exactly' and 'nomore' policies */
+	
+	struct hpr_tty_port *ports;
+	struct tty_driver *tty_driver;
+};
+
+struct hpr_tty_port {
+	int line;
+	struct device *dev;				/* parent device like in uart_port */
+	hpr_serial_port_data *data;
+	struct hpr_tty_driver *driver;		/* needed for not using global driver var in cases when tty is destroyed */
+
+	struct semaphore mutex;
+	
+	int open_count;
+	struct tty_struct *tty;
+
+	wait_queue_head_t work_wait_q;
+	struct workqueue_struct *work_q;
+	struct work_struct work;
+	struct completion work_done;
+	struct {
+		unsigned work_stop: 1;
+		unsigned work_suspend: 1;
+
+		/* set by:
+		 * - procedure making next frames
+		 * - write() method
+		 */
+		unsigned xmit_empty: 1;
+		
+		unsigned close_deny: 1;
+	} flags;
+
+	wait_queue_head_t close_wait_q;
+
+	struct circ_buf xmit;
+	hpr_pab in_pab;
+	hpr_pab out_pab;
+	struct {
+		/* HE_5672_Communication_principles.pdf: control byte, flag TR: Transmit Request  */
+		unsigned tr: 1;		/* value for next frame to be sent */
+		/* Additional flag to make module flush own internal buffer */
+		unsigned send: 1;		/* value for the current frame to be sent */
+
+		/* HE_5672_Communication_principles.pdf: status byte, flag RR: Receive Request  */
+		unsigned rr: 1;		/* actual value ot received RR flag */
+		/* HE_5672_Communication_principles.pdf: status byte, flag OVR: Receive Overrun (module buffer overflow) */
+		unsigned ovr: 1;		/* actual value of received OVR flag */
+
+		/* Note: if driver reloaded we can't determine for sure the currect state of counters, so
+		 * would it be sensible to not check RR for the fist transaction, i.e. assume that received value is correct.
+		 * Additionally, module can ignore the first data in such a case if it expects another TR
+		 */
+		unsigned synchronized: 1;
+		unsigned exp_rr: 1;	/* value expected in the next received frame */
+	} xmit_state;
+
+	int send_countdown;	/* SEND flag countdown for 'exactly' and 'nomore' policies */
+
+	char *out_data;		/* reference to input data */
+	int out_max_len;		/* max len of out data */
+	int out_len;			/* real len of out data set to be sent */
+	char *in_data;		/* reference to input data */
+	int in_len;			/* input data length */
+
+	void (*set_termios)(struct hpr_tty_port *port);			/* hw specific set termios */
+};
+
+#define work_to_hpr_tty_port(pwork) container_of(pwork, struct hpr_tty_port, work)
+
+#define hpr_serial_circ_clear(circ)		((circ)->head = (circ)->tail = 0)
+#define hpr_serial_circ_chars_free(circ)	\
+	(CIRC_SPACE((circ)->head, (circ)->tail, wsize))
+#define hpr_serial_circ_chars_pending(circ)	\
+	(CIRC_CNT((circ)->head, (circ)->tail, wsize))
+#define hpr_serial_circ_empty(circ)	((circ)->head == (circ)->tail)
+
+#define HPR_SERIAL_CIRC_CNT_TO_END(head,tail,size) \
+	({ (head) < (tail) ? (size) - (tail) : (head) - (tail); })
+
+#define hpr_serial_circ_chars_pending_part(circ)	\
+	(HPR_SERIAL_CIRC_CNT_TO_END((circ)->head, (circ)->tail, wsize))
+	
+static struct hpr_tty_driver tty_drv = {
+	.driver_name = "hpr_tty",
+	.dev_name = "ttyS",
+};
+
+static void hpr_serial_port_work(struct work_struct *work);
+static void hpr_he5672_set_termios(struct hpr_tty_port *port);
+static int hpr_he5672_set_config_mode(struct hpr_tty_port *port, int on);
+
+static int hpr_serial_port_work_start(struct hpr_tty_port *port)
+{
+	int r;
+
+	/* make work to sleep until at least one client opens the port */
+	init_waitqueue_head(&port->work_wait_q);
+	
+	port->work_q = create_singlethread_workqueue(dev_name(port->dev));
+	if (!port->work_q) {
+		pr_err("%s: failed to create a work queue for port=%d\n", 
+			__func__, port->line);
+		return -EPERM;
+	}
+
+	port->flags.work_stop = 0;
+	port->flags.work_suspend = 1;
+	port->flags.xmit_empty = 1;
+	init_completion(&port->work_done);
+
+	INIT_WORK(&port->work,  &hpr_serial_port_work);
+
+	r = queue_work(port->work_q, &port->work);
+	if (!r) {
+		pr_err("%s: failed to enqueue port work: port=%d, r=%d\n", 
+			__func__, port->line, r);
+
+		destroy_workqueue(port->work_q);
+		port->work_q = NULL;
+		return -EPERM;
+	}
+	pr_debug("%s: port work enqueued: port=%d\n", __func__, port->line);
+	return 0;
+}
+
+static void hpr_serial_port_work_stop(struct hpr_tty_port *port)
+{
+	port->flags.work_stop = 1;
+	wake_up(&port->work_wait_q);
+	wait_for_completion(&port->work_done);
+
+	destroy_workqueue(port->work_q);
+	port->work_q = NULL;
+	pr_debug("%s: port work stopped: port=%d\n", __func__, port->line);
+}
+
+static int __devinit hpr_serial_probe(struct platform_device *pdev)
+{
+	struct hpr_tty_port *port;
+	struct device *tty_dev;
+	int r = 0;
+
+	if (pdev->id >= tty_drv.nr) {
+		pr_err("%s: invalid hpr serial port id=%d (max supported ports: %d) - can't add\n",
+			__func__, pdev->id, tty_drv.nr);
+		return -EINVAL;
+	}
+
+	port = &tty_drv.ports[pdev->id];
+	port->driver = &tty_drv;
+
+	port->line = pdev->id;
+	port->dev = &pdev->dev;
+	port->data = pdev->dev.platform_data;
+	port->set_termios = hpr_he5672_set_termios;			/* HE5672 -specific */
+
+	/* alloc & init circ buffer */
+	port->xmit.buf = kzalloc(wsize, GFP_KERNEL);
+	if (!port->xmit.buf) {
+		pr_err("%s: failed to alloc xmit buffer for port=%d\n", __func__, port->line);
+		return -ENOMEM;
+	}
+	hpr_serial_circ_clear(&port->xmit);
+	port->send_countdown = tty_drv.send_chunk;	/* initial setting, reset in work procedure as need */
+	sema_init(&port->mutex, 1);
+	init_waitqueue_head(&port->close_wait_q);
+
+	/* HE5672 -specific */
+	port->in_data = &port->in_pab.io16b.pv[1];
+	port->out_data = &port->out_pab.io16b.pv[1];
+	port->out_max_len = 15;
+
+	/* start port's work */
+	r = hpr_serial_port_work_start(port);
+	if (r) {
+		kfree(port->xmit.buf);
+		port->xmit.buf = NULL;
+		return r;
+	}
+
+	tty_dev = tty_register_device(tty_drv.tty_driver, port->line, port->dev);
+	if (unlikely(IS_ERR(tty_dev))) {
+		pr_err("%s: failed to register tty device for port=%d\n", __func__, port->line);
+	}
+
+	platform_set_drvdata(pdev, port);
+	
+	pr_debug("%s: added hpr serial port=%d (bus_index=%d, module addr=%d)\n", 
+			__func__, port->line, port->data->bus_index, port->data->module_addr);
+
+	return r;
+}
+
+static int __devexit hpr_serial_remove(struct platform_device *pdev)
+{
+	struct hpr_tty_port *port;
+
+	if (pdev->id >= tty_drv.nr) {
+		pr_warning("%s: invalid hpr serial port id=%d (max supported ports: %d) - ignore\n",
+			__func__, pdev->id, tty_drv.nr);
+		return 0;
+	}
+
+	port = &tty_drv.ports[pdev->id];
+
+	/* first, stop possible work */
+	hpr_serial_port_work_stop(port);
+
+	tty_unregister_device(tty_drv.tty_driver, port->line);
+
+	if (port->xmit.buf) {
+		kfree(port->xmit.buf);
+		port->xmit.buf = NULL;
+	}
+
+	port->data = NULL;
+	platform_set_drvdata(pdev, NULL);
+
+	pr_debug("%s: hpr serial port id=%d removed\n", __func__, pdev->id);
+
+	return 0;
+}
+
+static struct platform_driver hpr_serial_driver = {
+	.probe		= hpr_serial_probe,
+	.remove		= __devexit_p(hpr_serial_remove),
+	.driver		= {
+		.name	= HPR_SERIAL_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+/* Create out_pab 
+ *  Data added to out frame are removed from the xmit buffer
+ * TODO: whether we need remove the data only after they are transmitted successfuly?
+ */
+static void hpr_serial_make_out_frame(struct hpr_tty_port *port)
+{
+	struct circ_buf *circ;
+	int left_count;
+
+#ifdef DEBUG
+	int head, tail, end_tail;
+#endif
+
+	left_count = port->out_max_len; 	/* count of chars to send in a frame */
+	memset(port->out_data, 0, port->out_max_len);
+	port->out_len = 0;
+
+	if (port->driver->send == HPR_SERIAL_SEND_EXACTLY ||
+		port->driver->send == HPR_SERIAL_SEND_NOMORE) {
+		/* use countdown */
+		if (left_count > port->send_countdown) {
+			left_count = port->send_countdown; /* send no more */
+		}
+	}
+
+	circ = &port->xmit;
+
+	/* get data from the buffer and fill out pab */
+	down(&port->mutex);
+#ifdef DEBUG
+	head = circ->head;
+	tail= circ->tail;
+#endif
+	while (left_count > 0) {
+		int c = hpr_serial_circ_chars_pending_part(circ);
+		if (!c) {
+			break;
+		}
+		if (c > left_count) {
+			c = left_count;
+		}
+		memcpy(&port->out_data[port->out_len], &circ->buf[circ->tail], c);
+		port->out_len += c;
+		left_count -= c;
+		circ->tail = (circ->tail + c) & (wsize - 1);
+	}
+#ifdef DEBUG
+	end_tail= circ->tail;
+#endif
+
+	/* determine SEND flag, by default do not set it */
+	port->xmit_state.send = 0;
+	do {
+		if (!port->out_len) {
+			pr_debug("%s: port=%d, NO SEND - len=0\n", __func__, port->line);
+			break;						/* do not set the flag - nothing to send actually */
+		}
+		
+		if (port->driver->send == HPR_SERIAL_SEND_NEVER) {
+			pr_debug("%s: port=%d, NO SEND - never\n", __func__, port->line);
+			break;						/* do not set the flag */
+		}
+		
+		if (port->driver->send == HPR_SERIAL_SEND_ALWAYS) {
+			port->xmit_state.send = 1;		/* do set the flag */
+			pr_debug("%s: port=%d, set SEND - always\n", __func__, port->line);
+			break;
+		}
+
+		/* check countdown condition */
+		if (port->driver->send == HPR_SERIAL_SEND_EXACTLY ||
+			port->driver->send == HPR_SERIAL_SEND_NOMORE) {
+			if (port->out_len >= port->send_countdown) {			/* actually it can be only < or ==, see above */
+				port->xmit_state.send = 1;							/* set the flag */
+				pr_debug("%s: port=%d, countdown run out(last val): %d, set SEND, reset countdown: %d\n",
+						__func__, port->line, port->send_countdown, port->driver->send_chunk);
+				port->send_countdown = port->driver->send_chunk;	/* reset counter for next frames */
+				break;
+			}
+			/* else - count down and do not set the flag so far */
+			port->send_countdown -= port->out_len;
+			pr_debug("%s: port=%d, countdown is: %d, NO SEND\n",
+						__func__, port->line, port->send_countdown);
+		}
+
+		/* check existence of data in xmit buffer condition */
+		if (port->driver->send == HPR_SERIAL_SEND_NODATA ||
+			port->driver->send == HPR_SERIAL_SEND_NOMORE) {
+			if (!hpr_serial_circ_chars_pending(circ)) {				/* these are last data */
+				pr_debug("%s: port=%d, no more data -  set SEND\n", __func__, port->line);
+				port->xmit_state.send = 1;							/* set the flag */
+				if (port->driver->send == HPR_SERIAL_SEND_NOMORE) {
+					port->send_countdown = port->driver->send_chunk;	/* reset counter for next frames */
+					pr_debug("%s: port=%d, reset countdown: %d\n",
+						__func__, port->line, port->send_countdown);
+				}
+				break;
+			}
+			pr_debug("%s: port=%d, data present - NO SEND\n", 
+						__func__, port->line);
+		}
+	} while (0);
+
+	if (port->out_len && port->open_count) {
+		pr_debug("%s: port=%d - wake up tty\n", __func__, port->line);
+		tty_wakeup(port->tty);	/* signal to tty core that buffer has more dta to accept */
+	}
+
+	/* set the flag for the work's next iteration */
+	port->flags.xmit_empty = hpr_serial_circ_empty(circ);
+
+	up(&port->mutex);
+
+#ifdef DEBUG
+	pr_debug("%s: made: count=%d, buf_init: head=%d, tail=%d, end_tail=%d\n",
+		__func__, port->out_len, head, tail, end_tail);
+#endif
+}
+
+static void hpr_serial_he5672_set_out_ctl(struct hpr_tty_port *port)
+{
+	port->out_pab.io16b.pv[0] = port->out_len << 4;
+
+	if (port->xmit_state.send) {
+		port->out_pab.io16b.pv[0] |= HPR_HE5672_CTL_SEND;
+	}
+	
+	if (port->xmit_state.tr) {
+		port->out_pab.io16b.pv[0] |= HPR_HE5672_CTL_TR;
+	}
+}
+
+static void hpr_serial_he5672_process_result(struct hpr_tty_port *port)
+{
+	int ctl;
+
+	ctl = port->in_pab.io16b.pv[0];
+
+	/* extract received data len, OVR and RR */
+	port->in_len = (ctl >> 4) & 0xf;
+	port->xmit_state.ovr = !!(ctl & HPR_HE5672_CTL_OVR);
+	port->xmit_state.rr = !!(ctl & HPR_HE5672_CTL_RR);
+	
+	if (unlikely(port->xmit_state.ovr)) {
+		/* prepare to repeat the same frame with changed TR */
+		port->out_pab.io16b.pv[0] ^= HPR_HE5672_CTL_TR;
+	}
+}
+
+static void hpr_serial_port_work(struct work_struct *work)
+{
+	struct hpr_tty_port *port;
+	int r;
+	int attempt, stop_trying;
+	int invalid_rr;
+	hpr_pv_query pv_query;
+
+	port = work_to_hpr_tty_port(work);
+
+	pr_debug("%s: started: port=%d\n", __func__, port->line);
+
+	while (!port->flags.work_stop) {
+		wait_event(port->work_wait_q, 
+				!port->flags.xmit_empty ||
+				!port->flags.work_suspend || 
+				port->flags.work_stop);
+		if (port->flags.work_stop) {
+			break;
+		}
+
+		/* TODO: more validation ?? */
+		if (port->data->flags.invalid) {
+			msleep(50);	/* TODO: use one more wait_q instead ??? */
+			continue;
+		}
+
+		pr_debug("\n%s: port=%d: new frame iteration:\n", __func__, port->line);
+
+		/* make next frame to send, TW++, SEND */
+		hpr_serial_make_out_frame(port);
+
+		hpr_serial_he5672_set_out_ctl(port);
+
+		memset(&pv_query, 0, sizeof(pv_query));
+		pv_query.out_data = &port->out_pab;
+		pv_query.out_count = 1;
+		pv_query.in_data = &port->in_pab;
+		pv_query.in_count = 1;
+
+		attempt = 0;
+		stop_trying = 0;
+		do {
+			attempt++;
+			pr_debug("%s: port=%d: attempt=%d\n", __func__, port->line, attempt);
+
+			/* exchange */
+			r = hpr_one_shot_async_exchange(port->data->bus_index, 
+									port->data->module_addr, &pv_query);
+			pr_debug("%s: port=%d: oneshot exchange done: r=%d, module status=0x%02x\n", 
+					__func__, port->line, r, pv_query.status.b);
+
+			//TODO: process module status ? (pv_query.status)
+			/*NOTE: the first TIMEOUT error is processed by hpr driver automatically: 
+			 * frame is repeated up to 3 times 
+			 * TODO: think whether to repeat just 2 times?
+			 */
+			if (r) {
+				/* TODO: lots reasons - process them
+				 * For now assume that higher level will be able to detect error by not getting correct answer
+				 */
+
+				if (r == -EBADMSG) {
+					//TODO: test and uncomment optimization
+					/*if (port->out_len > 0 && attempt <= 2) {*/
+					if (attempt < 2) {
+						/* if data in out frame present and this is first attempt, try again just the same frame:
+						 * we must have received answer for previous params request (when scanning)
+						 * NOTE: revise this if allow simulateous params get/set requests
+						 */
+
+						pr_debug("%s: port=%d: repeat reuest for EBADMSG\n", 
+								__func__, port->line);
+						continue;
+					}
+					pr_debug("%s: port=%d: do not repeat reuest for EBADMSG\n", 
+							__func__, port->line);
+				}
+
+				/* just forget the sent data and its error */
+				//stop_trying = 1;
+				msleep(10);
+				break;
+			} 
+
+			/* extract and process flags, extract data if ones are present */
+			hpr_serial_he5672_process_result(port);
+
+			/* TODO: is it a good idea? */
+			if (unlikely(!port->xmit_state.synchronized)) {
+				/* synchronize RR */
+				port->xmit_state.synchronized = 1;
+				port->xmit_state.exp_rr = port->xmit_state.rr; /* assign to expected RR one which came from the module - assume it is correct */
+				pr_debug("%s: port=%d: RR synchronized\n", __func__, port->line);
+			}
+
+#ifdef HPR_SERIAL_TEST
+			if (port->data->hw_id != HPR_HWID_HE5672) {
+				/* always correct RR for testing */
+				port->xmit_state.exp_rr = port->xmit_state.rr;
+				port->xmit_state.ovr = 0;
+				/* echo successfuly sent data back as incoming data */
+				memcpy(port->in_data, port->out_data, port->out_len);
+				port->in_len = port->out_len;
+			}
+#endif
+			pr_debug("%s: port=%d: out_len=%d, TR=%d, SEND=%d ==> in_len=%d, RR=%d (expected=%d), OVR=%d\n",
+					__func__, port->line, 
+					port->out_len, port->xmit_state.tr, port->xmit_state.send,
+					port->in_len, port->xmit_state.rr, port->xmit_state.exp_rr, port->xmit_state.ovr);
+
+			/* validate RR: is it the same as expected or not ? */
+			invalid_rr = port->xmit_state.exp_rr ^ port->xmit_state.rr;
+
+			if (unlikely(invalid_rr)) {
+				/* ignore repeated data, leave exp_rr the same */
+				port->in_len = 0;
+				pr_debug("%s: port=%d: invalid RR\n", __func__, port->line);
+			} else {
+				/* accept incoming frame, prepare exp_rr for next frame */
+				port->xmit_state.exp_rr = ~port->xmit_state.exp_rr;
+			}
+
+			/* prepare next TR... */
+			port->xmit_state.tr = ~port->xmit_state.tr;
+
+			/* ... and decide wether or not to repeat the sent frame regarding to OVR */
+			stop_trying = !port->xmit_state.ovr || (attempt >= HPR_SERIAL_OVR_REPEAT_COUNT);
+
+			pr_debug("%s: port=%d: repeat sent frame: %d\n",
+					__func__, port->line, !stop_trying);
+
+			/* pass input data (if present) to tty core */
+			if (port->in_len > 0) {
+				down(&port->mutex);
+				if (port->open_count) {
+					port->flags.close_deny = 1;
+				}
+				up(&port->mutex);
+
+				/* send chars to tty core */
+				if (port->flags.close_deny) {
+					tty_insert_flip_string(port->tty, port->in_data, port->in_len);
+					tty_flip_buffer_push(port->tty);
+					pr_debug("%s: port=%d: %d bytes pushed to tty core\n",
+						__func__, port->line, port->in_len);
+
+					port->flags.close_deny = 0;	/* resetting the flag doesn't need locking */
+
+					pr_debug("%s: port=%d: allow and wake up possible closings\n",
+							__func__, port->line);
+					wake_up(&port->close_wait_q);
+				}
+			}
+		} while (!stop_trying && !port->flags.work_stop);
+
+		pr_debug("%s: port=%d: frame processed\n", __func__, port->line);
+	}
+
+	complete(&port->work_done);
+	pr_debug("%s: done: port=%d\n", __func__, port->line);
+}
+
+static struct hpr_tty_port *hpr_tty_driver_get_port(struct hpr_tty_driver *drv, int line)
+{
+	if (line >= drv->nr) {
+		pr_err("%s: invalid device index: %d\n", __func__, line);
+		return NULL;
+	}
+
+	return &drv->ports[line];
+}
+
+static int hpr_tty_open(struct tty_struct *tty, struct file *file)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	int need_start_port = 0;
+
+	drv = tty->driver->driver_state;
+
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return -ENODEV;
+	}
+
+	if (port->data->flags.invalid) {
+		pr_err("%s: port=%d is invalid\n", __func__, port->line);
+		return -ENODEV;
+	}
+
+	pr_debug("%s: port=%d is valid - openeing\n", __func__, port->line);
+
+	down(&port->mutex);
+
+	if (!port->open_count) {
+		port->tty = tty;
+		tty->driver_data = port;
+		
+		/* clear port buffer && wake up port work.. */
+		need_start_port = 1;
+
+		//TODO: ??
+		//hpr_serial_circ_clear(&port->xmit);
+
+		//tty_wakeup(tty);
+	}
+
+	port->open_count++;
+
+	pr_debug("%s: opening port=%d, open_count=%d, invalid=%d\n",
+			__func__, port->line, port->open_count, port->data->flags.invalid);
+
+	up(&port->mutex);
+
+	if (need_start_port) {
+		port->flags.work_suspend = 0;
+		wake_up(&port->work_wait_q);
+		pr_debug("%s: port work is started: port=%d\n", 
+			__func__, port->line);
+	}
+
+	return 0;
+}
+
+static void hpr_tty_close(struct tty_struct *tty, struct file *file)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+
+	drv = tty->driver->driver_state;
+
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return;
+	}
+
+	while (1) {
+		pr_debug("%s: port=%d: try closing\n",
+				__func__, port->line);
+
+		down(&port->mutex);
+
+		/* check for error */
+		if (port->open_count <= 0) {
+			port->open_count = 0;
+			up(&port->mutex);
+			pr_warning("%s: port is not opened - ignore, port=%d\n", 
+				__func__, port->line);
+			return;
+		}
+
+		/* check whether we allowed to close */
+		if (!port->flags.close_deny) {
+			break; /* continue closing port */
+		}
+
+		/* otherwise wait and try again */
+
+		up(&port->mutex);
+
+		pr_debug("%s: port=%d: can't close immediately - waiting..\n",
+				__func__, port->line);
+
+		wait_event(port->close_wait_q, !port->flags.close_deny);
+	}/* try to close -wait -try again loop */
+
+	/* close and exit */
+	port->open_count--;
+
+	if (!port->open_count) {
+		/* make port work to sleep on next iteration;
+		 * - use flag instead fo semaphore to prevent deadlock caused by two downed semaphores
+		 * - TODO: NULL port's tty ptr and tty's driver_data ptr? 
+		 *            ..sinse tty struct won't be valid any more and can't be used by port's work.
+		 */
+		port->flags.work_suspend = 1;
+		pr_debug("%s: port work is marked to suspend: port=%d\n", 
+			__func__, port->line);
+	}
+
+	pr_debug("%s: closing port=%d, open_count=%d, invalid=%d\n",
+			__func__, port->line, port->open_count, port->data->flags.invalid);
+	up(&port->mutex);
+}
+
+static int hpr_tty_write(struct tty_struct *tty, const unsigned char *buffer, int count)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	struct circ_buf *circ;
+	int c, r;
+
+	drv = tty->driver->driver_state;
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return -ENODEV;
+	}
+
+#ifdef DEBUG
+	{
+		int i, n, cnt;
+		static char tmp_buf[64 + 3 * 15]; /* text + ~ 40 chars: x chars ... 10 last chars */
+		cnt = sizeof(tmp_buf);
+		n = sprintf(tmp_buf, "%s: writing to port=%d buffer:", __func__, port->line);
+		cnt = cnt - n - 1 - 4; /* left chars in buf, - reserved place for terminating 0, 5 chars " ..." */
+		cnt /= 3;	/* calc total count of bytes which can fit the free place */
+		for (i = 0; i < cnt - 10 && i < count; i++) {
+			n += sprintf(&tmp_buf[n], " %02X", buffer[i]);
+		}
+		if (i < count) {
+			if (count - i > 10) {
+				n += sprintf(&tmp_buf[n], " ...");
+				i = count - 10;
+			}
+			for (; i < count; i++) {
+				n += sprintf(&tmp_buf[n], " %02X", buffer[i]);
+			}
+		}
+		pr_info("%s\n", tmp_buf);
+	}
+#endif
+
+	circ = &port->xmit;	/* circ->buf can't be NULL, otherwise port is not created */
+	r = 0;
+
+	down(&port->mutex);
+	while (1) {
+		c = CIRC_SPACE_TO_END(circ->head, circ->tail, wsize);
+		if (count < c)
+			c = count;
+		if (c <= 0)
+			break;
+		memcpy(circ->buf + circ->head, buffer, c);
+		circ->head = (circ->head + c) & (wsize - 1);
+		buffer += c;
+		count -= c;
+		r += c;
+	}
+	/* set the flag for the work's next iteration */
+	port->flags.xmit_empty = hpr_serial_circ_empty(circ);
+	up(&port->mutex);
+
+	pr_debug("%s: written to port=%d buffer: %d bytes\n", __func__, port->line, r);
+	return r;
+}
+
+static int hpr_tty_write_room(struct tty_struct *tty)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	struct circ_buf *circ;
+	int r;
+
+	drv = tty->driver->driver_state;
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return -ENODEV;
+	}
+	circ = &port->xmit;	/* circ->buf can't be NULL, otherwise port is not created */
+
+	down(&port->mutex);
+	r = hpr_serial_circ_chars_free(circ);
+	up(&port->mutex);
+
+	pr_debug("%s: port=%d, write_room=%d bytes\n",
+			__func__, port->line, r);
+
+	return r;
+}
+
+static void hpr_tty_flush_buffer(struct tty_struct *tty)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	struct circ_buf *circ;
+
+	drv = tty->driver->driver_state;
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return;
+	}
+	circ = &port->xmit;	/* circ->buf can't be NULL, otherwise port is not created */
+
+	down(&port->mutex);
+	hpr_serial_circ_clear(circ);
+	up(&port->mutex);
+
+	tty_wakeup(tty);
+	
+	pr_debug("%s: port=%d: buffer cleared\n", __func__, port->line);
+}
+
+static int hpr_tty_chars_in_buffer(struct tty_struct *tty)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	struct circ_buf *circ;
+	int r;
+
+	drv = tty->driver->driver_state;
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return -ENODEV;
+	}
+	circ = &port->xmit;	/* circ->buf can't be NULL, otherwise port is not created */
+
+	down(&port->mutex);
+	r = hpr_serial_circ_chars_pending(circ);
+	up(&port->mutex);
+
+	pr_debug("%s: port=%d, chars_in_buf=%d\n",
+			__func__, port->line, r);
+	return r;
+}
+
+static int he5672_rates[] = {
+	1200, 2400, 4800, 7200, 9600, 14400, 19200, 38400, 56000, 57600, 115200
+};
+static int index_of_baud_rate(int rate, int rates[], int count)
+{
+	int i;
+	for (i = 0; i < count; i++) {
+		if (rates[i] == rate) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+/* TODO: for testing - remove */
+//#ifndef IRS485
+//#define IRS485	0100000
+//#endif
+
+static void hpr_he5672_set_termios(struct hpr_tty_port *port)
+{
+	int cflag;
+	int rate;
+	int rate_index;
+	hpr_param_arg param;
+	int r;
+
+	cflag = port->tty->termios->c_cflag;
+
+	/* port mode 232/485*/
+	if (port->tty->termios->c_iflag & IRS485) {
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_UART_MODE] = HPR_HE5672_MODE_RS485;
+	} else {
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_UART_MODE] = HPR_HE5672_MODE_RS232;
+	}
+
+	/* speed */
+	rate = tty_get_baud_rate(port->tty);
+	rate_index = index_of_baud_rate(rate, he5672_rates, sizeof(he5672_rates) / sizeof(he5672_rates[0]));
+	if (rate_index != -1) {
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_SPEED] = rate_index;
+	}
+	pr_debug("%s: port=%d: baud_rate=%d => index=%d\n",
+			__func__, port->line, rate, rate_index);
+	
+	/* parity */
+	if (cflag & PARENB) {
+		if (cflag & PARODD) {
+			/* odd */
+			port->data->priv.he5672.params[HPR_HE5672_PIDX_PARITY] = HPR_HE5672_PAR_ODD;
+		} else {
+			/* even */
+			port->data->priv.he5672.params[HPR_HE5672_PIDX_PARITY] = HPR_HE5672_PAR_EVEN;
+		}
+	} else {
+		/* none */
+			port->data->priv.he5672.params[HPR_HE5672_PIDX_PARITY] = HPR_HE5672_PAR_NONE;
+	}
+
+	/* stop bits */
+	if (cflag & CSTOPB) {
+		/* 2 */
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_STOP_BITS] = HPR_HE5672_SB_2;
+	} else {
+		/* 1 */
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_STOP_BITS] = HPR_HE5672_SB_1;
+	}
+
+	/* hardware flow control */
+	if (cflag & CRTSCTS) {
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_FLOW_CTL] = HPR_HE5672_RTSCTS_ON;
+	} else {
+		port->data->priv.he5672.params[HPR_HE5672_PIDX_FLOW_CTL] = HPR_HE5672_RTSCTS_OFF;
+	}
+	
+	r = hpr_he5672_set_config_mode(port, 1);
+
+	param.count = HPR_HE5672_PARAMS_COUNT - 1; /* do not change [0] param - direct UART*/
+	param.address = HPR_HE5672_PARAMS_ADDR + 1;
+	param.values.s = &port->data->priv.he5672.params[1];
+
+	r = hpr_set_module_params(port->data->bus_index, port->data->module_addr, &param);
+	if (r) {
+		pr_err("%s: port=%d: failed: r=%d\n", __func__, port->line, r);
+	}
+
+	r = hpr_he5672_set_config_mode(port, 0);
+}
+
+static int hpr_he5672_set_config_mode(struct hpr_tty_port *port, int on)
+{
+	int r = 0;
+	hpr_param_arg param;
+	unsigned short data = 1;
+
+	param.count = 1;
+	param.address = on ? HPR_HE5672_CONFIG_ON_ADDR : HPR_HE5672_CONFIG_OFF_ADDR;
+	param.values.s = &data;
+	r = hpr_set_module_params(port->data->bus_index, port->data->module_addr, &param);
+	if (r) {
+		pr_err("%s: port=%d: failed to switch config mode %s: r=%d\n", 
+			__func__, port->line, on ? "on" : "off", r);
+	}
+	return r;
+}
+
+#define RELEVANT_IFLAG(iflag) ((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+static void hpr_tty_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
+{
+	struct hpr_tty_port *port;
+	struct hpr_tty_driver *drv;
+	unsigned int cflag;
+
+	//TODO: need we locking here ???
+	if (!do_st) {
+		pr_debug("%s: tty=%d: ignoring the call\n", __func__, tty->index);
+		return;
+	}
+
+	cflag = tty->termios->c_cflag;
+
+	//TODO: ?
+	//pr_info("ECHO: old=%d, new=%d\n", old_termios->c_lflag & ECHO, tty->termios->c_lflag & ECHO);
+	//tty->termios->c_lflag &= ~ECHO; /* reset echo anyway */
+
+	/* check that they really want us to change something */
+	if (old_termios) {
+		if ((cflag == old_termios->c_cflag) &&
+			(RELEVANT_IFLAG(tty->termios->c_iflag) ==
+			RELEVANT_IFLAG(old_termios->c_iflag))) {
+				pr_debug("%s: tty=%d: nothing to change\n", __func__, tty->index);
+				return;
+		}
+	}
+
+	drv = tty->driver->driver_state;
+	port = hpr_tty_driver_get_port(drv, tty->index);
+	if (!port) {
+		return;
+	}
+
+	pr_debug("%s: port=%d: old_termios=0x%08X => new=0x%08X\n",
+		__func__, port->line, old_termios->c_cflag, cflag);
+
+	if (port->set_termios) {
+		port->set_termios(port);
+	}
+}
+
+#if 0
+static void hpr_tty_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	pr_info("%s: CALLED: to=%d\n", __func__, timeout);
+}
+static int hpr_tty_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	pr_info("%s: called\n", __func__);
+	return -1;
+}
+static int hpr_tty_tiocmset(struct tty_struct *tty, struct file *file, unsigned int set, unsigned int clear)
+{
+	pr_info("%s: called\n", __func__);
+	return -1;
+}
+static int hpr_tty_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	pr_info("%s: called\n", __func__);
+	return -1;
+}
+#endif
+
+static int hpr_tty_init_driver(struct hpr_tty_driver *drv)
+{
+	int i = 0;
+	drv->name_base = base_num;
+	drv->nr = ports_num;
+
+	if ((wsize <= 0) || (wsize & (wsize - 1))) {
+		pr_err("%s: invalid size of write buffer: %d (should be power of 2)\n", 
+			__func__, wsize);
+		return -EINVAL;
+	}
+
+	/* parse send policy */
+	if (!strcmp(send, "never")) {
+		drv->send = HPR_SERIAL_SEND_NEVER;
+	} else if (!strcmp(send, "always")) {
+		drv->send = HPR_SERIAL_SEND_ALWAYS;
+	} else if (!strcmp(send, "nodata")) {
+		drv->send = HPR_SERIAL_SEND_NODATA;
+	} else if (!memcmp(send, "exactly:", 8)) {
+		drv->send = HPR_SERIAL_SEND_EXACTLY;
+		i = 8;
+	} else if (!memcmp(send, "nomore:", 7)) {
+		drv->send = HPR_SERIAL_SEND_NOMORE;
+		i = 7;
+	} else {
+		pr_err("%s: invalid send policy: '%s'\n", __func__, send);
+		return -EINVAL;
+	}
+	if (drv->send == HPR_SERIAL_SEND_EXACTLY || drv->send == HPR_SERIAL_SEND_NOMORE) {
+		drv->send_chunk = (int)simple_strtol(&send[i], NULL, 0);
+		if (drv->send_chunk <= 0) {
+			pr_err("%s: invalid chunk size value '%s'\n", __func__, &send[i]);
+			return -EINVAL;
+		}
+	}
+
+	drv->ports = kzalloc(sizeof(struct hpr_tty_port) * drv->nr, GFP_KERNEL);
+	if (!drv->ports) {
+		pr_err("%s: failed to alloc ports' data\n", __func__);
+		return -ENOMEM;
+	}
+
+	pr_info("  * Number of supported ports: %d\n", drv->nr);
+	pr_info("  * First port: /dev/%s%d\n", drv->dev_name, drv->name_base);
+	pr_info("  * Send policy: %s", 
+		drv->send == HPR_SERIAL_SEND_NEVER ? "never" :
+		drv->send == HPR_SERIAL_SEND_ALWAYS ? "always" :
+		drv->send == HPR_SERIAL_SEND_NODATA ? "nodata" :
+		drv->send == HPR_SERIAL_SEND_EXACTLY ? "exactly" : "nomore");
+	if (drv->send == HPR_SERIAL_SEND_EXACTLY || drv->send == HPR_SERIAL_SEND_NOMORE) {
+		printk(", chunk size: %d bytes", drv->send_chunk);
+	}
+	printk("\n");
+	pr_info("  * Write buffer size: %d bytes\n", wsize);
+	pr_info("  * Apply termios settings for virtual ports: %s\n", do_st ? "yes" : "no");
+
+	return 0;
+}
+
+static void hpr_tty_uninit_driver(struct hpr_tty_driver *drv)
+{
+	if (drv->ports) {
+		kfree(drv->ports);
+		drv->ports = NULL;
+	}
+}
+
+static const struct tty_operations hpr_tty_ops = {
+	.open		= hpr_tty_open,
+	.close		= hpr_tty_close,
+	.write		= hpr_tty_write,
+	.write_room	= hpr_tty_write_room,
+
+	.flush_buffer	= hpr_tty_flush_buffer,
+	.chars_in_buffer	= hpr_tty_chars_in_buffer,
+
+	.set_termios	= hpr_tty_set_termios,
+
+#if 0
+	.wait_until_sent	= hpr_tty_wait_until_sent,
+	.tiocmget	= hpr_tty_tiocmget,
+	.tiocmset	= hpr_tty_tiocmset,
+	.ioctl = hpr_tty_ioctl,
+#endif
+};
+
+static int hpr_tty_register_driver(struct hpr_tty_driver *drv)
+{
+	struct tty_driver *d = NULL;
+	int r = 0;
+	
+	d = alloc_tty_driver(drv->nr);
+	if (!d) {
+		r = -ENOMEM;
+		goto err_tty_alloc;
+	}
+
+	drv->tty_driver = d;
+	d->driver_state = drv;
+
+	d->owner = THIS_MODULE;
+	d->driver_name = drv->driver_name;
+	d->name	 = drv->dev_name;
+	d->name_base = drv->name_base;
+	d->type = TTY_DRIVER_TYPE_SERIAL;
+	d->subtype = SERIAL_TYPE_NORMAL;
+	d->init_termios = tty_std_termios;
+	d->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	d->init_termios.c_ispeed = d->init_termios.c_ospeed = 9600;
+
+	d->init_termios.c_lflag &= ~ECHO; /* do not echo input chars */
+
+	
+	d->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(d, &hpr_tty_ops);
+
+	r = tty_register_driver(d);
+	if (r) {
+		drv->tty_driver = NULL;
+		put_tty_driver(d);
+		pr_err("%s: failed to register hpr tty driver: %d\n", __func__, r);
+	} else {
+		pr_debug("%s: hpr tty driver registered: %d\n", __func__, r);
+	}
+
+err_tty_alloc:
+	return r;
+}
+
+static void hpr_tty_unregister_driver(struct hpr_tty_driver *drv)
+{
+	struct tty_driver *d = drv->tty_driver;
+	tty_unregister_driver(d);
+	put_tty_driver(d);
+	drv->tty_driver = NULL;	
+	pr_debug("%s: hpr tty driver unregistered\n", __func__);
+}
+
+static int __init hpr_serial_init(void)
+{
+	int r;
+
+	pr_info("Serial over HPR driver v.%s\n", HPR_SERIAL_DRV_VERSION);
+
+	r = hpr_tty_init_driver(&tty_drv);
+	if (r)
+		return r;
+
+	r = hpr_tty_register_driver(&tty_drv);
+	if (r)
+		goto err_tty;
+
+	r = platform_driver_register(&hpr_serial_driver);
+	if (r)
+		goto err_platform;
+
+	return 0;
+
+err_platform:
+	hpr_tty_unregister_driver(&tty_drv);
+err_tty:
+	hpr_tty_uninit_driver(&tty_drv);
+	return r;
+}
+
+static void __exit hpr_serial_exit(void)
+{
+	platform_driver_unregister(&hpr_serial_driver);
+	hpr_tty_unregister_driver(&tty_drv);
+	hpr_tty_uninit_driver(&tty_drv);
+	pr_info("Serial over HPR driver unloaded\n");
+}
+
+module_init(hpr_serial_init);
+module_exit(hpr_serial_exit);
+
+MODULE_AUTHOR("alex@softerra.com");
+MODULE_DESCRIPTION("Driver for serial port over HPR");
+MODULE_LICENSE("GPL");
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/hpr_serial/Makefile linux-3.0.x-arm/drivers/tty/serial/hpr_serial/Makefile
--- linux-3.0.x-orig/drivers/tty/serial/hpr_serial/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/hpr_serial/Makefile	2012-12-19 11:28:05.000000000 +0200
@@ -0,0 +1,8 @@
+ifeq ($(CONFIG_SERIAL_HPR_DEBUG),y)
+	EXTRA_CFLAGS		+= -DDEBUG
+endif
+
+obj-$(CONFIG_SERIAL_HPR) += hpr_serial.o
+
+#hpr_serial-objs := .o
+
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/Kconfig linux-3.0.x-arm/drivers/tty/serial/Kconfig
--- linux-3.0.x-orig/drivers/tty/serial/Kconfig	2013-09-19 17:39:50.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/Kconfig	2012-12-19 11:28:05.000000000 +0200
@@ -384,6 +384,23 @@
 	  properly when DMA is enabled. Make sure that ports where
 	  this matters don't use DMA.
 
+config SERIAL_ATMEL_DBGU_DMA_RX
+	bool "Allow Atmel BDGU DMA RX with software timer"
+	depends on SERIAL_ATMEL_PDC=y
+	default n
+	help
+	  Say y to allow software timer implementation for 
+	  DMA RX capability of DBGU (e.g. on AT91RM9200, AT91SAM9263).
+	  By design DBGU does not have RX timer capability, so 
+	  DMA RX is possible only by complete fill of the RX buffer.
+	  The given option allows a software timer which periodically
+	  schedules atmel_serial driver's tasklet which processes 
+	  port's activities including RX. This allows to use DMA RX though with
+	  some predefined delay of incoming data detection and at the
+	  cost of some extra processor load.
+	  The delay of the incoming data processing by default is about 100ms and
+	  can be altered through /sys/devices/platform/atmel_usart.0/dbgu_timeout
+
 config SERIAL_ATMEL_TTYAT
 	bool "Install as device ttyATn instead of ttySn"
 	depends on SERIAL_ATMEL=y
@@ -1635,4 +1652,20 @@
 	help
 	  Enable a Xilinx PS UART port to be the system console.
 
+config SERIAL_HPR
+	tristate "Support for serial port HPR modules"
+	depends on ATMEL_HPR
+	---help---
+	Represent HPR serial modules as usual serial ports on Linux.
+
+if SERIAL_HPR
+config SERIAL_HPR_DEBUG
+	bool "Enable hpr serial driver debuging"
+	depends on SERIAL_HPR
+	default n
+	---help---
+	  This is an option for use by developers; most people should
+	  say N here. This adds a lot of debugging output to dmesg.
+endif
+
 endmenu
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/Makefile linux-3.0.x-arm/drivers/tty/serial/Makefile
--- linux-3.0.x-orig/drivers/tty/serial/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/Makefile	2012-12-19 11:28:05.000000000 +0200
@@ -96,3 +96,4 @@
 obj-$(CONFIG_SERIAL_MXS_AUART) += mxs-auart.o
 obj-$(CONFIG_SERIAL_LANTIQ)	+= lantiq.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART) += xilinx_uartps.o
+obj-$(CONFIG_SERIAL_HPR) += hpr_serial/
\ No newline at end of file
diff -x .svn -Nru linux-3.0.x-orig/drivers/tty/serial/omap-serial.c linux-3.0.x-arm/drivers/tty/serial/omap-serial.c
--- linux-3.0.x-orig/drivers/tty/serial/omap-serial.c	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/tty/serial/omap-serial.c	2013-03-28 10:55:54.000000000 +0200
@@ -37,11 +37,16 @@
 #include <linux/clk.h>
 #include <linux/serial_core.h>
 #include <linux/irq.h>
+#include <linux/uaccess.h>
 
 #include <plat/dma.h>
 #include <plat/dmtimer.h>
 #include <plat/omap-serial.h>
 
+#include <linux/gpio.h>
+
+#define OMAP_RS485_SUPPORTED	(SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND)
+
 static struct uart_omap_port *ui[OMAP_MAX_HSUART_PORTS];
 
 /* Forward declaration of functions */
@@ -114,6 +119,49 @@
 	serial_out(up, UART_IER, up->ier);
 }
 
+static inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)
+{
+	if (!(up->ier & UART_IER_THRI)) {
+		up->ier |= UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static inline void serial_omap_disable_ier_thri(struct uart_omap_port *up)
+{
+	if (up->ier & UART_IER_THRI) {
+		up->ier &= ~UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static inline void serial_omap_thri_mode(struct uart_omap_port *up)
+{
+	unsigned char scr = serial_in(up, UART_OMAP_SCR);
+
+	if (up->tx_wait_end)
+		scr |= UART_OMAP_SCR_TX_EMPTY_CTL_IT;
+	else
+		scr &= ~UART_OMAP_SCR_TX_EMPTY_CTL_IT;
+	serial_out(up, UART_OMAP_SCR, scr);
+}
+
+static inline void serial_omap_update_rts(struct uart_omap_port *up)
+{
+	unsigned char mcr = up->mcr;
+	int rts_on_send = up->rs485.flags & SER_RS485_RTS_ON_SEND;
+
+	if (up->rs485.flags & SER_RS485_ENABLED) {
+		if ((up->tx_in_progress && rts_on_send) ||
+			!(up->tx_in_progress || rts_on_send)) {
+			mcr &= ~UART_MCR_RTS; /* inactivate signal - set to high */
+		} else {
+			mcr |= UART_MCR_RTS;
+		}
+		serial_out(up, UART_MCR, mcr);
+	}
+}
+
 static void serial_omap_stop_tx(struct uart_port *port)
 {
 	struct uart_omap_port *up = (struct uart_omap_port *)port;
@@ -131,9 +179,12 @@
 		up->uart_dma.tx_dma_channel = OMAP_UART_DMA_CH_FREE;
 	}
 
-	if (up->ier & UART_IER_THRI) {
-		up->ier &= ~UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
+	if (!(up->rs485.flags & SER_RS485_ENABLED)) {
+		serial_omap_disable_ier_thri(up);
+	} else {
+		up->tx_wait_end = 1;
+		serial_omap_thri_mode(up);
+		serial_omap_enable_ier_thri(up);
 	}
 }
 
@@ -246,13 +297,23 @@
 		serial_omap_stop_tx(&up->port);
 }
 
-static inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)
+#ifdef CONFIG_MACH_OWEN_SPK2XX_VAR
+static void rs485_block_rx(struct uart_omap_port *up)
 {
-	if (!(up->ier & UART_IER_THRI)) {
-		up->ier |= UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
-	}
+	/* disable RX interrupts */
+	up->ier &= ~(UART_IER_RDI | UART_IER_RLSI);
+	serial_out(up, UART_IER, up->ier);
+}
+static void rs485_unblock_rx(struct uart_omap_port *up)
+{
+	/* clear RX FIFO */
+	serial_omap_clear_fifos(up);
+	serial_out(up, UART_FCR, up->fcr);
+	/* restore RX interrupts */
+	up->ier |= (UART_IER_RDI | UART_IER_RLSI);
+	serial_out(up, UART_IER, up->ier);
 }
+#endif
 
 static void serial_omap_start_tx(struct uart_port *port)
 {
@@ -261,6 +322,22 @@
 	unsigned int start;
 	int ret = 0;
 
+	if (up->rs485.flags & SER_RS485_ENABLED) {
+		if (!up->tx_in_progress) {
+#ifdef CONFIG_MACH_OWEN_SPK2XX_VAR
+			rs485_block_rx(up);
+			dev_dbg(up->port.dev, "RX blocked for RS485 TX\n");
+#endif
+			up->tx_in_progress = 1;
+			serial_omap_update_rts(up);
+		}
+		if (up->tx_wait_end) {
+			up->tx_wait_end = 0;
+			serial_omap_thri_mode(up);
+			serial_omap_disable_ier_thri(up);
+		}
+	}
+
 	if (!up->use_dma) {
 		serial_omap_enable_ier_thri(up);
 		return;
@@ -315,16 +392,51 @@
 	omap_start_dma(up->uart_dma.tx_dma_channel);
 }
 
+static unsigned int read_msr(struct uart_omap_port *up)
+{
+	unsigned int status;
+	status = serial_in(up, UART_MSR);
+
+	/* override status bits by line state if the gpios are defined */
+	if (up->pin_RI) {
+		if (!gpio_get_value(up->pin_RI)) {
+			status |= UART_MSR_TERI;
+		} else {
+			status &= ~UART_MSR_TERI;
+		}
+	}
+	if (up->pin_DCD) {
+		if (!gpio_get_value(up->pin_DCD)) {
+			status |= UART_MSR_DDCD;
+		} else {
+			status &= ~UART_MSR_DDCD;
+		}
+	}
+	if (up->pin_DSR) {
+		if (!gpio_get_value(up->pin_DSR)) {
+			status |= UART_MSR_DDSR;
+		} else {
+			status &= ~UART_MSR_DDSR;
+		}
+	}
+	
+	return status;
+}
+
 static unsigned int check_modem_status(struct uart_omap_port *up)
 {
 	unsigned int status;
 
-	status = serial_in(up, UART_MSR);
+	status = read_msr(up);
 	status |= up->msr_saved_flags;
 	up->msr_saved_flags = 0;
 	if ((status & UART_MSR_ANY_DELTA) == 0)
 		return status;
 
+	/* TODO: since read_msr() is used 
+	* it's unclear whether we should someshow emulate modem status interrupt? 
+	* should we set up and handle irqs on the respective gpios?
+	*/
 	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
 	    up->port.state != NULL) {
 		if (status & UART_MSR_TERI)
@@ -343,6 +455,11 @@
 	return status;
 }
 
+static inline unsigned int __serial_omap_tx_empty(struct uart_omap_port *up)
+{
+	return serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+}
+
 /**
  * serial_omap_irq() - This handles the interrupt from one port
  * @irq: uart port irq number
@@ -359,8 +476,38 @@
 		return IRQ_NONE;
 
 	spin_lock_irqsave(&up->port.lock, flags);
+	if (up->tx_wait_end && (iir & UART_IIR_THRI) &&
+			__serial_omap_tx_empty(up)) {
+		up->tx_wait_end = 0;
+		up->tx_in_progress = 0;
+		serial_omap_thri_mode(up);
+		serial_omap_update_rts(up);
+		serial_omap_disable_ier_thri(up);
+
+#ifdef CONFIG_MACH_OWEN_SPK2XX_VAR
+		rs485_unblock_rx(up);
+#endif
+		spin_unlock_irqrestore(&up->port.lock, flags);
+
+#ifdef CONFIG_MACH_OWEN_SPK2XX_VAR
+		dev_dbg(up->port.dev, "RX unblocked after end of RS485 TX\n");
+#endif
+		return IRQ_HANDLED;
+	}
+
 	lsr = serial_in(up, UART_LSR);
-	if (iir & UART_IIR_RLSI) {
+	if (iir & UART_IIR_RDI) {
+		/* TODO: incorrect condition is still left
+		* Was: if (iir & UART_IIR_RLSI) .. iir & RLSI -> iir & 0000 0110 - 
+		* which is not correct either. It covers the next cases of
+		* IT_TYPE [5:1]-
+		* 	 0x1 (0 001 0)- THR interrupt   !!!!
+		*
+		* 	 0x2 (0 010 0) - RHR interrupt
+		* 	 0x3 (0 011 0) - Receiver line status error
+		* 	 0x6 (0 110 0) - RX timeout
+		* (& xxx_RDI) removes THR interrupt case
+		*/
 		if (!up->use_dma) {
 			if (lsr & UART_LSR_DR)
 				receive_chars(up, &lsr);
@@ -390,7 +537,7 @@
 
 	dev_dbg(up->port.dev, "serial_omap_tx_empty+%d\n", up->pdev->id);
 	spin_lock_irqsave(&up->port.lock, flags);
-	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+	ret = __serial_omap_tx_empty(up);
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
 	return ret;
@@ -426,6 +573,9 @@
 		mcr |= UART_MCR_RTS;
 	if (mctrl & TIOCM_DTR)
 		mcr |= UART_MCR_DTR;
+	if (up->pin_DTR) {
+		gpio_set_value(up->pin_DTR, mctrl & TIOCM_DTR ? 0 : 1);
+	}
 	if (mctrl & TIOCM_OUT1)
 		mcr |= UART_MCR_OUT1;
 	if (mctrl & TIOCM_OUT2)
@@ -890,7 +1040,7 @@
 	if (up->port.flags & UPF_CONS_FLOW) {
 		tmout = 1000000;
 		for (tmout = 1000000; tmout; tmout--) {
-			unsigned int msr = serial_in(up, UART_MSR);
+			unsigned int msr = read_msr(up);
 
 			up->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
 			if (msr & UART_MSR_CTS)
@@ -1026,6 +1176,57 @@
 
 #endif
 
+static int
+serial_omap_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned long flags;
+
+	switch (cmd) {
+	case TIOCSRS485:
+		if (copy_from_user(&rs485conf, (struct serial_rs485 *) arg,
+					sizeof(rs485conf)))
+			return -EFAULT;
+
+		rs485conf.flags &= OMAP_RS485_SUPPORTED;
+
+		/* if switching RS232/RS485 supported, process given data,
+		* otherwise ignore 
+		*/
+		if (!up->rs485_switch.enabled) {
+			dev_dbg(port->dev, "port=%d: skip RS485 configuration - not allowed\n", port->line);
+			return -EPERM; /* error - RS485/232 should be configured once at startup and never changed */
+		}
+		
+		spin_lock_irqsave(&up->port.lock, flags);
+		if (!(rs485conf.flags & SER_RS485_ENABLED)) {
+			up->tx_in_progress = 0;
+			up->tx_wait_end = 0;
+		}
+		up->rs485 = rs485conf;
+		/* switch output circuit */
+		if (up->rs485_switch.pin) {
+			gpio_set_value(up->rs485_switch.pin,
+				(rs485conf.flags & SER_RS485_ENABLED) ? 
+					up->rs485_switch.rs485_level : !up->rs485_switch.rs485_level);
+		}
+		serial_omap_update_rts(up);
+		serial_omap_thri_mode(up);
+		spin_unlock_irqrestore(&up->port.lock, flags);
+
+	case TIOCGRS485:
+		if (copy_to_user((struct serial_rs485 *) arg,
+					&(up->rs485), sizeof(rs485conf)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
 static struct uart_ops serial_omap_pops = {
 	.tx_empty	= serial_omap_tx_empty,
 	.set_mctrl	= serial_omap_set_mctrl,
@@ -1039,6 +1240,7 @@
 	.shutdown	= serial_omap_shutdown,
 	.set_termios	= serial_omap_set_termios,
 	.pm		= serial_omap_pm,
+	.ioctl		= serial_omap_ioctl,
 	.type		= serial_omap_type,
 	.release_port	= serial_omap_release_port,
 	.request_port	= serial_omap_request_port,
@@ -1261,7 +1463,11 @@
 		ret = -ENOMEM;
 		goto do_release_region;
 	}
+#ifdef CONFIG_OMAP_SERIAL_REORDER
+	sprintf(up->name, "OMAP UART%d", omap_up_info->uart_num);
+#else
 	sprintf(up->name, "OMAP UART%d", pdev->id);
+#endif
 	up->pdev = pdev;
 	up->port.dev = &pdev->dev;
 	up->port.type = PORT_OMAP;
@@ -1292,6 +1498,19 @@
 		up->uart_dma.rx_dma_channel = OMAP_UART_DMA_CH_FREE;
 	}
 
+	/* pass RS232/485 info and modem pins,
+	* note: unlike atmel_serial and atmel PLCs - 
+	*         initial state of lines is set by board initilization code
+	*/
+	up->rs485 = omap_up_info->rs485;
+
+	up->rs485_switch = omap_up_info->rs485_switch;
+
+	up->pin_DCD = omap_up_info->pin_DCD;
+	up->pin_DTR = omap_up_info->pin_DTR;
+	up->pin_DSR = omap_up_info->pin_DSR;
+	up->pin_RI = omap_up_info->pin_RI;
+
 	ui[pdev->id] = up;
 	serial_omap_add_console_port(up);
 
@@ -1300,6 +1519,7 @@
 		goto do_release_region;
 
 	platform_set_drvdata(pdev, up);
+
 	return 0;
 err:
 	dev_err(&pdev->dev, "[UART%d]: failure [%s]: %d\n",
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/gadget/at91_udc.c linux-3.0.x-arm/drivers/usb/gadget/at91_udc.c
--- linux-3.0.x-orig/drivers/usb/gadget/at91_udc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/gadget/at91_udc.c	2012-12-19 11:28:32.000000000 +0200
@@ -1556,7 +1556,7 @@
 	.ep[3] = {
 		.ep = {
 			/* could actually do bulk too */
-			.name	= "ep3-int",
+			.name	= "ep3-int-bulk",
 			.ops	= &at91_ep_ops,
 		},
 		.udc		= &controller,
@@ -1931,7 +1931,7 @@
 	 */
 	if ((!udc->suspended && udc->addr)
 			|| !wake
-			|| at91_suspend_entering_slow_clock()) {
+			|| clk_must_disable(udc->fclk)) {
 		spin_lock_irqsave(&udc->lock, flags);
 		pullup(udc, 0);
 		wake = 0;
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/gadget/composite.c linux-3.0.x-arm/drivers/usb/gadget/composite.c
--- linux-3.0.x-orig/drivers/usb/gadget/composite.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/gadget/composite.c	2012-12-19 11:28:32.000000000 +0200
@@ -1131,6 +1131,14 @@
 	 */
 	usb_ep_autoconfig_reset(cdev->gadget);
 
+	/* standardized runtime overrides for device ID data */
+	if (idVendor)
+		cdev->desc.idVendor = cpu_to_le16(idVendor);
+	if (idProduct)
+		cdev->desc.idProduct = cpu_to_le16(idProduct);
+	if (bcdDevice)
+		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
+
 	/* composite gadget needs to assign strings for whole device (like
 	 * serial number), register function drivers, potentially update
 	 * power state and consumption, etc
@@ -1142,14 +1150,6 @@
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
-	/* standardized runtime overrides for device ID data */
-	if (idVendor)
-		cdev->desc.idVendor = cpu_to_le16(idVendor);
-	if (idProduct)
-		cdev->desc.idProduct = cpu_to_le16(idProduct);
-	if (bcdDevice)
-		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
-
 	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {
 		if (!iManufacturer && !composite->iManufacturer &&
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/gadget/Kconfig linux-3.0.x-arm/drivers/usb/gadget/Kconfig
--- linux-3.0.x-orig/drivers/usb/gadget/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/gadget/Kconfig	2012-12-19 11:28:32.000000000 +0200
@@ -961,16 +961,21 @@
 
 config USB_G_MULTI
 	tristate "Multifunction Composite Gadget (EXPERIMENTAL)"
-	depends on BLOCK && NET
-	select USB_G_MULTI_CDC if !USB_G_MULTI_RNDIS
+	depends on BLOCK && (NET || ARCH_AT91RM9200 || ARCH_AT91SAM9263)
+	select USB_G_MULTI_CDC if !USB_G_MULTI_RNDIS && !(ARCH_AT91RM9200 || ARCH_AT91SAM9263)
 	help
 	  The Multifunction Composite Gadget provides Ethernet (RNDIS
 	  and/or CDC Ethernet), mass storage and ACM serial link
 	  interfaces.
 
+	  Ethernet is not supported for ARCH_AT91RM9200 or ARCH_AT91SAM9263
+	  (Owen PLC's because of lack of endpoints)
+	  
+	  If supported, ethernet function has two configurations. 
+	  You may enable one of them or neiter (disable Ethernet at all).
 	  You will be asked to choose which of the two configurations is
-	  to be available in the gadget.  At least one configuration must
-	  be chosen to make the gadget usable.  Selecting more than one
+	  to be available in the gadget. Selecting none of the configurations
+	  disables Ethernet support. Selecting more than one
 	  configuration will prevent Windows from automatically detecting
 	  the gadget as a composite gadget, so an INF file will be needed to
 	  use the gadget.
@@ -980,8 +985,8 @@
 
 config USB_G_MULTI_RNDIS
 	bool "RNDIS + CDC Serial + Storage configuration"
-	depends on USB_G_MULTI
-	default y
+	depends on USB_G_MULTI && !(ARCH_AT91RM9200 || ARCH_AT91SAM9263)
+	default n
 	help
 	  This option enables a configuration with RNDIS, CDC Serial and
 	  Mass Storage functions available in the Multifunction Composite
@@ -992,7 +997,7 @@
 
 config USB_G_MULTI_CDC
 	bool "CDC Ethernet + CDC Serial + Storage configuration"
-	depends on USB_G_MULTI
+	depends on USB_G_MULTI && !(ARCH_AT91RM9200 || ARCH_AT91SAM9263)
 	default n
 	help
 	  This option enables a configuration with CDC Ethernet (ECM), CDC
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/gadget/multi.c linux-3.0.x-arm/drivers/usb/gadget/multi.c
--- linux-3.0.x-orig/drivers/usb/gadget/multi.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/gadget/multi.c	2012-12-19 11:28:32.000000000 +0200
@@ -62,6 +62,7 @@
 #include "u_serial.c"
 #include "f_acm.c"
 
+#if defined(CONFIG_USB_G_MULTI_RNDIS) || defined(CONFIG_USB_G_MULTI_CDC)
 #include "f_ecm.c"
 #include "f_subset.c"
 #ifdef USB_ETH_RNDIS
@@ -69,6 +70,7 @@
 #  include "rndis.c"
 #endif
 #include "u_ether.c"
+#endif
 
 
 
@@ -86,6 +88,9 @@
 #ifdef CONFIG_USB_G_MULTI_CDC
 	MULTI_CDC_CONFIG_NUM,
 #endif
+#if !defined(CONFIG_USB_G_MULTI_RNDIS) && !defined(CONFIG_USB_G_MULTI_CDC)
+	MULTI_NOETHER_CONFIG_NUM,
+#endif
 };
 
 
@@ -119,7 +124,6 @@
 	NULL,
 };
 
-
 enum {
 #ifdef CONFIG_USB_G_MULTI_RNDIS
 	MULTI_STRING_RNDIS_CONFIG_IDX,
@@ -127,6 +131,9 @@
 #ifdef CONFIG_USB_G_MULTI_CDC
 	MULTI_STRING_CDC_CONFIG_IDX,
 #endif
+#if !defined(CONFIG_USB_G_MULTI_RNDIS) && !defined(CONFIG_USB_G_MULTI_CDC)
+	MULTI_STRING_NOETHER_CONFIG_IDX,
+#endif
 };
 
 static struct usb_string strings_dev[] = {
@@ -136,6 +143,9 @@
 #ifdef CONFIG_USB_G_MULTI_CDC
 	[MULTI_STRING_CDC_CONFIG_IDX].s   = "Multifunction with CDC ECM",
 #endif
+#if !defined(CONFIG_USB_G_MULTI_RNDIS) && !defined(CONFIG_USB_G_MULTI_CDC)
+	[MULTI_STRING_NOETHER_CONFIG_IDX].s   = "Multifunction without ethernet (MS + ACM)",
+#endif
 	{  } /* end of list */
 };
 
@@ -157,7 +167,9 @@
 
 static struct fsg_common fsg_common;
 
+#if defined(CONFIG_USB_G_MULTI_RNDIS) || defined(CONFIG_USB_G_MULTI_CDC)
 static u8 hostaddr[ETH_ALEN];
+#endif
 
 
 /********** RNDIS **********/
@@ -262,6 +274,51 @@
 #endif
 
 
+/********** NOETHER **********/
+
+#if !defined(CONFIG_USB_G_MULTI_RNDIS) && !defined(CONFIG_USB_G_MULTI_CDC)
+
+static __init int noether_do_config(struct usb_configuration *c)
+{
+	int ret;
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	ret = acm_bind_config(c, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = fsg_bind_config(c->cdev, c, &fsg_common);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int noether_config_register(struct usb_composite_dev *cdev)
+{
+	static struct usb_configuration config = {
+		.bConfigurationValue	= MULTI_NOETHER_CONFIG_NUM,
+		.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+	};
+
+	config.label          = strings_dev[MULTI_STRING_NOETHER_CONFIG_IDX].s;
+	config.iConfiguration = strings_dev[MULTI_STRING_NOETHER_CONFIG_IDX].id;
+
+	return usb_add_config(cdev, &config, noether_do_config);
+}
+
+#else
+
+static int noether_config_register(struct usb_composite_dev *cdev)
+{
+	return 0;
+}
+
+#endif
 
 /****************************** Gadget Bind ******************************/
 
@@ -271,6 +328,7 @@
 	struct usb_gadget *gadget = cdev->gadget;
 	int status, gcnum;
 
+#if defined(CONFIG_USB_G_MULTI_RNDIS) || defined(CONFIG_USB_G_MULTI_CDC)
 	if (!can_support_ecm(cdev->gadget)) {
 		dev_err(&gadget->dev, "controller '%s' not usable\n",
 		        gadget->name);
@@ -281,6 +339,7 @@
 	status = gether_setup(cdev->gadget, hostaddr);
 	if (status < 0)
 		return status;
+#endif
 
 	/* set up serial link layer */
 	status = gserial_setup(cdev->gadget, 1);
@@ -320,6 +379,11 @@
 	if (unlikely(status < 0))
 		goto fail2;
 
+	/* register configuration w/o ethernet */
+	status = noether_config_register(cdev);
+	if (unlikely(status < 0))
+		goto fail2;
+
 	/* we're done */
 	dev_info(&gadget->dev, DRIVER_DESC "\n");
 	fsg_common_put(&fsg_common);
@@ -332,14 +396,18 @@
 fail1:
 	gserial_cleanup();
 fail0:
+#if defined(CONFIG_USB_G_MULTI_RNDIS) || defined(CONFIG_USB_G_MULTI_CDC)
 	gether_cleanup();
+#endif
 	return status;
 }
 
 static int __exit multi_unbind(struct usb_composite_dev *cdev)
 {
 	gserial_cleanup();
+#if defined(CONFIG_USB_G_MULTI_RNDIS) || defined(CONFIG_USB_G_MULTI_CDC)
 	gether_cleanup();
+#endif
 	return 0;
 }
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/gadget/u_serial.c linux-3.0.x-arm/drivers/usb/gadget/u_serial.c
--- linux-3.0.x-orig/drivers/usb/gadget/u_serial.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/gadget/u_serial.c	2012-12-19 11:28:32.000000000 +0200
@@ -93,7 +93,7 @@
  * (and thus for each /dev/ node).
  */
 struct gs_port {
-	spinlock_t		port_lock;	/* guard port_* access */
+	raw_spinlock_t	port_lock;	/* guard port_* access */
 
 	struct gserial		*port_usb;
 	struct tty_struct	*port_tty;
@@ -393,9 +393,9 @@
 		 * NOTE that we may keep sending data for a while after
 		 * the TTY closed (dev->ioport->port_tty is NULL).
 		 */
-		spin_unlock(&port->port_lock);
+		raw_spin_unlock(&port->port_lock);
 		status = usb_ep_queue(in, req, GFP_ATOMIC);
-		spin_lock(&port->port_lock);
+		raw_spin_lock(&port->port_lock);
 
 		if (status) {
 			pr_debug("%s: %s %s err %d\n",
@@ -448,9 +448,9 @@
 		/* drop lock while we call out; the controller driver
 		 * may need to call us back (e.g. for disconnect)
 		 */
-		spin_unlock(&port->port_lock);
+		raw_spin_unlock(&port->port_lock);
 		status = usb_ep_queue(out, req, GFP_ATOMIC);
-		spin_lock(&port->port_lock);
+		raw_spin_lock(&port->port_lock);
 
 		if (status) {
 			pr_debug("%s: %s %s err %d\n",
@@ -486,7 +486,7 @@
 	bool			do_push = false;
 
 	/* hand any queued data to the tty */
-	spin_lock_irq(&port->port_lock);
+	raw_spin_lock_irq(&port->port_lock);
 	tty = port->port_tty;
 	while (!list_empty(queue)) {
 		struct usb_request	*req;
@@ -579,7 +579,7 @@
 	if (!disconnect && port->port_usb)
 		gs_start_rx(port);
 
-	spin_unlock_irq(&port->port_lock);
+	raw_spin_unlock_irq(&port->port_lock);
 }
 
 static void gs_read_complete(struct usb_ep *ep, struct usb_request *req)
@@ -587,17 +587,17 @@
 	struct gs_port	*port = ep->driver_data;
 
 	/* Queue all received data until the tty layer is ready for it. */
-	spin_lock(&port->port_lock);
+	raw_spin_lock(&port->port_lock);
 	list_add_tail(&req->list, &port->read_queue);
 	tasklet_schedule(&port->push);
-	spin_unlock(&port->port_lock);
+	raw_spin_unlock(&port->port_lock);
 }
 
 static void gs_write_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct gs_port	*port = ep->driver_data;
 
-	spin_lock(&port->port_lock);
+	raw_spin_lock(&port->port_lock);
 	list_add(&req->list, &port->write_pool);
 	port->write_started--;
 
@@ -618,7 +618,7 @@
 		break;
 	}
 
-	spin_unlock(&port->port_lock);
+	raw_spin_unlock(&port->port_lock);
 }
 
 static void gs_free_requests(struct usb_ep *ep, struct list_head *head,
@@ -734,7 +734,7 @@
 		if (!port)
 			status = -ENODEV;
 		else {
-			spin_lock_irq(&port->port_lock);
+			raw_spin_lock_irq(&port->port_lock);
 
 			/* already open?  Great. */
 			if (port->open_count) {
@@ -750,7 +750,7 @@
 				status = -EAGAIN;
 				port->openclose = true;
 			}
-			spin_unlock_irq(&port->port_lock);
+			raw_spin_unlock_irq(&port->port_lock);
 		}
 		mutex_unlock(&ports[port_num].lock);
 
@@ -772,14 +772,14 @@
 	} while (status != -EAGAIN);
 
 	/* Do the "real open" */
-	spin_lock_irq(&port->port_lock);
+	raw_spin_lock_irq(&port->port_lock);
 
 	/* allocate circular buffer on first open */
 	if (port->port_write_buf.buf_buf == NULL) {
 
-		spin_unlock_irq(&port->port_lock);
+		raw_spin_unlock_irq(&port->port_lock);
 		status = gs_buf_alloc(&port->port_write_buf, WRITE_BUF_SIZE);
-		spin_lock_irq(&port->port_lock);
+		raw_spin_lock_irq(&port->port_lock);
 
 		if (status) {
 			pr_debug("gs_open: ttyGS%d (%p,%p) no buffer\n",
@@ -817,7 +817,7 @@
 	status = 0;
 
 exit_unlock_port:
-	spin_unlock_irq(&port->port_lock);
+	raw_spin_unlock_irq(&port->port_lock);
 	return status;
 }
 
@@ -826,9 +826,9 @@
 	int cond;
 
 	/* return true on disconnect or empty buffer */
-	spin_lock_irq(&p->port_lock);
+	raw_spin_lock_irq(&p->port_lock);
 	cond = (p->port_usb == NULL) || !gs_buf_data_avail(&p->port_write_buf);
-	spin_unlock_irq(&p->port_lock);
+	raw_spin_unlock_irq(&p->port_lock);
 
 	return cond;
 }
@@ -838,7 +838,7 @@
 	struct gs_port *port = tty->driver_data;
 	struct gserial	*gser;
 
-	spin_lock_irq(&port->port_lock);
+	raw_spin_lock_irq(&port->port_lock);
 
 	if (port->open_count != 1) {
 		if (port->open_count == 0)
@@ -864,11 +864,11 @@
 	 * most GS_CLOSE_TIMEOUT seconds; then discard the rest
 	 */
 	if (gs_buf_data_avail(&port->port_write_buf) > 0 && gser) {
-		spin_unlock_irq(&port->port_lock);
+		raw_spin_unlock_irq(&port->port_lock);
 		wait_event_interruptible_timeout(port->drain_wait,
 					gs_writes_finished(port),
 					GS_CLOSE_TIMEOUT * HZ);
-		spin_lock_irq(&port->port_lock);
+		raw_spin_lock_irq(&port->port_lock);
 		gser = port->port_usb;
 	}
 
@@ -891,7 +891,7 @@
 
 	wake_up_interruptible(&port->close_wait);
 exit:
-	spin_unlock_irq(&port->port_lock);
+	raw_spin_unlock_irq(&port->port_lock);
 }
 
 static int gs_write(struct tty_struct *tty, const unsigned char *buf, int count)
@@ -903,13 +903,13 @@
 	pr_vdebug("gs_write: ttyGS%d (%p) writing %d bytes\n",
 			port->port_num, tty, count);
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	if (count)
 		count = gs_buf_put(&port->port_write_buf, buf, count);
 	/* treat count == 0 as flush_chars() */
 	if (port->port_usb)
 		status = gs_start_tx(port);
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	return count;
 }
@@ -923,9 +923,9 @@
 	pr_vdebug("gs_put_char: (%d,%p) char=0x%x, called from %p\n",
 		port->port_num, tty, ch, __builtin_return_address(0));
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	status = gs_buf_put(&port->port_write_buf, &ch, 1);
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	return status;
 }
@@ -937,10 +937,10 @@
 
 	pr_vdebug("gs_flush_chars: (%d,%p)\n", port->port_num, tty);
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	if (port->port_usb)
 		gs_start_tx(port);
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 }
 
 static int gs_write_room(struct tty_struct *tty)
@@ -949,10 +949,10 @@
 	unsigned long	flags;
 	int		room = 0;
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	if (port->port_usb)
 		room = gs_buf_space_avail(&port->port_write_buf);
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	pr_vdebug("gs_write_room: (%d,%p) room=%d\n",
 		port->port_num, tty, room);
@@ -966,9 +966,9 @@
 	unsigned long	flags;
 	int		chars = 0;
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	chars = gs_buf_data_avail(&port->port_write_buf);
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	pr_vdebug("gs_chars_in_buffer: (%d,%p) chars=%d\n",
 		port->port_num, tty, chars);
@@ -982,7 +982,7 @@
 	struct gs_port		*port = tty->driver_data;
 	unsigned long		flags;
 
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	if (port->port_usb) {
 		/* Kickstart read queue processing.  We don't do xon/xoff,
 		 * rts/cts, or other handshaking with the host, but if the
@@ -991,7 +991,7 @@
 		tasklet_schedule(&port->push);
 		pr_vdebug(PREFIX "%d: unthrottle\n", port->port_num);
 	}
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 }
 
 static int gs_break_ctl(struct tty_struct *tty, int duration)
@@ -1003,11 +1003,11 @@
 	pr_vdebug("gs_break_ctl: ttyGS%d, send break (%d) \n",
 			port->port_num, duration);
 
-	spin_lock_irq(&port->port_lock);
+	raw_spin_lock_irq(&port->port_lock);
 	gser = port->port_usb;
 	if (gser && gser->send_break)
 		status = gser->send_break(gser, duration);
-	spin_unlock_irq(&port->port_lock);
+	raw_spin_unlock_irq(&port->port_lock);
 
 	return status;
 }
@@ -1037,7 +1037,7 @@
 	if (port == NULL)
 		return -ENOMEM;
 
-	spin_lock_init(&port->port_lock);
+	raw_spin_lock_init(&port->port_lock);
 	init_waitqueue_head(&port->close_wait);
 	init_waitqueue_head(&port->drain_wait);
 
@@ -1158,9 +1158,9 @@
 {
 	int cond;
 
-	spin_lock_irq(&port->port_lock);
+	raw_spin_lock_irq(&port->port_lock);
 	cond = (port->open_count == 0) && !port->openclose;
-	spin_unlock_irq(&port->port_lock);
+	raw_spin_unlock_irq(&port->port_lock);
 	return cond;
 }
 
@@ -1258,7 +1258,7 @@
 	gser->out->driver_data = port;
 
 	/* then tell the tty glue that I/O can work */
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	gser->ioport = port;
 	port->port_usb = gser;
 
@@ -1282,7 +1282,7 @@
 			gser->disconnect(gser);
 	}
 
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	return status;
 
@@ -1312,7 +1312,7 @@
 		return;
 
 	/* tell the TTY glue not to do I/O here any more */
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 
 	/* REVISIT as above: how best to track this? */
 	port->port_line_coding = gser->port_line_coding;
@@ -1324,7 +1324,7 @@
 		if (port->port_tty)
 			tty_hangup(port->port_tty);
 	}
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 
 	/* disable endpoints, aborting down any active I/O */
 	usb_ep_disable(gser->out);
@@ -1334,7 +1334,7 @@
 	gser->in->driver_data = NULL;
 
 	/* finally, free any unused/unusable I/O buffers */
-	spin_lock_irqsave(&port->port_lock, flags);
+	raw_spin_lock_irqsave(&port->port_lock, flags);
 	if (port->open_count == 0 && !port->openclose)
 		gs_buf_free(&port->port_write_buf);
 	gs_free_requests(gser->out, &port->read_pool, NULL);
@@ -1344,5 +1344,5 @@
 	port->read_allocated = port->read_started =
 		port->write_allocated = port->write_started = 0;
 
-	spin_unlock_irqrestore(&port->port_lock, flags);
+	raw_spin_unlock_irqrestore(&port->port_lock, flags);
 }
diff -x .svn -Nru linux-3.0.x-orig/drivers/usb/host/ohci-at91.c linux-3.0.x-arm/drivers/usb/host/ohci-at91.c
--- linux-3.0.x-orig/drivers/usb/host/ohci-at91.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/usb/host/ohci-at91.c	2012-12-19 11:28:32.000000000 +0200
@@ -329,7 +329,7 @@
 	 *
 	 * REVISIT: some boards will be able to turn VBUS off...
 	 */
-	if (at91_suspend_entering_slow_clock()) {
+	if (clk_must_disable(fclk)) {
 		ohci_usb_reset (ohci);
 		/* flush the writes */
 		(void) ohci_readl (ohci, &ohci->regs->control);
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/displays/Kconfig linux-3.0.x-arm/drivers/video/omap2/displays/Kconfig
--- linux-3.0.x-orig/drivers/video/omap2/displays/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/displays/Kconfig	2012-12-19 11:27:15.000000000 +0200
@@ -10,6 +10,23 @@
 	  Supports LCD Panel used in TI SDP3430 and EVM boards,
 	  OMAP3517 EVM boards and CM-T35.
 
+config PANEL_VARISCITE
+	bool "VAR-DVK-OM3x and/or VAR-DVK-AM35 LCD Panel"
+choice
+	bool "LCD Panel Type"
+	depends on OMAP2_DSS
+	depends on MACH_VAR_SOM_OM3X || MACH_VAR_SOM_AM35 || MACH_OWEN_SPK2XX_VAR
+	default PANEL_URT_UMSH8272MD
+
+config PANEL_URT_UMSH8272MD
+	bool "URT UMSH-8272MS-1T"
+	depends on PANEL_VARISCITE
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  URT UMSH-8272MS-1T LCD Panel for VAR-DVK-OM35 and VAR-DVK-AM35
+
+endchoice
+
 config PANEL_LGPHILIPS_LB035Q02
 	tristate "LG.Philips LB035Q02 LCD Panel"
 	depends on OMAP2_DSS_DPI && SPI
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/displays/Makefile linux-3.0.x-arm/drivers/video/omap2/displays/Makefile
--- linux-3.0.x-orig/drivers/video/omap2/displays/Makefile	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/displays/Makefile	2012-12-19 11:27:15.000000000 +0200
@@ -2,6 +2,7 @@
 obj-$(CONFIG_PANEL_LGPHILIPS_LB035Q02) += panel-lgphilips-lb035q02.o
 obj-$(CONFIG_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
 obj-$(CONFIG_PANEL_NEC_NL8048HL11_01B) += panel-nec-nl8048hl11-01b.o
+obj-$(CONFIG_PANEL_URT_UMSH8272MD) += panel-variscite.o
 
 obj-$(CONFIG_PANEL_TAAL) += panel-taal.o
 obj-$(CONFIG_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/displays/panel-generic-dpi.c linux-3.0.x-arm/drivers/video/omap2/displays/panel-generic-dpi.c
--- linux-3.0.x-orig/drivers/video/omap2/displays/panel-generic-dpi.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/displays/panel-generic-dpi.c	2012-12-19 11:27:15.000000000 +0200
@@ -82,6 +82,27 @@
 		.name			= "generic",
 	},
 
+	/* UM */
+	{
+		{
+			.x_res		= 800,
+			.y_res		= 480,
+
+			.pixel_clock	= 28000,
+
+			.hsw		= 28,
+			.hfp		= 29,
+			.hbp		= 17,
+
+			.vsw		= 3,
+			.vfp		= 13,
+			.vbp		= 20,
+		},
+		.power_on_delay		= 50,
+		.power_off_delay	= 100,
+		.name			= "URT_UMSH8272MD",
+	},
+
 	/* Sharp LQ043T1DG01 */
 	{
 		{
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/displays/panel-variscite.c linux-3.0.x-arm/drivers/video/omap2/displays/panel-variscite.c
--- linux-3.0.x-orig/drivers/video/omap2/displays/panel-variscite.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/displays/panel-variscite.c	2012-12-19 11:27:15.000000000 +0200
@@ -0,0 +1,195 @@
+/*
+ * LCD panel driver for UMT 
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/fb.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+
+#include <video/omapdss.h>
+
+struct UMT_data {
+	struct backlight_device *bl;
+};
+
+static struct omap_video_timings UMT_ls_timings = {
+		.x_res = 800,
+		.y_res = 480,
+
+		.pixel_clock	= 28000,
+
+		.hsw		= 28,
+		.hfp		= 29,
+		.hbp		= 17,
+
+		.vsw		= 3,
+		.vfp		= 13,
+		.vbp		= 20,
+};
+
+static int UMT_ls_bl_update_status(struct backlight_device *bl)
+{
+	struct omap_dss_device *dssdev = dev_get_drvdata(&bl->dev);
+	int level;
+
+	if (!dssdev->set_backlight)
+		return -EINVAL;
+
+	if (bl->props.fb_blank == FB_BLANK_UNBLANK &&
+			bl->props.power == FB_BLANK_UNBLANK)
+		level = bl->props.brightness;
+	else
+		level = 0;
+
+	return dssdev->set_backlight(dssdev, level);
+}
+
+static int UMT_ls_bl_get_brightness(struct backlight_device *bl)
+{
+	if (bl->props.fb_blank == FB_BLANK_UNBLANK &&
+			bl->props.power == FB_BLANK_UNBLANK)
+		return bl->props.brightness;
+
+	return 0;
+}
+
+static const struct backlight_ops UMT_ls_bl_ops = {
+	.get_brightness = UMT_ls_bl_get_brightness,
+	.update_status  = UMT_ls_bl_update_status,
+};
+
+
+
+static int UMT_ls_panel_probe(struct omap_dss_device *dssdev)
+{
+	dssdev->panel.config = OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS |
+		OMAP_DSS_LCD_IHS;
+	dssdev->panel.acb = 0x28;
+	dssdev->panel.timings = UMT_ls_timings;
+
+
+	return 0;
+}
+
+static void __exit UMT_ls_panel_remove(struct omap_dss_device *dssdev)
+{
+}
+
+static int UMT_ls_power_on(struct omap_dss_device *dssdev)
+{
+	int r = 0;
+
+	if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
+		return 0;
+
+	r = omapdss_dpi_display_enable(dssdev);
+	if (r)
+		goto err0;
+
+	/* wait couple of vsyncs until enabling the LCD */
+	msleep(50);
+
+	if (dssdev->platform_enable) {
+		r = dssdev->platform_enable(dssdev);
+		if (r)
+			goto err1;
+	}
+
+	return 0;
+err1:
+	omapdss_dpi_display_disable(dssdev);
+err0:
+	return r;
+}
+
+static void UMT_ls_power_off(struct omap_dss_device *dssdev)
+{
+	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)
+		return;
+
+	if (dssdev->platform_disable)
+		dssdev->platform_disable(dssdev);
+
+	/* wait at least 5 vsyncs after disabling the LCD */
+
+	msleep(100);
+
+	omapdss_dpi_display_disable(dssdev);
+}
+
+static int UMT_ls_panel_enable(struct omap_dss_device *dssdev)
+{
+	int r;
+	r = UMT_ls_power_on(dssdev);
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+	return r;
+}
+
+static void UMT_ls_panel_disable(struct omap_dss_device *dssdev)
+{
+	UMT_ls_power_off(dssdev);
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+}
+
+static int UMT_ls_panel_suspend(struct omap_dss_device *dssdev)
+{
+	UMT_ls_power_off(dssdev);
+	dssdev->state = OMAP_DSS_DISPLAY_SUSPENDED;
+	return 0;
+}
+
+static int UMT_ls_panel_resume(struct omap_dss_device *dssdev)
+{
+	int r;
+	r = UMT_ls_power_on(dssdev);
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+	return r;
+}
+
+static struct omap_dss_driver UMT_ls_driver = {
+	.probe		= UMT_ls_panel_probe,
+	.remove		= __exit_p(UMT_ls_panel_remove),
+
+	.enable		= UMT_ls_panel_enable,
+	.disable	= UMT_ls_panel_disable,
+	.suspend	= UMT_ls_panel_suspend,
+	.resume		= UMT_ls_panel_resume,
+
+	.driver         = {
+		.name   = "URT_UMSH8272MD",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init UMT_ls_panel_drv_init(void)
+{
+	return omap_dss_register_driver(&UMT_ls_driver);
+}
+
+static void __exit UMT_ls_panel_drv_exit(void)
+{
+	omap_dss_unregister_driver(&UMT_ls_driver);
+}
+
+module_init(UMT_ls_panel_drv_init);
+module_exit(UMT_ls_panel_drv_exit);
+MODULE_LICENSE("GPL");
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/dss/dispc.c linux-3.0.x-arm/drivers/video/omap2/dss/dispc.c
--- linux-3.0.x-orig/drivers/video/omap2/dss/dispc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/dss/dispc.c	2012-12-19 11:27:15.000000000 +0200
@@ -3659,7 +3659,7 @@
 	dispc_save_context();
 
 	rev = dispc_read_reg(DISPC_REVISION);
-	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
+	printk(KERN_INFO "OMAP DISPC rev %d.%d\n",
 	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
 	enable_clocks(0);
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/dss/dsi.c linux-3.0.x-arm/drivers/video/omap2/dss/dsi.c
--- linux-3.0.x-orig/drivers/video/omap2/dss/dsi.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/dss/dsi.c	2012-12-19 11:27:15.000000000 +0200
@@ -4518,7 +4518,7 @@
 	enable_clocks(1);
 
 	rev = dsi_read_reg(dsidev, DSI_REVISION);
-	dev_dbg(&dsidev->dev, "OMAP DSI rev %d.%d\n",
+	printk(KERN_INFO "OMAP DSI rev %d.%d\n",
 	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
 	dsi->num_data_lanes = dsi_get_num_data_lanes(dsidev);
diff -x .svn -Nru linux-3.0.x-orig/drivers/video/omap2/dss/venc.c linux-3.0.x-arm/drivers/video/omap2/dss/venc.c
--- linux-3.0.x-orig/drivers/video/omap2/dss/venc.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/video/omap2/dss/venc.c	2012-12-19 11:27:15.000000000 +0200
@@ -748,7 +748,7 @@
 	venc_enable_clocks(1);
 
 	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
-	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
+	printk(KERN_INFO "OMAP VENC rev %d\n", rev_id);
 
 	venc_enable_clocks(0);
 
diff -x .svn -Nru linux-3.0.x-orig/drivers/watchdog/at91rm9200_wdt.c linux-3.0.x-arm/drivers/watchdog/at91rm9200_wdt.c
--- linux-3.0.x-orig/drivers/watchdog/at91rm9200_wdt.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/drivers/watchdog/at91rm9200_wdt.c	2013-09-20 18:29:46.000000000 +0300
@@ -24,6 +24,19 @@
 #include <linux/uaccess.h>
 #include <mach/at91_st.h>
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+/* defined in at91rm9200_time.c */
+extern atomic_t at91_wdt_ovf_counter;
+extern int at91_wdt_irq_enabled;
+
+static int old_ovf_counter = 0;
+static void (*do_before_reset)(void *data) = NULL;
+static void *before_reset_data = NULL;
+#endif
+
 #define WDT_DEFAULT_TIME	5	/* seconds */
 #define WDT_MAX_TIME		256	/* seconds */
 
@@ -41,7 +54,6 @@
 				__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
 #endif
 
-
 static unsigned long at91wdt_busy;
 
 /* ......................................................................... */
@@ -51,6 +63,12 @@
  */
 static inline void at91_wdt_stop(void)
 {
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (at91_wdt_irq_enabled) {
+		at91_sys_write(AT91_ST_IDR, AT91_ST_WDOVF);
+	}
+#endif
+	
 	at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN);
 }
 
@@ -59,8 +77,20 @@
  */
 static inline void at91_wdt_start(void)
 {
-	at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN | AT91_ST_RSTEN |
-				(((65536 * wdt_time) >> 8) & AT91_ST_WDV));
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (at91_wdt_irq_enabled) {
+		old_ovf_counter = atomic_read(&at91_wdt_ovf_counter);
+		at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN |
+					(((65536 * wdt_time) >> 8) & AT91_ST_WDV));
+		at91_sys_write(AT91_ST_IER, AT91_ST_WDOVF);
+	} else {
+#endif
+		at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN | AT91_ST_RSTEN |
+					(((65536 * wdt_time) >> 8) & AT91_ST_WDV));
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	}
+#endif
+
 	at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);
 }
 
@@ -180,6 +210,31 @@
 	return len;
 }
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+static irqreturn_t at91_wdt_interrupt(int irq, void *dev_id)
+{
+	int ovf_counter = atomic_read(&at91_wdt_ovf_counter);
+
+	if (old_ovf_counter != ovf_counter) {
+		dev_info((struct device *)dev_id, 
+				"interrupt fired (counters: old=%d, new=%d)\n",
+				old_ovf_counter, ovf_counter);
+		old_ovf_counter = ovf_counter;
+
+		preempt_disable();
+		if (do_before_reset != NULL) {
+			(*do_before_reset)(before_reset_data);
+		}
+		udelay(30);
+		at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN | AT91_ST_RSTEN | 1);
+		dev_info((struct device *)dev_id, "resetting..\n");
+		while (1);
+	}
+
+	return IRQ_NONE;
+}
+#endif
+
 /* ......................................................................... */
 
 static const struct file_operations at91wdt_fops = {
@@ -197,6 +252,16 @@
 	.fops		= &at91wdt_fops,
 };
 
+
+#if defined(CONFIG_OWEN_FLASH_SETUP_ON_WATCHDOG)
+extern void physmap_flash_setup_for_reset(void *data);
+
+static int __devinit match_dev_name(struct device *dev, void *name)
+{
+	return !strcmp(name, dev_name(dev));
+}
+#endif
+
 static int __devinit at91wdt_probe(struct platform_device *pdev)
 {
 	int res;
@@ -205,7 +270,45 @@
 		return -EBUSY;
 	at91wdt_miscdev.parent = &pdev->dev;
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	
+	if (at91_wdt_irq_enabled) {
+#if defined(CONFIG_OWEN_FLASH_SETUP_ON_WATCHDOG)
+		/* find physmap-flash device */
+		struct device *flash_dev;
+		
+		flash_dev = device_find_child(&platform_bus, "physmap-flash", match_dev_name);
+		if (!flash_dev) {
+			flash_dev = device_find_child(&platform_bus, "physmap-flash.0", match_dev_name);
+			if (!flash_dev) {
+				dev_warn(&pdev->dev, "failed to find physmap-flash device, it won't be touched on reset\n");
+			}
+		}
+		if (flash_dev) {
+			do_before_reset = &physmap_flash_setup_for_reset;
+			before_reset_data = to_platform_device(flash_dev);
+			dev_info(&pdev->dev, "physmap-flash device found, and set to be configured before reset\n");
+		}
+#endif
+		
+		res = request_irq(AT91_ID_SYS, at91_wdt_interrupt, IRQF_SHARED,
+						pdev->name, &pdev->dev);
+		if (res) {
+			dev_warn(&pdev->dev, "failed to setup irq handler - fall back on non-irq mode\n");
+			at91_wdt_irq_enabled = 0;
+		} else {
+			dev_info(&pdev->dev, "watchdog irq enabled\n");
+		}
+	}else {
+		dev_info(&pdev->dev, "watchdog irq disabled\n");
+	}
+#endif
+
 	res = misc_register(&at91wdt_miscdev);
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (res && at91_wdt_irq_enabled)
+		free_irq(AT91_ID_SYS, &pdev->dev);
+#endif
 	if (res)
 		return res;
 
@@ -222,6 +325,18 @@
 	if (!res)
 		at91wdt_miscdev.parent = NULL;
 
+#if defined(CONFIG_OWEN_WATCHDOG_RESET_BY_IRQ)
+	if (at91_wdt_irq_enabled)
+		free_irq(AT91_ID_SYS, &pdev->dev);
+
+#if defined(CONFIG_OWEN_FLASH_SETUP_ON_WATCHDOG)
+	if (before_reset_data != NULL) {
+		put_device(&((struct platform_device *)before_reset_data)->dev);
+	}
+#endif
+
+#endif
+
 	return res;
 }
 
diff -x .svn -Nru linux-3.0.x-orig/.gitignore linux-3.0.x-arm/.gitignore
--- linux-3.0.x-orig/.gitignore	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,81 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# NOTE! Please use 'git ls-files -i --exclude-standard'
-# command after changing this file, to see if there are
-# any tracked files which get ignored after the change.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.ko
-*.so
-*.so.dbg
-*.mod.c
-*.i
-*.lst
-*.symtypes
-*.order
-modules.builtin
-*.elf
-*.bin
-*.gz
-*.bz2
-*.lzma
-*.xz
-*.lzo
-*.patch
-*.gcno
-
-#
-# Top-level generic files
-#
-/tags
-/TAGS
-/linux
-/vmlinux
-/vmlinuz
-/System.map
-/Module.markers
-/Module.symvers
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated include files
-#
-include/config
-include/linux/version.h
-include/generated
-arch/*/include/generated
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-ncscope.*
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
diff -x .svn -Nru linux-3.0.x-orig/include/linux/clk.h linux-3.0.x-arm/include/linux/clk.h
--- linux-3.0.x-orig/include/linux/clk.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/include/linux/clk.h	2012-12-19 11:24:34.000000000 +0200
@@ -126,6 +126,26 @@
 struct clk *clk_get_parent(struct clk *clk);
 
 /**
+ * clk_must_disable - report whether a clock's users must disable it
+ * @clk: one node in the clock tree
+ *
+ * This routine returns true only if the upcoming system state requires
+ * disabling the specified clock.
+ *
+ * It's common for platform power states to constrain certain clocks (and
+ * their descendants) to be unavailable, while other states allow that
+ * clock to be active.  A platform's power states often include an "all on"
+ * mode; system wide sleep states like "standby" or "suspend-to-RAM"; and
+ * operating states which sacrifice functionality for lower power usage.
+ *
+ * The constraint value is commonly tested in device driver suspend(), to
+ * leave clocks active if they are needed for features like wakeup events.
+ * On platforms that support reduced functionality operating states, the
+ * constraint may also need to be tested during resume() and probe() calls.
+ */
+int clk_must_disable(struct clk *clk);
+
+/**
  * clk_get_sys - get a clock based upon the device name
  * @dev_id: device name
  * @con_id: connection ID
diff -x .svn -Nru linux-3.0.x-orig/include/linux/hpr/hpr.h linux-3.0.x-arm/include/linux/hpr/hpr.h
--- linux-3.0.x-orig/include/linux/hpr/hpr.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/include/linux/hpr/hpr.h	2012-12-19 11:24:29.000000000 +0200
@@ -0,0 +1,157 @@
+#ifndef _LINUX_HPR_H_
+#define _LINUX_HPR_H_
+
+/* interface of hpr driver to other kernel */
+
+typedef union {
+	struct {
+		int alarm_0: 1;
+		int alarm_1: 1;
+		int status_1: 1;
+		int wrong_output_value: 1;
+		int reserve: 1;
+		int comm_error: 1;
+		int update: 1;
+		int busy: 1;
+	} field;
+	unsigned char b;
+} hpr_module_status;
+
+/* Process Value Communication:
+ *                         ---PAB structure -> 1 channel --
+ *                         |                              |
+ *             I/O        data                control info        channel info
+ *
+ * Standard
+ *   DIDO      IO       1/2 byte                  -                  -
+ *
+ *   AIAO      IO       2/4 byte                  -                  I:+ O:-
+ *
+ * DMS         I        2/4 byte                  1 byte(?)          +
+ *             O         -                        1 byte             +
+ *
+ * COMPLEX     IO       2/4 byte * 3(channels)    -                  + (start data addr)
+ *
+ * IO16B       IO       16 byte(?)                ?                  ?   
+ *
+ * AI_HART     I        PV,SV,TV,QV x 2 byte ?    -                  +
+ *             O        -                         -                  - (?)
+ */
+
+typedef struct {
+	union {
+		unsigned char b;
+		unsigned short w;
+	} pv;
+} hpr_pab_dido;
+
+typedef struct {
+	union {
+		unsigned short w;
+		unsigned long dw;
+	} pv;
+} hpr_pab_aiao;
+
+#define HPR_DMS_VS_MASK		0x07
+#define HPR_DMS_VS_GROSS	0
+#define HPR_DMS_VS_NET		1
+#define HPR_DMS_VS_TARA		2
+#define HPR_DMS_VS_OFFSET	3
+
+typedef union {
+	struct {
+		int value_select: 3;
+		int reserve_3: 1;	/* use the same naming for unused bits like for for hpr_module_status */
+		int carry_out_reset: 1;
+		int carry_out_taring: 1;
+		int taring_reset: 1;
+		int reserve_7: 1;
+	} field;
+	unsigned char b;
+} hpr_dms_control_info;
+
+typedef struct {
+	union {
+		unsigned short w;
+		unsigned long dw;
+	} pv;
+	hpr_dms_control_info ci;
+} hpr_pab_dms;
+
+typedef struct {
+	union {
+		unsigned short w;
+		unsigned long dw;
+	} pv;
+} hpr_pab_complex;
+
+typedef struct {
+	unsigned char pv[16];
+} hpr_pab_io16b;
+
+typedef struct {
+	unsigned short pv;
+	unsigned short sv;
+	unsigned short tv;
+	unsigned short qv;
+} hpr_pab_ai_hart;
+
+/* Channel info is not included into pab structure 
+ * because:
+ *  - channel address always eq. to the pab's index in module's pab array
+ *  - in rw_query:
+ *     - for async exchange - all pabs from 0 are included
+ *     - for sync exchange - channel address is passed via tx_channel, rx_channel fields of rw_query
+ */
+typedef union {				/* Access to vals: */
+	hpr_pab_dido dido;		/* pab.dido.pv.b/w */
+	hpr_pab_aiao aiao;		/* pab.aiao.pv.w/dw */
+	hpr_pab_dms dms;		/* pab.dms.pv.w/dw, pab.dms.ci */
+	hpr_pab_complex complex;	/* pab.complex.pv.w/dw */
+	hpr_pab_io16b io16b;		/* pab.io16b.pv[] */
+	hpr_pab_ai_hart ai_hart;	/* pab.ai_hart.pv, pab.ai_hart.sv/tv/qv */
+} hpr_pab;
+
+
+/* It seems better to pass adresses of bus and module as args of respective library call
+ */
+typedef struct {
+	unsigned char sync; 		/* synchronous or asynchronous exchange: immediate exchange or exchange through group work */
+
+	hpr_pab *out_data;		/* ptr to array of output pab structs */
+	unsigned short out_count;	/* count of the array - for security reason */
+	unsigned short out_channel;	/* address of the channel/pab to pass to a module (ignored by async call, when all used pabs implied */
+
+	hpr_pab *in_data;		/* ptr to array of input pab structs */
+	unsigned short in_count;	/* count of the array - for security reason */
+	unsigned short in_channel;	/* address of the channel/pab received from the module (ignored by async call, when all used pabs implied */
+
+	hpr_module_status status;	/* status of module after exchange (sync only?) */
+} hpr_pv_query;
+
+/* synchronous exchange with module using asynchronous group work */
+extern int hpr_one_shot_async_exchange(int bus_index, int module_address, 
+										hpr_pv_query *pv_query);
+
+/* parameter types */
+#define HPR_PT_INT		0
+#define HPR_PT_FLOAT	1
+/* get/set param(s) arg */
+typedef struct hpr_param_arg {
+	int address;	/* param address */
+	int count;		/* count of params to R/W */
+	unsigned char type;		/* type of values */
+	union {
+		void *v;				/* values type is any */
+		short *s;				/* values type is short */
+		float *f;				/* values type is float */
+	} values;				/* ptr to a buffer of values to write or to a buffer for read values */
+	unsigned char ack;		/* error code of operation from ack byte */
+} hpr_param_arg;
+
+extern int hpr_set_module_params(int bus_index, int module_address, 
+					hpr_param_arg *param);
+extern int hpr_get_module_params(int bus_index, int module_address, 
+					hpr_param_arg *param);
+
+#endif /* _LINUX_HPR_H_ */
diff -x .svn -Nru linux-3.0.x-orig/include/linux/hpr/hpr_serial.h linux-3.0.x-arm/include/linux/hpr/hpr_serial.h
--- linux-3.0.x-orig/include/linux/hpr/hpr_serial.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.x-arm/include/linux/hpr/hpr_serial.h	2012-12-19 11:24:29.000000000 +0200
@@ -0,0 +1,79 @@
+#ifndef _LINUX_HPR_SERIAL_H_
+#define _LINUX_HPR_SERIAL_H_
+
+#define HPR_SERIAL_DRIVER_NAME	"hpr_serial"
+
+/* HE5672: 
+ * 0x800		UART connection: 0 - HPR, 1 - dedicated UART 
+ * 0x801		UART mode: 0 - RS485, 1 - RS232
+ * 0x802		speed: 0 - 10: 1200, 2400, 4800,... 115200
+ * 0x803		parity: 0 -none, 1 - odd, 2 - even
+ * 0x804		stop bits: 1 - one, 2 - two
+ * 0x805		flow control: 0 -CTS/RTS off, 1 - CTS/RTS on
+ */
+#define HPR_HWID_HE5672			0x2720
+
+#define HPR_HE5672_PARAMS_ADDR	0x800
+#define HPR_HE5672_PARAMS_COUNT	6
+
+#define HPR_HE5672_PIDX_UART_CONN	0
+#define HPR_HE5672_PIDX_UART_MODE	1
+#define HPR_HE5672_PIDX_SPEED			2
+#define HPR_HE5672_PIDX_PARITY		3
+#define HPR_HE5672_PIDX_STOP_BITS		4
+#define HPR_HE5672_PIDX_FLOW_CTL		5
+
+#define HPR_HE5672_CONFIG_ON_ADDR	0x100
+#define HPR_HE5672_CONFIG_OFF_ADDR	0x102
+#define HPR_HE5672_UART_HPR		0
+#define HPR_HE5672_UART_DIRECT	1
+#define HPR_HE5672_MODE_RS485		0
+#define HPR_HE5672_MODE_RS232		1
+#define HPR_HE5672_B1200			0
+#define HPR_HE5672_B2400			1
+#define HPR_HE5672_B4800			2
+#define HPR_HE5672_B7200			3
+#define HPR_HE5672_B9600			4
+#define HPR_HE5672_B14400			5
+#define HPR_HE5672_B19200			6
+#define HPR_HE5672_B38400			7
+#define HPR_HE5672_B56000			8
+#define HPR_HE5672_B57600			9
+#define HPR_HE5672_B115200			10
+#define HPR_HE5672_PAR_NONE		0
+#define HPR_HE5672_PAR_ODD		1
+#define HPR_HE5672_PAR_EVEN		2
+#define HPR_HE5672_SB_1			1
+#define HPR_HE5672_SB_2			2
+#define HPR_HE5672_RTSCTS_ON		1
+#define HPR_HE5672_RTSCTS_OFF		0
+
+#define HPR_HE5672_CTL_TR			(1 << 0)
+#define HPR_HE5672_CTL_RR			(1 << 1)
+#define HPR_HE5672_CTL_SEND		(1 << 2)
+#define HPR_HE5672_CTL_OVR			(1 << 3)
+
+typedef struct hpr_he5672_data {
+	unsigned short params[HPR_HE5672_PARAMS_COUNT];
+} hpr_he5672_data;
+
+typedef struct hpr_serial_port_data {
+	int bus_index;
+	int module_addr;
+	unsigned short hw_id;
+
+	struct {
+		/* SET by hpr */
+//		unsigned scanning: 1;	/* bus scanning in progress */
+		unsigned invalid: 1;	/* whether device is invalid: direct RS232/485 or re-scan failure */
+
+		/* SET by hpr_serial */
+		//unsigned opened: 1;	/* whether or not device is used */
+	} flags;
+
+	union {
+		hpr_he5672_data he5672;
+	} priv;				/* module-specific data */
+} hpr_serial_port_data;
+
+#endif /* _LINUX_HPR_SERIAL_H_ */
diff -x .svn -Nru linux-3.0.x-orig/include/linux/lockdep.h linux-3.0.x-arm/include/linux/lockdep.h
--- linux-3.0.x-orig/include/linux/lockdep.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/include/linux/lockdep.h	2012-12-19 11:24:34.000000000 +0200
@@ -29,7 +29,7 @@
  */
 #define XXX_LOCK_USAGE_STATES		(1+3*4)
 
-#define MAX_LOCKDEP_SUBCLASSES		8UL
+#define MAX_LOCKDEP_SUBCLASSES		16UL
 
 /*
  * NR_LOCKDEP_CACHING_CLASSES ... Number of classes
diff -x .svn -Nru linux-3.0.x-orig/include/linux/serial.h linux-3.0.x-arm/include/linux/serial.h
--- linux-3.0.x-orig/include/linux/serial.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/include/linux/serial.h	2012-12-19 11:24:34.000000000 +0200
@@ -220,5 +220,12 @@
 #ifdef __KERNEL__
 #include <linux/compiler.h>
 
+/* control structure for switching between RS232/RS485 */
+struct serial_rs485_switch {
+	unsigned char enabled;	/* run time switching enabled */
+	unsigned int pin;			/* GPIO used for switching output circuit */
+	unsigned char rs485_level;	/* GPIO level for RS485 mode (RS232 - inversed level) */
+};
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SERIAL_H */
diff -x .svn -Nru linux-3.0.x-orig/include/linux/serial_reg.h linux-3.0.x-arm/include/linux/serial_reg.h
--- linux-3.0.x-orig/include/linux/serial_reg.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/include/linux/serial_reg.h	2013-01-02 14:50:21.000000000 +0200
@@ -362,5 +362,7 @@
 #define UART_OMAP_MDR1_CIR_MODE		0x06	/* CIR mode */
 #define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
 
+#define UART_OMAP_SCR_TX_EMPTY_CTL_IT	0x08	/* TX Empty IRQ mode */
+
 #endif /* _LINUX_SERIAL_REG_H */
 
diff -x .svn -Nru linux-3.0.x-orig/include/linux/spi/eeprom.h linux-3.0.x-arm/include/linux/spi/eeprom.h
--- linux-3.0.x-orig/include/linux/spi/eeprom.h	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/include/linux/spi/eeprom.h	2012-12-19 11:31:58.000000000 +0200
@@ -13,15 +13,23 @@
 struct spi_eeprom {
 	u32		byte_len;
 	char		name[10];
-	u16		page_size;		/* for writes */
+	u16		page_size;	/* for writes */
 	u16		flags;
-#define	EE_ADDR1	0x0001			/*  8 bit addrs */
-#define	EE_ADDR2	0x0002			/* 16 bit addrs */
-#define	EE_ADDR3	0x0004			/* 24 bit addrs */
-#define	EE_READONLY	0x0008			/* disallow writes */
+#define	EE_ADDR1		0x0001	/*  8 bit addrs */
+#define	EE_ADDR2		0x0002	/* 16 bit addrs */
+#define	EE_ADDR3		0x0004	/* 24 bit addrs */
+#define	EE_READONLY		0x0008	/* disallow writes */
+#define	EE_NODELAY_WRITE	0x0010	/* NoDelay write for MRAM, e.g. FM25H20 */
+#define	EE_ARBITRARY_WRITE	0x0020	/* MRAM chip allows write with arbitrary start address and length */
 
 	/* for exporting this chip's data to other kernel code */
 	void (*setup)(struct memory_accessor *mem, void *context);
+
+	                                                        
+	                                                             
+	                                                                                                                  
+	                                                                                                                                   
+	
 	void *context;
 };
 
diff -x .svn -Nru linux-3.0.x-orig/init/do_mounts.c linux-3.0.x-arm/init/do_mounts.c
--- linux-3.0.x-orig/init/do_mounts.c	2013-09-19 17:39:50.000000000 +0300
+++ linux-3.0.x-arm/init/do_mounts.c	2012-12-19 11:24:53.000000000 +0200
@@ -337,6 +337,10 @@
 				root_device_name, b);
 		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
 
+#ifdef CONFIG_OWEN_PANIC_BLINK
+		system_serial_low = 0;  //Needed for machine-specific code, in order to understand cause of the kernel panic
+#endif
+
 		printk_all_partitions();
 #ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
 		printk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "
@@ -354,6 +358,9 @@
 #ifdef CONFIG_BLOCK
 	__bdevname(ROOT_DEV, b);
 #endif
+#ifdef CONFIG_OWEN_PANIC_BLINK
+	system_serial_low = 0;  //Needed for machine-specific code, in order to understand cause of the kernel panic
+#endif
 	panic("VFS: Unable to mount root fs on %s", b);
 out:
 	putname(fs_names);
diff -x .svn -Nru linux-3.0.x-orig/kernel/panic.c linux-3.0.x-arm/kernel/panic.c
--- linux-3.0.x-orig/kernel/panic.c	2013-09-19 17:40:00.000000000 +0300
+++ linux-3.0.x-arm/kernel/panic.c	2012-12-19 11:24:23.000000000 +0200
@@ -24,8 +24,13 @@
 #include <linux/nmi.h>
 #include <linux/dmi.h>
 
-#define PANIC_TIMER_STEP 100
-#define PANIC_BLINK_SPD 18
+#ifdef CONFIG_OWEN_PANIC_BLINK
+#   define PANIC_TIMER_STEP 50
+#   define PANIC_BLINK_SPD 36
+#else
+#   define PANIC_TIMER_STEP 100
+#   define PANIC_BLINK_SPD 18
+#endif
 
 int panic_on_oops;
 static unsigned long tainted_mask;
diff -x .svn -Nru linux-3.0.x-orig/.mailmap linux-3.0.x-arm/.mailmap
--- linux-3.0.x-orig/.mailmap	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/.mailmap	1970-01-01 03:00:00.000000000 +0300
@@ -1,114 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# repo-abbrev: /pub/scm/linux/kernel/git/
-#
-
-Aaron Durbin <adurbin@google.com>
-Adam Oldham <oldhamca@gmail.com>
-Adam Radford <aradford@gmail.com>
-Adrian Bunk <bunk@stusta.de>
-Alan Cox <alan@lxorguk.ukuu.org.uk>
-Alan Cox <root@hraefn.swansea.linux.org.uk>
-Aleksey Gorelov <aleksey_gorelov@phoenix.com>
-Al Viro <viro@ftp.linux.org.uk>
-Al Viro <viro@zenIV.linux.org.uk>
-Andreas Herrmann <aherrman@de.ibm.com>
-Andrew Morton <akpm@osdl.org>
-Andrew Vasquez <andrew.vasquez@qlogic.com>
-Andy Adamson <andros@citi.umich.edu>
-Archit Taneja <archit@ti.com>
-Arnaud Patard <arnaud.patard@rtp-net.org>
-Arnd Bergmann <arnd@arndb.de>
-Axel Dyks <xl@xlsigned.net>
-Axel Lin <axel.lin@gmail.com>
-Ben Gardner <bgardner@wabtec.com>
-Ben M Cahill <ben.m.cahill@intel.com>
-Björn Steinbrink <B.Steinbrink@gmx.de>
-Brian Avery <b.avery@hp.com>
-Brian King <brking@us.ibm.com>
-Christoph Hellwig <hch@lst.de>
-Corey Minyard <minyard@acm.org>
-Damian Hobson-Garcia <dhobsong@igel.co.jp>
-David Brownell <david-b@pacbell.net>
-David Woodhouse <dwmw2@shinybook.infradead.org>
-Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
-Domen Puncer <domen@coderock.org>
-Douglas Gilbert <dougg@torque.net>
-Ed L. Cashin <ecashin@coraid.com>
-Evgeniy Polyakov <johnpol@2ka.mipt.ru>
-Felipe W Damasio <felipewd@terra.com.br>
-Felix Kuhling <fxkuehl@gmx.de>
-Felix Moeller <felix@derklecks.de>
-Filipe Lautert <filipe@icewall.org>
-Franck Bui-Huu <vagabon.xyz@gmail.com>
-Frank Zago <fzago@systemfabricworks.com>
-Greg Kroah-Hartman <greg@echidna.(none)>
-Greg Kroah-Hartman <gregkh@suse.de>
-Greg Kroah-Hartman <greg@kroah.com>
-Henk Vergonet <Henk.Vergonet@gmail.com>
-Henrik Kretzschmar <henne@nachtwindheim.de>
-Herbert Xu <herbert@gondor.apana.org.au>
-Jacob Shin <Jacob.Shin@amd.com>
-James Bottomley <jejb@mulgrave.(none)>
-James Bottomley <jejb@titanic.il.steeleye.com>
-James E Wilson <wilson@specifix.com>
-James Ketrenos <jketreno@io.(none)>
-Jean Tourrilhes <jt@hpl.hp.com>
-Jeff Garzik <jgarzik@pretzel.yyz.us>
-Jens Axboe <axboe@suse.de>
-Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
-John Stultz <johnstul@us.ibm.com>
-Juha Yrjola <at solidboot.com>
-Juha Yrjola <juha.yrjola@nokia.com>
-Juha Yrjola <juha.yrjola@solidboot.com>
-Kay Sievers <kay.sievers@vrfy.org>
-Kenneth W Chen <kenneth.w.chen@intel.com>
-Koushik <raghavendra.koushik@neterion.com>
-Leonid I Ananiev <leonid.i.ananiev@intel.com>
-Linas Vepstas <linas@austin.ibm.com>
-Mark Brown <broonie@sirena.org.uk>
-Matthieu CASTET <castet.matthieu@free.fr>
-Mayuresh Janorkar <mayur@ti.com>
-Michael Buesch <mb@bu3sch.de>
-Michael Buesch <mbuesch@freenet.de>
-Michel Dänzer <michel@tungstengraphics.com>
-Mitesh shah <mshah@teja.com>
-Morten Welinder <terra@gnome.org>
-Morten Welinder <welinder@anemone.rentec.com>
-Morten Welinder <welinder@darter.rentec.com>
-Morten Welinder <welinder@troll.com>
-Mythri P K <mythripk@ti.com>
-Nguyen Anh Quynh <aquynh@gmail.com>
-Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
-Patrick Mochel <mochel@digitalimplant.org>
-Peter A Jonsson <pj@ludd.ltu.se>
-Peter Oruba <peter@oruba.de>
-Peter Oruba <peter.oruba@amd.com>
-Praveen BP <praveenbp@ti.com>
-Rajesh Shah <rajesh.shah@intel.com>
-Ralf Baechle <ralf@linux-mips.org>
-Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
-Rémi Denis-Courmont <rdenis@simphalempin.com>
-Rudolf Marek <R.Marek@sh.cvut.cz>
-Rui Saraiva <rmps@joel.ist.utl.pt>
-Sachin P Sant <ssant@in.ibm.com>
-Sam Ravnborg <sam@mars.ravnborg.org>
-Sascha Hauer <s.hauer@pengutronix.de>
-S.Çağlar Onur <caglar@pardus.org.tr>
-Simon Kelley <simon@thekelleys.org.uk>
-Stéphane Witzmann <stephane.witzmann@ubpmes.univ-bpclermont.fr>
-Stephen Hemminger <shemminger@osdl.org>
-Sumit Semwal <sumit.semwal@ti.com>
-Tejun Heo <htejun@gmail.com>
-Thomas Graf <tgraf@suug.ch>
-Tony Luck <tony.luck@intel.com>
-Tsuneo Yoshioka <Tsuneo.Yoshioka@f-secure.com>
-Uwe Kleine-König <ukleinek@informatik.uni-freiburg.de>
-Uwe Kleine-König <ukl@pengutronix.de>
-Uwe Kleine-König <Uwe.Kleine-Koenig@digi.com>
-Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
-Takashi YOSHII <takashi.yoshii.zj@renesas.com>
diff -x .svn -Nru linux-3.0.x-orig/sound/atmel/ac97c.c linux-3.0.x-arm/sound/atmel/ac97c.c
--- linux-3.0.x-orig/sound/atmel/ac97c.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/sound/atmel/ac97c.c	2012-12-19 11:24:46.000000000 +0200
@@ -278,8 +278,6 @@
 		return retval;
 	/* snd_pcm_lib_malloc_pages returns 1 if buffer is changed. */
 	if (cpu_is_at32ap7000()) {
-		if (retval < 0)
-			return retval;
 		/* snd_pcm_lib_malloc_pages returns 1 if buffer is changed. */
 		if (retval == 1)
 			if (test_and_clear_bit(DMA_RX_READY, &chip->flags))
@@ -715,7 +713,7 @@
 	}
 
 	if (sr & AC97C_SR_COEVT) {
-		dev_info(&chip->pdev->dev, "codec channel event%s%s%s%s%s\n",
+		dev_dbg(&chip->pdev->dev, "codec channel event%s%s%s%s%s\n",
 				cosr & AC97C_CSR_OVRUN   ? " OVRUN"   : "",
 				cosr & AC97C_CSR_RXRDY   ? " RXRDY"   : "",
 				cosr & AC97C_CSR_TXEMPTY ? " TXEMPTY" : "",
@@ -889,7 +887,9 @@
 
 static void atmel_ac97c_reset(struct atmel_ac97c *chip)
 {
-	ac97c_writel(chip, MR,   0);
+	/* use these lines instead of standard command, which results in probe() failure */
+	ac97c_writel(chip, MR,   AC97C_MR_WRST);
+	udelay(2);
 	ac97c_writel(chip, MR,   AC97C_MR_ENA);
 	ac97c_writel(chip, CAMR, 0);
 	ac97c_writel(chip, COMR, 0);
diff -x .svn -Nru linux-3.0.x-orig/sound/pci/ac97/ac97_codec.c linux-3.0.x-arm/sound/pci/ac97/ac97_codec.c
--- linux-3.0.x-orig/sound/pci/ac97/ac97_codec.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/sound/pci/ac97/ac97_codec.c	2012-12-19 11:24:51.000000000 +0200
@@ -2099,9 +2099,14 @@
 		snd_ac97_free(ac97);
 		return -EIO;
 	}
+
 	pid = look_for_codec_id(snd_ac97_codec_ids, ac97->id);
-	if (pid)
+	if (pid) {
 		ac97->flags |= pid->flags;
+		snd_printk(KERN_INFO "AC'97 %d find audio chip %s (vendor id:0x%x).\n", ac97->num, pid->name, ac97->id);
+	} else {
+		snd_printk(KERN_INFO "AC'97 %d find audio chip unknown wendor with id [0x%x].\n", ac97->num, ac97->id);
+	}
 	
 	/* test for AC'97 */
 	if (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO) && !(ac97->scaps & AC97_SCAP_AUDIO)) {
diff -x .svn -Nru linux-3.0.x-orig/sound/soc/omap/am3517evm.c linux-3.0.x-arm/sound/soc/omap/am3517evm.c
--- linux-3.0.x-orig/sound/soc/omap/am3517evm.c	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/sound/soc/omap/am3517evm.c	2012-12-19 11:24:44.000000000 +0200
@@ -139,7 +139,15 @@
 	.cpu_dai_name ="omap-mcbsp-dai.0",
 	.codec_dai_name = "tlv320aic23-hifi",
 	.platform_name = "omap-pcm-audio",
-	.codec_name = "tlv320aic23-codec.2-001a",
+
+	/* tlv320aic23-codec.2-001a --> tlv320aic23-codec.1-001a
+	 * as I2C bus number changed from 2 to 1 for VAR-AM35
+	 */
+#if !(defined(CONFIG_MACH_VAR_SOM_AM35) || defined(CONFIG_MACH_OWEN_SPK2XX_VAR))
+ 	.codec_name = "tlv320aic23-codec.2-001a",
+#else
+	.codec_name = "tlv320aic23-codec.1-001a",
+#endif
 	.init = am3517evm_aic23_init,
 	.ops = &am3517evm_ops,
 };
@@ -157,8 +165,10 @@
 {
 	int ret;
 
+#if !(defined(CONFIG_MACH_VAR_SOM_AM35) || defined(CONFIG_MACH_OWEN_SPK2XX_VAR))
 	if (!machine_is_omap3517evm())
 		return -ENODEV;
+#endif
 	pr_info("OMAP3517 / AM3517 EVM SoC init\n");
 
 	am3517evm_snd_device = platform_device_alloc("soc-audio", -1);
diff -x .svn -Nru linux-3.0.x-orig/sound/soc/omap/Kconfig linux-3.0.x-arm/sound/soc/omap/Kconfig
--- linux-3.0.x-orig/sound/soc/omap/Kconfig	2011-07-22 05:17:23.000000000 +0300
+++ linux-3.0.x-arm/sound/soc/omap/Kconfig	2012-12-19 11:24:44.000000000 +0200
@@ -75,7 +75,7 @@
 
 config SND_OMAP_SOC_AM3517EVM
 	tristate "SoC Audio support for OMAP3517 / AM3517 EVM"
-	depends on SND_OMAP_SOC && MACH_OMAP3517EVM && I2C
+	depends on SND_OMAP_SOC && (MACH_OMAP3517EVM || MACH_VAR_SOM_AM35 || MACH_OWEN_SPK2XX_VAR) && I2C
 	select SND_OMAP_SOC_MCBSP
 	select SND_SOC_TLV320AIC23
 	help
