diff -Nru a/wc/Makefile b/wc/Makefile
--- a/wc/Makefile	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/Makefile	2013-01-09 15:44:16.000000000 +0200
@@ -1,36 +1,85 @@
-VERSION=1.6.2
+VERSION=1.10.11
 
-WC_DEFS=-DOWEN_HE5684
+#make PLC=<config>:
+#	OWEN_HE5684
+#	OWEN_MODUS5684
+#	OWEN_PLC304
+#	OWEN_PLC304MSAN
+#	OWEN_PLC323
+ifneq ($(PLC), )
+WC_DEFS=-D$(PLC)
+endif
+
+# enable retain memory synchronization 'chunk' option
+#WC_DEFS+=-DWC_RM_CHUNK_OPTION
+
+ifeq ($(PLC), OWEN_PLC304MSAN)
+VER_INC=1
+else
+VER_INC=0
+endif
 
 SRCDIR=.
+VPATH=$(SRCDIR)
+DEPDIR=./.deps
 
 ifndef X86
-CROSS_COMPILE=/home/alex/owen_link/rt/buildsys/cross/bin/arm-unknown-linux-gnueabi-
+CROSS_COMPILE=/home/alex/owen/buildsys3/crossat91/bin/arm-unknown-linux-gnueabi-
 else
 CROSS_COMPILE=
 endif
 
 CFLAGS=-Wall
+CFLAGS+=-O2
 CC=$(CROSS_COMPILE)gcc
+STRIP=$(CROSS_COMPILE)strip
 AR=$(CROSS_COMPILE)ar
 RANLIB=$(CROSS_COMPILE)ranlib
 LDFLAGS=-L./ -lcgic -lcrypt
+INCLUDES=-I.
+CFLAGS+=$(INCLUDES)
+
+ifeq ($(DEBUG),1)
+WC_DEFS+=-DWC_DEBUG
+endif
 
 SRC_setup=wc_tpl.c \
     wc_main.c \
     wc_page_dt.c \
     wc_page_net.c \
+    wc_net_ppp.c \
+    wc_net_ddns.c \
     wc_page_sec.c \
     wc_page_plc.c \
-    wc_config.c
-    
+    wc_page_utils.c \
+    wc_utils_ping.c \
+    wc_strings.c \
+    wc_conf_file.c
+
+# make TEST=1 - enable test page
+ifeq ($(TEST), 1)
+SRC_setup+=wc_page_test.c
+WC_DEFS+=-DWC_PAGE_TEST
+endif
+
 OBJ_setup=$(SRC_setup:.c=.o)
 
 SETUP=setup.cgi
 TESTS=wc_test_config
 
-all: libcgic.a $(SETUP)
-        
+# App
+$(SETUP): version.h $(OBJ_setup) libcgic.a
+	$(CC) $(OBJ_setup) $(LDFLAGS) -o $@
+
+version.h: Makefile
+	$(SRCDIR)/version.sh $(VERSION) $(VER_INC)
+
+-include $(OBJ_setup:%.o=$(DEPDIR)/%.d)
+
+strip: $(SETUP)
+	$(STRIP) $^
+
+# CGI lib
 libcgic.a: cgic.o cgic.h
 	rm -f libcgic.a
 	$(AR) rc libcgic.a cgic.o
@@ -39,24 +88,24 @@
 cgic.o: cgic.c cgic.h
 	$(CC) -c $(CFLAGS) -o $@ $<
 
-$(SETUP): version.h $(OBJ_setup) libcgic.a
-	$(CC) $(OBJ_setup) $(LDFLAGS) -o $@
-
-version.h: $(SRC_setup)
-	$(SRCDIR)/version.sh $(VERSION)
-
+# Tests
 tests: $(TESTS)
 
-wc_test_config: wc_test_config.o wc_config.o
+wc_test_config: wc_test_config.o wc_conf_file.o
 	$(CC) $^ -o $@
 
-.SUFFIXES: .c .o
+-include $(DEPDIR)/wc_test_config.d
 
-.c.o:
+%.o: %.c
+	@mkdir -p $(DEPDIR)
+	@$(CC) -MM $(CFLAGS) $(WC_DEFS) $(SRCDIR)/$*.c > $(DEPDIR)/$*.d
 	$(CC) -c $(CFLAGS) $(WC_DEFS) -o $@ $<
 
 clean:
-	rm -f *.o *.a $(SETUP) $(TESTS)
+	rm -f *.o *.a 
+	rm -f $(SETUP) $(TESTS)
+	rm -rf $(DEPDIR)
 
 cleanall:
-	rm -f *.o *.a $(SETUP) $(TESTS) version.h
+	$(MAKE) clean
+	rm -f version.h wc_version.inc
diff -Nru a/wc/version.sh b/wc/version.sh
--- a/wc/version.sh	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/version.sh	2012-05-10 19:01:53.000000000 +0300
@@ -4,7 +4,13 @@
 #ifndef _VERSION_H_
 #define _VERSION_H_
 
-#define APP_VERSION "$1 (`date '+%Y-%m-%d %H:%M:%S'`)"
+#define APP_VERSION "$1"
 
 #endif
 END
+
+if [ "$2" == "1" ]; then
+cat > $PWD/wc_version.inc << END
+APP_VERSION="$1"
+END
+fi
diff -Nru a/wc/wc_conf_file.c b/wc/wc_conf_file.c
--- a/wc/wc_conf_file.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_conf_file.c	2012-07-07 17:15:58.000000000 +0300
@@ -0,0 +1,398 @@
+#include <unistd.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include "wc_conf_file.h"
+
+#define LINE_BUF_SIZE 512
+
+/* --- Local methods --- */
+
+static void remove_spaces_after(char *start, char **end);
+static void remove_spaces_before(char **start, char *end);
+//static void remove_quotes(char **start, char **end);
+static void parse_conf_file(FILE *fp, FILE *fp_out, 
+						wc_conf_line_process_t process_conf_line, void *data, int raw);
+static int process_conf_var_line(wc_conf_parse_data_t *parse_data, void *data);
+
+/* --- Local methods implementation --- */
+
+static void remove_spaces_after(char *start, char **end)
+{
+	char *q = *end;
+//printf("%s: start='%c', last='%c', len=%d\n", 
+//	__func__, *start, *(*end - 1), *end - start);
+	while (q > start) {
+		if (*(q - 1) != ' ' && *(q - 1) != '\t') {
+			break;
+		}
+		q--;
+	}
+	*end = q;
+//printf("%s: start='%c', last='%c', len=%d\n", 
+//	__func__, *start, *(*end - 1), *end - start);
+}
+
+static void remove_spaces_before(char **start, char *end)
+{
+	char *p = *start;
+
+//printf("%s: start='%c', last='%c', len=%d\n", 
+//	__func__, **start, *(end - 1), end - *start);
+	while (end > p) {
+		if (*p != ' ' && *p != '\t') {
+			break;
+		}
+		p++;
+	}
+	*start = p;
+//printf("%s: start='%c', last='%c', len=%d\n", 
+//	__func__, **start, *(end - 1), end - *start);
+}
+
+/* note: first quote is removed anyway, even if there is no closing quote 
+* if first char is not quote then any quotes are allowed in value, but first space or # marks the end of the value
+* if first char single quote then value can contain # and double quotes and spaces
+* if first char is double quote then value can contain # and single quotes and spaces
+*/
+static void remove_quotes_and_inline_comment(char **start, char **end)
+{
+	char *p = *start;
+	char *q = *end;
+	char delim;
+	char *s;
+
+	if (q - p < 2) {
+		return;
+	}
+
+	if (*p == '#') {	/* no val - immediate comment */
+		*end = p;
+		return;
+	}
+
+	delim = ' ';
+	if (*p == '\'' || *p == '"') {
+		delim = *p;
+		p++;
+	}
+	s = p;
+	
+	while ((p < q) && (*p != delim)) {
+		if (delim == ' ' && (*p == '\t' || *p == '#')) {
+			break;
+		}
+		p++;
+	}
+
+	*start = s;
+	*end = p;
+}
+
+#if 0
+static void remove_quotes(char **start, char **end)
+{
+	char *p = *start;
+	char *q = *end;
+
+	if (q - p < 2) {
+		return;
+	}
+//printf("%s: start='%c', last='%c', len=%d\n", 
+//	__func__, **start, *(*end - 1), *end - *start);
+	
+	if ((*p == '\'' && *(q - 1) == '\'') ||
+		(*p == '"' && *(q - 1) == '"')) {
+//printf("%s: quotes detected\n", __func__);
+		*start = p + 1;
+		*end = q - 1;
+	}
+}
+#endif
+
+/* fp_out can be NULL, it is not used by the function itself, 
+* but just passed to the callback via parse_data 
+* toletate to spaces(tabs) before and after VAR, =, and VAL
+* parse_data.line - points to not changed line as it was read from the file
+*/
+static void parse_conf_file(FILE *fp, FILE *fp_out, 
+						wc_conf_line_process_t process_conf_line, void *data, int raw)
+{
+	char buf[LINE_BUF_SIZE];
+	char *p, *c, *end;
+	wc_conf_parse_data_t parse_data;
+	int eof_need = 1;
+	int len;
+
+	memset(&parse_data, 0, sizeof(parse_data));
+	parse_data.fp_out = fp_out;
+	
+	while (fgets(buf, sizeof(buf), fp)) {
+		parse_data.line = buf;
+		parse_data.line_index++;
+		len = strlen(buf);
+
+		parse_data.var = NULL;
+		parse_data.var_len= 0;
+		
+		do {
+			p = buf;
+			end = p + len;
+			remove_spaces_before(&p, end);
+			
+			/* set val, val_len pointed to the first non-space/TAB char
+			* for _EMPTY - points to the end,
+			* for _COMMENT - points to the start of the comment
+			* for _WRONG - points to the non-var-val-text */
+			parse_data.val = p;
+			parse_data.val_len = end - p;
+
+			if (!*p || *p == '\n') {
+				/* empty line */
+				parse_data.type = WC_CLT_EMPTY;
+				break;
+			}
+			
+			if (*p == '#') {
+				/* comment (if too long just truncated) */
+				parse_data.type = WC_CLT_COMMENT;
+				break;
+			}
+			
+			/* return raw (WRONG) line as requested */
+			if (raw) {
+				parse_data.type = WC_CLT_WRONG;
+				break;
+			}
+
+			/* check wether line is VAR=VAL */
+			c = strchr(buf, '=');
+			if (!c) {
+				/* wrong config line */
+				parse_data.type = WC_CLT_WRONG;
+				break;
+			}
+
+			/* extract var */
+			end = c;
+			remove_spaces_after(p, &end);
+			parse_data.var = p;
+			parse_data.var_len = end - p;
+
+			/* check whether parsing is OK or not: if VAR extracted parsing is successfull,
+			* otherwise - return WRONG
+			*/
+			if (parse_data.var_len > 0) {
+				parse_data.type = WC_CLT_VAR;
+			} else {
+				parse_data.type = WC_CLT_WRONG;
+				break; /* do not parse further */
+			}
+
+			/* extract val */
+			p = c + 1;
+			end = p + strlen(p);
+			if (*(end - 1) == '\n') {		/* cut off ending NL if present */
+				end--;
+			}
+			remove_spaces_before(&p, end);
+			remove_spaces_after(p, &end);
+			remove_quotes_and_inline_comment(&p, &end);
+			//remove_quotes(&p, &end);
+			parse_data.val = p;
+			parse_data.val_len = end - p;
+		}while (0);
+
+		if (!process_conf_line(&parse_data, data)) {
+			/* stop processing more lines */
+			eof_need = 0;
+			break;
+		}
+	}
+	if (eof_need) {
+		/* other fields left from the previous call unchanged if only callback didn't change them
+		* when file is empty and EOF occured right at the first reading attempt, all fields are 0 including line_index
+		*/
+		parse_data.type = WC_CLT_EOF;
+		process_conf_line(&parse_data, data);
+	}
+}
+
+typedef struct process_conf_var_line_data {
+	wc_conf_var_process_t process_conf_var;	/* user-specified processor callback */
+	void *data;								/* user-specified data for the callback */
+} process_conf_var_line_data;
+
+static int process_conf_var_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	int r = 1;
+	process_conf_var_line_data *d = (process_conf_var_line_data*)data;
+	
+	if (parse_data->type == WC_CLT_VAR) {
+		parse_data->var[parse_data->var_len] = 0;
+		parse_data->val[parse_data->val_len] = 0;
+		r = d->process_conf_var(parse_data->var, parse_data->val, d->data);
+	}
+
+	return r;
+}
+
+static int conf_file_edit(const char *fname, wc_conf_line_process_t process_conf_line, 
+						void *data, int create, int raw, const char *target)
+{
+	FILE *fp;
+	FILE *fp_edited;
+	const char *fname_edited;
+	char fname_tmp[32];
+
+	/* try open target file for reading */
+	fp = fopen(fname, "r");
+	if (!fp) {
+		if (errno == ENOENT && create && !target) {
+			wc_conf_parse_data_t parse_data;
+			
+			/* try creating new target right on its place  */
+			fp = fopen(fname, "w");
+			if (!fp) {
+				/* failed */
+				return -errno;
+			}
+
+			/* note: all the rest fields are 0, including line_index */
+			memset(&parse_data, 0, sizeof(parse_data));
+			
+			parse_data.type = WC_CLT_CREATED;
+			parse_data.fp_out = fp;
+			process_conf_line(&parse_data, data);
+
+			fclose(fp);
+			sync();
+			return 0;
+		}
+		return -errno;
+	}
+
+	/* if source exists, 
+	* 	if target specified, edit source to the target
+	*     else edit source to a temp file, then move temp to the same name as source
+	*/
+
+	if (target) {
+		fname_edited = target;
+	} else {
+		sprintf(fname_tmp, "/tmp/wc_%d_conf.tmp", (int)getpid());
+		fname_edited = fname_tmp;
+	}
+
+	fp_edited = fopen(fname_edited, "w");
+	if (!fp_edited) {
+		fclose(fp);
+		return -errno;
+	}
+
+	parse_conf_file(fp, fp_edited, process_conf_line, data, raw);
+	fclose(fp_edited);
+	fclose(fp);
+
+	if (!target) {
+		/* move temp file in place of source */
+		return wc_file_move(fname_edited, fname);
+	}
+
+	/* else leave edited in target file */
+	sync();
+	return 0;
+}
+
+
+/* --- Interface methods --- */
+
+int wc_conf_file_read(const char *fname, wc_conf_var_process_t process_conf_var, 
+						void *data)
+{
+	FILE *fp;
+	process_conf_var_line_data d;
+	
+	fp = fopen(fname, "r");
+	if (!fp) {
+		return -errno;
+	}
+	
+	d.process_conf_var = process_conf_var;
+	d.data = data;
+	parse_conf_file(fp, NULL, &process_conf_var_line, (void*)&d, 0);
+	
+	fclose(fp);
+	return 0;
+}
+
+int wc_conf_file_edit(const char *fname, wc_conf_line_process_t process_conf_line, 
+						void *data, int create)
+{
+	return conf_file_edit(fname, process_conf_line, data, create, 0, NULL);
+}
+
+int wc_conf_file_read_raw(const char *fname,
+							wc_conf_line_process_t process_conf_line, void *data)
+{
+	FILE *fp;
+	
+	fp = fopen(fname, "r");
+	if (!fp) {
+		return -errno;
+	}
+	
+	parse_conf_file(fp, NULL, process_conf_line, data, 1);
+	
+	fclose(fp);
+	return 0;
+}
+
+int wc_conf_file_edit_raw(const char *fname,
+						wc_conf_line_process_t process_conf_line,
+						void *data, int create)
+{
+	return conf_file_edit(fname, process_conf_line, data, create, 1, NULL);
+}
+
+int wc_conf_file_from_tpl(const char *tpl, wc_conf_line_process_t process_conf_line,
+								void *data, const char *conf)
+{
+	/* If conf is NULL - error */
+	if (!conf) {
+		return -1;
+	}
+	return conf_file_edit(tpl, process_conf_line, data, 0, 1, conf);
+}
+
+
+int wc_file_move(const char *oldpath, const char *newpath)
+{
+	FILE *fp_old, *fp_new;
+	char buf[1024];
+	size_t size;
+
+	fp_old = fopen(oldpath, "r");
+	if (!fp_old) {
+		return -errno;
+	}
+	fp_new = fopen(newpath, "w");
+	if (!fp_new) {
+		fclose(fp_old);
+		return -errno;
+	}
+
+	while ((size = fread(buf, 1, sizeof(buf), fp_old)) > 0) {
+		fwrite(buf, size, 1, fp_new);
+	}
+	fclose(fp_new);
+	fclose(fp_old);
+	sync();
+
+	//TODO: check result?
+	unlink(oldpath);
+	return 0;
+}
+
diff -Nru a/wc/wc_conf_file.h b/wc/wc_conf_file.h
--- a/wc/wc_conf_file.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_conf_file.h	2012-07-07 17:15:58.000000000 +0300
@@ -0,0 +1,90 @@
+#ifndef _WC_CONF_FILE_H_
+#define _WC_CONF_FILE_H_
+
+#include <stdio.h>
+
+/* config line types */
+#define WC_CLT_EMPTY		0
+#define WC_CLT_COMMENT	1
+#define WC_CLT_WRONG		2
+#define WC_CLT_VAR			3
+/* WC_CLT_EOF - End of file: 
+ * used when editing - so user can add new vars if they were not found in the file.
+ * This type is not used when user-call back answered 0 - stop processing
+ */
+#define WC_CLT_EOF			4
+/* WC_CLT_CREATED - Special case: no actual parsing was done, handler function called for 
+ * just created new config file. The behaviour of the handler should be 
+ * similar to WC_CLT_EOF, i.e. all not existing vars can be set
+ */
+#define WC_CLT_CREATED		5
+typedef struct {
+	int type;
+	char *line;
+	int line_index; /* 1-based index of each line */
+	char *var;
+	int var_len;
+	char *val;
+	int val_len;
+	FILE *fp_out;		/* used for editing */
+} wc_conf_parse_data_t;
+
+/* attempt to allow run-time configuration of some web-configurator's parameters,
+ * e.g max allowed count of GPRS/VPN profiles. It was decided to  make it compile-time 
+ * configurable with pre-allocated static memory for max possible count of profiles 
+ */
+#define USE_WC_CONF 0
+#if USE_WC_CONF
+/* global WC configuration */
+typedef struct {
+	int gprs_profiles_max;
+	int vpn_profiles_max;
+} wc_conf_t;
+#endif
+
+/* data - user-specific data */
+typedef int (*wc_conf_line_process_t)(wc_conf_parse_data_t *parse_data, void *data);
+typedef int (*wc_conf_var_process_t)(char *var, char *val, void *data);
+
+/* Config files format, parsing rules:
+* - starting spaces and tabs - ignored
+* - # (WC_CLT_COMMENT) or \n (WC_CLT_EMPTY) - empty line - ignored.
+* - VAR line (WC_CLT_VAR) is: var=val#comment
+*     - comment can be right after the val
+*     - spaces can be between var, =, and val
+*     - val can be quoted single or double quote - quotes should be of the same kind at each sides
+*     - parse data contains all fields (except fp_out, which is set independently for EDIT)
+* - non VAR line (WC_CLT_WRONG) - line which has different format from the VAR line
+*     - parse data contains line field and val, val_len pointing to the line's first non-space char
+*/
+
+extern int wc_conf_file_read(const char *fname, wc_conf_var_process_t process_conf_var, 
+							void *data);
+extern int wc_conf_file_edit(const char *fname, wc_conf_line_process_t process_conf_line, 
+							void *data, int create);
+
+/* xxx_raw functions are similar to non-raw: 
+* the differces are:
+* - they do not try to extract VAR=VAL, just return WC_CLT_WRONG with 
+*    line, val and val_len set 
+* read-function requires wc_conf_line_process_t callback
+*/
+extern int wc_conf_file_read_raw(const char *fname,
+								wc_conf_line_process_t process_conf_line, void *data);
+extern int wc_conf_file_edit_raw(const char *fname,
+								wc_conf_line_process_t process_conf_line,
+								void *data, int create);
+
+/* the same as wc_conf_file_edit_raw() but:
+* - tpl_fname never created
+* - conf - used instead of tmp file and move() doesn't performed
+*
+* If conf is NULL - error
+*/
+extern int wc_conf_file_from_tpl(const char *tpl, wc_conf_line_process_t process_conf_line,
+								void *data, const char *conf);
+
+extern int wc_file_move(const char *oldpath, const char *newpath);
+
+#endif /* _WC_CONF_FILE_H_ */
+
diff -Nru a/wc/wc_config.c b/wc/wc_config.c
--- a/wc/wc_config.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_config.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,228 +0,0 @@
-#include <sys/types.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "wc_config.h"
-
-#define LINE_BUF_SIZE 512
-
-/* --- Local methods --- */
-
-static void remove_spaces_after(char *start, char **end);
-static void remove_spaces_before(char **start, char *end);
-static void remove_quotes(char **start, char **end);
-static void parse_conf_file(FILE *fp, wc_conf_line_process_t process_conf_line, void *data);
-static int process_conf_var_line(wc_conf_parse_data_t *parse_data, void *data);
-static int wc_move_file(const char *oldpath, const char *newpath);
-
-/* --- Local methods implementation --- */
-
-static void remove_spaces_after(char *start, char **end)
-{
-	char *q = *end;
-//printf("%s: start='%c', last='%c', len=%d\n", 
-//	__func__, *start, *(*end - 1), *end - start);
-	while (q > start) {
-		if (*(q - 1) != ' ' && *(q - 1) != '\t') {
-			break;
-		}
-		q--;
-	}
-	*end = q;
-//printf("%s: start='%c', last='%c', len=%d\n", 
-//	__func__, *start, *(*end - 1), *end - start);
-}
-
-static void remove_spaces_before(char **start, char *end)
-{
-	char *p = *start;
-
-//printf("%s: start='%c', last='%c', len=%d\n", 
-//	__func__, **start, *(end - 1), end - *start);
-	while (end > p) {
-		if (*p != ' ' && *p != '\t') {
-			break;
-		}
-		p++;
-	}
-	*start = p;
-//printf("%s: start='%c', last='%c', len=%d\n", 
-//	__func__, **start, *(end - 1), end - *start);
-}
-
-static void remove_quotes(char **start, char **end)
-{
-	char *p = *start;
-	char *q = *end;
-
-	if (q - p < 2) {
-		return;
-	}
-//printf("%s: start='%c', last='%c', len=%d\n", 
-//	__func__, **start, *(*end - 1), *end - *start);
-	
-	if ((*p == '\'' && *(q - 1) == '\'') ||
-		(*p == '"' && *(q - 1) == '"')) {
-//printf("%s: quotes detected\n", __func__);
-		*start = p + 1;
-		*end = q - 1;
-	}
-}
-
-static void parse_conf_file(FILE *fp, wc_conf_line_process_t process_conf_line, void *data)
-{
-	char buf[LINE_BUF_SIZE];
-	char *p, *end;
-	wc_conf_parse_data_t parse_data;
-	int eof_need = 1;
-	int len;
-	
-	while (fgets(buf, sizeof(buf), fp)) {
-		parse_data.line = buf;
-		len = strlen(buf);
-		
-		do {
-			if (buf[0] == '\n') {
-				/* empty line */
-				parse_data.type = WC_CLT_EMPTY;
-				break;
-			}
-			
-			if (buf[0] == '#' || buf[0] == ' ') {
-				/* commented line */
-				parse_data.type = WC_CLT_COMMENT;
-				if ((len == sizeof(buf) - 1) && buf[len - 1] != '\n') {
-					p = &buf[len - 3];
-					*p++ = '.';
-					*p++ = '.';
-					*p = '\n';
-				}
-				break;
-			}
-
-			/* check wether line is VAR=VAL */
-			p = strchr(buf, '=');
-			if (!p) {
-				/* wrong config line */
-				parse_data.type = WC_CLT_WRONG;
-				break;
-			}
-
-			/* extract var */
-			end = p;
-			remove_spaces_after(buf, &end);
-			parse_data.var = buf;
-			parse_data.var_len = end - buf;
-
-			/* extract val */
-			p++;
-			end = p + strlen(p);
-			remove_spaces_before(&p, end);
-			if (*(end - 1) == '\n') {
-				end--;
-			}
-			remove_spaces_after(p, &end);
-			remove_quotes(&p, &end);
-			parse_data.val = p;
-			parse_data.val_len = end - p;
-			if (parse_data.var_len > 0 && parse_data.val_len >= 0) {
-				parse_data.type = WC_CLT_VAR;
-			} else {
-				parse_data.type = WC_CLT_WRONG;
-			}
-		}while (0);
-
-		if (!process_conf_line(&parse_data, data)) {
-			/* stop processing more lines */
-			eof_need = 0;
-			break;
-		}
-	}
-	if (eof_need) {
-		parse_data.type = WC_CLT_EOF;
-		process_conf_line(&parse_data, data);
-	}
-}
-
-static int process_conf_var_line(wc_conf_parse_data_t *parse_data, void *data)
-{
-	int r = 1;
-	wc_conf_var_process_t process_conf_var = (wc_conf_var_process_t)data;
-	if (parse_data->type == WC_CLT_VAR) {
-		parse_data->var[parse_data->var_len] = 0;
-		parse_data->val[parse_data->val_len] = 0;
-		r = process_conf_var(parse_data->var, parse_data->val);
-	}
-	return r;
-}
-
-static int wc_move_file(const char *oldpath, const char *newpath)
-{
-	FILE *fp_old, *fp_new;
-	char buf[1024];
-	size_t size;
-
-	fp_old = fopen(oldpath, "r");
-	if (!fp_old) {
-		return -1;
-	}
-	fp_new = fopen(newpath, "w");
-	if (!fp_new) {
-		fclose(fp_old);
-		return -1;
-	}
-
-	while ((size = fread(buf, 1, sizeof(buf), fp_old)) > 0) {
-		fwrite(buf, size, 1, fp_new);
-	}
-	fclose(fp_new);
-	fclose(fp_old);
-
-	//TODO: check result?
-	unlink(oldpath);
-	return 0;
-}
-
-/* --- Interface methods --- */
-
-int wc_conf_read_file(const char *fname, wc_conf_var_process_t process_conf_var)
-{
-	FILE *fp;
-	
-	fp = fopen(fname, "r");
-	if (!fp) {
-		return -1;
-	}
-	parse_conf_file(fp, &process_conf_var_line, (void*)process_conf_var);
-	
-	fclose(fp);
-	return 0;
-}
-
-int wc_conf_edit_file(const char *fname, wc_conf_line_process_t process_conf_line)
-{
-	FILE *fp, *fp_tmp;
-	char fname_tmp[32];
-
-	sprintf(fname_tmp, "/tmp/wc_%d_conf.tmp", (int)getpid());
-	
-	fp = fopen(fname, "r");
-	if (!fp) {
-		return -1;
-	}
-
-	fp_tmp = fopen(fname_tmp, "w");
-	if (!fp_tmp) {
-		fclose(fp);
-		return -1;
-	}
-
-	parse_conf_file(fp, process_conf_line, (void*)fp_tmp);
-	fclose(fp_tmp);
-	fclose(fp);
-
-	/* move temp file in place of file */
-	return wc_move_file(fname_tmp, fname);
-}
-
diff -Nru a/wc/wc_config.h b/wc/wc_config.h
--- a/wc/wc_config.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_config.h	2013-01-09 15:44:16.000000000 +0200
@@ -1,32 +1,83 @@
 #ifndef _WC_CONFIG_H_
 #define _WC_CONFIG_H_
 
-#include <stdio.h>
+/* --- common --- */
+#define WC_CONFIG_MODEM_SPEED	115200
 
-/* config line types */
-#define WC_CLT_EMPTY		0
-#define WC_CLT_COMMENT	1
-#define WC_CLT_WRONG		2
-#define WC_CLT_VAR			3
-/* Special case - end of file: 
- * used when editing - so user can add new vars if they were not found in the file.
- * This type ios not used when user-call back answered 0 - stop processing
- */
-#define WC_CLT_EOF			4
-typedef struct {
-	int type;
-	char *line;
-	char *var;
-	int var_len;
-	char *val;
-	int val_len;
-} wc_conf_parse_data_t;
-
-typedef int (*wc_conf_line_process_t)(wc_conf_parse_data_t *parse_data, void *data);
-typedef int (*wc_conf_var_process_t)(char *var, char *val);
-
-extern int wc_conf_read_file(const char *fname, wc_conf_var_process_t process_conf_var);
-extern int wc_conf_edit_file(const char *fname, wc_conf_line_process_t process_conf_line);
+/* --- HE5684 ---*/
+#if defined(OWEN_HE5684)
+#include "wc_strings_en.h"
+#define WC_CONFIG_PLC_NAME WC_STR_PLC_NAME_HE5684
+#define WC_CONFIG_RC_SYNC
+#define WC_CONFIG_MODEM_PORT "/dev/ttyS1"
+#define WC_CONFIG_MENU_PLC
+#define WC_CONFIG_MENU_UTILS_PING
+
+/* --- Modus5684 (ru,1251) ---*/
+#elif defined(OWEN_MODUS5684)
+#include "wc_strings_ru.h"
+#define WC_CONFIG_PLC_NAME WC_STR_PLC_NAME_MODUS5684
+#define WC_CONFIG_RC_SYNC
+#define WC_CONFIG_MODEM_PORT "/dev/ttyS1"
+#define WC_CONFIG_MENU_PLC
+#define WC_CONFIG_MENU_NET_GPRS
+#define WC_CONFIG_MENU_NET_VPN
+#define WC_CONFIG_MENU_NET_DDNS
+#define WC_CONFIG_MENU_UTILS_PING
+
+/* --- PLC304 (ru,1251) ---*/
+#elif defined(OWEN_PLC304) || defined(OWEN_PLC304MSAN)
+#include "wc_strings_ru.h"
+#define WC_CONFIG_PLC_NAME WC_STR_PLC_NAME_PLC304
+#define WC_CONFIG_MODEM_PORT "/dev/ttyS2"
+#define WC_CONFIG_MODEM_HW_FLOW
+#define WC_CONFIG_MENU_PLC
+#define WC_CONFIG_MENU_NET_GPRS
+#define WC_CONFIG_MENU_NET_VPN
+#define WC_CONFIG_MENU_NET_DDNS
+#define WC_CONFIG_MENU_UTILS_PING
+
+/* PLC323xxx */
+#elif defined(OWEN_PLC323)
+#include "wc_strings_ru.h"
+#define WC_CONFIG_PLC_NAME WC_STR_PLC_NAME_PLC323
+#define WC_CONFIG_RC_SYNC
+#define WC_CONFIG_MODEM_PORT "/dev/ttyS2"
+#define WC_CONFIG_MODEM_HW_FLOW
+#define WC_CONFIG_MENU_PLC
+#define WC_CONFIG_MENU_NET_GPRS
+#define WC_CONFIG_NO_AUTO_GPRS
+#define WC_CONFIG_MENU_NET_VPN
+#define WC_CONFIG_MENU_NET_DDNS
+#define WC_CONFIG_MENU_UTILS_PING
+
+/* --- default ---*/
+#else
+#include "wc_strings_en.h"
+#define WC_CONFIG_PLC_NAME "OWEN PLC"
+#define WC_CONFIG_RC_SYNC
+#define WC_CONFIG_MODEM_PORT "/dev/ttyS1"
+//#define WC_CONFIG_MENU_PLC
+//#define WC_CONFIG_MENU_NET_GPRS
+//#define WC_CONFIG_MENU_NET_VPN
+//#define WC_CONFIG_MENU_NET_DDNS
+#define WC_CONFIG_MENU_UTILS_PING
+#endif
+
+/* common calculated definitions */
+
+#if defined(WC_CONFIG_MENU_NET_GPRS) || \
+	defined(WC_CONFIG_MENU_NET_VPN) || \
+	defined(WC_CONFIG_MENU_NET_DDNS)
+#define WC_CONFIG_MENU_NET_SUBMENU
+#endif
+#if defined(WC_CONFIG_MENU_NET_GPRS) || defined(WC_CONFIG_MENU_NET_VPN)
+#define WC_CONFIG_MENU_NET_PPP
+#endif
+
+#if defined(WC_CONFIG_MENU_UTILS_PING)
+#define WC_CONFIG_MENU_UTILS
+#endif
 
 #endif /* _WC_CONFIG_H_ */
 
diff -Nru a/wc/wc_debug.h b/wc/wc_debug.h
--- a/wc/wc_debug.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_debug.h	2012-06-28 16:16:43.000000000 +0300
@@ -0,0 +1,15 @@
+#ifndef _WC_DEBUG_H_
+#define _WC_DEBUG_H_
+
+#ifdef WC_DEBUG
+#define dbg_console(format, ...) \
+	{ \
+		char buf[1024]; \
+		sprintf(buf, "echo -n \"" format "\" > /dev/console", ##__VA_ARGS__); \
+		system(buf); \
+	}
+#else
+#define dbg_console(format, ...)
+#endif
+
+#endif /* _WC_DEBUG_H_ */
\ No newline at end of file
diff -Nru a/wc/wc_main.c b/wc/wc_main.c
--- a/wc/wc_main.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_main.c	2012-09-06 19:05:11.000000000 +0300
@@ -8,29 +8,71 @@
 #include "wc_tpl.h"
 
 #include "wc_page.h"
+#ifdef WC_PAGE_TEST
+#include "wc_page_test.h"
+#endif
 #include "wc_page_dt.h"
 #include "wc_page_net.h"
 #include "wc_page_sec.h"
+#ifdef WC_CONFIG_MENU_PLC
 #include "wc_page_plc.h"
+#endif
+#ifdef WC_CONFIG_MENU_UTILS
+#include "wc_page_utils.h"
+#endif
 
-#include "wc_plc_defs.h"
+#include "wc_strings.h"
 
 #include "version.h"
 
-/* is not needed because it can be done with wider variable template:
- * {ifp=<name>:<.tpl>|<text>} ==> {?page=<name>:<.tpl>|<text>|<=var>}
+wc_form_button_t wc_btn_ok = {
+	.title = WC_STR_OK,
+	.name = WC_NAME_FORM_SUBMIT,
+	.type = WC_FBT_SUBMIT,
+};
+wc_form_button_t wc_btn_reset = {
+	.title = WC_STR_RESET,
+	.name = "breset",
+	.type = WC_FBT_RESET,
+};
+wc_form_button_t wc_btn_cancel = {
+	.title = WC_STR_CANCEL,
+	.name = "bcancel",
+	.type = WC_FBT_BUTTON,
+};
+wc_form_button_t wc_btn_back = {
+	.title = WC_STR_BACK,
+	.name = "bback",
+	.type = WC_FBT_BUTTON,
+};
+wc_form_button_t wc_btn_close = {
+	.title = WC_STR_CLOSE,
+	.name = "bclose",
+	.type = WC_FBT_BUTTON,
+};
+
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+/* WC configuration file and defaults 
+ * (the config is expected in the same directory 
+ * where web configurator executable is placed)
  */
-//#define WC_COMMAND_IFP
+#define WC_CONFIG_FILE			"./wc.conf"
+#define CFG_VAR_GPRS_MAX		"GPRS_MAX"
+#define CFG_VAR_VPN_MAX		"VPN_MAX"
+
+#define CFG_VAL_GPRS_MAX		10
+#define CFG_VAL_VPN_MAX		5
+#endif
 
 /* --- Main template--- */
 
 #define APP_MAIN_TEMPLATE		"main.tpl"
+#define APP_POPUP_TEMPLATE	"popup.tpl"
 
-/* Pages: selected by APP_VAR_PAGE value, or APP_PAGE_DEFAULT is seelcted */
-
-#define APP_VAR_PAGE			"p"
-#define APP_PAGE_DEFAULT		"dt"
-static void process_home(wc_page_data_t *data);
+#define HVAR_PAGE			"p"
+#define HVAR_SUBPAGE		"sp"
+//static void process_home(wc_page_data_t *data, int submitted);
 
 /* page data passed to page processor func */
 static wc_page_data_t page_data = {
@@ -38,114 +80,219 @@
 	.status_buf = { '&', 'n', 'b', 's', 'p', ';', 0, },
 };
 
-typedef struct {
-	const char *name;
-	wc_page_process_t process;			/* pre-rendering page processing */
-	wc_page_post_process_t post_process;	/* post-rendering page tasks */
-} page_t;
-
-static page_t pages[] = {
-	{ .name = "home", .process = &process_home, .post_process = NULL, }, /* local */
-
-	{ .name = "dt", .process = &process_dt, .post_process = NULL, },
-	{ .name = "net", .process = &process_net, .post_process = &post_process_net, },
-	{ .name = "sec", .process = &process_sec, .post_process = NULL, },
-	{ .name = "plc", .process = &process_plc, .post_process = NULL, },
+static void main_menu_register(wc_menu_t *menu);
+static wc_menu_t pages[] = {
+//	{ .name = WC_NAME_PAGE_HOME, .title = , .process = &process_home, .post_process = NULL, }, /* local */
+	{ .name = WC_NAME_PAGE_DT,		.title = WC_STR_M_DT,
+		.process = &process_dt,	.post_process = NULL, },
+	{ .name = WC_NAME_PAGE_NET,		.title = WC_STR_M_NET,
+		.process = &process_net,	.post_process = &post_process_net, },
+	{ .name = WC_NAME_PAGE_SEC,	.title = WC_STR_M_SEC,
+		.process = &process_sec,	.post_process = NULL, },
+#ifdef WC_CONFIG_MENU_PLC
+	{ .name = WC_NAME_PAGE_PLC,		.title = WC_STR_M_PLC,
+		.process = &process_plc,	.post_process = NULL, },
+#endif
+#ifdef WC_CONFIG_MENU_UTILS
+	{ .name = WC_NAME_PAGE_UTILS,	.title = WC_STR_M_UTILS,
+		.process = &process_utils,	.post_process = &post_process_utils, },
+#endif
+#ifdef WC_PAGE_TEST
+	{ .name = WC_NAME_PAGE_TEST,	.title = WC_STR_M_TEST,
+		.process = &process_test,	.post_process = NULL, },		/* test page */
+#endif
+	{ .name = NULL, },
 };
-const int pages_count = sizeof(pages) / sizeof(pages[0]);
 
 /* --- Templates decriptioins with handlers declarations --- */
 
-#ifdef WC_COMMAND_IFP
-/* Command:
- *    {ifp=<name>:<.tpl>|<text>} - if page is "name": .tpl - include template or =text - print the text
- */
-#define TPL_COMMAND_IFP	"ifp"
-#define TPL_COMMAND_IFNP	"ifnp"
-static void do_if_page(char *arg);
-static void do_if_not_page(char *arg);
-/* separates command args each from other */
-#define IFP_CHAR_ARG_SEP	':'
-#define IFP_CHAR_INCLUDE	'.'
-#endif /*WC_COMMAND_IFP*/
-
-/* Commands */
-static wc_tpl_cmd_t tpl_commands[] = {
-#ifdef WC_COMMAND_IFP
-	{ .name = TPL_COMMAND_IFP, .handler = &do_if_page },
-	{ .name = TPL_COMMAND_IFNP, .handler = &do_if_not_page },
-#endif /*WC_COMMAND_IFP*/
-};
-const int tpl_commands_count = sizeof(tpl_commands) / sizeof(tpl_commands[0]);
-
 /* Vars */
+
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+#ifdef WC_DEBUG
+static const char *get_var_cfg(char *field);
+#endif
+#endif
+
+static const char *get_var_wcf(char *field);
+static const char *get_var_pgf(char *field);
 static const char *get_var_script(char *field);
-static const char *get_var_curpage(char *field);
+static const char *get_var_pg(char *field);
+static const char *get_var_pg_i(char *field);
+static const char *get_var_sp(char *field);
+static const char *get_var_sp_i(char *field);
 static const char *get_var_status(char *field);
 static const char *get_var_version(char *field);
-static const char *get_var_plc(char *field);
 static wc_tpl_var_t tpl_vars[] = {
+
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+#ifdef WC_DEBUG
+	{ .name = "cfg", .get = &get_var_cfg }, /* web-config config vars */
+#endif
+#endif
+
+	{ .name = "wcf", .get = &get_var_wcf }, /* web-config features */
+	{ .name = "pgf", .get = &get_var_pgf }, /* page flags */
 	{ .name = "script", .get = &get_var_script },
-	{ .name = "page", .get = &get_var_curpage },
+	{ .name = "pg", .get = &get_var_pg },			/* pg - name of current page */
+	{ .name = "pg_i", .get = &get_var_pg_i },			/* page iteration (pg_i.* (style,name,title,count '.s','.n', '.t', '.c') */
+	{ .name = "sp", .get = &get_var_sp },			/* sp - name of current sub menu(subpage) */
+	{ .name = "sp_i", .get = &get_var_sp_i },		/* sub menu iteration (style,name,title,count '.s','.n', '.t', '.c') */
 	{ .name = "status", .get = &get_var_status },
 	
 	{ .name = "version", .get = &get_var_version },
-	{ .name = "plc", .get = &get_var_plc },
+	
+	{ .name = NULL, },
+};
+
+static const char *get_var_frmb(char *field);
+static wc_tpl_var_t frmb_var = {	
+	.name = "frmb", .get = get_var_frmb,
 };
-const int tpl_vars_count = sizeof(tpl_vars) / sizeof(tpl_vars[0]);
 
 /* --- Local page processor --- */
 
-static void process_home(wc_page_data_t *data)
-{
-	/* nothing to do */
-}
+//static void process_home(wc_page_data_t *data, int submitted)
+//{
+//	/* nothing to do */
+//}
 
 /* --- Command handlers --- */
 
-#ifdef WC_COMMAND_IFP
-/* arg is '<name>:<act>', where act is .tpl or text */
-static void if_yn_page(char *arg, int yes)
-{
-	int is_page;
-	char *p = strchr(arg, IFP_CHAR_ARG_SEP);
-	if (!p) {
-		fprintf(cgiOut, "<!-- inv.arg -->");
-	}
-	*p = 0; /* desigred name name - arg string */ 
-
-	is_page = !strcmp(arg, page_data.name);
-	if ((is_page && yes) || (!is_page && !yes))
-	{
-		p++;
-		if (*p == IFP_CHAR_INCLUDE) {
-			wc_render_template(p + 1);	/* include specified template */
-		} else {
-			fprintf(cgiOut, "%s", p);		/* text */
-		}
-	} /* else - just ignore the template */
-}
+/* --- Var handlers --- */
 
-static void do_if_page(char *arg)
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+#ifdef WC_DEBUG
+static const char *get_var_cfg(char *field)
 {
-	if_yn_page(arg, 1);
+	const char *p = NULL;
+	
+	if (!field) {
+		return NULL;
+	}
+	
+	if (!strcmp(field, "gprs_max")) {
+		sprintf(page_data.val_buf, "%d", page_data.cfg.gprs_profiles_max);
+		p = page_data.val_buf;
+	}
+	if (!strcmp(field, "vpn_max")) {
+		sprintf(page_data.val_buf, "%d", page_data.cfg.vpn_profiles_max);
+		p = page_data.val_buf;
+	}
+	return p;
 }
-static void do_if_not_page(char *arg)
+#endif
+#endif
+
+/* note: for unknown features return 0 as for 'not supported' */
+static const char *get_var_wcf(char *field)
 {
-	if_yn_page(arg, 0);
+	if (!field) {
+		return "0";
+	}
+
+#ifdef OWEN_PLC304MSAN
+	if (!strcmp(field, "sensors")) {
+		return "1";
+	}
+#endif
+	
+	return "0";
 }
-#endif /*WC_COMMAND_IFP*/
 
-/* --- Var handlers --- */
+/* note: for unknown features return 0 as for 'not supported' */
+static const char *get_var_pgf(char *field)
+{
+	int flag = 0;
+	
+	if (!field) {
+		return "0";
+	}
+
+	if (!strcmp(field, "cntdn")) {
+		flag = page_data.flags.cntdn;
+	} else if (!strcmp(field, "subm")) {
+		flag = page_data.flags.subm_en;
+	} else if (!strcmp(field, "form")) {
+		flag = page_data.flags.form;
+	}
+	
+	return flag ? "1" : "0";
+}
 
 static const char *get_var_script(char *field)
 {
 	return cgiScriptName;
 }
-static const char *get_var_curpage(char *field)
+
+static const char *get_var_menu_i(char *field, wc_menu_t **fmenu, int *fcount, int *findex)
+{
+	int index;
+
+	if (!field) {
+		return NULL;
+	}
+
+	if (*field == 'c') {
+		sprintf(page_data.val_buf, "%d", *fcount);
+		return page_data.val_buf;
+	}
+
+	index = wc_loop_ctx.counter[0];
+	if (index >= *fcount) {
+		return NULL;
+	}
+
+	switch (*field) {
+		case 's':
+			return (index == *findex) ? "s" : "";
+			break;
+		case 'n':
+			if (*fmenu) {
+				return (*fmenu)[index].name;
+			}
+			break;
+		case 't':
+			if (*fmenu) {
+				return (*fmenu)[index].title;
+			}
+			break;
+	}
+
+	return NULL;
+}
+
+static const char *get_var_pg(char *field)
 {
 	return page_data.name;
 }
+
+static const char *get_var_pg_i(char *field)
+{
+	wc_menu_t **fmenu = &page_data.pages;
+	int *fcount = &page_data.count;
+	int *findex = &page_data.index;
+
+	return get_var_menu_i(field, fmenu, fcount, findex);
+}
+
+static const char *get_var_sp(char *field)
+{
+	return page_data.sub_name;
+}
+
+static const char *get_var_sp_i(char *field)
+{
+	wc_menu_t **fmenu = &page_data.sub_pages;
+	int *fcount = &page_data.sub_count;
+	int *findex = &page_data.sub_index;
+
+	return get_var_menu_i(field, fmenu, fcount, findex);
+}
+
 static const char *get_var_status(char *field)
 {
 	return page_data.status_text ? page_data.status_text : page_data.status_buf;
@@ -154,65 +301,227 @@
 {
 	return APP_VERSION;
 }
-static const char *get_var_plc(char *field)
-{
-	return WC_PLC_NAME;
-}
 
-/* CGI entry */
-
-int cgiMain()
+static const char *get_var_frmb(char *field)
 {
-	int i;
-	page_t *p = NULL;
-
-	/* register commands and vars */
-	for (i = 0; i < tpl_commands_count; i++) {
-		wc_tpl_cmd_register(&tpl_commands[i]);
+	int index;
+	
+	if (!field) {
+		return NULL;
 	}
-	for (i = 0; i < tpl_vars_count; i++) {
-		wc_tpl_var_register(&tpl_vars[i]);
+
+	if (*field == 'c') {
+		sprintf(page_data.val_buf, "%d", page_data.form_buttons_count);
+		return page_data.val_buf;
 	}
-	
-	/* determine current page name and call respective page processor */
-	cgiFormStringNoNewlines(APP_VAR_PAGE, 
-						page_data.name, 
-						sizeof(page_data.name));
 
-	for (i = 0; i < pages_count; i++) {
-		if (!strcmp(page_data.name, pages[i].name)) {
-			p = &pages[i];
-			break;
+	if (*field == 'a') {
+		switch (page_data.form_buttons_align) {
+			case WC_FBA_LEFT:
+				return "left";
+				break;
+			case WC_FBA_CENTER:
+				return "center";
+				break;
+			case WC_FBA_RIGHT:
+			default:
+				return "right";
+				break;
 		}
 	}
 
-	if (!p) {
-		int is_not_default = strcmp(page_data.name, APP_PAGE_DEFAULT);
-		if (is_not_default) {
-			strcpy(page_data.name, APP_PAGE_DEFAULT);
-			for (i = 0; i < pages_count; i++) {
-				if (!strcmp(APP_PAGE_DEFAULT, pages[i].name)) {
-					p = &pages[i];
+	index = wc_loop_ctx.counter[0];	/* TH_I - 1st level */
+	if (index >= page_data.form_buttons_count) {
+		return NULL;
+	}
+
+	switch (*field) {
+		case 'v': /* type */
+			return page_data.form_buttons[index]->title;
+			break;
+		case 'n':
+			return page_data.form_buttons[index]->name;
+			break;
+		case 't': /* type */
+			switch (page_data.form_buttons[index]->type) {
+				case WC_FBT_SUBMIT:
+					return "submit";
+					break;
+				case WC_FBT_RESET:
+					return "reset";
+					break;
+				case WC_FBT_BUTTON:
+				default:
+					return "button";
 					break;
-				}
 			}
-		}
+			break;
 	}
 
+	return NULL;
+}
+
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+static int process_cfg_line(char *var, char *val, void *data)
+{
+	if (!strcmp(var, CFG_VAR_GPRS_MAX)) {
+		page_data.cfg.gprs_profiles_max = atoi(val);
+	} else if (!strcmp(var, CFG_VAR_VPN_MAX)) {
+		page_data.cfg.vpn_profiles_max = atoi(val);
+	}
+	return 1;
+}
+
+static void read_wc_conf()
+{
+	/* thttpd as many other servers set PWD to the dir wgere the CGI is placed:
+	* so read config from the current directory
+	*/
+	wc_conf_file_read(WC_CONFIG_FILE, &process_cfg_line, NULL);
+
+	/* fix some config settings with defaults */
+	if (page_data.cfg.gprs_profiles_max <= 0) {
+		page_data.cfg.gprs_profiles_max = CFG_VAL_GPRS_MAX;
+	}
+	if (page_data.cfg.vpn_profiles_max <= 0) {
+		page_data.cfg.vpn_profiles_max = CFG_VAL_VPN_MAX;
+	}
+	dbg_console("gprs_max=%d, vpn_max=%d\n", 
+		page_data.cfg.gprs_profiles_max,
+		page_data.cfg.vpn_profiles_max);
+}
+#endif
+
+/* CGI entry */
+
+int cgiMain()
+{
+	wc_menu_t *p = NULL;
+
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+	/* read global config */
+	read_wc_conf();
+#endif
+
+	/* register vars */
+	wc_tpl_vars_register(tpl_vars);
+
+	/* register main menu - pages, determine current page name */
+	main_menu_register(pages);
+	p = &page_data.pages[page_data.index];
+
+	/* prepare common strings */
+	wc_strings_init(&page_data);
+
+	/* process page, note: if page has submenu it is registered in the processor */
 	if (p && p->process) {
-		p->process(&page_data);
+		p->process(&page_data, 
+					cgiFormSubmitClicked(WC_NAME_FORM_SUBMIT) == cgiFormSuccess);
 	}
 
 	/* render response */
-	cgiHeaderContentType("text/html");
-	
-	wc_render_template(APP_MAIN_TEMPLATE);
+	cgiHeaderContentType(page_data.content_type);
+
+	if (page_data.ct_id == WC_CT_HTML) {
+		if (page_data.flags.popup_tpl) {
+			wc_render_template(APP_POPUP_TEMPLATE);
+		} else {
+			wc_render_template(APP_MAIN_TEMPLATE);
+		}
+	}
 
 	/* post-rendering tasks */
 	if (p && p->post_process) {
-		p->post_process();
+		p->post_process(&page_data);
 	}
 	
 	return 0;
 }
 
+/* menu:
+* - can be NULL, then count=0,index<0 => no menu
+* - can have 1 NULL element, then menu is !NULL, but count=0,index<0=> no menu
+* - can have 1 !NULL element, then => menu of 1 element, etc. index may be <0 if selection is not found
+* So only count determines whether menu is present or not
+*/
+static void menu_register(wc_menu_t *menu, char *fname,
+			wc_menu_t **fmenu, int *fcount, int *findex)
+{
+	int count = 0;
+	int index = -1;
+	
+	*fmenu = menu;
+	if (menu) {
+		for (count = 0; menu[count].name; count++) {
+			if ((index < 0) && !strcmp(fname, menu[count].name)) {
+				index = count;
+			}
+		}
+	}
+
+	if (index < 0) {
+		if (count > 0) {
+			index = 0;
+			strcpy(fname, menu[0].name);
+		}
+	}
+
+	*fcount = count;
+	*findex = index;
+}
+
+static void main_menu_register(wc_menu_t *menu)
+{
+	wc_menu_t **fmenu = &page_data.pages;
+	int *fcount = &page_data.count;
+	int *findex = &page_data.index;
+
+	cgiFormStringNoNewlines(HVAR_PAGE, 
+						page_data.name, 
+						sizeof(page_data.name));
+	menu_register(menu, page_data.name, fmenu, fcount, findex);
+}
+
+void wc_sub_menu_register(wc_menu_t *menu)
+{
+	wc_menu_t **fmenu = &page_data.sub_pages;
+	int *fcount = &page_data.sub_count;
+	int *findex = &page_data.sub_index;
+
+	cgiFormStringNoNewlines(HVAR_SUBPAGE, 
+						page_data.sub_name, 
+						sizeof(page_data.sub_name));
+	menu_register(menu, page_data.sub_name, fmenu, fcount, findex);
+	if (*fcount > 0) {
+		page_data.flags.subm_en = 1;
+	}
+}
+
+#if defined(WC_CONFIG_RC_SYNC)
+int wc_sync_configs(void)
+{
+	return system("sh -c \"PATH=/sbin/:$PATH; /etc/rc.sync\" > /dev/null 2>&1");
+}
+#endif
+
+void wc_form_enable(int fba, wc_form_button_t *b1, wc_form_button_t *b2, 
+					wc_form_button_t *b3)
+{
+	int i = 0;
+	page_data.flags.form = 1;
+	page_data.form_buttons_align = fba;
+	if (b1) {
+		page_data.form_buttons[i++] = b1;
+	}
+	if (b2) {
+		page_data.form_buttons[i++] = b2;
+	}
+	if (b3) {
+		page_data.form_buttons[i++] = b3;
+	}
+	page_data.form_buttons_count = i;
+	wc_tpl_var_register(&frmb_var);
+}
+
diff -Nru a/wc/wc_net_ddns.c b/wc/wc_net_ddns.c
--- a/wc/wc_net_ddns.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_net_ddns.c	2012-09-18 17:50:00.000000000 +0300
@@ -0,0 +1,573 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+
+#include "cgic.h"
+
+#include "wc_conf_file.h"
+#include "wc_tpl.h"
+#include "wc_page.h"
+#include "wc_net_ddns.h"
+#include "wc_net.h"
+
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_NET_DDNS
+
+#define WC_DDNS_MAX_SYSTEMS	5
+
+#define DDNS_SYS_NAME_MAX_LEN	31
+#define DDNS_SYSTEM_MAX_LEN		63
+#define DDNS_LOGIN_MAX_LEN		15
+#define DDNS_PWD_MAX_LEN			15
+#define DDNS_DOMAIN_MAX_LEN		255
+#define DDNS_HASH_MAX_LEN			255
+
+typedef struct ddns_sys_conf_t {
+	char name[DDNS_SYS_NAME_MAX_LEN + 1];	/* name of system profile */
+	
+	char system[DDNS_SYSTEM_MAX_LEN + 1];	/* system passed to inadyn - pre-defined, not editable */
+	char login[DDNS_LOGIN_MAX_LEN + 1];
+	char pwd[DDNS_PWD_MAX_LEN + 1];
+	char domain[DDNS_DOMAIN_MAX_LEN + 1];
+	char hash[DDNS_HASH_MAX_LEN + 1];
+	int hash_req: 1;
+} ddns_sys_conf_t;
+
+static struct ddns_data {
+	wc_page_data_t *pdata;
+
+	char host_name[NET_MAX_HOSTNAME_LEN + 1];	/* got from main network config */
+
+	char sel_name[DDNS_SYS_NAME_MAX_LEN + 1];	/* name read from main config */
+	int update_period_sec;
+
+	ddns_sys_conf_t systems[WC_DDNS_MAX_SYSTEMS];
+	int count;			/* count of systems loaded */
+	int sel_index;		/* selected index: 0 - disabled, 1... - systems */
+} ddns;
+
+/* Commands */
+static void do_cmd_ddns_cfg(char *arg);
+static wc_tpl_cmd_t ddns_cfg_cmd = {
+	.name = "ddns_cfg", .handler = do_cmd_ddns_cfg,
+};
+
+/* Vars */
+static const char *get_var_ddns(char *field);
+static const char *get_var_ds(char *field);
+static wc_tpl_var_t ddns_vars[] = {
+	{ .name = "ddns", .get = &get_var_ddns },
+	{ .name = "ds", .get = &get_var_ds },
+	{ .name = NULL, },
+};
+
+/* local methods */
+static int get_current_settings(wc_page_data_t *data);
+static int apply_new_settings(wc_page_data_t *data);
+
+/* --- Var handlers --- */
+
+static const char *get_var_ddns(char *field)
+{
+	if (!field) {
+		return NULL;
+	}
+	switch (*field) {
+		case 'h':
+			return ddns.host_name;
+			break;
+	}
+	return NULL;
+}
+
+static const char *get_var_ds(char *field)
+{
+	int index;
+
+	if (!field) {
+		return NULL;
+	}
+
+	if (*field == 'c') {
+		sprintf(ddns.pdata->val_buf, "%d", ddns.count + 1);	/* + 1 for 'Disabled' option */
+		return ddns.pdata->val_buf;
+	}
+
+	index = wc_loop_ctx.counter[0];
+	if (index > WC_DDNS_MAX_SYSTEMS) {
+		return NULL;
+	}
+
+	switch (*field) {
+		case 's':		/* selected or not */
+			return (ddns.sel_index == index) ? " selected" : "";
+			break;
+
+		case 'v':		/* name of the system - for indexes != 0 - the same as 'n' */
+			if (!index) {
+				return ""; /* name "" - for disabled */
+			}
+		case 'n':		/* name of the system */
+			if (!index) {
+				return WC_STR_DDNS_DISABLED;
+			}
+
+			return ddns.systems[index - 1].name;
+			break;
+	}
+	
+	return NULL;
+}
+
+/* --- Interface methods --- */
+
+void wc_net_ddns_process(wc_page_data_t *data, int submitted)
+{
+	ddns.pdata = data;
+
+	wc_tpl_vars_register(ddns_vars);
+	wc_tpl_cmd_register(&ddns_cfg_cmd);
+
+	wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, &wc_btn_reset, NULL);
+
+	if (submitted) {
+		/* get data from the request .......???? */
+		apply_new_settings(data);
+	}
+
+	/* read ?????? and extract current settings */
+	get_current_settings(data);
+}
+
+/* --- local subroutines --- */
+
+static int read_main_conf_vars(char *var, char *val, void *data)
+{
+	do {	
+		if (!strcmp(var, CFG_DDNS_SYS_NAME)) {
+			size_t len;
+			len = strlen(val);
+			if (len && (len < sizeof(ddns.sel_name))) {
+				strcpy(ddns.sel_name, val);
+			}
+			break;
+		}
+
+		if (!strcmp(var, CFG_DDNS_UPDATE_PERIOD_SEC)) {
+			ddns.update_period_sec = atoi(val);
+			break;
+		}
+	} while (0);
+	
+	return 1;
+}
+
+static int read_sys_conf_vars(char *var, char *val, void *data)
+{
+	size_t len;
+	size_t size_max;
+	char *target;
+	int hr = 0;
+	
+	do {	
+		if (!strcmp(var, CFG_DDNS_SYSTEM)) {
+			size_max = sizeof(ddns.systems[0].system);
+			target = ddns.systems[ddns.count].system;
+			break;
+		}
+		if (!strcmp(var, CFG_DDNS_LOGIN)) {
+			size_max = sizeof(ddns.systems[0].login);
+			target = ddns.systems[ddns.count].login;
+			break;
+		}
+		if (!strcmp(var, CFG_DDNS_PASSWORD)) {
+			size_max = sizeof(ddns.systems[0].pwd);
+			target = ddns.systems[ddns.count].pwd;
+			break;
+		}
+		if (!strcmp(var, CFG_DDNS_DOMAIN)) {
+			size_max = sizeof(ddns.systems[0].domain);
+			target = ddns.systems[ddns.count].domain;
+			break;
+		}
+		if (!strcmp(var, CFG_DDNS_HASH)) {
+			size_max = sizeof(ddns.systems[0].hash);
+			target = ddns.systems[ddns.count].hash;
+			hr = 1;
+			break;
+		}
+		return 1; /* ignore */
+	} while (0);
+
+	len = strlen(val);
+	if (len && (len < size_max)) {
+		strcpy(target, val);
+	}
+	if (hr) {
+		ddns.systems[ddns.count].hash_req = 1;
+	}
+	
+	return 1;
+}
+
+static void read_sys_configs()
+{
+	DIR *dir;
+	struct dirent entry;
+	struct dirent *pentry;
+	char conf_file[sizeof(DDNS_CONFIG_DIR) + 4 + DDNS_SYS_NAME_MAX_LEN + 6];
+	char *pname;
+	int r;
+
+	dir = opendir(DDNS_CONFIG_DIR);
+	if (!dir) {
+		sprintf(ddns.pdata->status_buf, "Error: failed to open %s config dir", DDNS_CONFIG_DIR);
+		return;	/* failed to open dir with profiles */
+	}
+
+	memcpy(conf_file, DDNS_CONFIG_DIR, sizeof(DDNS_CONFIG_DIR));
+	conf_file[sizeof(DDNS_CONFIG_DIR) - 1] = '/';
+	pname = &conf_file[sizeof(DDNS_CONFIG_DIR)];
+	ddns.sel_index = 0;
+
+	ddns.count = 0;
+	while (ddns.count < WC_DDNS_MAX_SYSTEMS) {
+		size_t len;
+		
+		r = readdir_r(dir, &entry, &pentry);
+		if (r) {
+			/* err - ignore */
+			break;
+		}
+		if (!pentry) {
+			/* end of dir */
+			break;
+		}
+		if (pentry->d_name[0] == '.') {
+			continue;
+		}
+		
+		/* check the name for valid system conf file candidate: template & len */
+		len = strlen(pentry->d_name);
+		if ((len > (4 + DDNS_SYS_NAME_MAX_LEN + 5)) ||
+			memcmp(pentry->d_name, "sys_", 4) ||
+			memcmp(&pentry->d_name[len - 5], ".conf", 5)) {
+			continue;
+		}
+
+		/* clean ddns sys item */
+		memset(&ddns.systems[ddns.count], 0, sizeof(ddns.systems[ddns.count]));
+
+		/* extract system name from the file name */
+		memcpy(ddns.systems[ddns.count].name, &pentry->d_name[4], len - 5 - 4);
+		ddns.systems[ddns.count].name[len - 5 - 4] = 0;
+
+		/* build system's config full path */
+		memcpy(pname, pentry->d_name, len);
+		pname[len] = 0;
+
+		/* load system's config */
+		r = wc_conf_file_read(conf_file, read_sys_conf_vars, NULL);
+		if (r) {
+			/* ignore the system */
+			continue;
+		}
+
+		ddns.count++;
+	}
+}
+
+static int compare_sys_name(const void *n1, const void *n2)
+{
+	return strcmp(((ddns_sys_conf_t *)n1)->name, ((ddns_sys_conf_t *)n2)->name);
+}
+
+static int read_conf_vars(char *var, char *val, void *data)
+{
+	if (!strcmp(CFG_HOST_NAME, var)) {
+		strcpy(ddns.host_name, val);
+		/* get value and stop parsinbg more */
+		return 0;
+	}
+	/* ignore other vars */
+	return 1;
+}
+
+static int get_current_settings(wc_page_data_t *data)
+{
+	int r;
+	int i;
+
+	/* read ddns.conf */
+	ddns.sel_name[0] = 0;
+	ddns.update_period_sec = 0;
+	r = wc_conf_file_read(DDNS_CONFIG_FILE, read_main_conf_vars, NULL);
+	if (r) {
+		sprintf(data->status_buf, "Error: failed to read %s config file", DDNS_CONFIG_FILE);
+		return -1;
+	}
+
+	/* read systems' configs  up to max count of systems */
+	read_sys_configs();
+
+	/* sort systems by name */
+	if (ddns.count) {
+		qsort(ddns.systems, ddns.count, sizeof(ddns.systems[0]), &compare_sys_name);
+	}
+
+	/* determine sel_index */
+	for (i = 0; i < ddns.count; i++) {
+		/* check if the system is selected one - use 1-based order of the system as index */
+		if (!strcmp(ddns.sel_name, ddns.systems[i].name)) {
+			ddns.sel_index = i + 1;
+		}
+	}
+
+	wc_conf_file_read(NET_CONFIG_FILE, &read_conf_vars, NULL);
+
+	return 0;
+}
+
+typedef struct edit_ddns_sys_option {
+	const char *name;
+	const char *val;
+	int edited;
+} edit_ddns_sys_option; 
+
+static int edit_ddns_sys_conf_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp = parse_data->fp_out;
+	edit_ddns_sys_option *opts = (edit_ddns_sys_option *)data;
+	edit_ddns_sys_option *opt;
+
+	if (parse_data->type == WC_CLT_WRONG) {
+		return 1;	/* remove wrong lines */
+	}
+
+	if (parse_data->type == WC_CLT_EOF) {
+		for (opt = opts; opt->name; opt++) {
+			if (!opt->edited) {
+				fprintf(fp, "%s=%s\n", opt->name, opt->val);
+			}
+		}
+		return 0; /* ignore */
+	}
+
+	if (parse_data->type == WC_CLT_VAR) {
+		for (opt = opts; opt->name; opt++) {
+			if (!memcmp(opt->name, parse_data->var, parse_data->var_len) &&
+				!opt->name[parse_data->var_len]) {
+				/* found - edit */
+				fprintf(fp, "%s=%s\n", opt->name, opt->val);
+				opt->edited = 1;
+				return 1;
+			}
+		}
+		/* else, do not remove option - ignore leaving it as is */
+	}
+
+	/* printf the rest lines unchanged */
+	fprintf(fp, "%s", parse_data->line);
+	return 1;
+}
+
+static int ddns_set_system(ddns_sys_conf_t *conf)
+{
+	char conf_file[sizeof(DDNS_CONFIG_DIR) + 4 + DDNS_SYS_NAME_MAX_LEN + 6];
+	struct stat sbuf;
+	edit_ddns_sys_option opts[5];	/* login,pwd,domain,hash, 0 */
+	int r;
+
+	/* config file looks like: /etc/ddns/sys_name.conf,
+	* where "name" is name of the dyndns system
+	*/
+	sprintf(conf_file, "%s/sys_%s.conf", DDNS_CONFIG_DIR, conf->name);
+
+	r = stat(conf_file, &sbuf);
+	if (r || (!S_ISREG(sbuf.st_mode) && !S_ISLNK(sbuf.st_mode))) {
+		sprintf(ddns.pdata->status_buf, "%s: %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_INVAL_DDNS_NAME);
+		return -1;
+	}
+
+	/* if config file exists - extract settings, check them and 
+	* - update specifc config
+	* - update ddns.conf 
+	*/
+
+	cgiFormString("dl", conf->login, sizeof(conf->login));
+	cgiFormString("dp", conf->pwd, sizeof(conf->pwd));
+	cgiFormString("dd", conf->domain, sizeof(conf->domain));
+	cgiFormString("dh", conf->hash, sizeof(conf->hash));
+
+	/* check for existence of string values */
+	if (!conf->login[0] || !conf->pwd[0] || !conf->domain[0]) {
+		sprintf(ddns.pdata->status_buf, "%s: %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_INVAL_DDNS_SETTING);
+		return -1;
+	}
+
+	memset(opts, 0, sizeof(opts));
+	/* note: .system is pre-defined and not editable */
+	opts[0].name = CFG_DDNS_LOGIN;
+	opts[0].val = conf->login;
+	opts[1].name = CFG_DDNS_PASSWORD;
+	opts[1].val = conf->pwd;
+	opts[2].name = CFG_DDNS_DOMAIN;
+	opts[2].val = conf->domain;
+	opts[3].name = CFG_DDNS_HASH;
+	opts[3].val = conf->hash;
+	opts[3].edited = 1;	/* set always edited in order to prevent adding this option */
+
+	r = wc_conf_file_edit(conf_file, edit_ddns_sys_conf_line, opts, 0);
+	if (r) {
+		sprintf(ddns.pdata->status_buf, "%s: %s: %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_DDNS_CFG_EDIT, conf->name);
+	}
+
+	return r;
+}
+
+typedef struct edit_ddns_main_data {
+	const char *name;
+	int update_period_sec;
+	int disabled;
+} edit_ddns_main_data; 
+
+static int edit_ddns_main_conf_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp = parse_data->fp_out;
+	edit_ddns_main_data *d = (edit_ddns_main_data *)data;
+
+	if (parse_data->type == WC_CLT_WRONG) {
+		return 1;	/* remove wrong lines */
+	}
+
+	/* when option is edited it is reset to NULL/0,
+	* so add option if it is still !NULL/0
+	*/
+
+	if (parse_data->type == WC_CLT_EOF ||
+		parse_data->type == WC_CLT_CREATED) {
+		if (d->name) {
+			fprintf(fp, "%s=%s\n", CFG_DDNS_SYS_NAME, d->name);
+		}
+		if (!d->disabled && d->update_period_sec) {
+			fprintf(fp, "%s=%d\n", CFG_DDNS_UPDATE_PERIOD_SEC, d->update_period_sec);
+		}
+		return 0; /* ignore */
+	}
+
+	if (parse_data->type == WC_CLT_VAR) {
+		if (!memcmp(CFG_DDNS_SYS_NAME, parse_data->var, parse_data->var_len) &&
+			sizeof(CFG_DDNS_SYS_NAME) - 1 == parse_data->var_len) {
+			if (d->name) { /* edit once, remove redundant repetitions */
+				fprintf(fp, "%s=%s\n", CFG_DDNS_SYS_NAME, d->name);
+			}
+			d->name = NULL;
+			return 1;
+		}
+		if (!d->disabled &&
+			!memcmp(CFG_DDNS_UPDATE_PERIOD_SEC, parse_data->var, parse_data->var_len) &&
+			sizeof(CFG_DDNS_UPDATE_PERIOD_SEC) - 1 == parse_data->var_len) {
+			if (d->update_period_sec) {
+				fprintf(fp, "%s=%d\n", CFG_DDNS_UPDATE_PERIOD_SEC, d->update_period_sec);
+			}
+			d->update_period_sec = 0;
+			return 1;
+		}
+		/* else, do not remove option - ignore leaving it as is */
+	}
+
+	/* printf the rest lines unchanged */
+	fprintf(fp, "%s", parse_data->line);
+	return 1;
+}
+
+static int ddns_set_main_config(const char *name, int update_period_sec)
+{
+	int r;
+	edit_ddns_main_data data;
+
+	data.name = name;
+	data.update_period_sec = update_period_sec;
+	data.disabled = !name[0];
+
+	r = wc_conf_file_edit(DDNS_CONFIG_FILE, edit_ddns_main_conf_line, &data, 1);
+	if (r) {
+		sprintf(ddns.pdata->status_buf, "%s: %s (%s): %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_DDNS_CFG_EDIT,
+				DDNS_CONFIG_FILE, strerror(-r));
+	}
+	return r;
+}
+
+static int apply_new_settings(wc_page_data_t *data)
+{
+	ddns_sys_conf_t sys_conf;
+	cgiFormResultType result;
+	int update_period_sec = 0;
+	int r;
+
+	/* extract system name , build config file name */
+	result = cgiFormString("ds", sys_conf.name, sizeof(sys_conf.name));
+	if (result != cgiFormSuccess && result != cgiFormEmpty) {
+		sprintf(ddns.pdata->status_buf, "%s: %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_INVAL_DDNS_NAME);
+		return -1;
+	}
+
+	/* name "" for disabled */
+	if (sys_conf.name[0]) {
+		r = ddns_set_system(&sys_conf);
+		if (r) {
+			return -1;
+		}
+
+		cgiFormInteger("du", &update_period_sec, 0);
+		if (update_period_sec < DDNS_UPDATE_PERIOD_SEC_MIN ||
+			update_period_sec > DDNS_UPDATE_PERIOD_SEC_MAX) {
+			sprintf(ddns.pdata->status_buf, "%s: %s", 
+					WC_STR_STATUS_ERROR, WC_STR_ERR_INVAL_DDNS_SETTING);
+			return -1;
+		}
+	}
+
+	r = ddns_set_main_config(sys_conf.name, update_period_sec);
+
+	if (!r) {
+		char sys_cmd[256];
+		sprintf(sys_cmd, 
+			"sh -c \"PATH=/sbin:$PATH; %s/rc.net ddns update\" > /dev/null 2>&1 &",
+			RC_NET_DIR);
+		system(sys_cmd);
+		sprintf(ddns.pdata->status_buf, WC_STR_STATUS_DDNS_UPDATING);
+		data->flags.cntdn = 1;
+	}
+
+	return r;
+}
+
+static void do_cmd_ddns_cfg(char *arg)
+{
+	int i;
+	for (i = 0; i < ddns.count; i++) {
+		fprintf(cgiOut,
+			"ddns[%d]={dl: '%s', dp: '%s', dd: '%s', dhr: %d, dh: '%s', du: '%d'};",
+			i + 1, 
+			ddns.systems[i].login,
+			ddns.systems[i].pwd,
+			ddns.systems[i].domain,
+			ddns.systems[i].hash_req,
+			ddns.systems[i].hash_req ? ddns.systems[i].hash : "",
+			ddns.update_period_sec);
+	}
+}
+
+#endif /* WC_CONFIG_MENU_NET_DDNS */
+
diff -Nru a/wc/wc_net_ddns.h b/wc/wc_net_ddns.h
--- a/wc/wc_net_ddns.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_net_ddns.h	2012-05-13 17:03:30.000000000 +0300
@@ -0,0 +1,7 @@
+#ifndef _WC_NET_DDNS_H_
+#define _WC_NET_DDNS_H_
+
+extern void wc_net_ddns_process(wc_page_data_t *data, int submitted);
+
+#endif /* _WC_NET_DDNS_H_*/
+
diff -Nru a/wc/wc_net.h b/wc/wc_net.h
--- a/wc/wc_net.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_net.h	2012-09-18 12:58:35.000000000 +0300
@@ -0,0 +1,74 @@
+#ifndef _WC_NET_H_
+#define _WC_NET_H_
+
+#define NET_MAX_HOSTNAME_LEN	32
+
+#define RC_NET_DIR		"/etc"
+#define NET_CONFIG_FILE "/etc/network.conf"
+//#define NET_CONFIG_FILE "/home/alex/local/www/cgi/network.conf"
+#define CFG_DHCP		"DHCP"
+#define CFG_HOST_NAME	"HOST_NAME"
+#define CFG_IP_ADDR		"IPADDR"
+#define CFG_IP_MASK		"NETMASK"
+#define CFG_IP_GW		"GWADDR"
+#define CFG_IP_DNS1		"DNS1"
+#define CFG_IP_DNS2		"DNS2"
+
+#define WC_NET_SP_NAME_MAIN		"main"
+#define WC_NET_SP_NAME_GPRS		"gprs"
+#define WC_NET_SP_NAME_VPN		"vpn"
+#define WC_NET_SP_NAME_DDNS		"ddns"
+
+#define CFG_AUTO_GPRS				"GPRS_AUTO"
+#define CFG_AUTO_VPN				"VPN_AUTO"
+
+#define PPP_DIR						"/etc/ppp"
+#define PPP_PROFILES_DIR			PPP_DIR "/peers"
+#define PPP_SECRETS_PAP_FILE		PPP_DIR "/pap-secrets"
+#define PPP_SECRETS_CHAP_FILE		PPP_DIR "/chap-secrets"
+#define PPP_GPRS_CHAT_PROG		PPP_DIR "/gprs_chat.sh"
+
+#define PPP_SBIN_DIR				"/usr/sbin"
+
+#define PPP_GPRS_TPL_FILE			PPP_DIR "/tpl/gprs"
+#define PPP_VPN_TPL_FILE			PPP_DIR "/tpl/vpn"
+#define PPP_GPRS_CHAT_TPL_FILE		PPP_DIR "/tpl/gprs.chat"
+
+#define PPP_PID_DIR					"/var/run"
+#define NETWORK_RUN_DIR			"/var/run/network"
+#define PPP_LOG_DIR					"/var/log"
+#define PPP_MAX_DIR_SIZE			17
+
+#define CFG_WC_PIN				"WC_PIN"
+//#define CFG_WC_PIN_WAIT_SEC	"WC_PIN_WAIT_SEC"
+
+/* the line containing this keyword in the gprs chat template file will be replaced with real strings
+* configured via WC */
+#define CFG_WC_CHAT_KEYWORD	"{WC_CHAT}"
+
+#define CFG_OPT_PTY				"pty"
+/* can be used either 'name' or 'user', do not use 'login' */
+#define CFG_OPT_NAME			"name"
+/* 'password' option can be read only, when creating/editing profile use secrets files instead */
+#define CFG_OPT_PASSWORD		"password"
+#define CFG_OPT_IPPARAM		"ipparam"
+#define CFG_OPT_REMOTENAME	"remotename"
+#define CFG_OPT_LOGFILE		"logfile"
+#define CFG_OPT_HWFLOW		"crtscts"
+#define CFG_OPT_CONNECT		"connect"
+
+#define DDNS_CONFIG_DIR		"/etc/ddns"
+#define DDNS_CONFIG_FILE		DDNS_CONFIG_DIR "/ddns.conf"
+#define DDNS_UPDATE_PERIOD_SEC_MIN			60
+#define DDNS_UPDATE_PERIOD_SEC_MAX			(24*60*60)
+
+#define CFG_DDNS_SYS_NAME				"SYS_NAME"
+#define CFG_DDNS_UPDATE_PERIOD_SEC	"UPDATE_PERIOD_SEC"
+
+#define CFG_DDNS_SYSTEM		"SYSTEM"
+#define CFG_DDNS_LOGIN			"LOGIN"
+#define CFG_DDNS_PASSWORD		"PASSWORD"
+#define CFG_DDNS_DOMAIN		"DOMAIN"
+#define CFG_DDNS_HASH			"HASH"
+
+#endif /* _WC_NET_H_ */
diff -Nru a/wc/wc_net_ppp.c b/wc/wc_net_ppp.c
--- a/wc/wc_net_ppp.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_net_ppp.c	2013-01-09 15:44:16.000000000 +0200
@@ -0,0 +1,3239 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <dirent.h>
+#include <ctype.h>
+#include "cgic.h"
+
+#include "wc_conf_file.h"
+#include "wc_tpl.h"
+#include "wc_page.h"
+#include "wc_net.h"
+#include "wc_net_ppp.h"
+
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_NET_PPP
+
+#define HVAR_PPP_CMD		"cmd"
+/* item name is its ID, use the var for add/edit as well */
+#define HVAR_PPP_ITEM_ID	"iid"
+#define HVAR_PPP_NEW_NAME	"nn"
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+#define HVAR_PPP_PORT		"port"
+#define HVAR_PPP_BAUDRATE	"br"
+#define HVAR_PPP_HWF		"hwf"
+#define HVAR_PPP_SIM_PIN	"pin"
+#define HVAR_PPP_MODEM_IS	"is"
+#define HVAR_PPP_APN		"apn"
+#define HVAR_PPP_CALL_NUM	"cn"
+#define HVAR_PPP_STATIC_IP	"ip"
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+#define HVAR_PPP_VPN_SERVER	"vs"
+#define HVAR_PPP_VPN_ADDR		"vn"
+#define HVAR_PPP_VPN_MASK		"vm"
+#endif
+
+#define HVAR_PPP_LOGIN			"ln"
+#define HVAR_PPP_PASSWORD		"pwd"
+#define HVAR_PPP_AUTO			"as"
+
+#define HVAR_LOG_OFFS			"lo"
+#define HVAR_LOG_DELETE		"ld"
+
+#define IPV4_STR_MAX_LEN			15
+
+#define PR_NAME_MAX_LEN			31
+#define PR_LOGIN_MAX_LEN			15
+#define PR_PWD_MAX_LEN			15
+/* 1 - len of '-', 4 - max len of type "gprs" */
+#define PR_REMOTE_MAX_LEN			(PR_NAME_MAX_LEN + 1 + 4)
+#define PR_CALL_NAME_MAX_LEN		(PR_NAME_MAX_LEN + 1 + 4)
+
+#define GPRS_PR_PORT_MAX_LEN		15
+#define GPRS_PR_INIT_STR_MAX_LEN	63
+#define GPRS_PR_APN_MAX_LEN		63
+#define GPRS_PR_PIN_MAX_LEN		8
+
+#define VPN_PR_HOST_NAME_MAX_LEN	63
+
+/* e.g. ppp0 */
+#define PPP_IF_NAME_MAX_LEN		8
+
+/* PR_NAME_MAX_LEN + 1('.'|'-') + max(PPP_TYPE=4(gprs)) + 1(.) + 
+ *   max(id_type ext=8(starting)) + 1(terminating 0)
+ */
+#define PPP_IDENTITY_MAX_SIZE		(PR_NAME_MAX_LEN + 1 + 4 + 1 + 8 + 1)
+
+/* used when compiling paths into path_buf[WC_PATH_MAX] */
+#if (WC_PATH_MAX < PPP_MAX_DIR_SIZE + PPP_IDENTITY_MAX_SIZE)
+#error "Insufficient definition for WC_PATH_MAX"
+#endif
+
+#define PPP_REASON_MAX_LEN		128
+
+/* PPP types */
+typedef enum ppp_type {
+	PPP_TYPE_UNKNOWN = 0,
+	PPP_TYPE_GPRS,
+	PPP_TYPE_VPN,
+} ppp_type;
+
+/*
+ * Automatically generated values are:
+ * - pppd call name = "<name>.gprs"
+ * - pppd peer file name = "<name>.gprs"
+ * - pppd chat file name = "<name>.gprs.chat"
+ * - additional WC settings file name = "<name>.gprs.wc" - optional
+ * - pppd log file name = "<name>.gprs.log"
+ * - connection IF-file (/var/run/network/<name>.gprs.if)
+ * - connection STARTING-flag file (/var/run/network/<name>.gprs.starting)
+ * - peer name (for pap/chap-secrets) = "<name>-gprs"
+ *
+ * So all identities are generated using <name> and <ppp_type> strings
+ */
+
+/* profile identity types */
+typedef enum profile_identity_type {
+	PIT_MAIN_FILE	= 0,
+	PIT_CHAT_FILE,
+	PIT_WC_FILE,
+	PIT_LOG_FILE,
+	PIT_RUN_IF_FILE,
+	PIT_STARTING_FLAG_FILE,
+	PIT_REMOTE_NAME,
+	PIT_LOG_POPUP_NAME,
+	
+	PIT_COUNT,
+} profile_identity_type;
+#define PIT_CALL_NAME PIT_MAIN_FILE
+
+/* respective array of the name templates */
+const char *profile_identity_tpl[PIT_COUNT] = {
+	"%s.%s",
+	"%s.%s.chat",
+	"%s.%s.wc",
+	"%s.%s.log",
+	"%s.%s.if",
+	"%s.%s.starting",
+	"%s-%s",
+	"%s_%s",
+};
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+typedef struct ppp_profile_data_gprs {
+	/* PPP settings: port, auth, etc */
+	char port[GPRS_PR_PORT_MAX_LEN + 1];		/* path to the port device, e.g. /dev/ttySx */
+	int speed;
+
+	/* chat & additional WC settings */
+	/* note: modem init string is a line right after '"" AT' */
+	char modem_init_string[GPRS_PR_INIT_STR_MAX_LEN + 1];
+	char call_number[9];						/* '*99***1#' or '*99#' */
+	char apn[GPRS_PR_APN_MAX_LEN + 1];
+
+ 	char sim_pin[GPRS_PR_PIN_MAX_LEN + 1];
+//	int enter_pin_to_sec;						/* a timeout to wait after entering PIN in sec */
+
+	char static_ip[IPV4_STR_MAX_LEN + 1];		/* XXX.XXX.XXX.XXX0 */
+
+	struct {
+		unsigned hw_flow: 1;		/* 1 - crtscts, 0 - nocrtscts (default) */
+		unsigned static_ip: 1;		/* whether or not to use static local IP */
+	} flags;
+} ppp_profile_data_gprs;
+
+/* For now only GPRS profile can have wc-config options */
+typedef struct ppp_wc_data {
+	char sim_pin[GPRS_PR_PIN_MAX_LEN + 1];
+} ppp_wc_data;
+
+static int get_br_index(int speed);
+static int br_values[] = {
+	0,
+	300,
+	600,
+	1200,
+	1800,
+	2400,
+	4800,
+	7200,
+	9600,
+	14400,
+	19200,
+	38400,
+	57600,
+	115200,
+	230400,
+	460800,
+	921600
+};
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+typedef struct ppp_profile_data_vpn {
+	char srv_addr[VPN_PR_HOST_NAME_MAX_LEN + 1];	/* hostname or IP doesn't matter */
+	
+	char vpn_addr[IPV4_STR_MAX_LEN + 1];
+	char vpn_mask[IPV4_STR_MAX_LEN + 1];
+} ppp_profile_data_vpn;
+#endif /* WC_CONFIG_MENU_NET_VPN */
+
+typedef struct connection_info {
+	pid_t starting_pid;
+	char if_name[PPP_IF_NAME_MAX_LEN + 1];
+	pid_t if_pid;
+} connection_info;
+
+/* The following data is got from user and from config files.
+ * Common for GPRS and VPN PPP Profiles 
+ */
+typedef struct ppp_profile {
+	char name[PR_NAME_MAX_LEN + 1];		/* expected to be unique - used as ID */
+
+	/* PAP/CHAP auth */
+	char login[PR_LOGIN_MAX_LEN + 1];		/* 'name' PPP option value (can be used 'user' option value instead) */
+	char pwd[PR_PWD_MAX_LEN + 1];
+	char remote[PR_REMOTE_MAX_LEN + 1];	/* remotename */
+
+	struct {
+		unsigned auth: 1;				/* whether auth is used or not: login and pwd are defined. If only login defined - auth is not used */
+		unsigned std_remotename: 1;	/* standard (for WC) remote name or not */
+		unsigned ext_password: 1;		/* external password, i.e. in secrets file or not, i.e. in options */
+		unsigned debug: 1;			/* whether debug is ON or not */
+		unsigned auto_start: 1;		/* auto start - GPRS/VPN_AUTO in /etc/network.conf */
+
+		unsigned as_set: 1;			/* processing-time flag: add/edit: auto_start var set to network.conf */
+	} flags;
+
+	union {
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		ppp_profile_data_gprs gprs;
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+		ppp_profile_data_vpn vpn;
+#endif
+	} t;
+
+	connection_info cinfo;
+} ppp_profile;
+
+/* mode defines the page look & processing */
+typedef enum ppp_mode_type {
+	PPP_MODE_LIST	= 0,
+	PPP_MODE_ADD,
+	PPP_MODE_EDIT,
+	PPP_MODE_VIEW,
+	PPP_MODE_LOG,
+
+	PPP_MODE_COUNT,
+} ppp_mode_type;
+
+static const char *ppp_mode_titles[PPP_MODE_COUNT] = {
+	WC_STR_MODE_LIST_PROFILES,
+	WC_STR_MODE_ADD_PROFILE,
+	WC_STR_MODE_EDIT_PROFILE,
+	WC_STR_MODE_VIEW_PROFILE,
+
+	"", //	WC_STR_MODE_LOG_VIEW, - own title forming method
+	
+};
+
+typedef enum ppp_cmd_id {
+	PPP_CMD_LIST =		0,	/* default action */
+	PPP_CMD_ADD,
+	PPP_CMD_EDIT,			/* add/edit/view */
+	PPP_CMD_VIEW,			/* add/edit/view */
+	PPP_CMD_DEL,
+	PPP_CMD_START,
+	PPP_CMD_STOP,
+	PPP_CMD_LOG,			/* LOG w/o set - view log file, + set - switch to LIST optionally cleaning log file */
+
+	PPP_CMD_COUNT,
+} ppp_cmd_id;
+
+typedef struct ppp_action {
+	const char *name;			/* internal name for templates */
+	const char *title;			/* string for link */
+	ppp_cmd_id cmd;			/* value passed in request */
+	const char *confirm_fmt;	/* confirmation message format */
+	int popup;				/* whether or not the action should popup - excludes confirmation */
+} ppp_action;
+static ppp_action ppp_actions[PPP_CMD_COUNT] = {
+	[PPP_CMD_LIST]	=	{ "list",	NULL,				PPP_CMD_LIST, 	NULL, 0 },
+	[PPP_CMD_ADD]	=	{ "add",	WC_STR_ACT_ADD,	PPP_CMD_ADD,	NULL, 0 },
+	[PPP_CMD_EDIT]	=	{ "edit",	WC_STR_ACT_EDIT,	PPP_CMD_EDIT,	NULL, 0 },
+	[PPP_CMD_VIEW]	=	{ "view",	WC_STR_ACT_VIEW,	PPP_CMD_VIEW,	NULL, 0 },
+	[PPP_CMD_DEL]	=	{ "del",	WC_STR_ACT_DEL,	PPP_CMD_DEL,	WC_STR_CONFIRM_PPP_DEL, 0 },
+	[PPP_CMD_START]	=	{ "start",	WC_STR_ACT_START,	PPP_CMD_START,	WC_STR_CONFIRM_PPP_START, 0 },
+	[PPP_CMD_STOP]	=	{ "stop",	WC_STR_ACT_STOP,	PPP_CMD_STOP,	WC_STR_CONFIRM_PPP_STOP, 0 },
+	[PPP_CMD_LOG]	=	{ "log",	WC_STR_ACT_LOG,	PPP_CMD_LOG,	NULL, 1 },
+};
+
+typedef struct {
+	int colspan;
+	const char *title;
+} tab_head;
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static tab_head th_gprs[] = {
+	{ 0, WC_STR_PPP_NAME },
+	{ 0, WC_STR_PPP_PORT },
+	{ 0, WC_STR_PPP_IP },
+	{ 0, WC_STR_LOGIN },
+#ifndef WC_CONFIG_NO_AUTO_GPRS
+	{ 0, WC_STR_PPP_AUTO },
+#endif
+	{ 4, WC_STR_PPP_ACTION },
+};
+static int th_count_gprs = sizeof(th_gprs) / sizeof(th_gprs[0]);
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+static tab_head th_vpn[] = {
+	{ 0, WC_STR_PPP_NAME },
+	{ 0, WC_STR_PPP_SERVER },
+	{ 0, WC_STR_LOGIN },
+	{ 0, WC_STR_PPP_ROUTE },
+	{ 0, WC_STR_PPP_AUTO },
+	{ 4, WC_STR_PPP_ACTION },
+};
+static int th_count_vpn = sizeof(th_vpn) / sizeof(th_vpn[0]);
+#endif /* WC_CONFIG_MENU_NET_VPN */
+
+/* used as data for callback editing secrets: pointers to sercret values */
+typedef struct ppp_sectret_data_t {
+	const char *name;
+	const char *remote;
+	const char *pwd;
+	struct {
+		/* operation:
+		* clean=1 - remove all records matching <name> <remote> *
+		* clean=0 - edit first record matching <*> <remote> *, remove the rest of the matching records
+		*/
+		unsigned clean: 1;	
+
+		/* for editing - memorize that one line edited */
+		unsigned edited: 1;
+	} flags;
+} ppp_sectret_data_t;
+
+typedef struct {
+	/* passed by framework - global page data */
+	wc_page_data_t *pdata;
+
+	char err_reason[PPP_REASON_MAX_LEN + 1];
+
+	/* got from HTTP */
+	ppp_type type;			/* current profile type */
+	ppp_cmd_id cmd;			/* received action */
+
+	/* calculated according to CMD and result of performed action */
+	ppp_mode_type mode;		/* current mode (display mode) */
+
+	/* set up by type */
+	tab_head *th;
+	int th_count;
+	const char *type_name;
+	size_t type_name_len;
+
+	ppp_profile *profiles;		/* list of profiles for 'LIST' command */
+	int profiles_count;
+	int running_count;		/* count of running connections (LIST mode)*/
+	
+	ppp_profile o_profile;		/* profile being operated on: displayed, or read for more info for EDIT */
+	int log_offs;				/* log offset got from request to output plain log */
+
+	struct {
+		unsigned out_plain_log: 1;
+		unsigned log_del_req: 1;	/* whether or not log delete request is processing */
+
+		unsigned auto_start_enabled: 1;	/* whether or not auto-start functionality is enbaled */
+	} flags;
+
+	/* data got from /etc/network.conf */
+	char ppp_auto[WC_VAL_MAX_SIZE];	/* GPRS: single name, VPN: space-separated multiple names */
+} ppp_data;
+
+static ppp_data ppp;
+
+/* Commands */
+static void do_cmd_readlog(char *arg);
+static wc_tpl_cmd_t readlog_cmd = {
+	.name = "readlog", .handler = do_cmd_readlog,
+};
+
+/* Vars */
+
+/* common PPP vars */
+static const char *get_var_ppp(char *field);
+static const char *get_var_cmd(char *field);
+static wc_tpl_var_t common_vars[] = {
+	{ .name = "ppp", .get = &get_var_ppp },	/* current: type, if field is specified: (m)ode, etc. */
+	{ .name = "cmd", .get = &get_var_cmd },	/* current: command, if field is specified: commands numbers e.g. .add -> n of add, etc.*/
+	{ .name = NULL, },
+};
+
+/* Action: view profiles list */
+static const char *get_var_th_i(char *field);
+static const char *get_var_tdr_i(char *field);
+static const char *get_var_td_i(char *field);
+static const char *get_var_ta_i(char *field);
+static wc_tpl_var_t list_vars[] = {	
+	/* -- table vars */
+	{ .name = "th_i", .get = &get_var_th_i },	/* tab header iterator: fields: .c - count, .s - colspan, .t - title */
+	{ .name = "tdr_i", .get = &get_var_tdr_i },	/* tab data row iterator: fields: .c - count, .i - ID of the item */
+	{ .name = "td_i", .get = &get_var_td_i },	/* tab header iterator: fields .c - count, .v - data value */
+	{ .name = "ta_i", .get = &get_var_ta_i },	/* tab header iterator: fields .c - count,  .s - colspan, .a - ID of the action(command), .n - name, 
+											.o-onclick - for confirmation purposes, .m - confirmation message */
+	{ .name = NULL, },
+};
+
+/* profile data var - view, edit, add, log(view) */
+static const char *get_var_pr(char *field);
+static wc_tpl_var_t pr_var = {	
+	.name = "pr", .get = get_var_pr,
+};
+
+static const char *get_var_ldr(char *field);
+static wc_tpl_var_t ldr_var = {	
+	.name = "ldr", .get = get_var_ldr,
+};
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+/* profile data var - edit, add - now for GPRS only - modem settings */
+static const char *get_var_def(char *field);
+static wc_tpl_var_t def_var = {	
+	.name = "def", .get = get_var_def,
+};
+#endif
+
+/* local methods */
+static int get_current_settings(wc_page_data_t *data);
+static int apply_new_settings(wc_page_data_t *data);
+
+static void process_log_output_request(void);
+static void process_log_delete_request(void);
+static int ppp_profile_exists(const char *name);
+/* scan /etc/ppp/peers/ and count profiles of selected types, alloc memory for profiles,
+ * scan the dir again and read profiles' names,
+ * for each name read profile and get its connection status
+ */
+static void ppp_profile_list(void);
+/* read options, wc, chat, check name in AUTO list got previously from /etc/network.conf */
+static int ppp_profile_read(const char *name, ppp_profile *profile, int full);
+/* look for /var/run/network/<name>.gprs|vpn.if or <name>.gprs|vpn.starting (pid of the main pppd) */
+static void ppp_profile_get_cinfo(const char *name, connection_info *cinfo);
+static int ppp_profile_delete(ppp_profile *profile);
+/* profile can be NULL, if NULL - get profile form request */
+static int ppp_profile_add(ppp_profile *profile, int edit);
+static int ppp_profile_edit(ppp_profile *profile);
+static int ppp_profile_secrets_edit(ppp_profile *profile, int clean);
+
+static void compile_profile_identity(char *buf, const char *name, 
+								profile_identity_type id_type);
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static int is_gprs_running(void);
+#endif
+static int is_ip_addr(const char *s);
+static char *token(char *str, char **save_ptr, size_t *plen, char *pdelim);
+
+/* inline methods */
+static inline const char *get_ppp_auto_var(void)
+{
+	const char *auto_var = NULL;
+#ifdef WC_CONFIG_MENU_NET_GPRS
+#ifndef WC_CONFIG_NO_AUTO_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		auto_var = CFG_AUTO_GPRS;
+	}
+#endif
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		auto_var = CFG_AUTO_VPN;
+	}
+#endif
+	return auto_var;
+}
+static inline size_t get_ppp_auto_var_len(void)
+{
+	size_t len = 0;
+#ifdef WC_CONFIG_MENU_NET_GPRS
+#ifndef WC_CONFIG_NO_AUTO_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		len = sizeof(CFG_AUTO_GPRS) - 1;
+	}
+#endif
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		len = sizeof(CFG_AUTO_VPN) - 1;
+	}
+#endif
+	return len;
+}
+
+/* returns ptr to the constant filename string or NULL */
+static inline const char *get_ppp_secrets_file(void)
+{
+	const char *secrets_file = NULL;
+	
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		secrets_file = PPP_SECRETS_PAP_FILE;
+	}
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		secrets_file = PPP_SECRETS_CHAP_FILE;
+	}
+#endif
+
+	return secrets_file;
+}
+
+/* --- Command handlers --- */
+
+static void do_cmd_readlog(char *arg)
+{
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+	char chunk[256];
+	FILE *fp;
+	int r;
+	ssize_t count;
+
+	if (ppp.mode != PPP_MODE_LOG) {
+		return;
+	}
+
+	path_len = sizeof(PPP_LOG_DIR);
+	strcpy(path_buf, PPP_LOG_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], ppp.o_profile.name, PIT_LOG_FILE);
+
+	//dbg_console("%s: called, read from: %s\n", __func__, path_buf);
+	/* read log file and output it to browser */
+	fp = fopen(path_buf, "r");
+	if (fp) {
+		while (!feof(fp)) {
+			count = fread(chunk, 1, sizeof(chunk), fp);
+			if (count > 0)  {
+				r = fwrite(chunk, count, 1, cgiOut);
+				//dbg_console("read and written %d bytes from offs=%d: %d\n", count, ppp.log_offs, r);
+			}
+			if (count < sizeof(chunk)) {
+				//dbg_console("read not whole buf - stop\n");
+				break;
+			}
+		}
+		fclose(fp);
+	} else {
+		//dbg_console("open failed\n");
+	}
+}
+
+/* --- Var handlers --- */
+
+static const char *get_var_ppp(char *field)
+{
+	if (!field) {
+		return ppp.type_name;
+	}
+
+	switch (*field) {
+		case 'm':
+			ppp.pdata->val_buf[0] = 0x30 + ppp.mode;
+			ppp.pdata->val_buf[1] = 0;
+			return ppp.pdata->val_buf;
+			break;
+		case 'a':	/* auto-start enabled? */
+			return ppp.flags.auto_start_enabled ? "1" : "0";
+			break;
+		default:
+			break;
+	}
+	return NULL;
+}
+static int action_name_to_id(const char *name)
+{
+	int i;
+	for (i = 0; i < PPP_CMD_COUNT; i++) {
+		if (!strcmp(ppp_actions[i].name, name)) {
+			return i;
+		}
+	}
+	return -1;
+}
+static const char *get_var_cmd(char *field)
+{
+	int cmd;
+	
+	if (!field) {
+		ppp.pdata->val_buf[0] = 0x30 + ppp.cmd;
+		ppp.pdata->val_buf[1] = 0;
+		return ppp.pdata->val_buf;
+	}
+
+	cmd = action_name_to_id(field);
+	if (cmd < 0) {
+		return NULL;
+	}
+	
+	/* next code is valid while action id is 1 digit */
+	ppp.pdata->val_buf[0] = 0x30 + cmd;
+	ppp.pdata->val_buf[1] = 0;
+
+	return ppp.pdata->val_buf;
+}
+
+static const char *get_var_th_i(char *field)
+{
+	int index;
+
+	if (!field) {
+		return NULL;
+	}
+
+	if (!ppp.th) {
+		return NULL;
+	}
+
+	if (*field == 'c') {
+		sprintf(ppp.pdata->val_buf, "%d", ppp.th_count);
+		return ppp.pdata->val_buf;
+	}
+
+	index = wc_loop_ctx.counter[0];	/* TH_I - 1st level */
+	if (index >= ppp.th_count) {
+		index = 0;
+	}
+
+	switch (*field) {
+		case 's':
+			if (ppp.th[index].colspan > 1) {
+				sprintf(ppp.pdata->val_buf, " colspan=\"%d\"", ppp.th[index].colspan);
+				return ppp.pdata->val_buf; 
+			}
+			return "";
+			break;
+		case 't':
+			return ppp.th[index].title;
+			break;
+	}
+
+	return NULL;
+}
+
+static const char *get_var_tdr_i(char *field)
+{
+	int row_id;
+	ppp_profile *p;
+
+	if (!field) {
+		return NULL;
+	}
+
+	if (*field == 'c') {
+		sprintf(ppp.pdata->val_buf, "%d", ppp.profiles_count);
+		return ppp.pdata->val_buf;
+	}
+
+	row_id = wc_loop_ctx.counter[0];	/* TDR_I - 1st level */
+	if (row_id >= ppp.profiles_count) {
+		return NULL;
+	}
+
+	p = &ppp.profiles[row_id];
+	
+	if (*field == 'i') {
+		return p->name;
+	}
+
+	return NULL;
+}
+static const char *get_var_td_i(char *field)
+{
+	int td_count;
+	int row_id, data_id;
+	ppp_profile *p;
+	
+	if (!field) {
+		return NULL;
+	}
+
+	td_count = ppp.th_count - 1; /* 'Action' is not included */
+		
+	if (*field == 'c') {
+		sprintf(ppp.pdata->val_buf, "%d", td_count);
+		return ppp.pdata->val_buf;
+	}
+
+	if (*field == 'v') {
+		row_id = wc_loop_ctx.counter[0];	/* TDR_I - 1st level */
+		data_id = wc_loop_ctx.counter[1];	/* TD_I - 2nd level */
+		if (row_id >= ppp.profiles_count) {
+			return NULL;
+		}
+
+		p = &ppp.profiles[row_id];
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		if (ppp.type == PPP_TYPE_GPRS) {
+			switch (data_id) {
+				case 0:
+					return p->name;
+					break;
+				case 1:
+					return p->t.gprs.port;
+					break;
+				case 2:
+					if (p->t.gprs.flags.static_ip) {
+						return p->t.gprs.static_ip;
+					} else {
+						return WC_STR_DYNAMIC;
+					}
+					break;
+				case 3:
+					return p->flags.auth ? p->login : WC_STR_NO_AUTH;
+					break;
+#ifndef WC_CONFIG_NO_AUTO_GPRS
+				case 4:
+					return p->flags.auto_start ? WC_STR_YES : WC_STR_NO;
+					break;
+#endif
+					
+				default:
+					break;
+			}
+		}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+		if (ppp.type == PPP_TYPE_VPN) {
+			switch (data_id) {
+				case 0:
+					return p->name;
+					break;
+				case 1:
+					return p->t.vpn.srv_addr;
+					break;
+				case 2:
+					return p->flags.auth ? p->login : WC_STR_NO_AUTH;
+					break;
+				case 3:
+					sprintf(ppp.pdata->val_buf, "%s/%s", p->t.vpn.vpn_addr, p->t.vpn.vpn_mask);
+					return ppp.pdata->val_buf;
+					break;
+				case 4:
+					return p->flags.auto_start ? WC_STR_YES : WC_STR_NO;
+					break;
+					
+				default:
+					break;
+			}
+		}
+#endif /* WC_CONFIG_MENU_NET_VPN */
+
+	}
+
+	return NULL;
+}
+static const char *get_var_ta_i(char *field)
+{
+	ppp_profile *p;
+	int row_id, act_index;
+	int running;
+	int count;
+
+	int colspan = 0;
+	ppp_action *act = NULL;
+
+	if (!field) {
+		return NULL;
+	}
+
+	row_id = wc_loop_ctx.counter[0];	/* TDR_I - 1st level */
+	act_index = wc_loop_ctx.counter[1];	/* TA_I - 2nd level */
+	if (row_id >= ppp.profiles_count) {
+		return NULL;
+	}
+
+	p = &ppp.profiles[row_id];
+	running = (p->cinfo.if_pid > 0) || (p->cinfo.starting_pid > 0);
+	count = running ? 3 : 4;
+
+	if (*field == 'c') {
+		sprintf(ppp.pdata->val_buf, "%d", count);
+		return ppp.pdata->val_buf;
+	}
+
+	if (act_index >= count) {
+		return NULL;	/* wrong index */
+	}
+
+	/* actions:
+	 * running     :View(2), Stop, Log 
+	 * not running: Edit, Del, Start, Log
+	 */
+	if (running) {
+		switch (act_index) {
+			case 0:
+				act = &ppp_actions[PPP_CMD_VIEW];
+				colspan = 2;
+				break;
+			case 1:
+				act = &ppp_actions[PPP_CMD_STOP];
+				break;
+			case 2:
+				act = &ppp_actions[PPP_CMD_LOG];
+				break;
+		}
+	} else {
+		switch (act_index) {
+			case 0:
+				act = &ppp_actions[PPP_CMD_EDIT];
+				break;
+			case 1:
+				act = &ppp_actions[PPP_CMD_DEL];
+				break;
+			case 2:
+#ifdef WC_CONFIG_MENU_NET_GPRS
+				if (ppp.type == PPP_TYPE_GPRS && ppp.running_count) {
+					act = NULL; /* disabled */
+				} else {
+#endif
+					act = &ppp_actions[PPP_CMD_START];
+#ifdef WC_CONFIG_MENU_NET_GPRS
+				}
+#endif
+				break;
+			case 3:
+				act = &ppp_actions[PPP_CMD_LOG];
+				break;
+		}
+	}
+
+	switch (*field) {
+		case 'e':
+			return act ? "1" : "0";
+		case 'n':
+			return act ? act->title : NULL;
+			break;
+		case 's':
+			if (colspan > 1) {
+				sprintf(ppp.pdata->val_buf, " colspan=\"%d\"", colspan);
+				return ppp.pdata->val_buf; 
+			}
+			return "";
+			break;
+		case 'a':
+			sprintf(ppp.pdata->val_buf, "%d", act ? act->cmd : 0);
+			return ppp.pdata->val_buf;
+			break;
+		case 'o':
+			if (act) {
+				if (act->confirm_fmt) {
+					return "confirm";
+				}
+				if (act->popup) {
+					return "popup";
+				}
+			} 
+			return "0";
+			break;
+		case 'm':
+			if (act && act->confirm_fmt) {
+				sprintf(ppp.pdata->val_buf, act->confirm_fmt, WC_STR_CONFIRM_PREFIX, 
+						p->name);
+				return ppp.pdata->val_buf; 
+			}
+			return "";
+			break;
+	}
+
+	return NULL;
+}
+
+static const char *get_var_pr(char *field)
+{
+	ppp_profile *p;
+
+	if (!field) {
+		return NULL;
+	}
+
+	p = &ppp.o_profile;
+
+	if (!strcmp(field, "iid")) {
+		return p->name;
+	} else if (!strcmp(field, "ln")) {
+		return p->login;
+	} else if (!strcmp(field, "pwd")) {
+		return p->pwd;
+	} else if (!strcmp(field, "as")) {
+		if (!ppp.flags.auto_start_enabled) {
+			return NULL;
+		}
+		if (ppp.cmd == PPP_CMD_VIEW) {
+			return p->flags.auto_start ? WC_STR_YES : WC_STR_NO;
+		} else {
+			return p->flags.auto_start ? " checked" : "";
+		}
+	} else if (!strcmp(field, "state")) {
+		int pid = 0;
+		if (p->cinfo.if_pid > 0) {
+			pid = p->cinfo.if_pid;
+		} else if (p->cinfo.starting_pid > 0) {
+			pid = p->cinfo.starting_pid;
+		}
+
+		if (pid > 0) {
+			sprintf(ppp.pdata->val_buf, "%s: %s (%d)", WC_STR_RUN,
+					p->cinfo.if_name, pid);
+			return ppp.pdata->val_buf; 
+		}
+		return WC_STR_NRUN;
+	}
+		
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type ==  PPP_TYPE_GPRS) {
+		if (!strcmp(field, "port")) {
+			return p->t.gprs.port;
+		} else if (!strcmp(field, "br")) {
+			sprintf(ppp.pdata->val_buf, "%d", p->t.gprs.speed);
+			return ppp.pdata->val_buf;
+		} else if (!strcmp(field, "hwf")) {
+			if (ppp.cmd == PPP_CMD_VIEW) {
+				return p->t.gprs.flags.hw_flow ? WC_STR_YES : WC_STR_NO;
+			} else {
+				return p->t.gprs.flags.hw_flow ? " checked" : "";
+			}
+		} else if (!strcmp(field, "ip")) {
+			return p->t.gprs.flags.static_ip ? p->t.gprs.static_ip : "";
+		} else if (!strcmp(field, "ipd")) {
+			return p->t.gprs.flags.static_ip ? "" : " checked";
+		} else if (!strcmp(field, "pin")) {
+			return p->t.gprs.sim_pin;
+		} else if (!strcmp(field, "is")) {
+			return p->t.gprs.modem_init_string;
+		} else if (!strcmp(field, "apn")) {
+			return p->t.gprs.apn;
+		} else if (!strcmp(field, "cn")) {
+			return p->t.gprs.call_number;
+		} else if (!memcmp(field, "br.", 3)) {
+			int index;
+			int count;
+			
+			field += 3;
+			count = sizeof(br_values) / sizeof(br_values[0]);
+
+			if (*field == 'c') {
+				sprintf(ppp.pdata->val_buf, "%d", count);
+				return ppp.pdata->val_buf;
+			}
+
+			index = wc_loop_ctx.counter[0];
+			if (index >= count) {
+				return NULL;
+			}
+			
+			switch (*field) {
+				case 's':
+					if (br_values[index] == p->t.gprs.speed) {
+						return " selected";
+					}
+					return "";
+					break;
+					
+				case 'v':
+					if (!br_values[index]) {
+						return "";
+					}
+					sprintf(ppp.pdata->val_buf, "%d", br_values[index]);
+					return ppp.pdata->val_buf;
+					break;
+			}
+		}
+	}
+#endif	/* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		if (!strcmp(field, "vs")) {
+			return p->t.vpn.srv_addr;
+		} else if (!strcmp(field, "vn")) {
+			return p->t.vpn.vpn_addr;
+		} else if (!strcmp(field, "vm")) {
+			return p->t.vpn.vpn_mask;
+		}
+	}
+#endif	/* WC_CONFIG_MENU_NET_VPN */
+
+	return NULL;
+}
+
+static const char *get_var_ldr(char *field)
+{
+	return ppp.flags.log_del_req ? "1" : "0";
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static const char *get_var_def(char *field)
+{
+	if (!field) {
+		return NULL;
+	}
+
+	if (!strcmp(field, "port")) {
+#ifdef WC_CONFIG_MODEM_PORT
+		return WC_CONFIG_MODEM_PORT;
+#else
+		return "";
+#endif
+	} else if (!strcmp(field, "br")) {
+#ifdef WC_CONFIG_MODEM_SPEED
+		int index = get_br_index(WC_CONFIG_MODEM_SPEED);
+		sprintf(ppp.pdata->val_buf, "%d", index);
+		return ppp.pdata->val_buf;
+#else
+		return "0";
+#endif
+	} else if (!strcmp(field, "hwf")) {
+#ifdef WC_CONFIG_MODEM_HW_FLOW
+		return "1";
+#else
+		return "0";
+#endif
+	}
+	return NULL;
+}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+/* --- Interface methods --- */
+
+void wc_net_ppp_process(wc_page_data_t *data, int submitted)
+{
+//	int i;
+	size_t len;
+
+	/* setup data */
+	memset(&ppp, 0, sizeof(ppp));
+	ppp.pdata = data;
+
+	/* determine profile(page) type from sub page name */
+	ppp.type = PPP_TYPE_UNKNOWN;
+
+#ifdef WC_CONFIG_MENU_NET_GPRS	
+	if (!strcmp(data->sub_name, WC_NET_SP_NAME_GPRS)) {
+		ppp.th = th_gprs;
+		ppp.th_count = th_count_gprs;
+		ppp.type = PPP_TYPE_GPRS;
+		ppp.type_name = WC_NET_SP_NAME_GPRS;
+		ppp.type_name_len = strlen(ppp.type_name);
+
+#ifdef WC_CONFIG_NO_AUTO_GPRS
+		ppp.flags.auto_start_enabled = 0;
+#else
+		ppp.flags.auto_start_enabled = 1;
+#endif
+	}
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_UNKNOWN) {
+		if (!strcmp(data->sub_name, WC_NET_SP_NAME_VPN)) {
+			ppp.th = th_vpn;
+			ppp.th_count = th_count_vpn;
+			ppp.type = PPP_TYPE_VPN;
+			ppp.type_name = WC_NET_SP_NAME_VPN;
+			ppp.type_name_len = strlen(ppp.type_name);;
+			ppp.flags.auto_start_enabled = 1;
+		}
+	}
+#endif
+
+	if (ppp.type == PPP_TYPE_UNKNOWN) {
+		sprintf(data->status_buf, "Error: unsupported PPP type: %s", data->sub_name);
+		return;
+	}
+
+	/* get command */
+
+	/* process request and determine display mode (default is LIST) */
+
+	/* get command and pre-set current mode */
+	cgiFormInteger(HVAR_PPP_CMD, (int*)&ppp.cmd, PPP_CMD_LIST);
+
+	/* set default mode, in case no submission occurred */
+	switch (ppp.cmd) {
+		case PPP_CMD_ADD:
+			ppp.mode = PPP_MODE_ADD;
+			break;
+		case PPP_CMD_EDIT:
+			ppp.mode = PPP_MODE_EDIT;
+			break;
+		case PPP_CMD_VIEW:
+			ppp.mode = PPP_MODE_VIEW;
+			break;
+		case PPP_CMD_LOG:
+			{
+				cgiFormResultType cgi_r;
+				ppp.mode = PPP_MODE_LOG;	/* popup mode or plain/text output*/
+				cgi_r = cgiFormInteger(HVAR_LOG_OFFS, &ppp.log_offs, 0);
+				if (cgi_r == cgiFormSuccess) {
+					ppp.pdata->ct_id = WC_CT_TEXT;	/* will output TEXT instead of HTML */
+					ppp.flags.out_plain_log = 1;
+				}
+			}			
+			break;
+		default:
+			ppp.mode = PPP_MODE_LIST;
+			break;
+	}
+
+	if (ppp.cmd != PPP_CMD_LIST) {
+		/* get name (ID) of the item */
+		cgiFormString(HVAR_PPP_ITEM_ID, ppp.o_profile.name, sizeof(ppp.o_profile.name));
+	}
+
+	if (ppp.flags.out_plain_log) {
+		/* nothing to do more - out put plain log on post_process stage */
+		return;
+	}
+
+	if (submitted) {
+		/* Get data from the request and process it.
+		 * Data can be submitted by ADD, EDIT and LOG popup's forms,
+		 * also it can look like submitted by set=1 from commands DEL, START, STOP
+		 * Anyway, after request is processed, mode is set to LIST (except the case when mode is LOG)
+		 */
+		apply_new_settings(data);
+		if (ppp.mode != PPP_MODE_LOG) {
+			ppp.mode = PPP_MODE_LIST;
+		}
+	}
+
+	if (ppp.mode != PPP_MODE_LOG) {
+		/* -- prepare display info  - mode can be changed, so vars are registered later */
+		get_current_settings(data);
+	}
+
+	/* According to type and mode ... */
+	/* -- register vars and specify display info*/
+
+	wc_tpl_vars_register(common_vars);
+
+	switch (ppp.mode) {
+		case PPP_MODE_LIST:
+			wc_tpl_vars_register(list_vars);
+			break;
+		case PPP_MODE_VIEW:
+			wc_tpl_var_register(&pr_var);
+			wc_form_enable(WC_FBA_RIGHT, &wc_btn_back, NULL, NULL);
+			break;
+		case PPP_MODE_ADD:
+			wc_tpl_var_register(&pr_var);
+#ifdef WC_CONFIG_MENU_NET_GPRS
+			wc_tpl_var_register(&def_var);
+#endif
+			wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, &wc_btn_reset, &wc_btn_cancel);
+			break;
+		case PPP_MODE_EDIT:
+			wc_tpl_var_register(&pr_var);
+#ifdef WC_CONFIG_MENU_NET_GPRS
+			wc_tpl_var_register(&def_var);
+#endif
+			wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, &wc_btn_reset, &wc_btn_cancel);
+			break;
+		case PPP_MODE_LOG:
+			wc_tpl_var_register(&pr_var);
+			wc_tpl_cmd_register(&readlog_cmd);
+			wc_tpl_var_register(&ldr_var);
+			wc_form_enable(WC_FBA_CENTER, &wc_btn_close, NULL, NULL);
+			data->flags.popup_tpl = 1;
+			data->flags.subm_en = 0;
+			break;
+		default:
+			break;
+	}
+
+	if (ppp.mode == PPP_MODE_LOG) {
+		sprintf(data->form_title, "%s - %s  (%s)",
+			WC_STR_PPP_LOG_VIEW_TITLE, ppp.o_profile.name, ppp.type_name);
+	} else {
+		len = strlen(data->form_title);
+		strcpy(&data->form_title[len], " - ");
+		len += 3;
+		strcpy(&data->form_title[len], ppp_mode_titles[ppp.mode]);
+	}
+}
+
+void wc_net_ppp_post_process(wc_page_data_t *data)
+{
+	process_log_output_request();
+
+	if (ppp.profiles) {
+		free(ppp.profiles);
+		ppp.profiles = NULL;
+	}
+}
+
+/* --- local subroutines --- */
+
+static int read_network_conf_var(char *var, char *val, void *data);
+static int get_current_settings(wc_page_data_t *data)
+{
+	int r = 0;
+
+	/* need not clear o_profile field, because if it was used (which is possible for submitting
+	* after add/edit/del/start/stop) then display mode is LIST, so o_profile is not used, 
+	* otherwise when it was not used (no submission) it is still clear.
+	* In any case o_profile->name is set for !LIST mode from the request
+	*/
+
+	/* read main config - _AUTO only, so skip this step if auto start is not allowed */
+	if (ppp.flags.auto_start_enabled) {
+		wc_conf_file_read(NET_CONFIG_FILE, &read_network_conf_var, NULL);
+		//dbg_console("%s: ppp_auto: '%s'\n", __func__, ppp.ppp_auto);
+	}
+
+	switch (ppp.mode) {
+		case PPP_MODE_EDIT:
+			r = ppp_profile_read(ppp.o_profile.name, &ppp.o_profile, 1);
+			break;
+		case PPP_MODE_VIEW:
+			r = ppp_profile_read(ppp.o_profile.name, &ppp.o_profile, 1);
+			if (!r) {
+				ppp_profile_get_cinfo(ppp.o_profile.name, &ppp.o_profile.cinfo);
+			}
+			//dbg_console("pid=%d, starting_pid=%d\n", ppp.o_profile.cinfo.if_pid,
+			//	ppp.o_profile.cinfo.starting_pid);
+			break;
+		default:
+			break;
+	}
+
+	/* if profile was not able to be read (for EDIT/VIEW), then fall back to LIST mode,
+	* respective error message is set by failed function ppp_profile_read()
+	*/
+	if (r) {
+		ppp.mode = PPP_MODE_LIST;
+	}
+
+	switch (ppp.mode) {
+		case PPP_MODE_LIST:
+			ppp_profile_list();
+			break;
+		case PPP_MODE_ADD:
+			/* do nothing - empty profile data - adding new */
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+static int apply_new_settings(wc_page_data_t *data)
+{
+	ppp_profile *p;
+	int pid = 0;
+	int r = 0;
+	char sys_cmd[256];
+	char call_name[PR_CALL_NAME_MAX_LEN];
+
+	p = &ppp.o_profile;
+
+	/* get connection status for some commands */
+	if (ppp.cmd == PPP_CMD_EDIT ||
+		ppp.cmd == PPP_CMD_DEL ||
+		ppp.cmd == PPP_CMD_START ||
+		ppp.cmd == PPP_CMD_STOP ||
+		ppp.cmd == PPP_CMD_LOG) {
+
+		if (!p->name[0]) {
+			/* broken WC? or somebody specified url manually - ignore request */
+			sprintf(ppp.err_reason, WC_STR_RSN_CANT_IDENTIFY);
+			r = -EINVAL;
+		}
+
+		if (!r && (ppp.cmd != PPP_CMD_LOG)) {
+			ppp_profile_get_cinfo(p->name, &p->cinfo);
+			if (p->cinfo.if_pid > 0) {
+				pid = p->cinfo.if_pid;
+			} else {
+				pid = p->cinfo.starting_pid;
+			}
+		}
+	}
+
+	/* perform requested operation */
+	switch (ppp.cmd) {
+		case PPP_CMD_ADD:
+			if (!r) {
+				r = ppp_profile_add(NULL, 0);
+			}
+			if (r) {
+				sprintf(ppp.pdata->status_buf, WC_STR_ERR_PPP_ADD, ppp.err_reason);
+				return -1;
+			}
+			break;
+			
+		case PPP_CMD_EDIT:
+			if (!r) {
+				if (pid > 0) {
+					sprintf(ppp.err_reason, WC_STR_RSN_CONN_ACTIVE);
+					r = -EINVAL;
+				} else {
+					r = ppp_profile_edit(p);
+				}
+			}
+			if (r) {
+				sprintf(ppp.pdata->status_buf, WC_STR_ERR_PPP_EDIT, p->name, ppp.err_reason);
+				return -1;
+			}
+			break;
+			
+		case PPP_CMD_DEL:
+			if (!r) {
+				if (pid > 0) {
+					sprintf(ppp.err_reason, WC_STR_RSN_CONN_ACTIVE);
+					r = -EINVAL;
+				} else {
+					r = ppp_profile_delete(p);
+				}
+			}
+			if (r) {
+				sprintf(ppp.pdata->status_buf, WC_STR_ERR_PPP_DEL, p->name, ppp.err_reason);
+				return -1;
+			}
+			break;
+			
+		case PPP_CMD_START:
+			if (!r) {
+				do {
+					if (pid > 0) {
+						sprintf(ppp.err_reason, WC_STR_RSN_ALREADY_RUNNING);
+						r = -EINVAL;
+						break;
+					}
+					if (!ppp_profile_exists(p->name)) {
+						sprintf(ppp.err_reason, WC_STR_RSN_PROFILE_NEXIST);
+						r = -EINVAL;
+						break;
+					}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+					if ((ppp.type == PPP_TYPE_GPRS) && is_gprs_running()) {
+						sprintf(ppp.err_reason, WC_STR_RSN_OTHER_GPRS_RUNNING);
+						r = -EINVAL;
+						break;
+					}
+#endif
+				} while (0);
+			}
+			if (r) {
+				sprintf(ppp.pdata->status_buf, WC_STR_ERR_PPP_START, p->name, ppp.err_reason);
+				return -1;
+			}
+
+			compile_profile_identity(call_name, p->name, PIT_CALL_NAME);
+			sprintf(sys_cmd, 
+				"sh -c \"PATH=/sbin/:$PATH; %s/rc.net startppp %s\" > /dev/null 2>&1 &",
+				RC_NET_DIR, call_name);
+			
+			system(sys_cmd);
+
+			sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_STARTING, p->name);
+			data->flags.cntdn = 1;
+			break;
+			
+		case PPP_CMD_STOP:
+			if (!r) {
+				do {
+					if (!(pid > 0)) {
+						sprintf(ppp.err_reason, WC_STR_RSN_NOT_RUNNING);
+						r = -EINVAL;
+						break;
+					}
+					if (!ppp_profile_exists(p->name)) {
+						sprintf(ppp.err_reason, WC_STR_RSN_PROFILE_NEXIST);
+						r = -EINVAL;
+						break;
+					}
+				} while (0);
+			}
+			if (r) {
+				sprintf(ppp.pdata->status_buf, WC_STR_ERR_PPP_STOP, p->name, ppp.err_reason);
+				return -1;
+			}
+
+			compile_profile_identity(call_name, p->name, PIT_CALL_NAME);
+			sprintf(sys_cmd, 
+				"sh -c \"PATH=/sbin/:$PATH; %s/rc.net stopppp %s\" > /dev/null 2>&1 &",
+				RC_NET_DIR, call_name);
+			
+			system(sys_cmd);
+
+			sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_STOPPING, p->name);
+			data->flags.cntdn = 1;
+			break;
+
+		case PPP_CMD_LOG:
+			ppp.flags.log_del_req = 1;
+			if (!r) {
+				process_log_delete_request();
+			}
+			break;
+
+		default:
+			/* other commands ashould not be 'submitted' */
+			return -1;
+			break;
+	}
+
+	return r;
+}
+
+static int read_network_conf_var(char *var, char *val, void *data)
+{
+	size_t len;
+	len = strlen(val);
+	const char *auto_var;
+
+	auto_var = get_ppp_auto_var();
+	if (!auto_var) {
+		return 0;	/* no sence to read further */
+	}
+	
+	if (!strcmp(var, auto_var)) {
+		/* read the value, cut as need */
+		wc_strncpy(ppp.ppp_auto, sizeof(ppp.ppp_auto), val, strlen(val));
+	}
+	/* TODO: return 0 ? stop parsing more ?*/
+	return 1;
+}
+
+/* callback for profile directory entry 
+ * data - data passed to the callback
+ * return 0 - continue scanning, !0 - stop scanning
+ */
+typedef int (*item_cb)(const char *name, void *data);
+
+/* return 1 - call item_cb for the entry, 0 - filter off the item */
+typedef int (*filter_cb)(const char *name);
+
+int count_to_first(const char *name, void *data)
+{
+	int *pcounter = (int*)data;
+	(*pcounter)++;
+	return -1;
+}
+
+/* data is a pointer to integer counter */
+int count_profiles(const char *name, void *data)
+{
+	int *pcounter = (int*)data;
+	(*pcounter)++;
+	return 0;
+}
+
+int get_profiles_names(const char *name, void *data)
+{
+	int *pindex = (int*)data;
+
+	/* -too long names are filtered out by scanning procedure 
+	 * 		so copy the name w/o additional checking
+	 *  - name is copied w/o extension
+	 */
+	if (*pindex < ppp.profiles_count) {
+		char *p = strchr(name, '.');
+		if (p) {
+			memcpy(ppp.profiles[*pindex].name, name, p - name);
+			ppp.profiles[*pindex].name[p - name] = 0;
+			(*pindex)++;
+		}
+	}
+	
+	return *pindex < ppp.profiles_count ? 0 : -1;	/* continue or stop scanning respectively */
+}
+
+/* buf should be of size at least PPP_IDENTITY_MAX_SIZE */
+static void compile_profile_identity(char *buf, const char *name, 
+								profile_identity_type id_type)
+{
+	if (id_type >= PIT_COUNT) {
+		buf[0] = 0; /* empty */
+	} else {
+		sprintf(buf, profile_identity_tpl[id_type], name, ppp.type_name);
+	}
+}
+
+static int filter_profiles(const char *name)
+{
+	char *p;
+	
+	p = strrchr(name, '.');
+	if (!p) {
+		return 0;
+	}
+	
+	if (!strcmp(p + 1, ppp.type_name)) {
+		/* found a profile */
+
+		/* filter out profiles with too long names */
+		if (p - name > PR_NAME_MAX_LEN) {
+			return 0;
+		}
+
+		return 1;
+	}
+	
+	return 0;
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static int filter_gprs_flags(const char *name)
+{
+	char *p;
+	
+	p = strchr(name, '.');
+	if (!p) {
+		return 0;
+	}
+
+	if (!strcmp(p + 1, "gprs.if") || !strcmp(p + 1, "gprs.starting")) {
+		return 1;
+	}
+		
+	return 0;
+}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+/* note: uses path_buf */
+/* filters off: ., .., subdirs, not regular files, files w/o extension */
+static int scan_dir(const char *dir_path, filter_cb filter, item_cb cb, void *data)
+{
+	int r;
+	DIR *dir;
+	struct dirent entry;
+	struct dirent *pentry;
+	size_t dir_len;
+	struct stat sbuf;
+	char path_buf[WC_PATH_MAX];
+
+	dir = opendir(dir_path);
+	if (!dir) {
+		return -1;	/* failed to open dir with profiles */
+	}
+
+	dir_len = strlen(dir_path);
+	memcpy(path_buf, dir_path, dir_len);
+	path_buf[dir_len++] = '/';
+
+	do {
+		r = readdir_r(dir, &entry, &pentry);
+		if (r) {
+			/* err */
+			closedir(dir);
+			return -errno;
+		}
+		
+		if (!pentry) {
+			/* end of dir */
+			break;
+		}
+
+		if (pentry->d_name[0] == '.') {
+			continue;
+		}
+		
+		/* check if it is a file */
+		strcpy(&path_buf[dir_len], pentry->d_name);
+		r = stat(path_buf, &sbuf);
+		if (r) {
+			/* skip the item */
+			r = 0;
+			continue;
+		}
+
+		/* profile file can be a link to reg file but not directory or special file */
+		if (!S_ISREG(sbuf.st_mode)) {
+			continue;	/* is not regular file */
+		}
+
+		if (filter(pentry->d_name)) {
+			r = cb(pentry->d_name, data);
+		}
+	} while (!r);
+
+	closedir(dir);
+	return 0;
+}
+
+/* 0 - doesn't exist, 1 - exists; errors -> 0 as well */
+static int ppp_profile_exists(const char *name)
+{
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+	struct stat sbuf;
+	int r;
+
+	path_len = sizeof(PPP_PROFILES_DIR);
+	strcpy(path_buf, PPP_PROFILES_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], name, PIT_MAIN_FILE);
+
+	r = stat(path_buf, &sbuf);
+	if (r) {
+		return 0;
+	}
+
+	/* profile file can be a link to reg file but not directory or special file */
+	if (!S_ISREG(sbuf.st_mode)) {
+		return 0;
+	}
+
+	return 1;
+}
+
+/* scan /etc/ppp/peers/ and count profiles of selected types, alloc memory for profiles,
+ * scan the dir again and read profiles' names,
+ * for each name read profile and get its connection status
+ */
+static void ppp_profile_list(void)
+{
+	int i;
+
+	/* count profiles of current type, ignore errors */
+	i = 0;
+	scan_dir(PPP_PROFILES_DIR, &filter_profiles, &count_profiles, &i);
+
+	if (!i) {
+		return;	/* may be no profiles defined */
+	}
+
+	ppp.profiles = malloc(i * sizeof(ppp_profile));
+	if (!ppp.profiles) {
+		sprintf(ppp.pdata->status_buf, "Error: not enough memory to list profiles\n");
+		return;
+	}
+	ppp.profiles_count = i;
+	memset(ppp.profiles, 0, ppp.profiles_count * sizeof(ppp_profile));
+
+	/* read all profiles' names, 'i' is current index */
+	i = 0;
+	scan_dir(PPP_PROFILES_DIR, &filter_profiles, &get_profiles_names, &i);
+
+	/* read profiles data */
+	ppp.running_count = 0;
+	for (i = 0; i < ppp.profiles_count; i++) {
+		int r;
+		ppp_profile *p = &ppp.profiles[i];
+		//dbg_console("process profile: %d: '%s'", i, p->name);
+		/* for each profile read its data */
+		r = ppp_profile_read(p->name, p, 0);
+		if (!r) {
+			/* for each profile detremine its  connection state */
+			ppp_profile_get_cinfo(p->name, &p->cinfo);
+			if (p->cinfo.if_pid > 0 || p->cinfo.starting_pid > 0) {
+				ppp.running_count++;
+			}
+		}
+	}
+}
+
+/* return -1 if name was not read (not running, not ready or broken file), 0 - name is got
+ */
+static int get_ppp_connection_if_name(const char *if_file, connection_info *cinfo)
+{
+	FILE *fp;
+	char *p;
+
+	fp = fopen(if_file, "r");
+	if (!fp) {
+		return -1;	/* name is not read */
+	}
+
+	p = fgets(cinfo->if_name, sizeof(cinfo->if_name), fp);
+	fclose(fp);
+
+	if (p) {
+		/* name read and is not empty */
+		/* fix name in case it ends with NL */
+		p = strrchr(cinfo->if_name, '\n');
+		if (p) {
+			*p = 0;
+		}
+	}
+
+	return cinfo->if_name[0] != 0 ? 0 : -1 ;
+}
+
+/* return 0 pid value - on error, > 0 pid value on success */
+static pid_t get_pid_from_file(const char *pid_file)
+{
+	FILE *fp;
+	int n;
+	int pid;
+
+	fp = fopen(pid_file, "r");
+	if (!fp) {
+		return 0;
+	}
+
+	n = fscanf(fp, "%d", &pid);
+	
+	fclose(fp);
+	
+	return (n == 1) ? pid : 0;
+}
+
+/* look for /var/run/network/<name>.gprs|vpn.if or <name>.gprs|vpn.starting (pid of the main pppd) */
+static void ppp_profile_get_cinfo(const char *name, connection_info *cinfo)
+{
+	int r;
+	size_t path_len = sizeof(NETWORK_RUN_DIR);
+	size_t len;
+	char path_buf[WC_PATH_MAX];
+
+	memset(cinfo, 0, sizeof(*cinfo));
+
+	strcpy(path_buf, NETWORK_RUN_DIR);
+	path_buf[path_len - 1] = '/';
+
+	/* read IF */
+	compile_profile_identity(&path_buf[path_len], name, PIT_RUN_IF_FILE);
+
+	r = get_ppp_connection_if_name(path_buf, cinfo);
+
+	if (!r) {
+		/* we have name of the interface, so get the pid */
+		path_len = sizeof(PPP_PID_DIR) - 1;
+		memcpy(path_buf, PPP_PID_DIR, path_len);	/* w/o terminating 0 */
+		path_buf[path_len++] = '/';
+
+		len = strlen(cinfo->if_name);
+		memcpy(&path_buf[path_len], cinfo->if_name, len);
+		path_len += len;
+		strcpy(&path_buf[path_len], ".pid");
+
+		cinfo->if_pid = get_pid_from_file(path_buf);
+	} else {
+		/* still is not running, try check whether or not it is starting */
+
+		/* read STARTING_EXT, note that path_len in this branch is still points to the end of the common dir name */
+		compile_profile_identity(&path_buf[path_len], name, PIT_STARTING_FLAG_FILE);
+
+		cinfo->starting_pid = get_pid_from_file(path_buf);
+	}
+}
+
+/* Note: assume that is login name and password are specified 
+* then such profile has own secret record. No password - no record.
+* - Disallow: * wildcard for <name>, <server> and <secret>
+* - Disallow: @<file reference> for <secret>
+* - A secret record should be:
+*    <login> <server(remotename)> <secret> *
+* - Allow: whitespaces, tabs, quotes (' and ")
+* - Disallow: backslash escaping 
+*/
+static int read_secrets_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	//dbg_console("%s: called for:'%s' (%d)\n", __func__, parse_data->line, parse_data->type);
+	if (parse_data->type == WC_CLT_WRONG) {
+		ppp_profile *profile = (ppp_profile *)data;
+		char *p, *t;
+		size_t len;
+
+		t = token(parse_data->val, &p, NULL, NULL);
+		if (!t || strcmp(t, profile->login)) {
+			return 1;	/* EOS (comment or empty string) OR not a candidate record - different login*/
+		}
+
+		t = token(NULL, &p, NULL, NULL);
+		if (!t || strcmp(t, profile->remote)) {
+			return 1;	/* EOS (comment or empty string) OR not a candidate record - different server*/
+		}
+
+		t = token(NULL, &p, &len, NULL);
+		if (!t) {
+			return 1;
+		}
+
+		/* copy password, truncate it as need */
+		wc_strncpy(profile->pwd, sizeof(profile->pwd), t, len);
+		return 0; /* stop reading more */
+	}
+	
+	return 1;
+}
+
+static int edit_secrets_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp;
+	ppp_sectret_data_t *sd = (ppp_sectret_data_t *)data;
+
+	fp = parse_data->fp_out;
+
+//	dbg_console("%s: called for:'%s' (%d)\n", __func__, parse_data->line, parse_data->type);
+	
+	if (parse_data->type == WC_CLT_CREATED ||
+		parse_data->type == WC_CLT_EOF) {
+		if (!sd->flags.clean && !sd->flags.edited && sd->name[0] && sd->pwd[0]) {
+			fprintf(fp, "%s\t%s\t%s\t*\n", sd->name, sd->remote, sd->pwd);
+		}
+		return 0;
+	}
+		
+	if (parse_data->type == WC_CLT_WRONG) {
+		char *f1, *f2;
+		size_t f1_len, f2_len;
+		char delim;
+		char *p;
+
+		do {
+			f1 = token(parse_data->val, &p, &f1_len, &delim);
+			if (!f1) {
+				break;	/* failed extract 1st field, or field is empty */
+			}
+			f1[f1_len] = delim;		/* string restored */
+
+			f2 = token(NULL, &p, &f2_len, &delim);
+			if (!f2) {
+				break;	/* failed extract 2nd field, or field is empty */
+			}
+			f2[f2_len] = delim;		/* string restored */
+
+			/* make sure that at least something is present after the 2nd field */
+			if (!delim) {
+				break;
+			}
+
+			if ((f2_len == strlen(sd->remote)) && !memcmp(f2, sd->remote, f2_len)) {
+				/* the record */
+				if (sd->flags.clean || sd->flags.edited) {
+					/* remove all lines matched <*><remote> when 'clean' or when at least one such line was 'edited' */
+					//dbg_console("%s: FOUND - removed\n", __func__);
+					return 1;
+				} else {
+					/* edit first only line matched <*><remote> */
+					if (sd->name[0] && sd->pwd[0]) {
+						fprintf(fp, "%s\t%s\t%s\t*\n", sd->name, sd->remote, sd->pwd);
+					} /* otherwise remove old secret */
+					sd->flags.edited = 1;
+					//dbg_console("%s: FOUND - edited\n", __func__);
+					return 1;
+				}
+			}
+		} while (0);
+	}
+
+	/* printf the rest lines unchanged */
+	fprintf(fp, "%s", parse_data->line);
+	return 1;
+}
+
+static int edit_network_conf_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	const char *auto_var;
+	size_t auto_var_len;
+	int single = 0;
+	ppp_profile *p = (ppp_profile *)data;
+	FILE *fp;
+
+	fp = parse_data->fp_out;
+
+	if (parse_data->type == WC_CLT_WRONG) {
+		return 1;	/* remove wrong lines */
+	}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		single = 1;
+	}
+#endif
+	auto_var = get_ppp_auto_var();
+	auto_var_len = get_ppp_auto_var_len();
+
+	if (auto_var && auto_var_len) {
+		if (parse_data->type == WC_CLT_CREATED ||
+			parse_data->type == WC_CLT_EOF) {
+			if (!p->flags.as_set) {
+				fprintf(fp, "%s=\"%s\"\n", auto_var, p->flags.auto_start ? p->name : "");
+			}
+			return 0;
+		}
+
+		if (parse_data->type == WC_CLT_VAR) {
+			if ((auto_var_len == parse_data->var_len) &&
+				!memcmp(auto_var, parse_data->var, parse_data->var_len)) {
+				int n;
+				char *ptr, *t, *s;
+				/* formed string: "(<space><name>)*" */
+				char auto_new[sizeof(ppp.ppp_auto) + 1]; /* +1 for starting space */
+				char *p_new;
+				
+				if (p->flags.as_set) {
+					return 1; /* remove possible duplicates */
+				}
+
+				p->flags.as_set = 1;
+				
+				/* if single auto-profile is possible, check first the current profile
+				* if it should be auto-started, add it and stop
+				*/
+				if (single && p->flags.auto_start) {
+					fprintf(fp, "%s=\"%s\"\n", auto_var, p->name);
+					p->flags.as_set = 1;
+					return 1;
+				}
+
+				/* copy list of auto-started profiles, truncate the list if it's too big */
+				wc_strncpy(ppp.ppp_auto, sizeof(ppp.ppp_auto), 
+							parse_data->val, parse_data->val_len);
+
+				//dbg_console("ppp_auto='%s'\n", ppp.ppp_auto);
+
+				/* split the list, for each item
+				* - skip if item's name is the same as current profile's one (processed later separately)
+				* - check if profile exists, drop the item if not
+				* - check if the item already included and drop duplicate
+				*/
+				n = 0;
+				s = ppp.ppp_auto;
+				p_new = auto_new;
+				*p_new = 0;
+				while (!(n && single) && (t = strtok_r(s, " \t", &ptr))) {	/* local usage of ppp_auto so curruption of it is not important */
+					char *dup;
+					size_t len;
+					
+					s = NULL;	/* for next iteration use saved ptr's value */
+					//dbg_console("check: '%s'\n", t);
+					if (!strcmp(t, p->name)) {
+						//dbg_console("drop current\n");
+						continue;		/* drop current profile for now */
+					} else {
+						if (!ppp_profile_exists(t)) {
+							//dbg_console("drop non-existent\n");
+							continue;	/* drop non-existing profile */
+						}
+					}
+
+					len = strlen(t);
+
+					while ((dup = strstr(auto_new, t)) != NULL) {
+						if ((dup == auto_new || *(dup - 1) == ' ') && 
+							(dup[len] == ' ' || dup[len] == 0)) {
+							break; /* found duplicate */
+						}
+					}
+					if (dup) {
+						//dbg_console("drop duplicate\n");
+						continue; /* drop duplicate */
+					}
+
+					//dbg_console("added to list\n");
+					*p_new = ' ';
+					p_new++;
+					strcpy(p_new, t);
+					p_new += len;	/* points to terminating 0 */
+					n++;			/* count of included names */
+				}
+
+				fprintf(fp, "%s=\"", auto_var);
+				if (p->flags.auto_start) {
+					fprintf(fp, "%s", p->name);
+				}
+				/* auto_new is empty string or started with space list of space-separated names */
+				if (auto_new[0]) {
+					fprintf(fp, "%s", p->flags.auto_start ? auto_new : &auto_new[1]);
+				}
+				fprintf(fp, "\"\n");	
+				return 1;
+			}
+		}
+	}
+
+	/* printf the rest lines unchanged */
+	fprintf(fp, "%s", parse_data->line);
+	return 1;
+}
+
+static int ppp_profile_delete(ppp_profile *profile)
+{
+	int read_rc, r;
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+
+	read_rc = ppp_profile_read(profile->name, profile, 1);
+	//dbg_console("%s: profile reding rc=%d\n", __func__, read_rc);
+	if (read_rc == -ENOENT) {
+		sprintf(ppp.err_reason, WC_STR_RSN_PROFILE_NEXIST);
+		return read_rc;
+	}
+
+	/* if error something else, still try deleting */
+	
+	/* delete files /etc/ppp/peers/:
+	* <name>.gprs.wc		(GPRS)
+	* <name>.gprs.chat	(GPRS)
+	* <name>.type		(GPRS, VPN)
+	*/
+
+	path_len = sizeof(PPP_PROFILES_DIR);
+	strcpy(path_buf, PPP_PROFILES_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], profile->name, PIT_MAIN_FILE);
+
+	if (unlink(path_buf)) {
+		r = -errno;
+		sprintf(ppp.err_reason, "%s", strerror(errno));
+		return r;
+	}
+
+	sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_DELETED, profile->name);
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		compile_profile_identity(&path_buf[path_len], profile->name, PIT_CHAT_FILE);
+		unlink(path_buf);
+
+		compile_profile_identity(&path_buf[path_len], profile->name, PIT_WC_FILE);
+		unlink(path_buf);
+	}
+#endif
+
+	if (!read_rc) {
+		/* profile was read OK, so we have all info to process secrets as need */
+		/* remove only secrets for ours profiles, i.e. when remotename is WC-standard */
+		//dbg_console("%s: not read_rc, std_remotename=%d, ext_password=%d\n",
+		//	__func__, profile->flags.std_remotename, profile->flags.ext_password);
+		if (profile->flags.std_remotename && profile->flags.ext_password) {
+			ppp_profile_secrets_edit(profile, 1);
+		}
+
+	}
+
+	/* if auto_start functioinality is enabled..*/
+	if (ppp.flags.auto_start_enabled) {
+		/* set AUTO property in network.conf - if error - ignore it;
+		* the name will be removed (profile doesn't exist and flag is not set)
+		*/
+		profile->flags.auto_start = 0;	/*  */
+		wc_conf_file_edit(NET_CONFIG_FILE, &edit_network_conf_line, profile, 0);
+	}
+	
+	return 0;
+}
+
+static int ppp_profile_from_request(ppp_profile *p)
+{
+	memset(p, 0, sizeof(*p));
+
+	/* get new name */
+	cgiFormString(HVAR_PPP_NEW_NAME, p->name, sizeof(p->name));
+	if (!p->name[0]) {
+		sprintf(ppp.err_reason, WC_STR_RSN_REQ_FIELD, WC_STR_PPP_NAME);
+		return -EINVAL;
+	}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		/* port */
+		cgiFormString(HVAR_PPP_PORT, p->t.gprs.port, sizeof(p->t.gprs.port));
+		if (memcmp(p->t.gprs.port, "/dev/tty", 8) && 
+			memcmp(p->t.gprs.port, "tty", 3)) {
+			sprintf(ppp.err_reason, WC_STR_RSN_PORT_INVAL);
+			return -EINVAL;
+		}
+		/* speed */
+		cgiFormInteger(HVAR_PPP_BAUDRATE, &p->t.gprs.speed, 0);
+		if (!get_br_index(p->t.gprs.speed)) {
+			sprintf(ppp.err_reason, WC_STR_RSN_INVAL_FIELD, WC_STR_PPP_PORT_SPEED);
+			return -EINVAL;
+		}
+		/* hw flow */
+		p->t.gprs.flags.hw_flow = cgiFormCheckboxSingle(HVAR_PPP_HWF) == cgiFormSuccess;
+
+		/* sim pin */
+		cgiFormString(HVAR_PPP_SIM_PIN, p->t.gprs.sim_pin, sizeof(p->t.gprs.sim_pin));
+		/* modem init str */
+		cgiFormString(HVAR_PPP_MODEM_IS, p->t.gprs.modem_init_string,
+						sizeof(p->t.gprs.modem_init_string));
+		if (p->t.gprs.modem_init_string[0]) {
+			char *pch;
+			for (pch = p->t.gprs.modem_init_string; *pch; pch++) {
+				*pch = toupper(*pch);
+			}
+			if (memcmp(p->t.gprs.modem_init_string, "AT", 2)) {
+				sprintf(ppp.err_reason, WC_STR_RSN_IS_INVAL);
+				return -EINVAL;
+			}
+		}
+		/* apn */
+		cgiFormString(HVAR_PPP_APN, p->t.gprs.apn, sizeof(p->t.gprs.apn));
+		if (!p->t.gprs.apn[0]) {
+			sprintf(ppp.err_reason, WC_STR_RSN_REQ_FIELD, WC_STR_PPP_APN);
+			return -EINVAL;
+		}
+		/* call num */
+		cgiFormString(HVAR_PPP_CALL_NUM, p->t.gprs.call_number, 
+					sizeof(p->t.gprs.call_number));
+		if (!p->t.gprs.call_number[0]) {
+			sprintf(ppp.err_reason, WC_STR_RSN_REQ_FIELD, WC_STR_PPP_CALLNUM);
+			return -EINVAL;
+		}
+
+		/* IP/Dynamic */
+		cgiFormString(HVAR_PPP_STATIC_IP, p->t.gprs.static_ip, sizeof(p->t.gprs.static_ip));
+		if (is_ip_addr(p->t.gprs.static_ip)) {
+			p->t.gprs.flags.static_ip = 1;
+		} else if (p->t.gprs.static_ip[0]) {
+			p->t.gprs.static_ip[0] = 0;
+			//sprintf(ppp.pdata->status_buf, "TODO: Warning: static IP wrong - ignored (using dynamic IP)");
+		}
+	}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		/* VPN server */
+		cgiFormString(HVAR_PPP_VPN_SERVER, p->t.vpn.srv_addr, sizeof(p->t.vpn.srv_addr));
+		if (!p->t.vpn.srv_addr[0]) {
+			sprintf(ppp.err_reason, WC_STR_RSN_REQ_FIELD, WC_STR_PPP_VPN_SERVER);
+			return -EINVAL;
+		}
+		if (p->t.vpn.srv_addr[0] >= '0' && p->t.vpn.srv_addr[0] <= '9') {
+			/* IP */
+			if (!is_ip_addr(p->t.vpn.srv_addr)) {
+				sprintf(ppp.err_reason, WC_STR_RSN_INVAL_FIELD, WC_STR_PPP_VPN_SERVER);
+				return -EINVAL;
+			}
+		}
+		/* VPN Route: addr/mask TODO: +gw?? TODO: list of routes */
+		cgiFormString(HVAR_PPP_VPN_ADDR, p->t.vpn.vpn_addr, sizeof(p->t.vpn.vpn_addr));
+		cgiFormString(HVAR_PPP_VPN_MASK, p->t.vpn.vpn_mask, sizeof(p->t.vpn.vpn_mask));
+
+		if (p->t.vpn.vpn_addr[0]) {
+			if (!is_ip_addr(p->t.vpn.vpn_addr)) {
+				sprintf(ppp.err_reason, WC_STR_RSN_INVAL_FIELD, WC_STR_PPP_VPN_ADDR);
+				return -EINVAL;
+			}
+			if (!is_ip_addr(p->t.vpn.vpn_mask)) {
+				sprintf(ppp.err_reason, WC_STR_RSN_INVAL_FIELD, WC_STR_PPP_VPN_MASK);
+				//sprintf(ppp.pdata->status_buf, "TODO: Failed to apply profile data: invalid VPN network IP mask (required if addr specified)");
+				return -EINVAL;
+			}
+		}
+		if (p->t.vpn.vpn_mask[0] && !p->t.vpn.vpn_addr[0]) {
+			p->t.vpn.vpn_mask[0] = 0;
+			//sprintf(ppp.pdata->status_buf, "TODO: Warning: VPN mask ignored because address was not specified");
+		}
+	}
+#endif /* WC_CONFIG_MENU_NET_VPN */
+
+	/* common params */
+
+	/* login name */
+	cgiFormString(HVAR_PPP_LOGIN, p->login, sizeof(p->login));
+	/* password */
+	cgiFormString(HVAR_PPP_PASSWORD, p->pwd, sizeof(p->pwd));
+
+	if (p->login[0] && p->pwd[0]) {
+		p->flags.auth = 1;
+		p->flags.ext_password = 1;
+
+		/* build std remotename */
+		compile_profile_identity(p->remote, p->name, PIT_REMOTE_NAME);
+		p->flags.std_remotename = 1;
+	}
+
+	/* auto start */
+	if (ppp.flags.auto_start_enabled) {
+		p->flags.auto_start = cgiFormCheckboxSingle(HVAR_PPP_AUTO) == cgiFormSuccess;
+	}
+
+	return 0;
+}
+
+static void build_profile_file_path(char *buf, const char *name, int type, int edit)
+{
+	size_t len = sizeof(PPP_PROFILES_DIR);
+
+	strcpy(buf, PPP_PROFILES_DIR);
+	buf[len - 1] = '/';
+	compile_profile_identity(&buf[len], name, type);
+	if (edit) {
+		strcat(buf, ".edit");
+	}
+}
+
+/* For all edit_XXX_tpl_line():
+* - output before first line - required params (i.e. main params goes first)
+* - then output all the lines of the template as they are
+* - then, on EOF, output optional params
+*/
+
+static int edit_ppp_tpl_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp;
+	ppp_profile *p = (ppp_profile *)data;
+
+	fp = parse_data->fp_out;
+
+	if ((parse_data->line_index == 0 && parse_data->type == WC_CLT_EOF) || 
+		(parse_data->line_index == 1 && parse_data->type != WC_CLT_EOF)) {
+		/* before first line (at 1st line or when index==0 (EOF) - output mandatory params */
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		/* GPRS main params */
+		if (ppp.type == PPP_TYPE_GPRS) {
+			fprintf(fp, "%s\n", p->t.gprs.port);
+			fprintf(fp, "%d\n", p->t.gprs.speed);
+			fprintf(fp, "%s%s\n", p->t.gprs.flags.hw_flow ? "" : "no", CFG_OPT_HWFLOW);
+
+			/* connect option */
+			if (p->t.gprs.sim_pin[0]) {
+				fprintf(fp, "%s '%s %s.%s'\n", CFG_OPT_CONNECT,
+					PPP_GPRS_CHAT_PROG, p->name, ppp.type_name);
+			} else {
+				fprintf(fp, "%s '%s/chat -v -f %s/%s.%s.chat'\n", CFG_OPT_CONNECT,
+					PPP_SBIN_DIR, PPP_PROFILES_DIR, p->name, ppp.type_name);
+			}
+		}
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+		/* VPN main params */
+		if (ppp.type == PPP_TYPE_VPN) {
+			fprintf(fp, "%s '%s/pptp %s --nolaunchpppd'\n", 
+				CFG_OPT_PTY, PPP_SBIN_DIR, p->t.vpn.srv_addr);
+		}
+#endif
+		/* common main params */
+	}
+
+	/* WC_CLT_VAR, WC_CLT_CREATED - are not possible cases - do not check */
+	if (parse_data->type != WC_CLT_EOF) {
+		/* output all template's lines unchanged */
+		fprintf(fp, "%s", parse_data->line);
+	} else  {
+		/* output all optional params on EOF */
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		/* GPRS optional params */
+		if (ppp.type == PPP_TYPE_GPRS) {
+			if (p->t.gprs.flags.static_ip) {
+				fprintf(fp, "%s:\n", p->t.gprs.static_ip);
+			}
+		}
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+		/* VPN optional params */
+		if (ppp.type == PPP_TYPE_VPN) {
+			if (p->t.vpn.vpn_addr[0] && p->t.vpn.vpn_mask[0]) {
+				fprintf(fp, "%s 'VPN %s %s'\n", 
+					CFG_OPT_IPPARAM, p->t.vpn.vpn_addr, p->t.vpn.vpn_mask);
+			}
+		}
+#endif
+		/* common optional params */
+
+		if (p->login[0]) {
+			fprintf(fp, "%s %s\n", CFG_OPT_NAME, p->login);
+		}
+		if (p->flags.auth) {
+			fprintf(fp, "%s %s\n", CFG_OPT_REMOTENAME, p->remote);
+		}
+
+		fprintf(fp, "%s %s/%s.%s.log\n", 
+			CFG_OPT_LOGFILE, PPP_LOG_DIR, p->name, ppp.type_name);
+	}
+
+	return 1;
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static int edit_gprs_chat_tpl_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp;
+	ppp_profile *p = (ppp_profile *)data;
+
+	fp = parse_data->fp_out;
+
+	/* chat file template is expected to be not empty, and contain all chat strings except:
+	* - init string
+	* - setting context (APN)
+	* - calling
+	* These three strings SHOULD follow after <"" AT> line instead of line containing {WC_CHAT}
+	* so substitute this line with target strings, other lines output unchanged
+	*/
+
+	/* WC_CLT_VAR, WC_CLT_CREATED - are not possible cases - do not check */
+	if (parse_data->type == WC_CLT_EOF) {
+		return 0;
+	}
+
+	if (!strstr(parse_data->line, CFG_WC_CHAT_KEYWORD)) {
+		/* not changed */
+		fprintf(fp, "%s", parse_data->line);
+	} else {
+		/* wc-configured chat lines */
+		if (p->t.gprs.modem_init_string[0] && !memcmp(p->t.gprs.modem_init_string, "AT", 2)) {
+			fprintf(fp, "OK '%s'\n", p->t.gprs.modem_init_string);
+		}
+		fprintf(fp, "OK 'AT+CGDCONT=1,\"IP\",\"%s\"'\n", p->t.gprs.apn);
+		fprintf(fp, "OK 'ATD%s'\n", p->t.gprs.call_number);
+	}
+
+	return 1;
+}
+
+/* note: we might be editing '.wc.edit' file 
+*
+* So, when profile is added -file '.wc' is created - use WC_CLT_CREATED
+* when profile is editing - file '.wc.edit' is:
+*      edited - drop all vars and printf ours on WC_CLT_EOF
+*      created - use WC_CLT_CREATED
+*/
+static int edit_ppp_wc_line(wc_conf_parse_data_t *parse_data, void *data)
+{
+	FILE *fp;
+	ppp_profile *p = (ppp_profile *)data;
+
+	fp = parse_data->fp_out;
+
+	/* add vars on creating the file or on EOF after all old stuff was dropped */
+	if (parse_data->type == WC_CLT_CREATED ||
+		parse_data->type == WC_CLT_EOF) {
+		//dbg_console("type=%d - add vars\n", parse_data->type);
+		fprintf(fp, "# SIM PIN\n");
+		fprintf(fp, "%s=\"%s\"\n", CFG_WC_PIN, p->t.gprs.sim_pin);
+
+		return 0;
+	}
+
+	/* remove any lines */
+	return 1;
+}
+#endif
+
+static int ppp_profile_secrets_edit(ppp_profile *profile, int clean)
+{
+	const char *secrets_file;
+	ppp_sectret_data_t sd;
+	char remote[PR_REMOTE_MAX_LEN + 1];
+	int r = 0;
+
+	secrets_file = get_ppp_secrets_file();
+	if (secrets_file) {
+		memset(&sd, 0, sizeof(sd));
+		compile_profile_identity(remote, profile->name, PIT_REMOTE_NAME);
+		sd.name = profile->login;
+		sd.remote = remote;
+		if (!clean) {
+			sd.pwd = profile->pwd;
+		}
+		sd.flags.clean = clean;
+		r = wc_conf_file_edit_raw(secrets_file, &edit_secrets_line, &sd, 1);
+	}
+	return r;
+}
+
+/* 1) Add a new profile - profile=NULL(add) or !NULL (edit with renaming), edit=0, 
+*         if profile==NULL, new profile data got from request by the function
+*  2) Add a temp profile while editing w/o renaming - profile!=NULL, edit=1
+*/
+static int ppp_profile_add(ppp_profile *profile, int edit)
+{
+	ppp_profile req_profile;
+	ppp_profile *p;
+	char main_file[sizeof(PPP_PROFILES_DIR) + PPP_IDENTITY_MAX_SIZE + sizeof(".edit")];
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	char chat_file[sizeof(main_file)];
+	char wc_file[sizeof(main_file)];
+#endif
+	int r;
+
+	p = profile;
+	if (!p) {
+		p = &req_profile;
+		r = ppp_profile_from_request(p);
+		if (r) {
+			return r;
+		}
+	}
+
+	if (!edit && ppp_profile_exists(p->name)) {
+		sprintf(ppp.err_reason, WC_STR_RSN_PROFILE_EXIST, p->name);
+		return -EEXIST;
+	}
+
+	/* 
+	* - create profile (files) in profiles dir PPP_PROFILES_DIR (add suffix .edit if edit is set)
+	*    - name.type
+	*    - name.type.chat (for GPRS) - if fails, del name.type - error
+	*    - name.type.wc (for GPRS) - if fails, del name.type.chat, name.type - error
+	* - edit secrets by adding new login,remote,password or setting them instead of *,remote,* -
+	*    if secrets editing fails, remove new profile files - error
+	* - (optional) edit network.conf - set auto property as need (ignore result)
+	* - if edit is set and prev operations are successful, rename profile files 
+	*	the same names but w/o suffix .edit
+	*/
+
+	/* build file paths */
+	build_profile_file_path(main_file, p->name, PIT_MAIN_FILE, edit);
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		build_profile_file_path(chat_file, p->name, PIT_CHAT_FILE, edit);
+		/* re-create .wc file through .wc.edit - in order to be able to roll-back easily to the old settings */
+		build_profile_file_path(wc_file, p->name, PIT_WC_FILE, edit);
+
+		r = wc_conf_file_from_tpl(PPP_GPRS_TPL_FILE, edit_ppp_tpl_line, p, main_file);
+	}
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	if (ppp.type == PPP_TYPE_VPN) {
+		r = wc_conf_file_from_tpl(PPP_VPN_TPL_FILE, edit_ppp_tpl_line, p, main_file);
+	}
+#endif
+
+	if (r) {
+		sprintf(ppp.err_reason, "failed to create main file: %s", strerror(-r));
+		return r;
+	}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		r = wc_conf_file_from_tpl(PPP_GPRS_CHAT_TPL_FILE, edit_gprs_chat_tpl_line, 
+								p, chat_file);
+		if (r) {
+			unlink(main_file);
+			sprintf(ppp.err_reason, "failed to create chat file: %s", strerror(-r));
+			return r;
+		}
+
+		/* note: we might be editing '*.wc.edit' file */
+		r = wc_conf_file_edit(wc_file, edit_ppp_wc_line, p, 1);
+		if (r) {
+			unlink(main_file);
+			unlink(chat_file);
+			sprintf(ppp.err_reason, "failed to create WC conf file: %s", strerror(-r));
+			return r;
+		}
+	}
+#endif
+
+	/* set(ADD)/edit(EDIT-norename) serets as need */
+	r = ppp_profile_secrets_edit(p, 0);
+	if (r) {
+		/* failed to edit secrets - error - remove profile files */
+		unlink(main_file);
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		if (ppp.type == PPP_TYPE_GPRS) {
+			unlink(chat_file);
+			unlink(wc_file);
+		}
+#endif		
+
+		sprintf(ppp.err_reason, "failed to edit secrets file: %s", strerror(-r));
+		return r;
+	}
+
+	/* if auto_start functioinality is enabled..*/
+	if (ppp.flags.auto_start_enabled) {
+		/* set AUTO property in network.conf - if error - ignore it */
+		wc_conf_file_edit(NET_CONFIG_FILE, &edit_network_conf_line, p, 1);
+	}
+
+	if (edit) {
+		char target_file[sizeof(main_file)];
+		/* rename xxx.edit files to xxx files
+		* if an error occurs it is difficult to rollback (need saving/restoring old secrets?) 
+		* so ignore errors - let it be as is
+		*/
+
+		build_profile_file_path(target_file, p->name, PIT_MAIN_FILE, 0);
+		rename(main_file, target_file);
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+		if (ppp.type == PPP_TYPE_GPRS) {
+			build_profile_file_path(target_file, p->name, PIT_CHAT_FILE, 0);
+			rename(chat_file, target_file);
+			build_profile_file_path(target_file, p->name, PIT_WC_FILE, 0);
+			rename(wc_file, target_file);
+		}
+#endif
+
+	}
+
+	sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_ADDED, p->name);
+	return 0;
+}
+
+static int ppp_profile_edit(ppp_profile *profile)
+{
+	ppp_profile req_profile;
+	int read_rc;
+	int r;
+
+	//dbg_console("%s: called\n", __func__);
+	r = ppp_profile_from_request(&req_profile);
+	if (r) {
+		return r;
+	}
+
+	read_rc = ppp_profile_read(profile->name, profile, 1);
+	if (read_rc) {
+		sprintf(ppp.err_reason, "%s", strerror(-read_rc));
+//		sprintf(ppp.pdata->status_buf, "TODO: Error: can't edit profile '%s': %s\n", 
+//			profile->name, strerror(errno));
+		return read_rc;
+	}
+
+	if (!strcmp(req_profile.name, profile->name)) {
+		/* no rename - add with edit suffix and rename files to old names on success 
+		* note: secrets are edited, because remotename is not changed
+		*/
+		r = ppp_profile_add(&req_profile, 1);
+		sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_UPDATED, profile->name);
+	} else {
+		/* rename: add new, delete old
+		* note: secrets are added (for new name), then old secrets of old name are deleted
+		*/
+		r = ppp_profile_add(&req_profile, 0);
+		if (!r) {
+#ifdef WC_CONFIG_MENU_NET_GPRS
+#ifndef WC_CONFIG_NO_AUTO_GPRS
+			if (ppp.type == PPP_TYPE_GPRS) {
+				/* if we've added auto-start GPRS profile this automatically 
+				* removed the old profile from _AUTO var, so when deleting
+				* the old profile we won't need to remove it from _AUTO
+				*/
+				if (req_profile.flags.auto_start) {
+					profile->flags.auto_start = 0;
+				}
+			}
+#endif
+#endif
+			ppp_profile_delete(profile);
+
+			sprintf(ppp.pdata->status_buf, WC_STR_STATUS_PPP_UPDATED_REN, 
+				profile->name, req_profile.name);
+		}
+	}
+	
+	return r;
+}
+
+static int is_ip_addr(const char *s)
+{
+	/* IP should look like: D[DD].D[DD].D[DD].D[DD], where D is [0-9] */
+	/* do not validate the exact value of numbers */
+	int ni = 0;	/* index of number 0-3 */
+	int di = 0;	/* digit index in the number 0-2 */
+	const char *p;
+
+	for (p = s; *p != 0; p++) {
+		if (!di) {
+			/* should be digit */
+			if (!isdigit(*p)) {
+				return 0;
+			}
+			di++;
+		} else if (di == 3) {
+			/* should be dot */
+			if (*p != '.') {
+				return 0;
+			}
+			ni++;
+			di = 0;
+		} else {
+			if (isdigit(*p)) {
+				di++;
+			} else if (*p == '.') {
+				ni++;
+				di = 0;
+			} else {
+				return 0;
+			}
+		}
+	}
+	
+	return (ni == 3 && di > 0) ? 1 : 0;
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static int parse_local_ip_addr(char *s)
+{
+	char *p;
+	
+	if (*s == ':') {
+		return 0;	/* it must be remote IP - we don't need it */
+	}
+
+	p = strchr(s, ':');
+	if (!p) {
+		return 0;	/* local IP should end with : (without any spaces between) */
+	}
+
+	*p = 0;	/* terminate string */
+	if (is_ip_addr(s)) {
+		return 1;
+	}
+
+	/* otherwise, restore the value and report that this is something else */
+	*p = ':';
+	
+	return 0;
+}
+
+static int is_number(const char *s)
+{
+	while (*s != 0) {
+		if (!isdigit(*s)) {
+			return 0;
+		}
+		s++;
+	}
+	return 1;
+}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+/* NOTE: pppd options for WC has the following restritions:
+ * - Disallowed more than 1 option (with arg if required) per line
+ * - Disallowed for an option to span more than 1 line
+ * - Allowed quotes: single ' and double " as for standard options file
+ * - Allowed # to start comment as for standard options file
+ * - Disallowed back slash \
+ */
+#define CHAR_SPACE	' '
+#define CHAR_TAB	'\t'
+#define CHAR_QUOT	'\''
+#define CHAR_DQUOT	'"'
+#define CHAR_SHARP	'#'
+
+/* plen - optional pointer to len of token to return from function
+*  pdelim - optional pointer to char for returning actual delimiter
+*	Use it along with returned len to restore original string after token used
+*		t = token(s, &p, &len, &delim);
+*		... -use t
+*		t[len] = delim; - restore orig string
+* - both plen and pdelim have sence only when result is !NULL
+* - if result is NULL, the original string remains as it was before the call
+*/
+static char *token(char *str, char **save_ptr, size_t *plen, char *pdelim)
+{
+	char *p;
+	char delim = 0;
+	char *t;
+	size_t t_len;
+
+	p = str ? str : *save_ptr;
+	if (!p || !(*p)) {
+		return NULL;		/* wrong ptr or end of string */
+	}
+
+	/* skip spaces */
+	while (*p == CHAR_SPACE || *p == CHAR_TAB) p++;
+
+	if (*p == CHAR_SHARP) {
+		return NULL;		/* no more tokens - comment */
+	}
+
+	if (*p == CHAR_QUOT || *p == CHAR_DQUOT) {
+		delim = *p;
+		p++;
+	} else {
+		delim = CHAR_SPACE;
+	}
+	t = p;
+
+	while (*p && (*p != delim)) {
+		if (delim == CHAR_SPACE && 
+			(*p == CHAR_TAB || *p == CHAR_SHARP || *p == '\n')) {
+			break;
+		}
+		p++;
+	}
+
+	if (!(*p) || (*p == CHAR_SHARP)) {
+		/* eos */
+		*save_ptr = p;
+	} else {
+		*save_ptr = (p + 1);	/* may be eos or not */
+	}
+
+	t_len = p - t;
+	if (t_len > 0) {
+		if (pdelim) {
+			*pdelim = *p;
+		}
+		if (plen) {
+			*plen = t_len;
+		}
+		*p = 0;	/* terminate current token (for both cases, so CHAR_SHARP - terminates string as well) */
+		return t;
+	}
+
+	return NULL;	/* if result is empty string, - no tokens, no string corruption */
+}
+
+/* 0 - options file opened and somehow read, <0 (-errno) - failed to open the file */
+static int read_ppp_options_file(const char *file, ppp_profile *profile, int full)
+{
+	FILE * fp;
+	
+	fp = fopen(file, "r");
+	if (!fp) {
+		return -errno;
+	}
+
+	/* Very simple parsing of pppd options file:
+	 * line by line, word by word until found an option we can handle,
+	 * read option's value and start the loop again
+	 */
+	
+	while (!feof(fp)) {
+		char *p, *t, *line;
+		size_t len;
+		
+		line = fgets(ppp.pdata->val_buf, sizeof(ppp.pdata->val_buf), fp);
+		if (!line) {
+			break;	/* error? */
+		}
+
+		/* end string by NL */
+		p = strrchr(line, '\n');
+		if (p) {
+			*p = 0;
+		}
+
+		t = token(line, &p, &len, NULL);
+		if (!t) {
+			continue;	/* EOS (comment or empty string) */
+		}
+
+		do  {
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+			if (ppp.type == PPP_TYPE_GPRS) {
+				/* GPRS only options */
+				if (!strncmp(t, "/dev/tty", 8) || !strncmp(t, "tty", 3)) {
+					if (len < sizeof(profile->t.gprs.port)) {
+						strcpy(profile->t.gprs.port, t);
+					}
+					break; /* no arg for option - next line */
+				} else if (parse_local_ip_addr(t)) {
+					strcpy(profile->t.gprs.static_ip, t);
+					profile->t.gprs.flags.static_ip = 1;
+					break; /* no arg for option - next line */
+				} else if (full) {
+					//dbg_console("full, token:'%s'\n", t);
+					if (is_number(t)) {
+						profile->t.gprs.speed = atoi(t);
+						break; /* no arg for option - next line */
+					} else if (!strcmp(t, CFG_OPT_HWFLOW) || !strcmp(t, "no" CFG_OPT_HWFLOW)) {
+						profile->t.gprs.flags.hw_flow = (t[0] != 'n');
+						break;
+					}
+				}
+				/* do not break - try common options further */
+			}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+			if (ppp.type == PPP_TYPE_VPN) {
+				/* VPN only options */
+				if (!strcmp(t, CFG_OPT_PTY)) {
+					t = token(NULL, &p, NULL, NULL);
+					if (!t) {
+						break;	/* err */
+					}
+					
+					/* parse the token */
+					t = token(t, &p, &len, NULL);
+					if (!t || strcmp(&t[len - 4], "pptp")) {
+						break;	/* err: should be present and end with "pptp" */
+					}
+
+					t = token(NULL, &p, &len, NULL);
+					if (!t) {
+						break;	/* err */
+					}
+
+					if (len < sizeof(profile->t.vpn.srv_addr)) {
+						strcpy(profile->t.vpn.srv_addr, t);
+					}
+					break;
+				} else if (!strcmp(t, CFG_OPT_IPPARAM)) {
+					t = token(NULL, &p, &len, NULL);
+					if (!t) {
+						break;	/* err */
+					}
+
+					/* parse the token */
+					t = token(t, &p, &len, NULL);
+					if (!t || strcmp(t, "VPN")) {
+						break;	/* err: should be present and equal 'VPN' */
+					}
+
+					t = token(NULL, &p, &len, NULL);
+					if (!t || !is_ip_addr(t)) {
+						break;	/* err: shoulod be NET IP ADDR */
+					}
+					strcpy(profile->t.vpn.vpn_addr, t);
+
+					t = token(NULL, &p, &len, NULL);
+					if (!t || !is_ip_addr(t)) {
+						/* erase NET IP ADDR */
+						profile->t.vpn.vpn_addr[0] = 0;
+						break;	/* err: shoulod be NET MASK ADDR */
+					}
+					strcpy(profile->t.vpn.vpn_mask, t);
+					break;
+				}
+				/* do not break - try common options further */
+			}
+#endif /* WC_CONFIG_MENU_NET_VPN */
+
+			/* common options - read for any 'full' flag - they need to determine 'auth or not' */
+			if (!strcmp(t, CFG_OPT_NAME)) {
+				t = token(NULL, &p, &len, NULL);
+				if (!t) {
+					break;	/* err */
+				}
+				/* copy login, truncate it as need */
+				wc_strncpy(profile->login, sizeof(profile->login), t, len);
+				break;
+			} else if (!strcmp(t, CFG_OPT_PASSWORD)) {
+				t = token(NULL, &p, &len, NULL);
+				if (!t) {
+					break;	/* err */
+				}
+				/* copy password, truncate it as need */
+				wc_strncpy(profile->pwd, sizeof(profile->pwd), t, len);
+				break;
+			} else if (!strcmp(t, CFG_OPT_REMOTENAME)) {
+				t = token(NULL, &p, &len, NULL);
+				if (!t) {
+					break;	/* err */
+				}
+				/* copy remotename, truncate it as need */
+				wc_strncpy(profile->remote, sizeof(profile->remote), t, len);
+				break;
+			}
+		} while (0);
+	}
+
+	fclose(fp);
+	return 0;
+}
+
+static void ppp_secrets_file_read(ppp_profile *profile)
+{
+	const char *secrets_file = NULL;
+
+	if (!profile->login[0] || !profile->remote[0]) {
+		//dbg_console("login empty - exit\n");
+		return;	/* need not */
+	}
+
+	secrets_file = get_ppp_secrets_file();
+	if (!secrets_file) {
+		return;	/* int err */
+	}
+
+	wc_conf_file_read_raw(secrets_file, &read_secrets_line, profile);
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+/* return 0 - opened and somehow read, <0(-errno) - failed to open or called for wrong type */
+static int read_ppp_chat_file(const char *file, ppp_profile *profile)
+{
+	FILE * fp;
+	int f_apn = 0, f_cn = 0, f_1at = 0, f_exp_init = 0;
+	
+	if (ppp.type != PPP_TYPE_GPRS) {
+		return -EINVAL;	/* only GPRS profile may have .chat file */
+	}
+
+	//dbg_console("chatfile=%s\n", file);
+
+	fp = fopen(file, "r");
+	if (!fp) {
+		return -errno;
+	}
+
+	/* line by line search for:
+	* 1) "" AT ==>
+	*     .... init string ... (optional)
+	* 2) AT+CGDCONT	==> read APN
+	* 3) ATD			==> read call number
+	*/
+	while (!feof(fp) && !(f_apn && f_cn)) {
+		char *p, *c, *t, *line;
+		size_t len;
+		
+		line = fgets(ppp.pdata->val_buf, sizeof(ppp.pdata->val_buf), fp);
+		//dbg_console("line: '%s'\n", line);
+		if (!line) {
+			break;	/* error? */
+		}
+
+		/* end string by NL */
+		c = strrchr(line, '\n');
+		if (c) {
+			*c = 0;
+		}
+
+		if (*line == '#') {
+			/* comment */
+			continue;
+		}
+
+		/* skip everything until 1st <"" AT> line found */
+		if (!f_1at) {
+			t = strtok_r(line, " \t", &p);
+			if (!t) {
+				continue; /* empty line ? */
+			}
+
+			//dbg_console("token:'%s'\n", t);
+			/* token should be '' or "" - i.e. no expected answer - AT */
+			if ((*t == '\'' || *t == '"') && (*t == *(t + 1))) {
+				f_1at = 1;
+				f_exp_init = 1;
+			}
+			continue;
+		}
+
+		if (f_exp_init) {
+			f_exp_init = 0; /* do not expect init string more */
+
+			/* the target line:
+			* - should look like ['"]OK['"][spaces]['"]AT...['"] 
+			* - AT... should not be neither ATD nor AT+CGDCONT
+			*/
+
+			/* use simple condition, i.e. AT but not (ATD or AT+CGDCONT) */
+			p = strstr(line, "AT");
+			//dbg_console("exp init str\n");
+			if (p) {
+				if (strncmp(p, "ATD", 3) && strncmp(p, "AT+CGDCONT=", sizeof("AT+CGDCONT=") - 1)) {
+					/* OK, extract the init string with AT prefix, 
+					* w/o possible quotes at start and end - just remove ending quotes if they are
+					*/
+					//dbg_console("found init str\n");
+					len = strlen(p);
+					if (p[len - 1] == '\'' || p[len - 1] == '"') {
+						len--;
+						p[len] = 0;
+					}
+					/* copy, truncate as need */
+					wc_strncpy(profile->t.gprs.modem_init_string, 
+							sizeof(profile->t.gprs.modem_init_string), p, len);
+
+					continue;
+				}
+			}
+		}
+
+		/* the next string after 1st AT string is init string, but
+		* if some other strings line atd or at+cgdcont follow, then init string is omitted 
+		*/
+
+		if (!f_apn) {
+			p = strstr(line, "AT+CGDCONT=");
+			if (p) {
+				/* the line is found */
+				
+				if (p != line) {
+					/* check whether the whole command quoted - remove quotes */
+					if (*(p - 1) == '\'' || *(p - 1) == '"') {
+						/* command is quoted, it should end with the same quote */
+						c = strrchr(p, *(p - 1));
+						if (c) {
+							*c = 0; /* terminate command by the quote */
+						}
+					}
+				} /* else - command without quotes and starts w/o expected echo - impossible case */
+
+				/* so now we have AT+CGDCONT command w/o quotes */
+				t = strtok_r(p, ",", &p);
+				t = strtok_r(NULL, ",", &p);
+				t = strtok_r(NULL, ",", &p);
+				if (t) {
+					/* we may have 4 quotation cases: \"XX\", \'XX\', "XX", 'XX' */
+					/* for simplicity - remove any quote or slash+quote at start and end of the string 
+					* irrerspectively to whether it has a pair
+					*/
+					if (*t == '\\' && (*(t + 1) == '"' || *(t + 1) == '\'')) {
+						t += 2;
+					} else if (*t == '"' || *t == '\'') {
+						t += 1;
+					}
+
+					len = strlen(t);
+					if (t[len - 1] == '"' || t[len - 1] == '\'') {
+						len--;
+						if (t[len - 1] == '\\') {
+							len--;
+						}
+						t[len] = 0;
+					}
+
+					wc_strncpy(profile->t.gprs.apn, sizeof(profile->t.gprs.apn), t, len);
+				}
+				
+				f_apn = 1;
+				continue;
+			}
+		}
+
+		if (!f_cn) {
+			p = strstr(line, "ATD");
+			if (p) {
+				line = p + 3;
+				t = strtok_r(line, "'\"", &p);	/* can be quoted, double quoted */
+				if (!t) {
+					t = line;
+				}
+				len = strlen(t);
+
+				wc_strncpy(profile->t.gprs.call_number, 
+							sizeof(profile->t.gprs.call_number), t, len);
+				//dbg_console("CN:'%s', len=%d\n", profile->t.gprs.call_number, len);
+				f_cn = 1;
+				continue;
+			}
+		}
+	}
+	
+	fclose(fp);
+	return 0;
+}
+
+static int read_ppp_wc_var(char *var, char *val, void *data)
+{
+	ppp_wc_data *wc_data = (ppp_wc_data *)data;
+
+	if (ppp.type != PPP_TYPE_GPRS) {
+		return 0;	/* only GPRS profile may have .wc file for now */
+	}
+	
+	if (!strcmp(var, CFG_WC_PIN)) {
+		size_t len;
+		len = strlen(val);
+		if (len < sizeof(wc_data->sim_pin)) {
+			strcpy(wc_data->sim_pin, val);
+		} /* otherwise ignore bad value - it will be fixed when settings are updated */
+	}
+	return 1;
+}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+static void set_profile_auto_propery(const char *name, ppp_profile *profile)
+{
+	char *s, *e;
+	int single = 0;
+	size_t len;
+
+	if (!ppp.flags.auto_start_enabled) {
+		return;
+	}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		single = 1;
+	}
+#endif
+
+	//dbg_console("set AS for '%s': cur_val=%d, single=%d\n", name, profile->flags.auto_start, single);
+
+	/* note ppp_auto can't be corrupted, because used multiple times - for each profile */
+	len = strlen(name);
+	s = ppp.ppp_auto;
+
+	while (*s) { /* !EOS */
+		/* skip all spaces and tabs at start */
+		while (*s == ' ' || *s == '\t') s++;
+
+		/* find next EOS or ' ' or '\t' */
+		e = s;
+		while (*e && *e != ' ' && *e != '\t') e++;
+
+		if (e - s == len) {
+			if (!memcmp(s, name, len)) {
+				profile->flags.auto_start = 1;
+				//dbg_console("set AS for '%s' -SET\n", name);
+				break;
+			}
+		}
+
+		if (single) {
+			break;	/* if single auto start profile is possbile stop anyway after 1 iteration */
+		}
+
+		s = e;
+	}
+}
+
+/* read options, wc, chat, check name in AUTO list got previously from /etc/network.conf */
+/* return 0 - OK, < 0 - failed to perform (e.g. profile doesn't exist) */
+static int ppp_profile_read(const char *name, ppp_profile *profile, int full)
+{
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+	int r;
+
+	path_len = sizeof(PPP_PROFILES_DIR);
+	strcpy(path_buf, PPP_PROFILES_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], name, PIT_MAIN_FILE);
+	r = read_ppp_options_file(path_buf, profile, full);
+	if (r) {
+		sprintf(ppp.err_reason, "%s", strerror(-r));
+		//sprintf(ppp.pdata->status_buf, "TODO: failed to read profile %s: %s\n", 
+		//	name, strerror(-r));
+		return r;
+	}
+
+	if (profile->remote[0]) {
+		if (full) {
+			char buf[PR_REMOTE_MAX_LEN + 1];
+			/* determine whether remotename is WC-standard */
+			compile_profile_identity(buf, name, PIT_REMOTE_NAME);
+			profile->flags.std_remotename = !strcmp(buf, profile->remote);
+		}
+	}
+
+	if (profile->pwd[0]) {
+		if (profile->login[0]) {
+			profile->flags.auth = 1;			/* pwd from options file */
+		}
+	} else {
+		/* read pwd from secrets */
+		ppp_secrets_file_read(profile);
+		if (profile->pwd[0]) {
+			profile->flags.auth = 1;		/* pwd from secrets */
+			profile->flags.ext_password = 1;
+		}
+	}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	if (ppp.type == PPP_TYPE_GPRS) {
+		if (full) {
+			ppp_wc_data wc_data;
+			
+			compile_profile_identity(&path_buf[path_len], name, PIT_CHAT_FILE);
+			r = read_ppp_chat_file(path_buf, profile);
+//			if (r) {
+//				sprintf(ppp.pdata->status_buf, "Warning: failed to read chat file for %s: %s\n", 
+//					name, strerror(-r));
+//			}
+
+			compile_profile_identity(&path_buf[path_len], name, PIT_WC_FILE);
+			memset(&wc_data, 0, sizeof(wc_data));
+			/* .wc is optional, so ignore error */
+			wc_conf_file_read(path_buf, &read_ppp_wc_var, (void*)&wc_data);
+			strcpy(profile->t.gprs.sim_pin, wc_data.sim_pin);
+		}
+	}
+#endif
+
+	set_profile_auto_propery(name, profile);
+
+	return 0;
+}
+
+static void process_log_output_request(void)
+{
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+	char chunk[256];
+	FILE *fp;
+	int r;
+	ssize_t count;
+
+	if (!ppp.flags.out_plain_log) {
+		return;
+	}
+
+	path_len = sizeof(PPP_LOG_DIR);
+	strcpy(path_buf, PPP_LOG_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], ppp.o_profile.name, PIT_LOG_FILE);
+
+	//dbg_console("%s: called for %d, read from: %s\n", __func__, ppp.log_offs, path_buf);
+	/* read log file and output it to browser */
+	fp = fopen(path_buf, "r");
+	if (fp) {
+		r = fseek(fp, ppp.log_offs, SEEK_SET);
+		if (!r && !feof(fp)) {
+			count = fread(chunk, 1, sizeof(chunk), fp);
+			if (count > 0)  {
+				r = fwrite(chunk, count, 1, cgiOut);
+				//dbg_console("read and written %d bytes from offs=%d: %d\n", count, ppp.log_offs, r);
+			} else {
+				//dbg_console("read failed: %d\n", count);
+			}
+		} else {
+			//dbg_console("seek to %d failed\n", ppp.log_offs);
+		}
+		fclose(fp);
+	} else {
+		//dbg_console("open failed\n");
+	}
+	//fprintf(cgiOut, "a line from offset %d\n", ppp.log_offs);
+}
+static void process_log_delete_request(void)
+{
+	size_t path_len;
+	char path_buf[WC_PATH_MAX];
+
+	path_len = sizeof(PPP_LOG_DIR);
+	strcpy(path_buf, PPP_LOG_DIR);
+	path_buf[path_len - 1] = '/';
+	compile_profile_identity(&path_buf[path_len], ppp.o_profile.name, PIT_LOG_FILE);
+	unlink(path_buf);
+	//dbg_console("log '%s' deleted\n", path_buf);
+}
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+static int get_br_index(int speed)
+{
+	int i;
+	for (i = 0; i < sizeof(br_values) / sizeof(br_values[0]); i++) {
+		if (br_values[i] == speed) {
+			return i;
+		}
+	}
+	return 0;
+}
+
+static int is_gprs_running(void)
+{
+	int i = 0;
+	/* read dir /var/run/network:
+	* if *.gprs.if or *.gprs.starting is present -assume a connection is active
+	*/
+	scan_dir(NETWORK_RUN_DIR, &filter_gprs_flags, &count_to_first, &i);
+	
+	return i;
+}
+#endif /* WC_CONFIG_MENU_NET_GPRS */
+
+#endif /* WC_CONFIG_MENU_NET_PPP */
+
diff -Nru a/wc/wc_net_ppp.h b/wc/wc_net_ppp.h
--- a/wc/wc_net_ppp.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_net_ppp.h	2012-06-21 19:03:42.000000000 +0300
@@ -0,0 +1,8 @@
+#ifndef _WC_NET_PPP_H_
+#define _WC_NET_PPP_H_
+
+extern void wc_net_ppp_process(wc_page_data_t *data, int submitted);
+extern void wc_net_ppp_post_process(wc_page_data_t *data);
+	
+#endif /* _WC_NET_PPP_H_*/
+
diff -Nru a/wc/wc_page_dt.c b/wc/wc_page_dt.c
--- a/wc/wc_page_dt.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_dt.c	2012-07-12 00:31:53.000000000 +0300
@@ -16,6 +16,8 @@
 #include "wc_page.h"
 #include "wc_page_dt.h"
 
+#include "wc_strings.h"
+
 #define RTC_DEV_FILE	"/dev/rtc"
 
 typedef enum {
@@ -48,7 +50,13 @@
 
 static const char *get_var_dt(char *field)
 {
-	int i = *field - 0x30;
+	int i;
+
+	if (!field) {
+		return NULL;
+	}
+
+	i = *field - 0x30;
 	if (i < 0 || i >= DT_TYPE_COUNT) {
 		return NULL;
 	}
@@ -57,7 +65,7 @@
 
 /* --- Interface methods --- */
 
-void process_dt(wc_page_data_t *data)
+void process_dt(wc_page_data_t *data, int submitted)
 {
 	int i;
 
@@ -66,7 +74,9 @@
 		wc_tpl_var_register(&dt_vars[i]);
 	}
 
-	if (cgiFormSubmitClicked(WC_PAGE_SUBMIT_NAME) == cgiFormSuccess) {
+	wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, NULL, NULL);
+
+	if (submitted) {
 		/* get data from the request and apply */
 		apply_new_settings(data);
 	}
@@ -174,7 +184,7 @@
 		return -1;
 	}
 
-	data->status_text = "Date/Time settings applied.";
+	data->status_text = WC_STR_STATUS_APPLIED;
 
 	return 0;
 }
diff -Nru a/wc/wc_page_dt.h b/wc/wc_page_dt.h
--- a/wc/wc_page_dt.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_dt.h	2011-03-09 17:39:01.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _WC_PAGE_DT_H_
 #define _WC_PAGE_DT_H_
 
-extern void process_dt(wc_page_data_t *data);
+extern void process_dt(wc_page_data_t *data, int submitted);
 
 #endif /* _WC_PAGE_DT_H_*/
 
diff -Nru a/wc/wc_page.h b/wc/wc_page.h
--- a/wc/wc_page.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page.h	2012-07-12 18:25:29.000000000 +0300
@@ -1,20 +1,140 @@
 #ifndef _WC_PAGE_H_
 #define _WC_PAGE_H_
 
+#include <limits.h>
 #include "linux_list.h"
 
-#define WC_PAGE_SUBMIT_NAME	"set"
+#include "wc_config.h"
+#include "wc_debug.h"
+#include "wc_conf_file.h"
+
+/* content - type */
+#define WC_CT_HTML		0
+#define WC_CT_TEXT		1
+
+/* #define WC_PATH_MAX			PATH_MAX */
+#define WC_PATH_MAX			256
+#define WC_VAL_MAX_SIZE		256
+
 #define WC_PAGE_NAME_MAX_LEN	15
-#define WC_STATUS_BUF_LEN		256
+#define WC_STATUS_BUF_SIZE	256
+
+#define WC_NAME_FORM_SUBMIT	"set"
+
+#define WC_NAME_PAGE_HOME	"home"
+#ifdef WC_PAGE_TEST
+#define WC_NAME_PAGE_TEST		"test"
+#endif
+#define WC_NAME_PAGE_DT		"dt"
+#define WC_NAME_PAGE_NET		"net"
+#define WC_NAME_PAGE_SEC		"sec"
+#define WC_NAME_PAGE_PLC		"plc"
+#define WC_NAME_PAGE_UTILS	"utils"
+
+#define WC_NAME_PAGE_SENSORS	"sensors"
+
+#define WC_FORM_MAX_BUTTONS	3
+
+#define WC_FBA_LEFT	0
+#define WC_FBA_CENTER	1
+#define WC_FBA_RIGHT	2
+
+#define WC_FBT_BUTTON	0
+#define WC_FBT_SUBMIT	1
+#define WC_FBT_RESET	2
+
+typedef struct wc_form_button_t {
+	const char *title;		/* OK, Close, Cancel,...*/
+	const char *name;		/* button's name="" value */
+	int type;				/* button, submit, reset */
+} wc_form_button_t;
+
+typedef struct wc_page_data_t wc_page_data_t;
+
+typedef void (*wc_page_process_t)(wc_page_data_t *data, int submitted);
+typedef void (*wc_page_post_process_t)(wc_page_data_t *data);
+
+typedef struct wc_menu_t {
+	const char *name;						/* page name value passed via http */
+	const char *title;						/* lang dependent title */
+	wc_page_process_t process;			/* pre-rendering page processing */
+	wc_page_post_process_t post_process;	/* post-rendering page tasks */
+} wc_menu_t;
+
+struct wc_page_data_t {
+/* see comments in wc_config.h */
+#if USE_WC_CONF
+	wc_conf_t cfg;								/* WC configuration  */
+#endif
+
+	char val_buf[WC_VAL_MAX_SIZE];			/* buffer for static values e.g. returned strings from get-var-callbacks; reading lines from config files */
+	
+	wc_menu_t *pages;						/* possible pages (main menu) */
+	int count;								/* count of items in the array */
+	int index;								/* current page index */
+	char name[WC_PAGE_NAME_MAX_LEN + 1];	/* current page name */
 
-typedef struct {
-	char name[WC_PAGE_NAME_MAX_LEN + 1];	/* common: current page name */
-	char status_buf[WC_STATUS_BUF_LEN];		/* printed status if status_text is NULL */
+	char status_buf[WC_STATUS_BUF_SIZE];		/* printed status if status_text is NULL */
 	const char *status_text;					/* printed status if not NULL */
-} wc_page_data_t;
 
-typedef void (*wc_page_process_t)(wc_page_data_t *data);
-typedef void (*wc_page_post_process_t)(void);
+	wc_menu_t *sub_pages;					/* submenu */
+	int sub_count;							/* count of items in the array */
+	int sub_index;							/* current sub-page index (default =0 ) */
+	char sub_name[WC_PAGE_NAME_MAX_LEN + 1];/* current subpage name */
+
+	char content_type[64];
+	unsigned ct_id;							/* content type id: default 0 - HTML */
+	char title[255];	/* page title = app name + optional view/form title */
+	char form_title[64];
+
+	struct {
+		unsigned popup_tpl: 1;	/* use popup main template */
+		unsigned subm_en: 1;		/* submenu displaying enabled - automatically enabled by registration procedure if count > 0, displaying can be disabled by pages */
+		
+		unsigned form: 1;			/* need form */
+
+		unsigned cntdn: 1;		/* flag: countdown & refresh needed in the form's status line */
+	} flags;
+
+	wc_form_button_t *form_buttons[WC_FORM_MAX_BUTTONS];
+	int form_buttons_count;
+	int form_buttons_align;
+};
+
+extern wc_form_button_t wc_btn_ok;		/* submit */
+extern wc_form_button_t wc_btn_reset;		/* reset */
+extern wc_form_button_t wc_btn_cancel;
+extern wc_form_button_t wc_btn_back;
+extern wc_form_button_t wc_btn_close;
+extern void wc_form_enable(int fba, wc_form_button_t *b1, wc_form_button_t *b2, 
+						wc_form_button_t *b3);
+
+//extern void wc_subm_register(const char ** subm, int count);
+
+/* menu - NULL-item-terminated array 
+* default menu item is the first in the array
+*/
+extern void wc_sub_menu_register(wc_menu_t *menu);
+
+#if defined(WC_CONFIG_RC_SYNC)
+extern int wc_sync_configs(void);
+#endif
+
+/* utility macro and functions */
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+/* copies the string to destination, truncating the string as need.
+* the result is always NULL-terminated 
+*/
+static inline void wc_strncpy(char *buf, size_t size, const char *s, size_t len) 
+{
+	if (len >= size) {
+		len = size - 1;
+	}
+	memcpy(buf, s, len);
+	buf[len] = 0;
+}
 
 #endif /* _WC_PAGE_H_ */
 
diff -Nru a/wc/wc_page_net.c b/wc/wc_page_net.c
--- a/wc/wc_page_net.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_net.c	2012-09-18 12:58:35.000000000 +0300
@@ -1,45 +1,95 @@
+#include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "cgic.h"
 
-#include "wc_config.h"
+#include "wc_conf_file.h"
 #include "wc_tpl.h"
 #include "wc_page.h"
+#include "wc_net.h"
 #include "wc_page_net.h"
 
-#define NET_CONFIG_FILE "/etc/network.conf"
-//#define NET_CONFIG_FILE "/home/alex/local/www/cgi/network.conf"
+#ifdef WC_CONFIG_MENU_NET_PPP
+#include "wc_net_ppp.h"
+#endif
+#ifdef WC_CONFIG_MENU_NET_DDNS
+#include "wc_net_ddns.h"
+#endif
+
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_NET_SUBMENU
+static wc_menu_t submenu[] = {
+	{ .name = WC_NET_SP_NAME_MAIN,		.title = WC_STR_NET_MAIN,
+		.process = NULL,	.post_process = NULL, },
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	{ .name = WC_NET_SP_NAME_GPRS,		.title = WC_STR_NET_GPRS,
+		.process = wc_net_ppp_process,	.post_process = wc_net_ppp_post_process, },
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	{ .name = WC_NET_SP_NAME_VPN,		.title = WC_STR_NET_VPN,
+		.process = wc_net_ppp_process,	.post_process = wc_net_ppp_post_process, },
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_DDNS
+	{ .name = WC_NET_SP_NAME_DDNS,		.title = WC_STR_NET_DDNS,
+		.process = wc_net_ddns_process,	.post_process = NULL, },
+#endif
 
-#define CFG_DHCP		"DHCP"
-#define CFG_HOST_NAME	"HOST_NAME"
-#define CFG_IP_ADDR		"IPADDR"
-#define CFG_IP_MASK		"NETMASK"
-#define CFG_IP_GW		"GWADDR"
-#define CFG_IP_DNS1		"DNS1"
-#define CFG_IP_DNS2		"DNS2"
+	{ .name = NULL, },
+};
+#endif
 
-#define NET_MAX_HOSTNAME_LEN	10
 typedef enum {
-	IP_ADDR =	0,
-	IP_MASK,
-	IP_GW,
-	IP_DNS1,
-	IP_DNS2,
+	IPT_ADDR =	0,
+	IPT_MASK,
+	IPT_GW,
+	IPT_DNS1,
+	IPT_DNS2,
 	
-	IP_TYPE_COUNT,
+	IPT_COUNT,
 } ip_type_t;
 
+typedef enum {
+	NVT_HOST = 0,
+	NVT_DHCP,
+
+	/* notes!: 
+	 * - ip names the latest in the set,
+	 * - the order of IP names is THE SAME as order of IP types
+	 */
+	NVT_ADDR,
+	NVT_MASK,
+	NVT_GW,
+	NVT_DNS1,
+	NVT_DNS2,
+
+	NVT_COUNT,
+} net_var_type_t;
+
+#define nvt_to_ipt(nvt) ((nvt) - NVT_ADDR)
+
+static int net_var_set_map[NVT_COUNT];
+
 /* array of all types by 4 digits, each digit is string with len max 3 + term 0 */
-static char ip[][4][4] = {
-	[ IP_ADDR ]	= {} /*{ "192", "168", "100", "80" }*/,
-	[ IP_MASK ]	= {} /*{ "255", "255", "255", "0" }*/,
-	[ IP_GW ]	= {} /*{ "192", "168", "100", "90" }*/,
-	[ IP_DNS1 ]	= {} /*{ "192", "168", "100", "200" }*/,
-	[ IP_DNS2 ]	= {} /*{ "192", "168", "100", "44" }*/,
+static char ip[IPT_COUNT][4][4] = {
+	[ IPT_ADDR ]	= {} /*{ "192", "168", "100", "80" }*/,
+	[ IPT_MASK ]	= {} /*{ "255", "255", "255", "0" }*/,
+	[ IPT_GW ]	= {} /*{ "192", "168", "100", "90" }*/,
+	[ IPT_DNS1 ]	= {} /*{ "192", "168", "100", "200" }*/,
+	[ IPT_DNS2 ]	= {} /*{ "192", "168", "100", "44" }*/,
+};
+static const char *ip_cfg_names[IPT_COUNT] = {
+	[ IPT_ADDR ] = CFG_IP_ADDR,
+	[ IPT_MASK ] = CFG_IP_MASK,
+	[ IPT_GW ] = CFG_IP_GW,
+	[ IPT_DNS1 ] = CFG_IP_DNS1,
+	[ IPT_DNS2 ] = CFG_IP_DNS2,
 };
-//static char ip[5][4][4];
 static char host_name[NET_MAX_HOSTNAME_LEN + 1];
 static char dhcp[2] = "1";
 static int net_restart = 0;
@@ -52,14 +102,18 @@
 	{ .name = "host", .get = &get_var_host },
 	{ .name = "dhcp", .get = &get_var_dhcp },
 	{ .name = "ip", .get = &get_var_ip }, /* vars are: ip.addr|mask|gw|dns1|dns2.0-3 */
+	{ .name = NULL, },
 };
-const int net_vars_count = sizeof(net_vars) / sizeof(net_vars[0]);
 
 /* local methods */
-static void parse_ip_address(char *val, int addr_type);
-static int process_cfg_line(char *var, char *val);
+static void parse_ip_address(char *val, int addr_type, int is_optional);
+static int read_conf_vars(char *var, char *val, void *data);
+static int edit_conf_vars(wc_conf_parse_data_t *parse_data, void *data);
+static void set_conf_var(FILE *fp, net_var_type_t nvt);
+static int var_name_type(const char *name);
 static int get_current_settings(wc_page_data_t *data);
 static int ip_digit_validate_and_normalize(char *digit);
+static int ip_addr_validate_and_normalize(char addr[4][4], int is_optional);
 static int apply_new_settings(wc_page_data_t *data);
 
 /* --- Var handlers --- */
@@ -80,6 +134,10 @@
 	int addr_type;
 	int index;
 
+	if (!field) {
+		return NULL;
+	}
+
 	p = strchr(field, TPL_CHAR_VAR_FIELD_SEP);
 	if (!p) {
 		return NULL;
@@ -89,15 +147,15 @@
 	p++; /* points to 2-nd field */
 
 	if (!strcmp(field, "addr")) {
-		addr_type = IP_ADDR;
+		addr_type = IPT_ADDR;
 	} else if (!strcmp(field, "mask")) {
-		addr_type = IP_MASK;
+		addr_type = IPT_MASK;
 	} else if (!strcmp(field, "gw")) {
-		addr_type = IP_GW;
+		addr_type = IPT_GW;
 	} else if (!strcmp(field, "dns1")) {
-		addr_type = IP_DNS1;
+		addr_type = IPT_DNS1;
 	} else if (!strcmp(field, "dns2")) {
-		addr_type = IP_DNS2;
+		addr_type = IPT_DNS2;
 	} else {
 		return NULL;
 	}
@@ -109,16 +167,42 @@
 
 /* --- Interface methods --- */
 
-void process_net(wc_page_data_t *data)
+void process_net(wc_page_data_t *data, int submitted)
 {
-	int i;
+#ifdef WC_CONFIG_MENU_NET_SUBMENU
+	wc_menu_t *sp = NULL;
+
+	wc_sub_menu_register(submenu);
 
-	/* register vars & commands */
-	for (i = 0; i < net_vars_count; i++) {
-		wc_tpl_var_register(&net_vars[i]);
+	/* Assume: main submenu is always present! 
+	* if only 1 submenu is defined - behave like no submenu was defined at all
+	*/
+	if (data->sub_count > 1) {
+		sp = &data->sub_pages[data->sub_index];
+		strcat(data->form_title, " - ");
+		strcat(data->form_title, sp->title);
+	}
+
+	/* call special processor for subpage if:
+	* - submenu is defined, i.e. sp != NULL
+	* - if sub page is not main - for main process right in this procedure
+	*/
+	if (sp && strcmp(sp->name, WC_NET_SP_NAME_MAIN)) {
+		if (sp->process) {
+			sp->process(data, submitted);
+		}
+		return;
 	}
+#endif
+
+	/* Process MAIN net page */
+
+	/* register vars */
+	wc_tpl_vars_register(net_vars);
+
+	wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, &wc_btn_reset, NULL);
 
-	if (cgiFormSubmitClicked(WC_PAGE_SUBMIT_NAME) == cgiFormSuccess) {
+	if (submitted) {
 		/* get data from the request - edit/create network.conf */
 		apply_new_settings(data);
 	}
@@ -127,16 +211,34 @@
 	get_current_settings(data);
 }
 
-void post_process_net(void)
+void post_process_net(wc_page_data_t *data)
 {
+#ifdef WC_CONFIG_MENU_NET_SUBMENU
+	wc_menu_t *sp = NULL;
+
+	if (data->sub_count > 1) {
+		sp = &data->sub_pages[data->sub_index];
+	}
+
+	if (sp && strcmp(sp->name, WC_NET_SP_NAME_MAIN)) {
+		/* Process any net subpage, except main */
+		if (sp->post_process) {
+			sp->post_process(data);
+		}
+	}
+#endif
+
+	/* net restart request is common */
 	if (net_restart) {
-		system("sh -c \"PATH=/sbin/:$PATH; /etc/rc.net\" > /dev/null 2>&1");
+		/* background mode are required to let browser get the whole page before network gets down */
+		/* some sleep before restarting might be useful, but for now it works fine w/o such a sleep */
+		system("sh -c \"PATH=/sbin/:$PATH; "RC_NET_DIR"/rc.net reload\" > /dev/null 2>&1 &");
 	}
 }
 
 /* --- local subroutines --- */
 
-static void parse_ip_address(char *val, int addr_type)
+static void parse_ip_address(char *val, int addr_type, int is_optional)
 {
 	int i;
 	char *digit;
@@ -144,6 +246,10 @@
 	char *start= val;
 	char *end = start + strlen(val);
 
+	if (start == end && is_optional) {
+		return;	/* left them empty */
+	}
+
 	for (i = 0; i < 4; i++) {
 		digit = ip[addr_type][i];
 
@@ -165,27 +271,26 @@
 	}
 }
 
-static int process_cfg_line(char *var, char *val)
+static int read_conf_vars(char *var, char *val, void *data)
 {
-	if (!strcmp(var, CFG_DHCP)) {
-		strncpy(dhcp, val, 1);
-	} else if (!strcmp(var, CFG_HOST_NAME)) {
-		strcpy(host_name, val);
-	} else {
-		int addr_type = -1;
-		if (!strcmp(var, CFG_IP_ADDR)) {
-			addr_type = IP_ADDR;
-		} else if (!strcmp(var, CFG_IP_MASK)) {
-			addr_type = IP_MASK;
-		} else if (!strcmp(var, CFG_IP_GW)) {
-			addr_type = IP_GW;
-		} else if (!strcmp(var, CFG_IP_DNS1)) {
-			addr_type = IP_DNS1;
-		} else if (!strcmp(var, CFG_IP_DNS2)) {
-			addr_type = IP_DNS2;
-		}
-		if (addr_type >= 0) {
-			parse_ip_address(val, addr_type);
+	int nvt, ipt;
+
+	nvt = var_name_type(var);
+	if (nvt >= 0 && nvt < NVT_COUNT) {
+		switch (nvt) {
+			case NVT_HOST:
+				strcpy(host_name, val);
+				break;
+			case NVT_DHCP:
+				strncpy(dhcp, val, 1);
+				break;
+			default:
+				/* is IP */
+				ipt = nvt_to_ipt(nvt);
+				if (ipt >= 0) {
+					parse_ip_address(val, ipt, ipt == IPT_DNS1 || ipt == IPT_DNS2);
+				}
+				break;
 		}
 	}
 	return 1;
@@ -194,7 +299,7 @@
 static int get_current_settings(wc_page_data_t *data)
 {
 	int r;
-	r  = wc_conf_read_file(NET_CONFIG_FILE, &process_cfg_line);
+	r  = wc_conf_file_read(NET_CONFIG_FILE, &read_conf_vars, NULL);
 	if (r) {
 		sprintf(data->status_buf, "Error: failed to read %s config file", NET_CONFIG_FILE);
 		return -1;
@@ -214,7 +319,7 @@
 			break;
 		}
 		if (digit[i] < 0x30 || digit[i] > 0x39) {
-			return -1;
+			return -2;
 		}
 	}
 	// assume digit[3] == terminating 0
@@ -223,73 +328,206 @@
 		sprintf(digit, "%d", i);
 		return 0;
 	}
-	return -1;
+	return -3;
+}
+
+static int ip_addr_validate_and_normalize(char addr[4][4], int is_optional)
+{
+	int i, r;
+	for (i = 0; i < 4; i++) {
+		r = ip_digit_validate_and_normalize(addr[i]);
+		if (r) {
+			if (r != -1 || !is_optional) {
+				return r;
+			}
+			/* r == -1 && is_optional */
+			/* set whole ip to 0s - empty strings - will be processed when generating config */
+			addr[0][0] = 0;	
+			addr[1][0] = 0;	
+			addr[2][0] = 0;	
+			addr[3][0] = 0;	
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static void set_conf_var(FILE *fp, net_var_type_t nvt)
+{
+	int ipt;
+
+	if (nvt >= NVT_COUNT) {
+		return;
+	}
+	
+	switch (nvt) {
+		case NVT_HOST:
+			fprintf(fp, "%s=\"%s\"\n", CFG_HOST_NAME,  host_name);
+			break;
+		case NVT_DHCP:
+			fprintf(fp, "%s=\"%s\"\n", CFG_DHCP,  dhcp);
+			break;
+		default:
+			/* ip */
+			ipt = nvt_to_ipt(nvt);
+
+			if ((ipt == IPT_DNS1 || ipt == IPT_DNS2) && 
+				(ip[ipt][0][0] == 0)) {
+				fprintf(fp, "%s=\"\"\n", ip_cfg_names[ipt]);
+			} else {
+				fprintf(fp, "%s=\"%s.%s.%s.%s\"\n", ip_cfg_names[ipt],
+					ip[ipt][0], ip[ipt][1], ip[ipt][2], ip[ipt][3]);
+			}
+			break;
+	}
+	net_var_set_map[nvt]++;
+}
+
+/* return < 0 if var name type undefined, otherwise return the type value 
+* note: name is zero-terminated
+*/
+static int var_name_type(const char *name)
+{
+	int nvt;
+	int ipt;
+
+	for (nvt = 0; nvt < NVT_COUNT; nvt++) {
+		switch (nvt) {
+			case NVT_HOST:
+				if (!strcmp(CFG_HOST_NAME, name)) {
+					return nvt;
+				}
+				break;
+			case NVT_DHCP:
+				if (!strcmp(CFG_DHCP, name)) {
+					return nvt;
+				}
+				break;
+			default:
+				/* ip */
+				ipt = nvt_to_ipt(nvt);
+				if (!strcmp(ip_cfg_names[ipt], name)) {
+					return nvt;
+				}
+				break;
+		}
+	}
+	return -1; /* not found */
+}
+
+static int edit_conf_vars(wc_conf_parse_data_t *parse_data, void *data)
+{
+	int nvt;
+	FILE *fp = parse_data->fp_out;
+
+	if (parse_data->type == WC_CLT_WRONG) {
+		return 1;	/* remove wrong lines */
+	}
+
+	if (parse_data->type == WC_CLT_CREATED) {
+		/* print header */
+		fprintf(fp,	"# The parameters " CFG_IP_ADDR ", " CFG_IP_MASK ", " CFG_IP_GW " are required.\n"
+				"# Parameters MAC_ADDR, " CFG_DHCP " are optional.\n"
+				"\n");
+	}
+
+	if (parse_data->type == WC_CLT_EOF ||
+		parse_data->type == WC_CLT_CREATED) {
+		for (nvt = 0; nvt < NVT_COUNT; nvt++) {
+			if (!net_var_set_map[nvt]) {
+				set_conf_var(fp, nvt);
+			}
+		}
+		return 0; /* ignore */
+	}
+
+	if (parse_data->type == WC_CLT_VAR) {
+		char saved;
+
+		saved = parse_data->var[parse_data->var_len];
+		parse_data->var[parse_data->var_len] = 0;
+		nvt = var_name_type(parse_data->var);
+		parse_data->var[parse_data->var_len] = saved;
+		
+		if (!(nvt < 0)) {
+			set_conf_var(fp, nvt);
+			return 1;
+		}
+	}
+
+	/* printf the rest lines unchanged */
+	fprintf(fp, "%s", parse_data->line);
+	return 1;
 }
 
 static int apply_new_settings(wc_page_data_t *data)
 {
-	FILE *fp;
+	int r;
 	int invalid = 0;
+	const char *main_status;
 	
 	int addr_type;
-	char var_names[][4] = {
-		[ IP_ADDR ] = "ipN",
-		[ IP_MASK ] = "mN",
-		[ IP_GW ] = "gwN",
-		[ IP_DNS1 ] = "d1N",
-		[ IP_DNS2 ] = "d2N",
-	};
-	char cfg_names[][10] = {
-		[ IP_ADDR ] = CFG_IP_ADDR,
-		[ IP_MASK ] = CFG_IP_MASK,
-		[ IP_GW ] = CFG_IP_GW,
-		[ IP_DNS1 ] = CFG_IP_DNS1,
-		[ IP_DNS2 ] = CFG_IP_DNS2,
+	char ip_var_names[IPT_COUNT][4] = {
+		[ IPT_ADDR ] = "ipN",
+		[ IPT_MASK ] = "mN",
+		[ IPT_GW ] = "gwN",
+		[ IPT_DNS1 ] = "d1N",
+		[ IPT_DNS2 ] = "d2N",
 	};
-	int var_count = sizeof(var_names) / sizeof(var_names[0]);
 
+	/* extract vars from the request */
 	cgiFormStringNoNewlines("host", host_name, sizeof(host_name));
 	cgiFormStringNoNewlines("dhcp", dhcp, sizeof(dhcp));
 
-	for (addr_type = 0; addr_type < var_count; addr_type++) {
-		char *p = strchr(var_names[addr_type], 'N');
+	for (addr_type = 0; addr_type < IPT_COUNT; addr_type++) {
+		char *p = strchr(ip_var_names[addr_type], 'N');
 		int i;
 		for (i = 0; i < 4; i++) {
 			*p = 0x30 + i;
-			cgiFormStringNoNewlines(var_names[addr_type], ip[addr_type][i], 4);
-			if (ip_digit_validate_and_normalize(ip[addr_type][i]) != 0) {
-				invalid = 1;
-			}
+			cgiFormStringNoNewlines(ip_var_names[addr_type], ip[addr_type][i], 4);
+//			if (ip_digit_validate_and_normalize(ip[addr_type][i]) != 0) {
+//				invalid = 1;
+//			}
+		}
+		/* validate ip addr */
+		invalid = !!ip_addr_validate_and_normalize(ip[addr_type], 
+						addr_type == IPT_DNS1 || addr_type == IPT_DNS2);
+		if (invalid) {
+			sprintf(data->status_buf, "%s: %s", 
+					WC_STR_STATUS_ERROR, WC_STR_ERR_INVAL_IP);
+			return -1;
 		}
 	}
 
-	if (invalid) {
-		data->status_text = "Error: invalid ip addr data";
-		return -1;
-	}
-
-	/* generate new config */
-	fp = fopen(NET_CONFIG_FILE, "w");
-	if (!fp) {
-		sprintf(data->status_buf, "Error: failed to create %s config file", NET_CONFIG_FILE);
+	/* edit config if exists, create otherwise */
+	r = wc_conf_file_edit(NET_CONFIG_FILE, &edit_conf_vars, NULL, 1);
+	if (r) {
+		sprintf(data->status_buf, "Error: failed to edit/create %s config file", NET_CONFIG_FILE);
 		return -1;
 	}
 
-	fprintf(fp, "# The parameters " CFG_IP_ADDR ", " CFG_IP_MASK ", " CFG_IP_GW " are required.\n"
-			"# Parameters MAC_ADDR, " CFG_DHCP " are optional.\n"
-			"\n");
-	fprintf(fp, CFG_DHCP "=%s\n", dhcp);
-	for (addr_type = 0; addr_type < var_count; addr_type++) {
-		fprintf(fp, "%s=\"%s.%s.%s.%s\"\n", cfg_names[addr_type],
-			ip[addr_type][0], ip[addr_type][1], ip[addr_type][2], ip[addr_type][3]);
+	main_status = WC_STR_STATUS_APPLIED;
+		
+#if defined(WC_CONFIG_RC_SYNC)
+	{
+		int r;
+		r = wc_sync_configs();
+		if (r) {
+			main_status = WC_STR_STATUS_APPLIED_NS;
+		}
 	}
-	fprintf(fp, CFG_HOST_NAME "=\"%s\"\n", host_name);
-	
-	fflush(fp);
-	fclose(fp);
+#endif
 
-	data->status_text = "Settings updated. Restarting network..";
 	net_restart = 1;
+
+	if (dhcp[0] == '0') {
+		sprintf(data->status_buf, "%s %s", 
+				main_status, WC_STR_STATUS_NET_RESTART);
+		data->flags.cntdn = 1;
+	} else {
+		sprintf(data->status_buf, "%s %s", 
+				main_status, WC_STR_STATUS_NET_DYNIP);
+	}
 	
 	return 0;
 }
diff -Nru a/wc/wc_page_net.h b/wc/wc_page_net.h
--- a/wc/wc_page_net.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_net.h	2012-06-21 19:03:42.000000000 +0300
@@ -1,8 +1,8 @@
 #ifndef _WC_PAGE_NET_H_
 #define _WC_PAGE_NET_H_
 
-extern void process_net(wc_page_data_t *data);
-extern void post_process_net(void);
+extern void process_net(wc_page_data_t *data, int submitted);
+extern void post_process_net(wc_page_data_t *data);
 
 #endif /* _WC_PAGE_NET_H_*/
 
diff -Nru a/wc/wc_page_plc.c b/wc/wc_page_plc.c
--- a/wc/wc_page_plc.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_plc.c	2012-09-06 19:05:11.000000000 +0300
@@ -10,11 +10,15 @@
 
 #include "cgic.h"
 
-#include "wc_config.h"
+#include "wc_conf_file.h"
 #include "wc_tpl.h"
 #include "wc_page.h"
 #include "wc_page_plc.h"
 
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_PLC
+
 #define PLC_RMSYNC	"rmsync"
 #define PLC_RMSYNC_CFG	"/root/retain/" PLC_RMSYNC ".cfg"
 #define PLC_RMSYNC_PID	"/var/run/" PLC_RMSYNC ".pid"
@@ -27,11 +31,22 @@
 #define CFG_RETAIN_SCAN_INTERVAL	"RETAIN_SCAN_INTERVAL"
 #define CFG_RETAIN_SCAN_CHUNK		"RETAIN_SCAN_CHUNK"
 
+static const char *str_block_protection[] = 
+{
+	WC_STR_BP_NONE,
+	WC_STR_BP_UQ,
+	WC_STR_BP_UH,
+	WC_STR_BP_ALL,
+};
+static const char *str_rmsync_status[] = {
+	WC_STR_NRUN,
+	WC_STR_RUN,
+};
+
 typedef enum {
 	MRAM_SR = 0,
 	MRAM_PROT_VAL,
-
-	MRAM_TYPE_COUNT,
+	MRAM_PROT_FLAG,
 } mram_type_t;
 
 typedef enum {
@@ -39,40 +54,30 @@
 	RM_SIZE_KB,
 	RM_ADDR,
 	RM_FILE,
+	RM_RMSYNC_STATUS,
 	RM_INTERVAL,
+	RM_CHUNK_FLAG,		/* if set, chunk is processed */
 	RM_CHUNK,
-	RM_RMSYNC_STATUS,
-
-	RM_TYPE_COUNT,
 } rm_type_t;
 
 static char sr;
 static char sr_val[] = "0xXX";
-static const char *block_prot[] = {
-	"None",
-	"Upper Quarter",
-	"Upper Half",
-	"All",
-};
-
-#define RMSYNC_RUNNING "Running"
-#define RMSYNC_NOT_RUNNING "Not running"
 
-/* the same value as for whole line in rmsync app */
-#define VAL_BUF_LEN 256
 static char rm_size[11];		/* 8 digits hex: 0xffffffff = 10 digits dec: 4294967295 */
 static char rm_size_kb[8];		/* 8 digits hex: 0xffffffff in Kbytes - 7 digits dec = (4194304 - 1) */
 static char rm_addr[11];		/* 8 digit addr max like 0x2032a000 - 10 chars + 0 term */
-static char rm_file[VAL_BUF_LEN] = "";
+static char rm_file[WC_VAL_MAX_SIZE] = "";	/* /sys/.../eeprom - max len is not more than length of conf line of rmsync app i.e. 256 chars */
 static char rm_interval[4];		/* 1..300 - 4 chars */
+#ifdef WC_RM_CHUNK_OPTION
 static char rm_chunk[8];		/* 8 digits hex: 0xffffffff in Kbytes - 7 digits dec = (4194304 - 1) */
 static int rm_chunk_bytes;
-static const char *rm_rmsync_status; /* "running" or "not running" */
+#endif
 static struct {
 	unsigned edited_interval: 1;
 	unsigned edited_chunk: 1;
 
 	unsigned rmsync_running: 1;
+	unsigned retain_is_eeprom: 1; /* retain memory in MRAM or in FILE */
 } flags = { 
 	.edited_interval	= 0,
 	.edited_chunk		= 0,
@@ -89,11 +94,11 @@
 
 
 /* local methods */
-static int process_cfg_line(char *var, char *val);
+static int process_cfg_line(char *var, char *val, void *data);
 static int make_sr_fname(char *buf);
 static int get_and_check_rmsync_pid(void);
 static int get_current_settings(wc_page_data_t *data);
-static int get_conf_file(char *var, char *val);
+static int get_conf_file(char *var, char *val, void *data);
 static int edit_conf_vars(wc_conf_parse_data_t *parse_data, void *data);
 static int apply_new_settings(wc_page_data_t *data);
 
@@ -101,12 +106,21 @@
 
 static const char *get_var_mram(char *field)
 {
-	int i = *field - 0x30;
+	int i;
 
-	if (i == MRAM_SR) {
-		return sr_val;
-	} else if (i == MRAM_PROT_VAL) {
-		return block_prot[(sr >> 1) & 0x3];
+	if (!field) {
+		return flags.retain_is_eeprom ? "1" : "0";
+	}
+	
+	i = *field - 0x30;
+
+	switch (i) {
+		case MRAM_SR:
+			return sr_val;
+		case MRAM_PROT_VAL:
+			return str_block_protection[(sr >> 2) & 0x3];
+		case MRAM_PROT_FLAG:
+			return (sr >> 2) & 0x3 ? "1" : "0";
 	}
 	
 	return NULL;
@@ -114,22 +128,35 @@
 
 static const char *get_var_rm(char *field)
 {
-	int i = *field - 0x30;
+	int i;
+
+	if (!field) {
+		return NULL;
+	}
+	
+	i = *field - 0x30;
 
-	if (i == RM_SIZE) {
-		return rm_size;
-	} else if (i == RM_SIZE_KB) {
-		return rm_size_kb;
-	} else if (i == RM_ADDR) {
-		return rm_addr;
-	} else if (i == RM_FILE) {
-		return rm_file;
-	} else if (i == RM_INTERVAL) {
-		return rm_interval;
-	} else if (i == RM_CHUNK) {
-		return rm_chunk;
-	} else if (i == RM_RMSYNC_STATUS) {
-		return rm_rmsync_status;
+	switch (i) {
+		case RM_SIZE:
+			return rm_size;
+		case RM_SIZE_KB:
+			return rm_size_kb;
+		case RM_ADDR:
+			return rm_addr;
+		case RM_FILE:
+			return rm_file;
+		case RM_RMSYNC_STATUS:
+			return str_rmsync_status[flags.rmsync_running ? 1 : 0];
+		case RM_INTERVAL:
+			return rm_interval;
+		case RM_CHUNK_FLAG:
+#ifdef WC_RM_CHUNK_OPTION
+			return "1";
+		case RM_CHUNK:
+			return rm_chunk;
+#else
+			return "0";
+#endif
 	}
 
 	return NULL;
@@ -137,7 +164,7 @@
 
 /* --- Interface methods --- */
 
-void process_plc(wc_page_data_t *data)
+void process_plc(wc_page_data_t *data, int submitted)
 {
 	int i;
 
@@ -146,7 +173,9 @@
 		wc_tpl_var_register(&plc_vars[i]);
 	}
 
-	if (cgiFormSubmitClicked(WC_PAGE_SUBMIT_NAME) == cgiFormSuccess) {
+	wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, &wc_btn_reset, NULL);
+
+	if (submitted) {
 		/* get data from the request - edit conf, unprotect memory as need */
 		apply_new_settings(data);
 	}
@@ -157,7 +186,7 @@
 
 /* --- local subroutines --- */
 
-static int process_cfg_line(char *var, char *val)
+static int process_cfg_line(char *var, char *val, void *data)
 {
 	int len, buf_size;
 	char *pval = NULL;
@@ -179,10 +208,12 @@
 		} else if (!strcmp(var, CFG_RETAIN_SCAN_INTERVAL)) {
 			pval = rm_interval;
 			buf_size = sizeof(rm_interval);
+#ifdef WC_RM_CHUNK_OPTION
 		} else if (!strcmp(var, CFG_RETAIN_SCAN_CHUNK)) {
 			size_kb = ((unsigned long)atoll(val)) / 1024;
 			sprintf(rm_chunk, "%lu", size_kb);
 			break;
+#endif
 		}
 
 		if (!pval) {
@@ -224,7 +255,6 @@
 	char *p;
 
 	/* determine rmsync status and return pid */
-	rm_rmsync_status = RMSYNC_NOT_RUNNING;
 	flags.rmsync_running = 0;
 	do {
 		FILE *fp;
@@ -262,7 +292,6 @@
 
 		p = strstr(buf, PLC_RMSYNC);
 		if (p) {
-			rm_rmsync_status = RMSYNC_RUNNING;
 			flags.rmsync_running = 1;
 			r = pid;
 		}
@@ -274,50 +303,56 @@
 {
 	int r;
 	FILE *fp;
-	char buf[VAL_BUF_LEN];
 	char *p;
 
 	/* read rmsync config */
-	r = wc_conf_read_file(PLC_RMSYNC_CFG, &process_cfg_line);
+	r = wc_conf_file_read(PLC_RMSYNC_CFG, &process_cfg_line, NULL);
 	if (r) {
 		sprintf(data->status_buf, "Error: failed to read %s config file", PLC_RMSYNC_CFG);
 		return -1;
 	}
 
+	/* determine whether retain memory is EEPROM or FILE: EEPROM path starts with /sys/, otherwise - FILE */
+	flags.retain_is_eeprom= !memcmp(rm_file, "/sys/", 5);
+
 	/* determine rmsync status */
 	get_and_check_rmsync_pid();
 	
-	/* read MARM SR val */
-	do {
-		sr = 0;
-
-//data->status_text =rm_file;
-		if (make_sr_fname(buf) != 0) {
-			sprintf(sr_val, "err1");
-			break;
-		}
-		
-		fp = fopen(buf, "r");
-		if (!fp) {
-			sprintf(sr_val, "err2");
-			break;
-		}
+	if (flags.retain_is_eeprom) {
+		/* read MARM SR val */
+		do {
+			char sr_file[sizeof(rm_file)];
+			
+			sr = 0;
+
+			//data->status_text =rm_file;
+			if (make_sr_fname(sr_file) != 0) {
+				sprintf(sr_val, "err1");
+				break;
+			}
+			
+			fp = fopen(sr_file, "r");
+			if (!fp) {
+				sprintf(sr_val, "err2");
+				break;
+			}
 
-		p = fgets(buf, sizeof(buf), fp);
-		fclose(fp);
-		if (!p) {
-			sprintf(sr_val, "err3");
-			break;
-		}
+			p = fgets(data->val_buf, sizeof(data->val_buf), fp);
+			fclose(fp);
+			if (!p) {
+				sprintf(sr_val, "err3");
+				break;
+			}
 
-		sr = (char)strtol(buf, NULL, 0);
-		sprintf(sr_val, "0x%02X", sr);
-	} while (0);
+			sr = (char)strtol(data->val_buf, NULL, 0);
+			sprintf(sr_val, "0x%02X", sr);
+		} while (0);
+	}
 
 	return 0;
 }
 
-static int get_conf_file(char *var, char *val)
+static int get_conf_file(char *var, char *val, void *data)
 {
 	int r = 1;
 	if (!strcmp(var, CFG_RETAIN_FILE)) {
@@ -331,7 +366,7 @@
 
 static int edit_conf_vars(wc_conf_parse_data_t *parse_data, void *data)
 {
-	FILE *fp_out = (FILE*)data;
+	FILE *fp_out = parse_data->fp_out;
 
 	if (parse_data->type == WC_CLT_WRONG) {
 		return 1;	/* remove wrong lines */
@@ -341,9 +376,11 @@
 		if (!flags.edited_interval) {
 			fprintf(fp_out, "%s=%s\n", CFG_RETAIN_SCAN_INTERVAL, rm_interval);
 		}
-		if (!flags.edited_chunk) {
+#ifdef WC_RM_CHUNK_OPTION
+		if (!flags.edited_chunk && rm_chunk_bytes > 0) {
 			fprintf(fp_out, "%s=%d\n", CFG_RETAIN_SCAN_CHUNK, rm_chunk_bytes);
 		}
+#endif
 		return 0; /* ignore */
 	}
 
@@ -353,11 +390,13 @@
 			fprintf(fp_out, "%s=%s\n", CFG_RETAIN_SCAN_INTERVAL, rm_interval);
 			flags.edited_interval = 1;
 			return 1;
+#ifdef WC_RM_CHUNK_OPTION
 		} else if (!memcmp(CFG_RETAIN_SCAN_CHUNK, parse_data->var, parse_data->var_len) &&
 			(sizeof(CFG_RETAIN_SCAN_CHUNK) - 1 == parse_data->var_len)) {
 			fprintf(fp_out, "%s=%d\n", CFG_RETAIN_SCAN_CHUNK, rm_chunk_bytes);
 			flags.edited_chunk = 1;
 			return 1;
+#endif
 		}
 	}
 
@@ -370,7 +409,6 @@
 {
 	char unp[] = "0";
 	int unprotected = 0;
-	char buf[VAL_BUF_LEN];
 	FILE *fp;
 	int r;
 	int pid;
@@ -378,19 +416,28 @@
 	cgiFormStringNoNewlines("unp", unp, sizeof(unp));
 	if (unp[0] == '1') {
 		do {
+			char sr_file[sizeof(rm_file)];
+			
 			/* read file config option */
-			r = wc_conf_read_file(PLC_RMSYNC_CFG, &get_conf_file);
+			r = wc_conf_file_read(PLC_RMSYNC_CFG, &get_conf_file, NULL);
 			if (r) {
 				sprintf(data->status_buf, "Error: failed to read %s config file", PLC_RMSYNC_CFG);
 				return -1;
 			}
 
-			if (make_sr_fname(buf) != 0) {
+			/* determine whether retain memory is EEPROM or FILE: EEPROM path starts with /sys/, otherwise - FILE */
+			flags.retain_is_eeprom= !memcmp(rm_file, "/sys/", 5);
+			if (!flags.retain_is_eeprom) {
+				/* ignore for non-EEPROM */
+				break;
+			}
+
+			if (make_sr_fname(sr_file) != 0) {
 				//data->status_text = "failed to build fname";
 				break;
 			}
 
-			fp = fopen(buf, "w+");
+			fp = fopen(sr_file, "w+");
 			if (!fp) {
 				//data->status_text = "open error";
 				break;
@@ -405,10 +452,12 @@
 
 	/* edit config file */
 	cgiFormStringNoNewlines("interval", rm_interval, sizeof(rm_interval));
+#ifdef WC_RM_CHUNK_OPTION
 	cgiFormStringNoNewlines("chunk", rm_chunk, sizeof(rm_chunk));
 	rm_chunk_bytes = atoi(rm_chunk) * 1024;
+#endif
 	
-	r = wc_conf_edit_file(PLC_RMSYNC_CFG, &edit_conf_vars);
+	r = wc_conf_file_edit(PLC_RMSYNC_CFG, &edit_conf_vars, NULL, 0);
 	if (r) {
 		sprintf(data->status_buf, "Error: failed to edit %s config file", PLC_RMSYNC_CFG);
 		return -1;
@@ -423,9 +472,14 @@
 		}
 	}
 
-	sprintf(data->status_buf, "Settings applied%s\n", 
-		unprotected ? ", memory unprotected" : "");
+	if (unprotected) {
+		sprintf(data->status_buf, "%s %s", 
+			WC_STR_STATUS_APPLIED, WC_STR_STATUS_PLC_UNPROT);
+	} else {
+		data->status_text = WC_STR_STATUS_APPLIED;
+	}
 
 	return 0;
 }
 
+#endif /* WC_CONFIG_MENU_PLC */
diff -Nru a/wc/wc_page_plc.h b/wc/wc_page_plc.h
--- a/wc/wc_page_plc.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_plc.h	2011-03-09 17:39:01.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _WC_PAGE_PLC_H_
 #define _WC_PAGE_PLC_H_
 
-extern void process_plc(wc_page_data_t *data);
+extern void process_plc(wc_page_data_t *data, int submitted);
 
 #endif /* _WC_PAGE_PLC_H_*/
 
diff -Nru a/wc/wc_page_sec.c b/wc/wc_page_sec.c
--- a/wc/wc_page_sec.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_sec.c	2012-07-12 00:31:53.000000000 +0300
@@ -1,3 +1,4 @@
+#include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -10,6 +11,8 @@
 #include "wc_page.h"
 #include "wc_page_sec.h"
 
+#include "wc_strings.h"
+
 #define PASS_FILE "../.htpasswd"
 
 /* From local_passwd.c (C) Regents of Univ. of California blah blah */
@@ -39,21 +42,24 @@
 	return 0;
 }
 
-void process_sec(wc_page_data_t *data)
+void process_sec(wc_page_data_t *data, int submitted)
 {
 	int r;
 	FILE *fp;
 	char pwd[9], pwdr[9]; /* max len 8 + 1 for terminating 0 */
 
+	wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, NULL, NULL);
+
 	/* process pwd change if submitted */
-	if (cgiFormSubmitClicked(WC_PAGE_SUBMIT_NAME) != cgiFormSuccess) {
+	if (!submitted) {
 		return; /*nothing to do */
 	}
 
 	cgiFormStringNoNewlines("pwd", pwd, sizeof(pwd));
 	cgiFormStringNoNewlines("pwdr", pwdr, sizeof(pwdr));
 	if (strcmp(pwd, pwdr)) {
-		data->status_text = "Password hasn't been set: typed strings are not equal";
+		sprintf(data->status_buf, "%s: %s", 
+				WC_STR_STATUS_ERROR, WC_STR_ERR_PWD_NOT_EQUAL);
 		return;
 	}
 
@@ -65,10 +71,12 @@
 	r = add_password("www-data", pwd, fp);
 	fclose(fp);
 
+	sync();
+
 	if (r) {
 		data->status_text = "Password hasn't been set: failed to encrypt";
 	} else {
-		data->status_text = "Password has been changed successfully";
+		data->status_text = WC_STR_STATUS_APPLIED;
 	}
 }
 
diff -Nru a/wc/wc_page_sec.h b/wc/wc_page_sec.h
--- a/wc/wc_page_sec.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_page_sec.h	2011-03-09 17:39:01.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _WC_PAGE_SEC_H_
 #define _WC_PAGE_SEC_H_
 
-extern void process_sec(wc_page_data_t *data);
+extern void process_sec(wc_page_data_t *data, int submitted);
 
 #endif /* _WC_PAGE_SEC_H_*/
 
diff -Nru a/wc/wc_page_test.c b/wc/wc_page_test.c
--- a/wc/wc_page_test.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_page_test.c	2012-07-12 00:31:53.000000000 +0300
@@ -0,0 +1,105 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include "cgic.h"
+
+//#include "wc_conf_file.h"
+#include "wc_tpl.h"
+#include "wc_page.h"
+#include "wc_page_test.h"
+
+//#include "wc_strings.h"
+
+typedef enum {
+	SM_GENERAL	= 0,
+	SM_MODEM,
+	SM_PPP,
+	SM_PING,
+} test_subm_t;
+
+/* Vars */
+static const char *subm[] = {
+	"General",
+	"Modem",
+	"PPP",
+	"Ping"
+};
+#if 0
+static const char *get_var_mram(char *field);
+static wc_tpl_var_t plc_vars[] = {
+	{ .name = "mram", .get = &get_var_mram },
+};
+const int plc_vars_count = sizeof(plc_vars) / sizeof(plc_vars[0]);
+#endif
+
+/* local methods */
+static int get_current_settings(wc_page_data_t *data);
+static int apply_new_settings(wc_page_data_t *data);
+
+/* --- Var handlers --- */
+#if 0
+static const char *get_var_mram(char *field)
+{
+	int i;
+
+	if (!field) {
+		return flags.retain_is_eeprom ? "1" : "0";
+	}
+	
+	i = *field - 0x30;
+
+	switch (i) {
+		case MRAM_SR:
+			return sr_val;
+		case MRAM_PROT_VAL:
+			return str_block_protection[(sr >> 1) & 0x3];
+		case MRAM_PROT_FLAG:
+			return (sr >> 1) & 0x3 ? "1" : "0";
+	}
+	
+	return NULL;
+}
+#endif
+
+/* --- Interface methods --- */
+
+void process_test(wc_page_data_t *data, int submitted)
+{
+#if 0
+	int i;
+	/* register vars & commands */
+	for (i = 0; i < plc_vars_count; i++) {
+		wc_tpl_var_register(&plc_vars[i]);
+	}
+#endif
+
+	wc_subm_register(subm, 4);
+	if (data->subm_index == SM_PING) {
+		wc_form_enable(WC_FBA_RIGHT, &wc_btn_ok, NULL, NULL);
+	}
+	//data->flags.form_reset = 1;
+	strcpy(data->form_title, subm[data->subm_index]);
+
+	if (submitted) {
+		apply_new_settings(data);
+	}
+	get_current_settings(data);
+}
+
+/* --- local subroutines --- */
+
+
+static int get_current_settings(wc_page_data_t *data)
+{
+	return 0;
+}
+
+static int apply_new_settings(wc_page_data_t *data)
+{
+	if (data->subm_index == SM_PING) {
+		
+	}
+	return 0;
+}
diff -Nru a/wc/wc_page_test.h b/wc/wc_page_test.h
--- a/wc/wc_page_test.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_page_test.h	2011-05-10 18:53:36.000000000 +0300
@@ -0,0 +1,6 @@
+#ifndef _WC_PAGE_TEST_H_
+#define _WC_PAGE_TEST_H_
+
+extern void process_test(wc_page_data_t *data, int submitted);
+
+#endif /* _WC_PAGE_TEST_H_ */
diff -Nru a/wc/wc_page_utils.c b/wc/wc_page_utils.c
--- a/wc/wc_page_utils.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_page_utils.c	2012-09-06 19:05:11.000000000 +0300
@@ -0,0 +1,85 @@
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "cgic.h"
+
+#include "wc_tpl.h"
+#include "wc_page.h"
+#include "wc_page_utils.h"
+#ifdef WC_CONFIG_MENU_UTILS_PING
+#include "wc_utils_ping.h"
+#endif
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_UTILS
+
+static wc_menu_t submenu[] = {
+//	{ .name = WC_NET_SP_NAME_MAIN,		.title = WC_STR_NET_MAIN,
+//		.process = NULL,	.post_process = NULL, },
+
+#ifdef WC_CONFIG_MENU_UTILS_PING
+	{ .name = WC_UTILS_SP_PING,		.title = WC_STR_UTILS_PING,
+		.process = wc_utils_ping_process,	.post_process = wc_utils_ping_post_process, },
+#endif
+
+	{ .name = NULL, },
+};
+
+/* Vars */
+//static const char *get_var_host(char *field);
+//static wc_tpl_var_t net_vars[] = {
+//	{ .name = "host", .get = &get_var_host },
+//	{ .name = NULL, },
+//};
+
+/* local methods */
+//static int get_current_settings(wc_page_data_t *data);
+//static int apply_new_settings(wc_page_data_t *data);
+
+/* --- Var handlers --- */
+
+//static const char *get_var_host(char *field)
+//{
+//	return host_name;
+//}
+
+/* --- Interface methods --- */
+
+void process_utils(wc_page_data_t *data, int submitted)
+{
+	wc_menu_t *sp = NULL;
+
+	wc_sub_menu_register(submenu);
+
+	if (data->sub_count > 0) {
+		sp = &data->sub_pages[data->sub_index];
+		strcat(data->form_title, " - ");
+		strcat(data->form_title, sp->title);
+	}
+
+	/* call processor for current subpage */
+	if (sp && sp->process) {
+		sp->process(data, submitted);
+	}
+}
+
+void post_process_utils(wc_page_data_t *data)
+{
+	wc_menu_t *sp = NULL;
+
+	if (data->sub_count > 0) {
+		sp = &data->sub_pages[data->sub_index];
+	}
+
+	/* call postptocess for current subpage */
+	if (sp && sp->post_process) {
+		sp->post_process(data);
+	}
+}
+
+/* --- local subroutines --- */
+
+#endif /* WC_CONFIG_MENU_UTILS */
+
diff -Nru a/wc/wc_page_utils.h b/wc/wc_page_utils.h
--- a/wc/wc_page_utils.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_page_utils.h	2012-07-12 18:25:29.000000000 +0300
@@ -0,0 +1,10 @@
+#ifndef _WC_PAGE_UTILS_H_
+#define _WC_PAGE_UTILS_H_
+
+#include "wc_utils.h"
+
+extern void process_utils(wc_page_data_t *data, int submitted);
+extern void post_process_utils(wc_page_data_t *data);
+
+#endif /* _WC_PAGE_UTILS_H_*/
+
diff -Nru a/wc/wc_plc_defs.h b/wc/wc_plc_defs.h
--- a/wc/wc_plc_defs.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_plc_defs.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,30 +0,0 @@
-#ifndef _WC_PLC_DEFS_H_
-#define _WC_PLC_DEFS_H_
-
-/* --- HE5684 ---*/
-#if defined(OWEN_HE5684)
-#define WC_PLC_NAME "HE5684"
-
-/* --- PLC110 ---*/
-#elif defined(OWEN_PLC110)
-#define WC_PLC_NAME "PLC110"
-
-/* --- PLC100 ---*/
-#elif defined(OWEN_PLC100)
-#define WC_PLC_NAME "PLC100"
-
-/* --- PLC240 ---*/
-#elif defined(OWEN_PLC240)
-#define WC_PLC_NAME "PLC240"
-
-/* --- PLC304 ---*/
-#elif defined(OWEN_PLC304)
-#define WC_PLC_NAME "PLC304"
-
-/* --- default ---*/
-#else
-#define WC_PLC_NAME "PLC"
-#endif
-
-#endif /* _WC_PLC_DEFS_H_ */
-
diff -Nru a/wc/wc_strings.c b/wc/wc_strings.c
--- a/wc/wc_strings.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_strings.c	2012-09-19 16:24:51.000000000 +0300
@@ -0,0 +1,336 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "wc_tpl.h"
+#include "wc_net.h"
+#include "wc_utils.h"
+#include "wc_strings.h"
+
+static wc_page_data_t *pd = NULL;
+
+typedef struct sub_strings_t {
+	const char *sub_name;
+	const char **strings;
+	size_t count;
+} sub_strings_t;
+
+/* Vars */
+
+static const char *get_var_str(char *field);
+static wc_tpl_var_t tpl_var_str = { .name = "str", .get = &get_var_str };
+
+/* strings arrays for forms */
+static const char *strings_dt[] = {
+	WC_STR_DT_0,
+	WC_STR_DT_1,
+	WC_STR_DT_2,
+};
+
+/* submenu's string arrays should be NULL-terminated */
+static const char *strings_net_main[] = {
+	WC_STR_NET_0,
+	WC_STR_NET_1,
+	WC_STR_NET_2,
+	WC_STR_NET_3,
+	WC_STR_NET_4,
+	WC_STR_NET_5,
+	WC_STR_NET_6,
+};
+
+#ifdef WC_CONFIG_MENU_NET_PPP
+/* common strings set for GPRS and VPN in order to use common templates */
+static const char *strings_net_ppp[] = {
+	WC_STR_PPP_NAME,	/* .0 */
+
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	WC_STR_PPP_PORT_OPTS,	/* .1, etc. */
+	WC_STR_PPP_PORT,
+	WC_STR_PPP_PORT_SPEED,
+	WC_STR_PPP_PORT_FLOW,
+
+	WC_STR_PPP_MODEM_OPTS,	/*5*/
+	WC_STR_PPP_SIM_PIN,
+	WC_STR_PPP_INIT_STR,
+	WC_STR_PPP_APN,
+	WC_STR_PPP_CALLNUM,
+#else /* to keep order the same subst the absent strings with the same number of empty strings "" */
+	"", "", "", "", "", "", "", "", "", 
+#endif
+
+	WC_STR_PPP_PPP_OPTS,	/*10*/
+	WC_STR_LOGIN,
+	WC_STR_PASSWORD,
+	WC_STR_PPP_IP,
+	WC_STR_DYNAMIC,
+
+	WC_STR_PPP_START_OPTS,	/*15*/
+	WC_STR_PPP_AUTO_START,
+	"",	/* str removed */
+
+	WC_STR_PPP_STATE,		/*18*/
+
+#ifdef WC_CONFIG_MENU_NET_VPN
+	/* VPN -only */
+	WC_STR_PPP_VPN_SERVER,		/*19*/
+
+	WC_STR_PPP_VPN_ROUTE,		/*20*/
+	WC_STR_PPP_VPN_ADDR,
+	WC_STR_PPP_VPN_MASK,
+#else
+	"", "", "", "",
+#endif
+
+	WC_STR_PPP_CLEAR_LOG,		/* 23 */
+};
+#endif
+
+#ifdef WC_CONFIG_MENU_NET_DDNS
+static const char *strings_net_ddns[] = {
+	WC_STR_DDNS_SYSTEM,
+	WC_STR_LOGIN,
+	WC_STR_PASSWORD,
+	WC_STR_DDNS_HOST,
+	WC_STR_DDNS_DOMAIN,
+	WC_STR_DDNS_HASH,
+	WC_STR_DDNS_UPDATE_PERIOD,
+};
+#endif
+
+static sub_strings_t strings_net[] = {
+	{ WC_NET_SP_NAME_MAIN,	strings_net_main,	ARRAY_SIZE(strings_net_main) },
+#ifdef WC_CONFIG_MENU_NET_GPRS
+	{ WC_NET_SP_NAME_GPRS,	strings_net_ppp,		ARRAY_SIZE(strings_net_ppp) },
+#endif
+#ifdef WC_CONFIG_MENU_NET_VPN
+	{ WC_NET_SP_NAME_VPN,	strings_net_ppp,		ARRAY_SIZE(strings_net_ppp) },
+#endif
+#ifdef WC_CONFIG_MENU_NET_DDNS
+	{ WC_NET_SP_NAME_DDNS,	strings_net_ddns,		ARRAY_SIZE(strings_net_ddns) },
+#endif
+};
+
+static const char *strings_sec[] = {
+	WC_STR_SEC_0,
+	WC_STR_SEC_1,
+};
+
+#ifdef WC_CONFIG_MENU_PLC
+static const char *strings_plc_mp[] = {
+	WC_STR_PLC_MP_0,
+	WC_STR_PLC_MP_1,
+	WC_STR_PLC_MP_2,
+	WC_STR_PLC_MP_3,
+};
+static const char *strings_plc_rm[] = {
+	WC_STR_PLC_RM_0,
+	WC_STR_PLC_RM_1,
+	WC_STR_PLC_RM_2,
+	WC_STR_PLC_RM_3,
+	WC_STR_PLC_RM_4,
+	WC_STR_PLC_RM_5,
+	WC_STR_PLC_RM_6,
+};
+#endif
+
+#ifdef WC_CONFIG_MENU_UTILS
+#ifdef WC_CONFIG_MENU_UTILS_PING
+static const char *strings_utils_ping[] = {
+	WC_STR_PING_HOST_ADDR,
+	WC_STR_PING_CHECKING,
+};
+#endif
+
+static sub_strings_t strings_utils[] = {
+#ifdef WC_CONFIG_MENU_UTILS_PING
+	{ WC_UTILS_SP_PING,	strings_utils_ping,	ARRAY_SIZE(strings_utils_ping) },
+#endif
+};
+#endif /* WC_CONFIG_MENU_UTILS */
+
+static const char *get_str_by_num_field(const char *strings[], int count, const char *field)
+{
+	int i;
+	if (*field == 0) {
+		return NULL;
+	}
+	i = atoi(field);
+	if (i < count) {
+		return strings[i];
+	}
+	return NULL;
+}
+
+/* --- Var handlers --- */
+
+static const char *get_var_str(char *field)
+{
+	char c;
+	char *p;
+
+	if (!field) {
+		return NULL;
+	}
+
+	if (*(field + 1) == TPL_CHAR_VAR_FIELD_SEP && *(field + 2) != 0) {
+		/* =str.C.Name - where C - category, Name - name in the category */
+		c = *field;
+		field = field + 2;
+
+		switch (c) {
+			case 'b':
+				/* buttons */
+				if (!strcmp(field, "on")) {
+					return WC_STR_ON;
+				} else if (!strcmp(field, "off")) {
+					return WC_STR_OFF;
+				} else if (!strcmp(field, "reset")) {
+					return WC_STR_RESET;
+				} else if (!strcmp(field, "ok")) {
+					return WC_STR_OK;
+				} else if (!strcmp(field, "cancel")) {
+					return WC_STR_CANCEL;
+				} else if (!strcmp(field, "back")) {
+					return WC_STR_BACK;
+				} else if (!strcmp(field, "whole")) {
+					return WC_STR_WHOLE;
+				} else if (!strcmp(field, "std")) {
+					return WC_STR_STANDARD_VALS;
+				}
+				break;
+			case 'm': /* external menu items (see plc304msan) */
+				if (!strcmp(field, "sensors")) {
+					return WC_STR_M_SENSORS;
+				}
+				break;
+		}
+
+		return NULL;
+	}
+
+	/* =str.name(>=2chars).index|name */
+	p = strchr(field, TPL_CHAR_VAR_FIELD_SEP);
+	if (p) {
+		int len = p - field;
+		if (len + 1 == sizeof(WC_NAME_PAGE_DT) && !memcmp(field, WC_NAME_PAGE_DT, len)) {
+			return get_str_by_num_field(strings_dt, ARRAY_SIZE(strings_dt), p + 1);
+		} else if (len + 1 == sizeof(WC_NAME_PAGE_NET) && !memcmp(field, WC_NAME_PAGE_NET, len)) {
+#ifdef WC_CONFIG_MENU_NET_SUBMENU
+			if (pd->sub_count > 1) {
+				int i;
+				/* NET has subpages, so distinguish between them.. */
+				for (i = 0; i < ARRAY_SIZE(strings_net); i++) {
+					if (!strcmp(pd->sub_name, strings_net[i].sub_name)) {
+						return get_str_by_num_field(strings_net[i].strings, 
+											strings_net[i].count, p + 1);
+					}
+				}
+				return NULL;
+			} else {
+#endif
+				/* NET does not have subpages, or has 1 subpage, which is main, which is the first item - required */
+				return get_str_by_num_field(strings_net[0].strings, 
+										strings_net[0].count, p + 1);
+#ifdef WC_CONFIG_MENU_NET_SUBMENU
+			}
+#endif
+		} else if (len + 1 == sizeof(WC_NAME_PAGE_SEC) && !memcmp(field, WC_NAME_PAGE_SEC, len)) {
+			return get_str_by_num_field(strings_sec, ARRAY_SIZE(strings_sec), p + 1);
+		}
+#ifdef WC_CONFIG_MENU_PLC
+		else if (len + 1 == sizeof(WC_NAME_PAGE_PLC) && !memcmp(field, WC_NAME_PAGE_PLC, len)) {
+			/* the field is 'mp.N' or 'rm.N' */
+			p++;
+			if (!memcmp(p, "mp.", 3)) {
+				return get_str_by_num_field(strings_plc_mp, 
+										ARRAY_SIZE(strings_plc_mp), p + 3);
+			} else if (!memcmp(p, "rm.", 3)) {
+				return get_str_by_num_field(strings_plc_rm, 
+										ARRAY_SIZE(strings_plc_rm), p + 3);
+			}
+		}
+#endif
+#ifdef WC_CONFIG_MENU_UTILS
+		else if (len + 1 == sizeof(WC_NAME_PAGE_UTILS) && !memcmp(field, WC_NAME_PAGE_UTILS, len)) {
+			int i;
+			/* submenu is always */
+			for (i = 0; i < ARRAY_SIZE(strings_utils); i++) {
+				if (!strcmp(pd->sub_name, strings_utils[i].sub_name)) {
+					return get_str_by_num_field(strings_utils[i].strings, 
+										strings_utils[i].count, p + 1);
+				}
+			}
+			return NULL;
+		}
+#endif /* WC_CONFIG_MENU_UTILS */
+
+		return NULL;
+	}
+
+	/* =str.name */
+	if (!strcmp(field, "plc")) {
+		return WC_CONFIG_PLC_NAME;
+	} else if (!strcmp(field, "title")) {
+		return pd->title;
+	} else if (!strcmp(field, "ftitle")) {
+		return pd->form_title;
+	} else if (!strcmp(field, "yes")) {
+		return WC_STR_YES;
+	} else if (!strcmp(field, "no")) {
+		return WC_STR_NO;
+	} else if (!strcmp(field, "secs")) {
+		return WC_STR_SECONDS;
+	} else if (!strcmp(field, "bytes")) {
+		return WC_STR_BYTES;
+	} else if (!strcmp(field, "kbytes")) {
+		return WC_STR_KBYTES;
+	} else if (!strcmp(field, "add")) {
+		return WC_STR_ACT_ADD;
+	} else if (!strcmp(field, "norec")) {
+		return WC_STR_TAB_NO_RECORDS;
+	}
+
+	return NULL;
+}
+
+void wc_strings_init(wc_page_data_t *page_data)
+{
+	pd = page_data;
+	
+	/* register 'str' var */
+	wc_tpl_var_register(&tpl_var_str);
+
+	/* init strings */
+	switch (pd->ct_id) {
+		case WC_CT_TEXT:
+			strcpy(pd->content_type, "plain/text");
+			break;
+		case WC_CT_HTML:
+		default:
+			sprintf(pd->content_type, "text/html; charset=%s", WC_STR_CHARSET);
+			break;
+	}
+
+	sprintf(pd->title, WC_STR_TITLE_FMT, WC_CONFIG_PLC_NAME);
+
+	/* select form title by page name */
+	pd->form_title[0] = 0;
+	if (!strcmp(pd->name, WC_NAME_PAGE_DT)) {
+		strncat(pd->form_title, WC_STR_DT_TITLE, sizeof(pd->form_title) - 1);
+	} else if (!strcmp(pd->name, WC_NAME_PAGE_NET)) {
+		strncat(pd->form_title, WC_STR_NET_TITLE, sizeof(pd->form_title) - 1);
+	} else if (!strcmp(pd->name, WC_NAME_PAGE_SEC)) {
+		strncat(pd->form_title, WC_STR_SEC_TITLE, sizeof(pd->form_title) - 1);
+	}
+#ifdef WC_CONFIG_MENU_PLC
+	else if (!strcmp(pd->name, WC_NAME_PAGE_PLC)) {
+		strncat(pd->form_title, WC_STR_PLC_TITLE, sizeof(pd->form_title) - 1);
+	}
+#endif
+#ifdef WC_CONFIG_MENU_UTILS
+	else if (!strcmp(pd->name, WC_NAME_PAGE_UTILS)) {
+		strncat(pd->form_title, WC_STR_UTILS_TITLE, sizeof(pd->form_title) - 1);
+	}
+#endif
+}
+
diff -Nru a/wc/wc_strings_en.h b/wc/wc_strings_en.h
--- a/wc/wc_strings_en.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_strings_en.h	2012-09-14 19:04:42.000000000 +0300
@@ -0,0 +1,220 @@
+#ifndef _WC_STRINGS_LANG_H_
+#define _WC_STRINGS_LANG_H_
+
+#define WC_STR_PLC_NAME_HE5684	"HE5684"
+#define WC_STR_PLC_NAME_MODUS5684	"Modus 5684"
+#define WC_STR_PLC_NAME_PLC304	"PLC 304"
+#define WC_STR_PLC_NAME_PLC323	"PLC 323"
+#define WC_STR_CHARSET		"iso-8859-1"
+#define WC_STR_TITLE_FMT	"%s Setup"
+
+#define WC_STR_BP_NONE		"None"
+#define WC_STR_BP_UQ		"Upper quarter"
+#define WC_STR_BP_UH		"Upper half"
+#define WC_STR_BP_ALL		"All"
+
+#define WC_STR_RUN			"Running"
+#define WC_STR_NRUN		"Not running"
+
+#define WC_STR_DYNAMIC		"Dynamic"
+#define WC_STR_NO_AUTH	"No auth"
+
+#define WC_STR_ACT_ADD	"Add"
+
+#define WC_STR_ACT_VIEW	"view"
+#define WC_STR_ACT_EDIT	"edit"
+#define WC_STR_ACT_DEL		"del"
+#define WC_STR_ACT_START	"start"
+#define WC_STR_ACT_STOP	"stop"
+#define WC_STR_ACT_LOG		"log"
+
+#define WC_STR_CONFIRM_PREFIX		"Are you sure you want to"
+
+#define WC_STR_CONFIRM_PPP_DEL	"%s delete profile \\'%s\\'?"
+#define WC_STR_CONFIRM_PPP_START	"%s start connection \\'%s\\'?"
+#define WC_STR_CONFIRM_PPP_STOP	"%s stop connection \\'%s\\'?"
+
+#define WC_STR_MODE_LIST_PROFILES		"List of profiles"
+#define WC_STR_MODE_ADD_PROFILE		"Adding profile"
+#define WC_STR_MODE_EDIT_PROFILE		"Editing profile"
+#define WC_STR_MODE_VIEW_PROFILE		"Viewing profile"
+
+#define WC_STR_PPP_LOG_VIEW_TITLE	"Viewing log"
+#define WC_STR_PPP_CLEAR_LOG			"Clear log"
+
+#define WC_STR_TAB_NO_RECORDS			"There are no records."
+
+/* =str.<name> */
+#define WC_STR_YES		"Yes"
+#define WC_STR_NO		"No"
+#define WC_STR_SECONDS	"sec."
+#define WC_STR_BYTES	"bytes"
+#define WC_STR_KBYTES	"KBytes"
+
+/* buttons =str.b.<name> */
+#define WC_STR_ON		"On"
+#define WC_STR_OFF		"Off"
+#define WC_STR_RESET	"Reset"
+#define WC_STR_OK		"OK"
+#define WC_STR_CANCEL	"Cancel"
+#define WC_STR_BACK	"Back"
+#define WC_STR_CLOSE	"Close"
+#define WC_STR_CHECK	"Check"
+#define WC_STR_WHOLE	"Whole"
+#define WC_STR_STANDARD_VALS	"Standard values"
+
+/* menus =str.m.<name> */
+#define WC_STR_M_DT	"Date/Time"
+#define WC_STR_M_NET	"Network"
+#define WC_STR_M_SEC	"Security"
+#define WC_STR_M_PLC	"PLC options"
+#define WC_STR_M_UTILS	"Utilities"
+#define WC_STR_M_SENSORS	"Sensors"
+#define WC_STR_M_TEST	"Test"
+
+/* menu-form title =str.ftitle */
+#define WC_STR_DT_TITLE	"Set date/time"
+#define WC_STR_NET_TITLE	"Network settings"
+#define WC_STR_SEC_TITLE	"Set password for user www-data"
+#define WC_STR_PLC_TITLE	"Misc. PLC options"
+#define WC_STR_UTILS_TITLE	"Utilities"
+
+/* page-specifc =str.<PG>.<FIELD> */
+
+#define WC_STR_DT_0		"Time (hh:mm:ss)"
+#define WC_STR_DT_1		"Date (dd/mm/yyyy)"
+#define WC_STR_DT_2		"Synchronize to PC"
+
+#define WC_STR_NET_MAIN	"Main"
+#define WC_STR_NET_GPRS	"GPRS"
+#define WC_STR_NET_VPN		"VPN"
+#define WC_STR_NET_DDNS	"DDNS"
+#define WC_STR_NET_ROUTE	"Routing"
+
+#define WC_STR_NET_0		"Host name"
+#define WC_STR_NET_1		"DHCP"
+#define WC_STR_NET_2		"IP address"
+#define WC_STR_NET_3		"IP mask"
+#define WC_STR_NET_4		"IP gateway"
+#define WC_STR_NET_5		"DNS1"
+#define WC_STR_NET_6		"DNS2"
+
+/* -- net-gprs strings */
+#define WC_STR_PPP_NAME			"Name"
+
+#define WC_STR_PPP_PORT_OPTS		"Port options"
+#define WC_STR_PPP_PORT			"Port"
+#define WC_STR_PPP_PORT_SPEED		"Baudrate"
+#define WC_STR_PPP_PORT_FLOW		"HW flow control"
+
+#define WC_STR_PPP_MODEM_OPTS	"Modem options"
+#define WC_STR_PPP_SIM_PIN			"SIM PIN"
+#define WC_STR_PPP_INIT_STR		"Init string"
+#define WC_STR_PPP_APN				"AP name"
+#define WC_STR_PPP_CALLNUM		"Call number"
+
+#define WC_STR_PPP_PPP_OPTS		"PPP options"
+#define WC_STR_LOGIN				"Login"
+#define WC_STR_PASSWORD			"Password"
+#define WC_STR_PPP_IP				"IP"
+
+#define WC_STR_PPP_START_OPTS		"Start-up options"
+#define WC_STR_PPP_AUTO			"Auto"
+#define WC_STR_PPP_AUTO_START	"Auto-start"
+
+#define WC_STR_PPP_STATE			"State"
+
+#define WC_STR_PPP_VPN_SERVER		"VPN Server"
+
+#define WC_STR_PPP_VPN_ROUTE		"VPN Route"
+#define WC_STR_PPP_VPN_ADDR		"VPN Net Address"
+#define WC_STR_PPP_VPN_MASK		"VPN Net Mask"
+
+#define WC_STR_PPP_ACTION			"Action"
+#define WC_STR_PPP_SERVER			"Server"
+#define WC_STR_PPP_ROUTE			"Route"
+
+#define WC_STR_DDNS_SYSTEM				"Dynamic DNS System"
+#define WC_STR_DDNS_HOST					"Host"
+#define WC_STR_DDNS_DOMAIN				"Domain"
+#define WC_STR_DDNS_HASH					"Hash code"
+#define WC_STR_DDNS_UPDATE_PERIOD		"Update period (sec.)"
+
+#define WC_STR_DDNS_DISABLED				"Disabled"
+
+#define WC_STR_SEC_0		"Enter password"
+#define WC_STR_SEC_1		"Re-type password"
+
+#define WC_STR_PLC_MP_0	"EEPROM protection"
+#define WC_STR_PLC_MP_1	"Status register"
+#define WC_STR_PLC_MP_2	"Block protection"
+#define WC_STR_PLC_MP_3	"Unprotect"
+
+#define WC_STR_PLC_RM_0	"Retain memory"
+#define WC_STR_PLC_RM_1	"Size"
+#define WC_STR_PLC_RM_2	"Address"
+#define WC_STR_PLC_RM_3	"File"
+#define WC_STR_PLC_RM_4	"rmsync status"
+#define WC_STR_PLC_RM_5	"Refresh interval"
+#define WC_STR_PLC_RM_6	"Sync. chunk"
+
+#define WC_STR_UTILS_PING			"Ping"
+#define WC_STR_PING_HOST_ADDR	"IP Address/Host"
+
+/* statuses */
+#define WC_STR_STATUS_APPLIED		"Settings applied."
+#define WC_STR_STATUS_APPLIED_NS	"Settings applied (NOT COMMITTED)."
+#define WC_STR_STATUS_ERROR		"Error"
+
+#define WC_STR_STATUS_NET_RESTART	"Restarting network.."
+#define WC_STR_STATUS_NET_DYNIP		"Please access device via dynamically assigned IP."
+#define WC_STR_STATUS_PLC_UNPROT		"EEPROM unprotected."
+
+#define WC_STR_ERR_INVAL_IP			"invalid ip address specified."
+#define WC_STR_ERR_PWD_NOT_EQUAL	"passwords are not equal."
+
+#define WC_STR_ERR_INVAL_DDNS_NAME		"invalid Dyn DNS service name"
+#define WC_STR_ERR_INVAL_DDNS_SETTING	"invalid option"
+#define WC_STR_ERR_DDNS_CFG_EDIT			"editing of configuration failed"
+
+#define WC_STR_STATUS_DDNS_UPDATING		"Updating Dyn DNS service state..."
+
+/* ppp statuses */
+#define WC_STR_ERR_PPP_ADD			"Failed to add a new profile: %s."
+#define WC_STR_ERR_PPP_EDIT			"Failed to update profile '%s': %s."
+#define WC_STR_ERR_PPP_DEL			"Failed to delete profile '%s': %s."
+#define WC_STR_ERR_PPP_START			"Failed to start connection '%s': %s."
+#define WC_STR_ERR_PPP_STOP			"Failed to stop connection '%s': %s."
+
+#define WC_STR_STATUS_PPP_STARTING	"Starting '%s'..."
+#define WC_STR_STATUS_PPP_STOPPING	"Stopping '%s'..."
+
+#define WC_STR_STATUS_PPP_ADDED			"Profile '%s' added."
+#define WC_STR_STATUS_PPP_UPDATED		"Profile '%s' updated."
+#define WC_STR_STATUS_PPP_UPDATED_REN	"Profile '%s' updated, name changed for '%s'."
+#define WC_STR_STATUS_PPP_DELETED		"Profile '%s' deleted."
+
+#define WC_STR_STATUS_PING				"Host %s: %s."
+#define WC_STR_PING_ALIVE					"is alive"
+#define WC_STR_PING_NALIVE					"is not alive"
+#define WC_STR_PING_CHECKING				"Checking"
+
+#define WC_STR_RSN_CANT_IDENTIFY			"failed to identify profile"
+#define WC_STR_RSN_CONN_ACTIVE			"respective connection is active"
+#define WC_STR_RSN_ALREADY_RUNNING		"already running"
+#define WC_STR_RSN_PROFILE_NEXIST			"profile does not exist"
+#define WC_STR_RSN_OTHER_GPRS_RUNNING	"another GPRS connection is already running"
+#define WC_STR_RSN_NOT_RUNNING			"is not running"
+
+#define WC_STR_RSN_REQ_FIELD				"'%s' is required"
+#define WC_STR_RSN_INVAL_FIELD			"'%s' value is invalid"
+
+#define WC_STR_RSN_PORT_INVAL				"port is required and should start with /dev/tty or tty"
+#define WC_STR_RSN_IS_INVAL				"modem init string should start with AT"
+
+#define WC_STR_RSN_PROFILE_EXIST			"profile '%s' already exists"
+
+#define WC_STR_ERR_PING_START				"Failed to start ping: host IP/name is invalid"
+
+#endif /*_WC_STRINGS_LANG_H_*/
+
diff -Nru a/wc/wc_strings.h b/wc/wc_strings.h
--- a/wc/wc_strings.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_strings.h	2012-07-03 14:14:15.000000000 +0300
@@ -0,0 +1,10 @@
+#ifndef _WC_STRINGS_H_
+#define _WC_STRINGS_H_
+
+#include "wc_page.h"
+#include "wc_config.h"
+
+extern void wc_strings_init(wc_page_data_t *page_data);
+
+#endif /* _WC_STRINGS_H_ */
+
diff -Nru a/wc/wc_strings_ru.h b/wc/wc_strings_ru.h
--- a/wc/wc_strings_ru.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_strings_ru.h	2012-09-14 19:04:42.000000000 +0300
@@ -0,0 +1,220 @@
+#ifndef _WC_STRINGS_LANG_H_
+#define _WC_STRINGS_LANG_H_
+
+#define WC_STR_CHARSET		"windows-1251"
+#define WC_STR_PLC_NAME_HE5684	"HE5684"
+#define WC_STR_PLC_NAME_MODUS5684	" 5684"
+#define WC_STR_PLC_NAME_PLC304	" 304"
+#define WC_STR_PLC_NAME_PLC323	" 323"
+#define WC_STR_TITLE_FMT	" %s"
+
+#define WC_STR_BP_NONE		""
+#define WC_STR_BP_UQ		" "
+#define WC_STR_BP_UH		" "
+#define WC_STR_BP_ALL		""
+
+#define WC_STR_RUN			""
+#define WC_STR_NRUN		" "
+
+#define WC_STR_DYNAMIC		""
+#define WC_STR_NO_AUTH	""
+
+#define WC_STR_ACT_ADD	""
+
+#define WC_STR_ACT_VIEW	""
+#define WC_STR_ACT_EDIT	"."
+#define WC_STR_ACT_DEL		""
+#define WC_STR_ACT_START	""
+#define WC_STR_ACT_STOP	""
+#define WC_STR_ACT_LOG		""
+
+#define WC_STR_CONFIRM_PREFIX		" ,  "
+
+#define WC_STR_CONFIRM_PPP_DEL	"%s   \\'%s\\'?"
+#define WC_STR_CONFIRM_PPP_START	"%s   \\'%s\\'?"
+#define WC_STR_CONFIRM_PPP_STOP	"%s   \\'%s\\'?"
+
+#define WC_STR_MODE_LIST_PROFILES		" "
+#define WC_STR_MODE_ADD_PROFILE		" "
+#define WC_STR_MODE_EDIT_PROFILE		" "
+#define WC_STR_MODE_VIEW_PROFILE		" "
+
+#define WC_STR_PPP_LOG_VIEW_TITLE	" -"
+#define WC_STR_PPP_CLEAR_LOG			" -"
+
+#define WC_STR_TAB_NO_RECORDS		" ."
+
+/* =str.<name> */
+#define WC_STR_YES		""
+#define WC_STR_NO		""
+#define WC_STR_SECONDS	"."
+#define WC_STR_BYTES	""
+#define WC_STR_KBYTES	""
+
+/* buttons =str.b.<name> */
+#define WC_STR_ON		"."
+#define WC_STR_OFF		"."
+#define WC_STR_RESET	""
+#define WC_STR_OK		"OK"
+#define WC_STR_CANCEL	""
+#define WC_STR_BACK	""
+#define WC_STR_CLOSE	""
+#define WC_STR_CHECK	""
+#define WC_STR_WHOLE	" "
+#define WC_STR_STANDARD_VALS	" "
+
+/* menus =str.m.<name> */
+#define WC_STR_M_DT	"/"
+#define WC_STR_M_NET	""
+#define WC_STR_M_SEC	""
+#define WC_STR_M_PLC	" "
+#define WC_STR_M_UTILS	""
+#define WC_STR_M_SENSORS	""
+#define WC_STR_M_TEST	""
+
+/* menu-form title =str.ftitle */
+#define WC_STR_DT_TITLE	" /"
+#define WC_STR_NET_TITLE	" "
+#define WC_STR_SEC_TITLE	"    www-data"
+#define WC_STR_PLC_TITLE	"  "
+#define WC_STR_UTILS_TITLE	""
+
+/* page-specifc =str.<PG>.<FIELD> */
+
+#define WC_STR_DT_0		" (::)"
+#define WC_STR_DT_1		" (//)"
+#define WC_STR_DT_2		"  PC"
+
+#define WC_STR_NET_MAIN	""
+#define WC_STR_NET_GPRS	"GPRS"
+#define WC_STR_NET_VPN		"VPN"
+#define WC_STR_NET_DDNS	"DDNS"
+#define WC_STR_NET_ROUTE	""
+
+#define WC_STR_NET_0		" "
+#define WC_STR_NET_1		"DHCP"
+#define WC_STR_NET_2		"IP-"
+#define WC_STR_NET_3		"IP-"
+#define WC_STR_NET_4		" "
+#define WC_STR_NET_5		"DNS1"
+#define WC_STR_NET_6		"DNS2"
+
+/* -- net-gprs strings */
+#define WC_STR_PPP_NAME			""
+
+#define WC_STR_PPP_PORT_OPTS		" "
+#define WC_STR_PPP_PORT			""
+#define WC_STR_PPP_PORT_SPEED		""
+#define WC_STR_PPP_PORT_FLOW		"  "
+
+#define WC_STR_PPP_MODEM_OPTS	" "
+#define WC_STR_PPP_SIM_PIN			"SIM PIN"
+#define WC_STR_PPP_INIT_STR		" "
+#define WC_STR_PPP_APN				"  "
+#define WC_STR_PPP_CALLNUM		" "
+
+#define WC_STR_PPP_PPP_OPTS		" PPP"
+#define WC_STR_LOGIN				"Login"
+#define WC_STR_PASSWORD			""
+#define WC_STR_PPP_IP				"IP"
+
+#define WC_STR_PPP_START_OPTS		" "
+#define WC_STR_PPP_AUTO			""
+#define WC_STR_PPP_AUTO_START	""
+
+#define WC_STR_PPP_STATE			""
+
+#define WC_STR_PPP_VPN_SERVER		"VPN "
+
+#define WC_STR_PPP_VPN_ROUTE		"VPN "
+#define WC_STR_PPP_VPN_ADDR		"  VPN"
+#define WC_STR_PPP_VPN_MASK		"  VPN"
+
+#define WC_STR_PPP_ACTION			""
+#define WC_STR_PPP_SERVER			""
+#define WC_STR_PPP_ROUTE			""
+
+#define WC_STR_DDNS_SYSTEM				" Dynamic DNS"
+#define WC_STR_DDNS_HOST					" "
+#define WC_STR_DDNS_DOMAIN				""
+#define WC_STR_DDNS_HASH					" "
+#define WC_STR_DDNS_UPDATE_PERIOD		"  (.)"
+
+#define WC_STR_DDNS_DISABLED				""
+
+#define WC_STR_SEC_0		" "
+#define WC_STR_SEC_1		" "
+
+#define WC_STR_PLC_MP_0	" EEPROM"
+#define WC_STR_PLC_MP_1	" "
+#define WC_STR_PLC_MP_2	" "
+#define WC_STR_PLC_MP_3	""
+
+#define WC_STR_PLC_RM_0	"Retain-"
+#define WC_STR_PLC_RM_1	""
+#define WC_STR_PLC_RM_2	""
+#define WC_STR_PLC_RM_3	""
+#define WC_STR_PLC_RM_4	" rmsync"
+#define WC_STR_PLC_RM_5	" "
+#define WC_STR_PLC_RM_6	"  "
+
+#define WC_STR_UTILS_PING			"Ping"
+#define WC_STR_PING_HOST_ADDR	"IP / "
+
+/* statuses */
+#define WC_STR_STATUS_APPLIED		" ."
+#define WC_STR_STATUS_APPLIED_NS	"  ( )."
+#define WC_STR_STATUS_ERROR		""
+
+#define WC_STR_STATUS_NET_RESTART	" .."
+#define WC_STR_STATUS_NET_DYNIP		"      IP."
+#define WC_STR_STATUS_PLC_UNPROT		" EEPROM ."
+
+#define WC_STR_ERR_INVAL_IP			"  IP-."
+#define WC_STR_ERR_PWD_NOT_EQUAL	"  ."
+
+#define WC_STR_ERR_INVAL_DDNS_NAME		"  Dyn DNS "
+#define WC_STR_ERR_INVAL_DDNS_SETTING	"  "
+#define WC_STR_ERR_DDNS_CFG_EDIT			"  "
+
+#define WC_STR_STATUS_DDNS_UPDATING		"   Dyn DNS..."
+
+/* ppp statuses */
+#define WC_STR_ERR_PPP_ADD			"   : %s."
+#define WC_STR_ERR_PPP_EDIT			"    '%s': %s."
+#define WC_STR_ERR_PPP_DEL			"    '%s': %s."
+#define WC_STR_ERR_PPP_START			"    '%s': %s."
+#define WC_STR_ERR_PPP_STOP			"    '%s': %s."
+
+#define WC_STR_STATUS_PPP_STARTING	" '%s'..."
+#define WC_STR_STATUS_PPP_STOPPING	" '%s'..."
+
+#define WC_STR_STATUS_PPP_ADDED			"  '%s'."
+#define WC_STR_STATUS_PPP_UPDATED		" '%s' ."
+#define WC_STR_STATUS_PPP_UPDATED_REN	" '%s' ,   '%s'."
+#define WC_STR_STATUS_PPP_DELETED		" '%s' ."
+
+#define WC_STR_STATUS_PING				" %s: %s."
+#define WC_STR_PING_ALIVE					""
+#define WC_STR_PING_NALIVE					" "
+#define WC_STR_PING_CHECKING				""
+
+#define WC_STR_RSN_CANT_IDENTIFY			"  "
+#define WC_STR_RSN_CONN_ACTIVE			".  "
+#define WC_STR_RSN_ALREADY_RUNNING		" "
+#define WC_STR_RSN_PROFILE_NEXIST			"  "
+#define WC_STR_RSN_OTHER_GPRS_RUNNING	" GPRS   "
+#define WC_STR_RSN_NOT_RUNNING			" "
+
+#define WC_STR_RSN_REQ_FIELD				"   '%s'"
+#define WC_STR_RSN_INVAL_FIELD			"  '%s'"
+
+#define WC_STR_RSN_PORT_INVAL				"        /dev/tty or tty"
+#define WC_STR_RSN_IS_INVAL				"      AT"
+
+#define WC_STR_RSN_PROFILE_EXIST			" '%s'  "
+
+#define WC_STR_ERR_PING_START				"  ping:    IP "
+
+#endif /*_WC_STRINGS_LANG_H_*/
+
diff -Nru a/wc/wc_test_config.c b/wc/wc_test_config.c
--- a/wc/wc_test_config.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_test_config.c	2012-07-04 19:30:24.000000000 +0300
@@ -1,15 +1,16 @@
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>
+#include <stdlib.h>
 
-#include "wc_config.h"
+#include "wc_conf_file.h"
 
 #define DEFAULT_CONFIG_FILE "/etc/network.cfg"
 
 const char *one_var = NULL;
 const char *set_val = NULL;
 
-static int process_var(char *var, char *val)
+static int process_var(char *var, char *val, void *data)
 {
 	int r = 1;
 
@@ -20,22 +21,28 @@
 
 		r = 0; /* found - stop */
 	}
-	printf("var=[%s], val=[%s]\n", var, val);
+	printf("var=[%s], val=[%s], user_data='%s'\n", var, val, (const char *)data);
 	return r;
 }
 static int process_line_edit_var(wc_conf_parse_data_t *parse_data, void *data)
 {
-	FILE *fp_out = (FILE*)data;
+	FILE *fp_out;
 	static int edited = 0;
 
+	fp_out = parse_data->fp_out;
+
 	if (parse_data->type == WC_CLT_WRONG) {
 		return 1;	/* remove wrong lines */
 	}
 
-	if (parse_data->type == WC_CLT_EOF) {
+	if (parse_data->type == WC_CLT_EOF ||
+		parse_data->type == WC_CLT_CREATED) {
 		if (!edited) {
 			/* add the var if we didn't edit it i.e. it is not present */
-			printf("EOF, edited=%d\n", edited);
+			if (parse_data->type == WC_CLT_CREATED) {
+				fprintf(fp_out, "# Auto-created, user string: '%s'\n", (const char*)data);
+			}
+			fprintf(fp_out, "# Added, user string: '%s'\n", (const char*)data);
 			fprintf(fp_out, "%s=\"%s\"\n", one_var, set_val);
 		}
 		return 0; /* result doesn't matter here */
@@ -44,9 +51,12 @@
 	if ((parse_data->type == WC_CLT_VAR) &&
 		!memcmp(one_var, parse_data->var, parse_data->var_len) &&
 		(strlen(one_var) == parse_data->var_len)) {
+		char *p;
 		/* edit the VAR's line */
 		parse_data->var[parse_data->var_len] = 0;
-		fprintf(fp_out, "%s=\"%s\"\n", parse_data->var, set_val);
+		fprintf(fp_out, "# edited with user string: '%s'\n", (const char*)data);
+		p = strchr(set_val, '"');
+		fprintf(fp_out, p ? "%s='%s'\n" : "%s=\"%s\"\n", parse_data->var, set_val);
 		edited = 1;
 	} else {
 		/* print as is the rest of lines */
@@ -55,28 +65,46 @@
 	return 1;
 }
 
+/* args:
+* 1 - config file to read/edit/create
+* 2 - var to process (read or edit/add)
+* 3 - user string - to test passing user data to callbacks
+* 4 - val - if specified perform EDIT, otherwise - READ
+* 5 - flag: 0 - do not create config file, !0 - create config if it does not exist
+*/
 int main(int argc, char *argv[])
 {
 	int r;
 	const char *fname = DEFAULT_CONFIG_FILE;
-	
-	if (argc > 1) {
-		fname = argv[1];
+	int create = 0;
+
+	const char *user_str;
+
+	if (argc < 4) {
+		printf("args: <file> <var> <user data string> [value_set] [create_flag]\n");
+		return -1;
 	}
-	if (argc > 2) {
-		one_var = argv[2];
+	
+	fname = argv[1];
+	one_var = argv[2];
+	user_str = argv[3];
+
+	if (argc > 4) {
+		set_val = argv[4];
 	}
-	if (argc > 3) {
-		set_val = argv[3];
+	if (argc > 5) {
+		create = atoi(argv[5]);	/* create config if not exists? */
 	}
 
+	//TODO: test for _raw() functions
+
 	if (!set_val) {
-		r = wc_conf_read_file(fname, &process_var);
+		r = wc_conf_file_read(fname, &process_var, (void*)user_str);
 		if (r) {
 			printf("failed to read %s file\n", fname);
 		}
 	} else {
-		r = wc_conf_edit_file(fname, &process_line_edit_var);
+		r = wc_conf_file_edit(fname, &process_line_edit_var, (void*)user_str, create);
 		if (r) {
 			printf("failed to edit %s file\n", fname);
 		}
diff -Nru a/wc/wc_tpl.c b/wc/wc_tpl.c
--- a/wc/wc_tpl.c	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_tpl.c	2012-07-11 15:15:32.000000000 +0300
@@ -1,12 +1,24 @@
 #include <stdio.h>
 #include "cgic.h"
-#include <string.h>
 #include <stdlib.h>
 #include <errno.h>
 
+#include <string.h>
+extern void *memrchr(const void *s, int c, size_t n);
+
 #include "linux_list.h"
 #include "wc_tpl.h"
 
+/* --- Features --- */
+
+/* if TPL_EXTENSION is defined then only these files will be parsed as temlates,
+ * other files will be just included 
+*/
+#define TPL_EXTENSION	".tpl"
+
+/* Enable/disable tpl commands processing */
+#define TPL_COMMANDS	1
+
 /* --- Constants --- */
 
 /* relative paths only */
@@ -19,6 +31,7 @@
  * {.file.ext} - include "file.ext"
  * {=var[.field]} - print variable "var" or field "field" of the complex variable "var"
  * {?var[.field]<cond>val:<.tpl>|<text>|=var[.field]} - if var = val (equal) do: include|print text|print other var
+ * {#var:<.tpl>} - parse given tpl var number of times (from 0 to var-1)
  * {cmd[=arg]} - do command with command-specific argument arg (optional), e.g.
  *  Example (removed after r1157):   {ifp=<name>:<.tpl>|<text>} - if page is "name": .tpl - include template or =text - print the text
  */
@@ -29,6 +42,7 @@
 #define TPL_CHAR_INCLUDE			'.'
 #define TPL_CHAR_PRINT_VAR			'='
 #define TPL_CHAR_IF_VAR			'?'
+#define TPL_CHAR_LOOP_VAR			'#'
 
 #define TPL_CHAR_CMD_SEP			'='
 #define TPL_CHAR_VAR_DO_SEP		':'
@@ -36,15 +50,27 @@
 /* escape chr inside templates */
 #define TPL_CHAR_VAL_ESCAPE		'\\'
 
+/* --- global vars --- */
+
+wc_tpl_loop_t wc_loop_ctx = {
+	.level	= -1,
+};
+
 /* --- Local vars & methods declarations --- */
 
 static LLIST_HEAD(tpl_vars);
+#if TPL_COMMANDS
 static LLIST_HEAD(tpl_commands);
+#endif
 
+#ifdef TPL_EXTENSION
+static int render_non_template_file(const char *full_fname);
+#endif
 static int render_template_file(const char *full_fname);
 static int process_template(char *tpl_str, size_t len);
 static int lookup_var(char *tpl_str);
 static int lookup_cmd(char *tpl_str);
+static int process_loop(const char *max_value_str, const char *fname);
 
 /* --- Interface methods --- */
 
@@ -52,14 +78,25 @@
 {
 	llist_add(&var->list, &tpl_vars);
 }
+void wc_tpl_vars_register(wc_tpl_var_t *vars)
+{
+	wc_tpl_var_t *v;
+
+	for (v = vars; v->name; v++) {
+		llist_add(&v->list, &tpl_vars);
+	}
+}
 
 void wc_tpl_cmd_register(wc_tpl_cmd_t *cmd)
 {
+#if TPL_COMMANDS
 	llist_add(&cmd->list, &tpl_commands);
+#endif
 }
 
 int wc_render_template(const char *fname)
 {
+	int r;
 	char full_fname[MAX_TPL_PATH_LEN];
 
 	if (sizeof(TPL_PATH) + 1 + strlen(fname) > MAX_TPL_PATH_LEN) { /* sizeof("") includes terminating 0 */
@@ -70,10 +107,44 @@
 	strcat(full_fname, "/");
 	strcat(full_fname, fname);
 
-	return render_template_file(full_fname);
+#ifdef TPL_EXTENSION
+	{
+		int len = strlen(fname);
+		len -= (sizeof(TPL_EXTENSION) - 1);
+		if (!strcmp(TPL_EXTENSION, &fname[len])) {
+			r = render_template_file(full_fname);
+		} else {
+			r = render_non_template_file(full_fname);
+		}
+	}
+#else
+	r = render_template_file(full_fname);
+#endif
+
+	return r;
 }
 
 /* --- Local methods --- */
+#ifdef TPL_EXTENSION
+static int render_non_template_file(const char *full_fname)
+{
+	FILE *tpl;
+	char buf[MAX_TPL_PARSE_BUF_LEN];
+	size_t len;
+
+	tpl = fopen(full_fname, "r");
+	if (!tpl) {
+		return errno;
+	}
+
+	while ((len = fread(buf, 1, sizeof(buf), tpl)) > 0) {
+		fwrite(buf, len, 1, cgiOut);
+	}
+
+	fclose(tpl);
+	return 0;
+}
+#endif
 
 static int render_template_file(const char *full_fname)
 {
@@ -163,6 +234,23 @@
 		}
 
 		/* END was found: process template */
+
+		/* but first, check if another START is present between found start and end, 
+		 * if so move to the latest START 
+		 */
+		start = (char*)memrchr(pos, TPL_CHAR_START, end - pos);
+		if (start) {
+			/* flush data before the latest START and move to it the begining of the template */
+			fputc(TPL_CHAR_START, cgiOut);
+			//fprintf(cgiOut, "//moving to next START!\n");
+			len = start - pos;
+			if (len > 0) {
+				fwrite(pos, 1, len, cgiOut);
+			}
+			data_len -= (len + 1);
+			pos += (len + 1);
+		}
+		
 		r = process_template(pos, end - pos);
 		if (r) {
 			/* template was not recognized: print it as is */
@@ -205,6 +293,7 @@
 			
 		case TPL_CHAR_PRINT_VAR:
 		case TPL_CHAR_IF_VAR:
+		case TPL_CHAR_LOOP_VAR:
 			r = lookup_var(tpl_str);
 			break;
 
@@ -214,7 +303,7 @@
 				sprintf(cgiOut, "error:%s:", strerror(r));
 			}*/
 			break;
-			
+
 		default:
 			/* find command and process it */
 			r = lookup_cmd(tpl_str);
@@ -287,35 +376,42 @@
 static int parse_tpl_var(char action, char *tpl_str, parsed_var_t *pv)
 {
 	int r;
+
+	memset(pv, 0, sizeof(*pv));
 	
 	if (action != TPL_CHAR_PRINT_VAR &&
-		action != TPL_CHAR_IF_VAR) {
+		action != TPL_CHAR_IF_VAR && 
+		action != TPL_CHAR_LOOP_VAR) {
 		return -1;
 	}
 
-	if (action == TPL_CHAR_IF_VAR) {
+	if (action == TPL_CHAR_IF_VAR ||
+		action == TPL_CHAR_LOOP_VAR) {
 		/* first extract 'do' part */
 		pv->do_tpl = strchr(tpl_str, TPL_CHAR_VAR_DO_SEP);
 		if (!pv->do_tpl) {
-			/* error: do is required for _IF_VAR template */
+			/* error: do is required for _IF/LOOP_VAR templates */
 			return -1;
 		}
 		/* terminate template at do-separator */
 		*pv->do_tpl = 0;
 
-		/* extract value and condition */
-		r = parse_tpl_var_cond(tpl_str, pv);
-		if (r) {
-			/* restore template */
-			*pv->do_tpl = TPL_CHAR_VAR_DO_SEP;
-			/* error: cond is required for _IF_VAR template */
-			return r;
+		if (action == TPL_CHAR_IF_VAR) {
+			/* extract condition and value (pv->cond and pv->cmp_val) - required for _IF_VAR only */
+			r = parse_tpl_var_cond(tpl_str, pv);
+			if (r) {
+				/* restore template */
+				*pv->do_tpl = TPL_CHAR_VAR_DO_SEP;
+				/* error: cond is required for _IF_VAR template */
+				return r;
+			}
 		}
 
 		/* adjust pointer to do-part */
 		pv->do_tpl++;
 	}
 
+	/* var name */
 	pv->name = tpl_str;
 
 	pv->field = strchr(tpl_str, TPL_CHAR_VAR_FIELD_SEP);
@@ -364,6 +460,10 @@
 		return 0;
 	}
 
+	if (action == TPL_CHAR_LOOP_VAR) {
+		return process_loop(val, pv.do_tpl + 1);
+	}
+
 	switch (pv.cond) {
 		case TPL_COND_EQ:
 			cmp_result = !strcmp(val, pv.cmp_val);
@@ -407,6 +507,7 @@
 
 static int lookup_cmd(char *tpl_str)
 {
+#if TPL_COMMANDS
 	char *p;
 	size_t len;
 	wc_tpl_cmd_t *cmd;
@@ -425,6 +526,31 @@
 			return 0;
 		}
 	}
+#endif
 	return -1;
 }
 
+static int process_loop(const char *max_value_str, const char *fname)
+{
+	int r = 0;
+	int max_value = atoi(max_value_str);
+
+	wc_loop_ctx.level++;
+	if (wc_loop_ctx.level >= WC_TPL_LOOP_MAX_LEVEL) {
+		fprintf(cgiOut, "template loop level %d exceeded\n", WC_TPL_LOOP_MAX_LEVEL);
+		wc_loop_ctx.level--;
+		return -1;
+	}
+
+	for (wc_loop_ctx.counter[wc_loop_ctx.level] = 0;
+		wc_loop_ctx.counter[wc_loop_ctx.level] < max_value;
+		wc_loop_ctx.counter[wc_loop_ctx.level]++) {
+		r = wc_render_template(fname);
+		if (r) {
+			break;
+		}
+	}
+	wc_loop_ctx.level--;
+	return r;
+}
+
diff -Nru a/wc/wc_tpl.h b/wc/wc_tpl.h
--- a/wc/wc_tpl.h	2011-02-28 16:04:30.000000000 +0200
+++ b/wc/wc_tpl.h	2012-06-30 17:11:07.000000000 +0300
@@ -21,10 +21,23 @@
 	wc_tpl_var_get_t get;
 } wc_tpl_var_t;
 
+#define WC_TPL_LOOP_MAX_LEVEL		10
+typedef struct {
+	int level;
+	int counter[WC_TPL_LOOP_MAX_LEVEL];
+} wc_tpl_loop_t;
+
+extern wc_tpl_loop_t wc_loop_ctx;
+
 extern void wc_tpl_var_register(wc_tpl_var_t *var);
+/* array of vars, terminating by var record with NULL name */
+extern void wc_tpl_vars_register(wc_tpl_var_t *vars);
 extern void wc_tpl_cmd_register(wc_tpl_cmd_t *cmd);
 
 extern int wc_render_template(const char *fname);
 
+//TODO:
+//extern const char *wc_to_html_escaped_string(const char *s);
+
 #endif /* _WC_TPL_H_ */
 
diff -Nru a/wc/wc_utils.h b/wc/wc_utils.h
--- a/wc/wc_utils.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_utils.h	2012-07-12 18:25:29.000000000 +0300
@@ -0,0 +1,6 @@
+#ifndef _WC_UTILS_H_
+#define _WC_UTILS_H_
+
+#define WC_UTILS_SP_PING		"ping"
+
+#endif /* _WC_UTILS_H_ */
diff -Nru a/wc/wc_utils_ping.c b/wc/wc_utils_ping.c
--- a/wc/wc_utils_ping.c	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_utils_ping.c	2012-09-06 19:05:11.000000000 +0300
@@ -0,0 +1,130 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <dirent.h>
+#include <ctype.h>
+#include "cgic.h"
+
+//#include "wc_conf_file.h"
+#include "wc_tpl.h"
+#include "wc_page.h"
+#include "wc_utils_ping.h"
+
+#include "wc_strings.h"
+
+#ifdef WC_CONFIG_MENU_UTILS_PING
+
+#define PING_COMMAND				"/bin/ping"
+#define PING_MAX_HOST_LEN			64
+
+#define HVAR_PING_HOST				"host"
+
+static wc_form_button_t ping_btn_check = {
+	.title = WC_STR_CHECK,
+	.name = WC_NAME_FORM_SUBMIT,
+	.type = WC_FBT_SUBMIT,
+};
+
+typedef struct ping_data_t {
+	wc_page_data_t *pdata;
+
+	char host[PING_MAX_HOST_LEN + 1];
+} ping_data_t;
+
+static ping_data_t ping;
+
+/* Commands */
+
+/* Vars */
+
+static const char *get_var_ping(char *field);
+static wc_tpl_var_t ping_var = {	
+	.name = "ping", .get = get_var_ping,
+};
+
+/* local methods */
+static int get_current_settings(wc_page_data_t *data);
+static int apply_new_settings(wc_page_data_t *data);
+
+/* inline methods */
+
+/* --- Command handlers --- */
+
+/* --- Var handlers --- */
+
+static const char *get_var_ping(char *field)
+{
+	if (field) {
+		if (*field == 'h') {
+			return ping.host;
+		}
+	}
+	return NULL;	
+}
+/* --- Interface methods --- */
+
+void wc_utils_ping_process(wc_page_data_t *data, int submitted)
+{
+	memset(&ping, 0, sizeof(ping));
+	ping.pdata = data;
+
+	if (submitted) {
+		apply_new_settings(data);
+	}
+
+	get_current_settings(data);
+	
+	wc_tpl_var_register(&ping_var);
+	wc_form_enable(WC_FBA_RIGHT, &ping_btn_check, NULL, NULL);
+	ping.pdata->flags.cntdn = 1;
+}
+
+void wc_utils_ping_post_process(wc_page_data_t *data)
+{
+}
+
+/* --- local subroutines --- */
+
+static int get_current_settings(wc_page_data_t *data)
+{
+	return 0;
+}
+
+static int apply_new_settings(wc_page_data_t *data)
+{
+	/* host submitted */
+	cgiFormResultType fr;
+	int r;
+	char cmd[256];
+	
+	/* get params and check */
+	fr = cgiFormStringNoNewlines(HVAR_PING_HOST, ping.host, sizeof(ping.host));
+	if (fr != cgiFormSuccess || !ping.host[0]) {
+		strcpy(ping.pdata->status_buf, WC_STR_ERR_PING_START);
+		return -EINVAL;
+	}
+	/* avoid embedding commands into our ping command - 
+	* we quote host arg with double quote, so user won't be able to specify <addr"; do his cmd>*/
+	if (strchr(ping.host, '"')) {
+		strcpy(ping.pdata->status_buf, WC_STR_ERR_PING_START);
+		return -EINVAL;
+	}
+
+	/* do ping */
+	sprintf(cmd, "%s \"%s\" -c 1 >/dev/null 2>&1", PING_COMMAND, ping.host);
+	r = system(cmd);
+
+	sprintf(ping.pdata->status_buf, WC_STR_STATUS_PING, ping.host, 
+			r ? WC_STR_PING_NALIVE : WC_STR_PING_ALIVE);
+	
+//	r = system("sh -c \"PATH=/sbin/:$PATH; "RC_NET_DIR"/rc.net reload\" > /dev/null 2>&1 &");
+	
+	return 0;
+}
+
+#endif /* WC_CONFIG_MENU_UTILS_PING */
+
diff -Nru a/wc/wc_utils_ping.h b/wc/wc_utils_ping.h
--- a/wc/wc_utils_ping.h	1970-01-01 03:00:00.000000000 +0300
+++ b/wc/wc_utils_ping.h	2012-07-12 18:25:29.000000000 +0300
@@ -0,0 +1,8 @@
+#ifndef _WC_UTILS_PING_H_
+#define _WC_UTILS_PING_H_
+
+extern void wc_utils_ping_process(wc_page_data_t *data, int submitted);
+extern void wc_utils_ping_post_process(wc_page_data_t *data);
+	
+#endif /* _WC_UTILS_PING_H_*/
+
diff -Nru a/www/cgi/tpl/baud_rate_option.tpl b/www/cgi/tpl/baud_rate_option.tpl
--- a/www/cgi/tpl/baud_rate_option.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/baud_rate_option.tpl	2012-06-30 17:11:07.000000000 +0300
@@ -0,0 +1 @@
+<option{=pr.br.s}>{=pr.br.v}</option>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/contents.tpl b/www/cgi/tpl/contents.tpl
--- a/www/cgi/tpl/contents.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/contents.tpl	2012-07-12 18:25:29.000000000 +0300
@@ -1,4 +1,20 @@
 <table width="100%" border="0" cellspacing="2" cellpadding="0">
-	<tr><td>{?page=home:.cont_home.tpl}
-		{?page!=home:.cont_form.tpl}</td></tr>
-</table>
\ No newline at end of file
+	{?pgf.subm=1:.submenu.tpl}
+	<tr><td>{?pgf.form=1:.form_head.tpl}
+		<table width="90%" align="center" border="0">
+			<tr><td nowrap align="center"><h3>{=str.ftitle}</h3></td></tr>
+			<!--tr><td>&nbsp;</td></tr-->
+			<tr><td>{?pg=dt:.dt_form.tpl}
+				{?pg=net:.net.tpl}
+				{?pg=sec:.sec_form.tpl}
+				{?pg=plc:.plc_form.tpl}
+				{?pg=utils:.utils.tpl}
+				{?pg=test:.test_cont.tpl}</td></tr>
+
+			{?pgf.form=1:.form_control.tpl}
+
+			<tr><td class="status" id="status">{=status}{?pgf.cntdn=1:.form_el_cntdn.tpl}</td></tr>
+		</table>
+		{?pgf.form=1:.form_foot.tpl}</td>
+	</tr>
+</table>
diff -Nru a/www/cgi/tpl/cont_form.tpl b/www/cgi/tpl/cont_form.tpl
--- a/www/cgi/tpl/cont_form.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/cont_form.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,18 +0,0 @@
-<form method="get" action="{=script}" onsubmit="if (val) { return val(); } else {return true; }">
-	<input type="hidden" name="p" value="{=page}">
-	<table width="90%" align="center" border="0">
-		<tr><th>{?page=dt:Set date/time}
-			{?page=net:Network settings}
-			{?page=sec:Set password for user www-data}
-			{?page=plc:=plc}{?page=plc:-specific options}</th></tr>
-		<tr><td>&nbsp;</td></tr>
-		<tr><td>{?page=dt:.form_dt.tpl}
-			{?page=net:.form_net.tpl}
-			{?page=sec:.form_sec.tpl}
-			{?page=plc:.form_plc.tpl}</td></tr>
-		<tr><td align="right"><input type="submit" name="set" value="OK">
-			{?page=net:<input type="reset" value="Reset">}
-			{?page=plc:<input type="reset" value="Reset">}</td></tr>
-		<tr><td class="status">{=status}</td></tr>
-	</table>
-</form>
diff -Nru a/www/cgi/tpl/cont_home.tpl b/www/cgi/tpl/cont_home.tpl
--- a/www/cgi/tpl/cont_home.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/cont_home.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,4 +0,0 @@
-<table width="80%" align="center" border="0">
-<tr><td>&nbsp;</td></tr>
-</table>
-
diff -Nru a/www/cgi/tpl/ddns_sysopt.tpl b/www/cgi/tpl/ddns_sysopt.tpl
--- a/www/cgi/tpl/ddns_sysopt.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/ddns_sysopt.tpl	2012-09-14 18:01:22.000000000 +0300
@@ -0,0 +1 @@
+<option value="{=ds.v}"{=ds.s}>{=ds.n}</option>
diff -Nru a/www/cgi/tpl/dt_form.tpl b/www/cgi/tpl/dt_form.tpl
--- a/www/cgi/tpl/dt_form.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/dt_form.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1,20 @@
+<script language="javascript">
+<!--
+str_on = '{=str.b.on}';
+str_off = '{=str.b.off}';
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td>{=str.dt.0}</td>
+		<td><input id="dt0" name="dt0" type="text" value="{=dt.0}" maxlength="2" size="2">:
+			<input id="dt1" name="dt1" type="text" value="{=dt.1}" maxlength="2" size="2">:
+			<input id="dt2" name="dt2" type="text" value="{=dt.2}" maxlength="2" size="2"></td>
+		<td rowspan="3" valign="top"><input id="sw" type="button" value="" onclick="sw_clock()" style="width: 60pt;"></td></tr>
+	<tr><td>{=str.dt.1}</td>
+		<td><input id="dt3" name="dt3" type="text" value="{=dt.3}" maxlength="2" size="2">/
+			<input id="dt4" name="dt4" type="text" value="{=dt.4}" maxlength="2" size="2">/
+			<input id="dt5" name="dt5" type="text" value="{=dt.5}" maxlength="4" size="4"></td></tr>
+	<tr><td>{=str.dt.2}</td>
+		<td><input id="sync" type="checkbox"></td></tr>
+</table>
+
diff -Nru a/www/cgi/tpl/dt.js b/www/cgi/tpl/dt.js
--- a/www/cgi/tpl/dt.js	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/dt.js	2011-03-07 19:30:00.000000000 +0200
@@ -1,6 +1,9 @@
 var clk_sw = 0;
 var int_id;
 
+var str_on;
+var str_off;
+
 function tick()
 {
 	var dt;
@@ -26,13 +29,13 @@
 	//alert('called: clk_sw=' + clk_sw);
 	if (clk_sw) 
 	{
-		ge('sw').value = 'Clock on';
+		ge('sw').value = str_on;
 		window.clearInterval(int_id);
 		clk_sw = 0;
 	}
 	else
 	{
-		ge('sw').value = 'Clock off';
+		ge('sw').value = str_off;
 		int_id = window.setInterval('tick()', 1000);
 		clk_sw = 1;
 	}
diff -Nru a/www/cgi/tpl/form_button.tpl b/www/cgi/tpl/form_button.tpl
--- a/www/cgi/tpl/form_button.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/form_button.tpl	2012-07-12 00:31:53.000000000 +0300
@@ -0,0 +1 @@
+<input type="{=frmb.t}" name="{=frmb.n}" value="{=frmb.v}" onclick="if ({=frmb.n}_click) return {=frmb.n}_click();">
diff -Nru a/www/cgi/tpl/form_control.tpl b/www/cgi/tpl/form_control.tpl
--- a/www/cgi/tpl/form_control.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/form_control.tpl	2012-07-12 00:31:53.000000000 +0300
@@ -0,0 +1 @@
+		<tr><td align="{=frmb.a}">{#frmb.c:.form_button.tpl}</td></tr>
diff -Nru a/www/cgi/tpl/form_dt.tpl b/www/cgi/tpl/form_dt.tpl
--- a/www/cgi/tpl/form_dt.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/form_dt.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,14 +0,0 @@
-<table class="ft" cellpadding="5" cellspacing="5">
-	<tr><td>Time (HH:mm:ss)</td>
-		<td><input id="dt0" name="dt0" type="text" value="{=dt.0}" maxlength="2" size="2">:
-			<input id="dt1" name="dt1" type="text" value="{=dt.1}" maxlength="2" size="2">:
-			<input id="dt2" name="dt2" type="text" value="{=dt.2}" maxlength="2" size="2"></td>
-		<td rowspan="3" valign="top"><input id="sw" type="button" value="" onclick="sw_clock()" style="width: 60pt;"></td></tr>
-	<tr><td>Date (D/M/Y)</td>
-		<td><input id="dt3" name="dt3" type="text" value="{=dt.3}" maxlength="2" size="2">/
-			<input id="dt4" name="dt4" type="text" value="{=dt.4}" maxlength="2" size="2">/
-			<input id="dt5" name="dt5" type="text" value="{=dt.5}" maxlength="4" size="4"></td></tr>
-	<tr><td>Synchronize to PC</td>
-		<td><input id="sync" type="checkbox"></td></tr>
-</table>
-
diff -Nru a/www/cgi/tpl/form_el_cntdn.tpl b/www/cgi/tpl/form_el_cntdn.tpl
--- a/www/cgi/tpl/form_el_cntdn.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/form_el_cntdn.tpl	2011-03-24 19:32:31.000000000 +0200
@@ -0,0 +1 @@
+<b id="cntdn"></b>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/form_foot.tpl b/www/cgi/tpl/form_foot.tpl
--- a/www/cgi/tpl/form_foot.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/form_foot.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1 @@
+		</form>
diff -Nru a/www/cgi/tpl/form_head.tpl b/www/cgi/tpl/form_head.tpl
--- a/www/cgi/tpl/form_head.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/form_head.tpl	2012-07-11 15:15:32.000000000 +0300
@@ -0,0 +1,3 @@
+		<form method="get" action="{=script}" id="mform" onsubmit="if (val) { return val(); } else {return true; }">
+		<input type="hidden" name="p" value="{=pg}">
+		<input type="hidden" name="sp" value="{=sp}">
diff -Nru a/www/cgi/tpl/form_net.tpl b/www/cgi/tpl/form_net.tpl
--- a/www/cgi/tpl/form_net.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/form_net.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,50 +0,0 @@
-<script language="javascript">
-<!--
-run = function()
-{
-	ge('host').focus();
-}
-val = function()
-{
-	return v_hn(ge('host'));
-}
-//-->
-</script>
-<table class="ft" cellpadding="5" cellspacing="5">
-	<tr><td>Host name</td>
-		<td><input id="host" name="host" type="text" value="{=host}" maxlength="10"></td></tr>
-	<tr><td>DHCP</td>
-		<td>Yes <input name="dhcp" type="radio" value="1" {?dhcp=1:checked="1"}> 
-			No<input name="dhcp" type="radio" value="0" {?dhcp=0:checked="1"}>
-		</td></tr>
-	<tr><td>IP address</td>
-		<td><input name="ip0" type="text" value="{=ip.addr.0}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="ip1" type="text" value="{=ip.addr.1}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="ip2" type="text" value="{=ip.addr.2}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="ip3" type="text" value="{=ip.addr.3}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">
-		</td></tr>
-	<tr><td>IP mask</td>
-		<td><input name="m0" type="text" value="{=ip.mask.0}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="m1" type="text" value="{=ip.mask.1}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="m2" type="text" value="{=ip.mask.2}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="m3" type="text" value="{=ip.mask.3}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">
-		</td></tr>
-	<tr><td>IP gateway</td>
-		<td><input name="gw0" type="text" value="{=ip.gw.0}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="gw1" type="text" value="{=ip.gw.1}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="gw2" type="text" value="{=ip.gw.2}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="gw3" type="text" value="{=ip.gw.3}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">
-		</td></tr>
-	<tr><td>IP DNS 1</td>
-		<td><input name="d10" type="text" value="{=ip.dns1.0}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d11" type="text" value="{=ip.dns1.1}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d12" type="text" value="{=ip.dns1.2}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d13" type="text" value="{=ip.dns1.3}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">
-		</td></tr>
-	<tr><td>IP DNS 2</td>
-		<td><input name="d20" type="text" value="{=ip.dns2.0}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d21" type="text" value="{=ip.dns2.1}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d22" type="text" value="{=ip.dns2.2}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">.
-			<input name="d23" type="text" value="{=ip.dns2.3}" maxlength="3" size="3" onkeyup="v_r(this, 0, 255)">
-		</td></tr>
-</table>
diff -Nru a/www/cgi/tpl/form_plc.tpl b/www/cgi/tpl/form_plc.tpl
--- a/www/cgi/tpl/form_plc.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/form_plc.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,38 +0,0 @@
-<script language="javascript">
-<!--
-run = function()
-{
-	ge('interval').focus();
-}
-//-->
-</script>
-<table class="ft" cellpadding="5" cellspacing="5">
-	<tr><td colspan="3"><strong>MRAM protection</strong></td></tr>
-	<tr><td width="35%">Status resgiter</td>
-		<td>{=mram.0}</td>
-		<td width="20%">&nbsp;</td></tr>
-	<tr><td>Block protection</td>
-		<td>{=mram.1}</td>
-		<td>{?mram.1=None:&nbsp;}{?mram.1!=None:<input name="unp" type="checkbox" value="1" unchecked>Unprotect}</td></tr>
-		
-	<tr><td colspan="3"><hr/></td></tr>
-
-	<tr><td colspan="3"><strong>Retain memory</strong></td></tr>
-
-	<tr><td>Size</td>
-		<td colspan="2">{=rm.0} bytes</td></tr>
-	<tr><td>Address</td>
-		<td colspan="2">{=rm.2}</td></tr>
-	<tr><td>File</td>
-		<td colspan="2"><div>{=rm.3}</div></td></tr>
-		
-	<tr><td>rmsync</td>
-		<td colspan="2">{=rm.6}</td></tr>
-
-	<tr><td>Refresh interval</td>
-		<td colspan="2"><input type="text" id="interval" name="interval" value="{=rm.4}" size="3" maxlength="3" onkeyup="v_r(this, 1, 300)">seconds</td></tr>
-	<tr><td>Sync. chunk</td>
-		<td><input type="text" id="chunk" name="chunk" value="{=rm.5}" size="7" maxlength="7" onkeyup="v_r(this, 1, {=rm.1})">Kbytes</td>
-		<td><input type="button" value="Whole" class="inp1" onclick="ge('chunk').value='{=rm.1}';"></td></tr>
-</table>
-
diff -Nru a/www/cgi/tpl/form_sec.tpl b/www/cgi/tpl/form_sec.tpl
--- a/www/cgi/tpl/form_sec.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/form_sec.tpl	1970-01-01 03:00:00.000000000 +0300
@@ -1,14 +0,0 @@
-<script language="javascript">
-<!--
-run = function()
-{
-	ge('pwd').focus();
-}
-//-->
-</script>
-<table class="ft" cellpadding="5" cellspacing="5">
-	<tr><td>Enter password:</td>
-		<td><input id="pwd" name="pwd" type="password" value="" maxlength="8"></td></tr>
-	<tr><td>Repeat password:</td>
-		<td><input name="pwdr" type="password" value="" maxlength="8"></td></tr>
-</table>
diff -Nru a/www/cgi/tpl/main.tpl b/www/cgi/tpl/main.tpl
--- a/www/cgi/tpl/main.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/main.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -1,10 +1,10 @@
 <html>
 <head>
-<title>{=plc} Setup</title>
+<title>{=str.title}</title>
 <script language="javascript" type="text/javascript">
 <!--
 {.wc.js}
-{?page=dt:.dt.js}
+{?pg=dt:.dt.js}
 //-->
 </script>
 <style type="text/css">
@@ -15,7 +15,7 @@
 <table width="772" border="0" cellspacing="0" cellpadding="0" class="page">
 	<tr>
 		<td><table width="100%" border="0" cellspacing="0" cellpadding="0">
-				<tr><td nowrap align="center"><h1>{=plc} Setup</h1></td></tr>
+				<tr><td nowrap align="center"><h1>{=str.title}</h1></td></tr>
 				<tr><td class="copy">ver. {=version}</td></tr>
 			</table></td>
 	</tr>
@@ -24,8 +24,8 @@
 		<td><table width="100%" border="0" cellspacing="0" cellpadding="0">
 				<tr>
 					<td width="5">&nbsp;</td>
-					<td width="160" class="menu">{.menu.tpl}</td>
-					<!--td width="5" class="cont">&nbsp;</td-->
+					<td width="1%" class="menu">{.menu.tpl}</td>
+					<td width="5">&nbsp;</td>
 					<td class="cont">{.contents.tpl}</td>
 				</tr>
 			</table></td>
diff -Nru a/www/cgi/tpl/menu_item.tpl b/www/cgi/tpl/menu_item.tpl
--- a/www/cgi/tpl/menu_item.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/menu_item.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -0,0 +1 @@
+<tr><td class="mi{=pg_i.s}"><a href="{=script}?p={=pg_i.n}">{=pg_i.t}</a></td></tr>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/menu_sensors.tpl b/www/cgi/tpl/menu_sensors.tpl
--- a/www/cgi/tpl/menu_sensors.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/menu_sensors.tpl	2011-04-19 21:07:44.000000000 +0300
@@ -0,0 +1 @@
+<tr><td class="mi"><a href="sensors.cgi">{=str.m.sensors}</a></td></tr>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/menu.tpl b/www/cgi/tpl/menu.tpl
--- a/www/cgi/tpl/menu.tpl	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/menu.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -1,7 +1,6 @@
 <table width="100%" border="0" cellspacing="0" cellpadding="10">
-	<!--tr><td class="mi{?page=home:s}"><a href="{=script}?p=home">Home</a></td></tr-->
-	<tr><td class="mi{?page=dt:s}"><a href="{=script}?p=dt">Date/Time</a></td></tr>
-	<tr><td class="mi{?page=net:s}"><a href="{=script}?p=net">Network</a></td></tr>
-	<tr><td class="mi{?page=sec:s}"><a href="{=script}?p=sec">Security</a></td></tr>
-	<tr><td class="mi{?page=plc:s}"><a href="{=script}?p=plc">PLC options</a></td></tr>
+	<tr><td class="mi">&nbsp;</td></tr>
+	{#pg_i.c:.menu_item.tpl}
+	{?wcf.sensors=1:.menu_sensors.tpl}
+	<tr><td class="mi">&nbsp;</td></tr>
 </table>
diff -Nru a/www/cgi/tpl/net_ddns.tpl b/www/cgi/tpl/net_ddns.tpl
--- a/www/cgi/tpl/net_ddns.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ddns.tpl	2012-09-18 12:58:35.000000000 +0300
@@ -0,0 +1,70 @@
+<script language="javascript">
+<!--
+var initIndex = 0;
+function breset_click()
+{
+	ge('ds').selectedIndex = initIndex;
+	set_ds();
+	return false;
+}
+
+var ddns=[];
+ddns[0] = {dl: '', dp: '', dd: '', dhr: 0, dh: '', du: ''};
+{ddns_cfg}
+
+function set_ds()
+{
+	var ds = ge('ds');
+	var i = ds.selectedIndex;
+	ge('dset').style.visibility = i ? 'visible' : 'hidden';
+	if (i < ddns.length) {
+		ge('dl').value = ddns[i].dl;
+		ge('dp').value = ddns[i].dp;
+		ge('dd').value = ddns[i].dd;
+		ge('dhr').style.visibility = ddns[i].dhr ? 'visible' : 'hidden';
+		if (ddns[i].dhr) {
+			ge('dh').value = ddns[i].dh;
+		}
+		ge('du').value = ddns[i].du;
+	}
+}
+
+run = function()
+{
+	initIndex = ge('ds').selectedIndex;
+	set_ds();
+
+	if (ge('cntdn')) {
+		url = '{=script}?p={=pg}&sp={=sp}';
+		set_cntdn(2, url);
+	}
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td class="sh">{=str.net.0}</td>
+		<td class="sh"><select id="ds" name="ds" onchange="set_ds()">
+			{#ds.c:.ddns_sysopt.tpl}
+		</select></td></tr>
+
+		<tbody id="dset">
+		
+		<tr><td>&nbsp;&nbsp;{=str.net.1} *</td>
+			<td><input id="dl" name="dl" type="text" value=""/></td></tr>
+			
+		<tr><td>&nbsp;&nbsp;{=str.net.2} *</td>
+			<td><input id="dp" name="dp" type="text" value=""/></td></tr>
+			
+		<tr><td>&nbsp;&nbsp;{=str.net.3}</td>
+			<td>{=ddns.h}</td></tr>
+			
+		<tr><td>&nbsp;&nbsp;{=str.net.4} *</td>
+			<td><input id="dd" name="dd" type="text" value=""/></td></tr>
+			
+		<tr id="dhr"><td>&nbsp;&nbsp;{=str.net.5}</td>
+			<td><input id="dh" name="dh" type="text" value=""/></td></tr>
+
+		<tr><td class="sh">{=str.net.6} *</td>
+			<td class="sh"><input id="du" name="du"  type="text" value=""/></td></tr>
+		</tbody>
+</table>
diff -Nru a/www/cgi/tpl/net_form_main.tpl b/www/cgi/tpl/net_form_main.tpl
--- a/www/cgi/tpl/net_form_main.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_form_main.tpl	2012-09-18 12:58:35.000000000 +0300
@@ -0,0 +1,56 @@
+<script language="javascript">
+<!--
+run = function()
+{
+	ge('host').focus();
+	if (ge('cntdn')) {
+		url = location.protocol + '//';
+		url += '{=ip.addr.0}.{=ip.addr.1}.{=ip.addr.2}.{=ip.addr.3}' + location.pathname;
+		url += '?p=net';
+		set_cntdn(2, url);
+	}
+}
+val = function()
+{
+	return v_hn(ge('host'));
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td>{=str.net.0} *</td>
+		<td><input id="host" name="host" type="text" value="{=host}" maxlength="32"></td></tr>
+	<tr><td>{=str.net.1}</td>
+		<td>{=str.yes} <input name="dhcp" type="radio" value="1" {?dhcp=1:checked="1"}> 
+			{=str.no}<input name="dhcp" type="radio" value="0" {?dhcp=0:checked="1"}>
+		</td></tr>
+	<tr><td>{=str.net.2} *</td>
+		<td><input name="ip0" type="text" value="{=ip.addr.0}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="ip1" type="text" value="{=ip.addr.1}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="ip2" type="text" value="{=ip.addr.2}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="ip3" type="text" value="{=ip.addr.3}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">
+		</td></tr>
+	<tr><td>{=str.net.3} *</td>
+		<td><input name="m0" type="text" value="{=ip.mask.0}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="m1" type="text" value="{=ip.mask.1}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="m2" type="text" value="{=ip.mask.2}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="m3" type="text" value="{=ip.mask.3}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">
+		</td></tr>
+	<tr><td>{=str.net.4} *</td>
+		<td><input name="gw0" type="text" value="{=ip.gw.0}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="gw1" type="text" value="{=ip.gw.1}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="gw2" type="text" value="{=ip.gw.2}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">.
+			<input name="gw3" type="text" value="{=ip.gw.3}" maxlength="3" size="3" onblur="v_r(this, 0, 255)">
+		</td></tr>
+	<tr><td>{=str.net.5}</td>
+		<td><input name="d10" type="text" value="{=ip.dns1.0}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d11" type="text" value="{=ip.dns1.1}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d12" type="text" value="{=ip.dns1.2}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d13" type="text" value="{=ip.dns1.3}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">
+		</td></tr>
+	<tr><td>{=str.net.6}</td>
+		<td><input name="d20" type="text" value="{=ip.dns2.0}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d21" type="text" value="{=ip.dns2.1}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d22" type="text" value="{=ip.dns2.2}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">.
+			<input name="d23" type="text" value="{=ip.dns2.3}" maxlength="3" size="3" onblur="v_re(this, 0, 255)">
+		</td></tr>
+</table>
diff -Nru a/www/cgi/tpl/net_ppp_edit_as.tpl b/www/cgi/tpl/net_ppp_edit_as.tpl
--- a/www/cgi/tpl/net_ppp_edit_as.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_as.tpl	2013-01-09 15:44:16.000000000 +0200
@@ -0,0 +1,4 @@
+	<tr><td class="sh" colspan="3">{=str.net.15}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.16}</td>
+		<td><input type="checkbox" name="as"{=pr.as}/></td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_edit_gprs_modem.tpl b/www/cgi/tpl/net_ppp_edit_gprs_modem.tpl
--- a/www/cgi/tpl/net_ppp_edit_gprs_modem.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_gprs_modem.tpl	2012-07-01 11:14:03.000000000 +0300
@@ -0,0 +1,13 @@
+	<tr><td class="sh" colspan="3">{=str.net.5}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.6}</td>
+		<td><input type="text" name="pin" value="{=pr.pin}" maxlength="8"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.7}</td>
+		<td><input type="text" name="is" value="{=pr.is}" maxlength="63"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.8} *</td>
+		<td><input type="text" name="apn" value="{=pr.apn}" maxlength="63"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.9} *</td>
+		<td><input type="text" name="cn" value="{=pr.cn}" maxlength="8"/></td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_edit_gprs_port.tpl b/www/cgi/tpl/net_ppp_edit_gprs_port.tpl
--- a/www/cgi/tpl/net_ppp_edit_gprs_port.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_gprs_port.tpl	2012-07-01 11:14:03.000000000 +0300
@@ -0,0 +1,13 @@
+	<tr><td class="sh" colspan="2">{=str.net.1}</td>
+		<td><input type="button" value="{=str.b.std}" onclick="set_def();"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.2} *</td>
+		<td><input type="text" id="port" name="port" value="{=pr.port}" maxlength="15"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.3} *</td>
+		<td><select size="1" id="br" name="br">
+			{#pr.br.c:.baud_rate_option.tpl}
+			</select></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.4}</td>
+		<td><input type="checkbox" id="hwf" name="hwf"{=pr.hwf}/></td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_edit_gprs_pppopt.tpl b/www/cgi/tpl/net_ppp_edit_gprs_pppopt.tpl
--- a/www/cgi/tpl/net_ppp_edit_gprs_pppopt.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_gprs_pppopt.tpl	2012-07-01 11:14:03.000000000 +0300
@@ -0,0 +1,4 @@
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.13}</td>
+		<td><input type="text" name="ip" value="{=pr.ip}" maxlength="15" id="ip"/>&nbsp;
+			<input type="checkbox" onclick="ge('ip').disabled=this.checked;" id="ipd"{=pr.ipd}/> {=str.net.14}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_edit_js.tpl b/www/cgi/tpl/net_ppp_edit_js.tpl
--- a/www/cgi/tpl/net_ppp_edit_js.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_js.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,21 @@
+<script language="javascript">
+<!--
+run = function()
+{
+	if (ge('cmd').value=={=cmd.add}) {
+		set_def();
+	}
+	ge('ip').disabled=ge('ipd').checked;
+}
+val = function()
+{
+	return true;
+}
+function set_def()
+{
+	ge('port').value='{=def.port}';
+	ge('br').options[{=def.br}].selected=1;
+	ge('hwf').checked={=def.hwf};
+}
+//-->
+</script>
diff -Nru a/www/cgi/tpl/net_ppp_edit.tpl b/www/cgi/tpl/net_ppp_edit.tpl
--- a/www/cgi/tpl/net_ppp_edit.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit.tpl	2013-01-09 15:44:16.000000000 +0200
@@ -0,0 +1,32 @@
+<script language="javascript">
+<!--
+function bcancel_click()
+{
+	location.href='{=script}?p={=pg}&sp={=sp}';
+}
+//-->
+</script>
+{?ppp=gprs:.net_ppp_edit_js.tpl}
+<input type="hidden" id="cmd" name="cmd" value="{=cmd}"/>
+<input type="hidden" name="iid" value="{=pr.iid}"/>
+<table class="ft" cellpadding="5" cellspacing="0">
+	<tr><td colspan="2">{=str.net.0} *</td>
+		<td><input type="text" name="nn" value="{=pr.iid}" maxlength="31"/></td></tr>
+
+	{?ppp=gprs:.net_ppp_edit_gprs_port.tpl}
+
+	{?ppp=gprs:.net_ppp_edit_gprs_modem.tpl}
+
+	<tr><td class="sh" colspan="3">{=str.net.10}</td></tr>
+	{?ppp=vpn:.net_ppp_edit_vpn_pppopt.tpl}
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.11}</td>
+		<td><input type="text" name="ln" value="{=pr.ln}" maxlength="15"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.12}</td>
+		<td><input type="text" name="pwd" value="{=pr.pwd}" maxlength="15"/></td></tr>
+	{?ppp=gprs:.net_ppp_edit_gprs_pppopt.tpl}
+	{?ppp=vpn:.net_ppp_edit_vpn_route.tpl}
+
+	{?ppp.a=1:.net_ppp_edit_as.tpl}
+</table>
diff -Nru a/www/cgi/tpl/net_ppp_edit_vpn_pppopt.tpl b/www/cgi/tpl/net_ppp_edit_vpn_pppopt.tpl
--- a/www/cgi/tpl/net_ppp_edit_vpn_pppopt.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_vpn_pppopt.tpl	2012-07-05 00:18:54.000000000 +0300
@@ -0,0 +1,3 @@
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.19} *</td>
+		<td><input type="text" name="vs" value="{=pr.vs}" maxlength="63"/></td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_edit_vpn_route.tpl b/www/cgi/tpl/net_ppp_edit_vpn_route.tpl
--- a/www/cgi/tpl/net_ppp_edit_vpn_route.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_edit_vpn_route.tpl	2012-07-01 11:14:03.000000000 +0300
@@ -0,0 +1,8 @@
+	<tr><td class="sh">&nbsp;</td>
+		<td class="sh" colspan="2">{=str.net.20}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.21}</td>
+		<td><input type="text" name="vn" value="{=pr.vn}" maxlength="15"/></td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.22}</td>
+		<td><input type="text" name="vm" value="{=pr.vm}" maxlength="15"/></td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_list.tpl b/www/cgi/tpl/net_ppp_list.tpl
--- a/www/cgi/tpl/net_ppp_list.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_list.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -0,0 +1,16 @@
+<script language="javascript">
+<!--
+run = function()
+{
+	if (ge('cntdn')) {
+		url = '{=script}?p={=pg}&sp={=sp}&cmd={=cmd.list}';
+		set_cntdn(2, url);
+	}
+}
+//-->
+</script>
+<table style="width: 100%;" cellpadding="5" cellspacing="5">
+	<tr><td style="text-align: right;"><a href="{=script}?p={=pg}&sp={=sp}&cmd={=cmd.add}">{=str.add}</a></td></tr>
+</table>
+{?tdr_i.c>=1:.tab_data.tpl}
+{?tdr_i.c=0:.tab_no_data.tpl}
diff -Nru a/www/cgi/tpl/net_ppp_log_view.tpl b/www/cgi/tpl/net_ppp_log_view.tpl
--- a/www/cgi/tpl/net_ppp_log_view.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_log_view.tpl	2012-07-12 00:31:53.000000000 +0300
@@ -0,0 +1,74 @@
+<script language="javascript">
+<!--
+var log_offs = 0;
+var as_on = 1;
+var log_url = '{=script}?p={=pg}&sp={=sp}&iid={=pr.iid}&cmd={=cmd.log}';
+var refr_id;
+
+function bclose_click()
+{
+	if (ge('ldr').checked) {
+		ge('mform').submit();
+	} else {
+		window.close();
+	}
+}
+function schedule_refresh()
+{
+	refr_id = window.setTimeout('read_log()', 1 * 1000);
+}
+run = function() 
+{
+	if ({=ldr}) {
+		window.close();
+	}
+	e = ge('log');
+	log_offs = e.value.length;
+	e.scrollTop = e.scrollHeight;
+	schedule_refresh();
+}
+function read_handler()
+{
+	var e;
+	var t;
+
+	if (this.readyState != 4) {
+		return;
+	}
+
+	e = ge('log');
+	t = e.scrollTop;
+	e.value += this.responseText;
+	e.scrollTop = as_on ? e.scrollHeight : t;
+	log_offs += this.responseText.length;
+	schedule_refresh();
+}
+function set_as(e)
+{
+	as_on = e.scrollTop + e.clientHeight >= e.scrollHeight;
+}
+function read_log()
+{
+	var cl;
+	try {
+		cl = new XMLHttpRequest();
+	} catch(ex) {
+	}
+	if (!cl) {
+		document.location.replace(log_url);
+		return;
+	}
+
+	cl.open('GET', log_url + '&lo=' + log_offs, true);
+	cl.onreadystatechange = read_handler;
+	cl.send();
+}
+//-->
+</script>
+<input type="hidden" name="set" value="1"/>
+<input type="hidden" name="cmd" value="{=cmd.log}"/>
+<input type="hidden" name="iid" value="{=pr.iid}"/>
+<table border="0" width="100%" cellpadding="5" cellspacing="0">
+<tr><td><textarea style="width: 100%;" id="log" rows="25" cols="80" readonly onscroll="set_as(this)">{readlog}</textarea></td></tr>
+<tr><td><input type="checkbox" name="ldr" id="ldr"> {=str.net.23}</td></tr>
+</table>
diff -Nru a/www/cgi/tpl/net_ppp.tpl b/www/cgi/tpl/net_ppp.tpl
--- a/www/cgi/tpl/net_ppp.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp.tpl	2012-07-11 15:15:32.000000000 +0300
@@ -0,0 +1,5 @@
+{?ppp.m=0:.net_ppp_list.tpl}
+{?ppp.m=1:.net_ppp_edit.tpl}
+{?ppp.m=2:.net_ppp_edit.tpl}
+{?ppp.m=3:.net_ppp_view.tpl}
+{?ppp.m=4:.net_ppp_log_view.tpl}
\ No newline at end of file
diff -Nru a/www/cgi/tpl/net_ppp_view_as.tpl b/www/cgi/tpl/net_ppp_view_as.tpl
--- a/www/cgi/tpl/net_ppp_view_as.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_as.tpl	2013-01-09 15:44:16.000000000 +0200
@@ -0,0 +1,4 @@
+	<tr><td class="sh" colspan="3">{=str.net.15}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.16}</td>
+		<td>{=pr.as}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_view_gprs_modem.tpl b/www/cgi/tpl/net_ppp_view_gprs_modem.tpl
--- a/www/cgi/tpl/net_ppp_view_gprs_modem.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_gprs_modem.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,13 @@
+	<tr><td class="sh" colspan="3">{=str.net.5}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.6}</td>
+		<td>{=pr.pin}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.7}</td>
+		<td>{=pr.is}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.8}</td>
+		<td>{=pr.apn}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.9}</td>
+		<td>{=pr.cn}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_view_gprs_port.tpl b/www/cgi/tpl/net_ppp_view_gprs_port.tpl
--- a/www/cgi/tpl/net_ppp_view_gprs_port.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_gprs_port.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,10 @@
+	<tr><td class="sh" colspan="3">{=str.net.1}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.2}</td>
+		<td>{=pr.port}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.3}</td>
+		<td>{=pr.br}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.4}</td>
+		<td>{=pr.hwf}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_view_gprs_pppopt.tpl b/www/cgi/tpl/net_ppp_view_gprs_pppopt.tpl
--- a/www/cgi/tpl/net_ppp_view_gprs_pppopt.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_gprs_pppopt.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,3 @@
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.13}</td>
+		<td>{=pr.ip}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_view.tpl b/www/cgi/tpl/net_ppp_view.tpl
--- a/www/cgi/tpl/net_ppp_view.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view.tpl	2013-01-09 15:44:16.000000000 +0200
@@ -0,0 +1,33 @@
+<script language="javascript">
+<!--
+function bback_click()
+{
+	location.href='{=script}?p={=pg}&sp={=sp}';
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="0">
+	<tr><td colspan="2">{=str.net.0}</td>
+		<td>{=pr.iid}</td></tr>
+
+	{?ppp=gprs:.net_ppp_view_gprs_port.tpl}
+
+	{?ppp=gprs:.net_ppp_view_gprs_modem.tpl}
+
+	<tr><td class="sh" colspan="3">{=str.net.10}</td></tr>
+	{?ppp=vpn:.net_ppp_view_vpn_pppopt.tpl}
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.11}</td>
+		<td>{=pr.ln}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.12}</td>
+		<td>{=pr.pwd}</td></tr>
+	{?ppp=gprs:.net_ppp_view_gprs_pppopt.tpl}
+	{?ppp=vpn:.net_ppp_view_vpn_route.tpl}
+
+	{?ppp.a=1:.net_ppp_view_as.tpl}
+
+	<tr><td colspan="3">&nbsp;</td></tr>
+	<tr><td class="sh" colspan="2">{=str.net.18}</td>
+		<td class="sh">{=pr.state}</td></tr>
+</table>
diff -Nru a/www/cgi/tpl/net_ppp_view_vpn_pppopt.tpl b/www/cgi/tpl/net_ppp_view_vpn_pppopt.tpl
--- a/www/cgi/tpl/net_ppp_view_vpn_pppopt.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_vpn_pppopt.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,3 @@
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.19}</td>
+		<td>{=pr.vs}</td></tr>
diff -Nru a/www/cgi/tpl/net_ppp_view_vpn_route.tpl b/www/cgi/tpl/net_ppp_view_vpn_route.tpl
--- a/www/cgi/tpl/net_ppp_view_vpn_route.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net_ppp_view_vpn_route.tpl	2012-07-01 00:05:09.000000000 +0300
@@ -0,0 +1,8 @@
+	<tr><td class="sh">&nbsp;</td>
+		<td class="sh" colspan="2">{=str.net.20}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.21}</td>
+		<td>{=pr.vn}</td></tr>
+	<tr><td>&nbsp;</td>
+		<td>{=str.net.22}</td>
+		<td>{=pr.vm}</td></tr>
diff -Nru a/www/cgi/tpl/net.tpl b/www/cgi/tpl/net.tpl
--- a/www/cgi/tpl/net.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/net.tpl	2012-09-14 18:01:22.000000000 +0300
@@ -0,0 +1,5 @@
+{?sp=main:.net_form_main.tpl}
+{?sp=:.net_form_main.tpl}
+{?sp=gprs:.net_ppp.tpl}
+{?sp=vpn:.net_ppp.tpl}
+{?sp=ddns:.net_ddns.tpl}
\ No newline at end of file
diff -Nru a/www/cgi/tpl/plc_form.tpl b/www/cgi/tpl/plc_form.tpl
--- a/www/cgi/tpl/plc_form.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/plc_form.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1,27 @@
+<script language="javascript">
+<!--
+run = function()
+{
+	ge('interval').focus();
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	{?mram=1:.plc_mram_prot.tpl}
+	<tr><td colspan="3"><strong>{=str.plc.rm.0}</strong></td></tr>
+
+	<tr><td>{=str.plc.rm.1}</td>
+		<td colspan="2">{=rm.0} {=str.bytes}</td></tr>
+	<tr><td>{=str.plc.rm.2}</td>
+		<td colspan="2">{=rm.2}</td></tr>
+	<tr><td>{=str.plc.rm.3}</td>
+		<td colspan="2"><div>{=rm.3}</div></td></tr>
+		
+	<tr><td>{=str.plc.rm.4}</td>
+		<td colspan="2">{=rm.4}</td></tr>
+
+	<tr><td>{=str.plc.rm.5}</td>
+		<td colspan="2"><input type="text" id="interval" name="interval" value="{=rm.5}" size="3" maxlength="3" onkeyup="v_r(this, 1, 300)">{=str.secs}</td></tr>
+	{?rm.6=1:.plc_retain_chunk.tpl}
+</table>
+
diff -Nru a/www/cgi/tpl/plc_mram_prot.tpl b/www/cgi/tpl/plc_mram_prot.tpl
--- a/www/cgi/tpl/plc_mram_prot.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/plc_mram_prot.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1,9 @@
+	<tr><td colspan="3"><strong>{=str.plc.mp.0}</strong></td></tr>
+	<tr><td width="35%">{=str.plc.mp.1}</td>
+		<td>{=mram.0}</td>
+		<td width="20%">&nbsp;</td></tr>
+	<tr><td>{=str.plc.mp.2}</td>
+		<td>{=mram.1}</td>
+		<td>{?mram.2=0:&nbsp;}{?mram.2!=0:.plc_mram_unprot.tpl}</td></tr>
+	<tr><td colspan="3"><hr/></td></tr>
+
diff -Nru a/www/cgi/tpl/plc_mram_unprot.tpl b/www/cgi/tpl/plc_mram_unprot.tpl
--- a/www/cgi/tpl/plc_mram_unprot.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/plc_mram_unprot.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1 @@
+<input name="unp" type="checkbox" value="1" unchecked>{=str.plc.mp.3}
\ No newline at end of file
diff -Nru a/www/cgi/tpl/plc_retain_chunk.tpl b/www/cgi/tpl/plc_retain_chunk.tpl
--- a/www/cgi/tpl/plc_retain_chunk.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/plc_retain_chunk.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1,4 @@
+	<tr><td>{=str.plc.rm.6}</td>
+		<td><input type="text" id="chunk" name="chunk" value="{=rm.7}" size="7" maxlength="7" onkeyup="v_r(this, 1, {=rm.1})">{=str.kbytes}</td>
+		<td><input type="button" value="{=str.b.whole}" class="inp1" onclick="ge('chunk').value='{=rm.1}';"></td></tr>
+
diff -Nru a/www/cgi/tpl/popup.tpl b/www/cgi/tpl/popup.tpl
--- a/www/cgi/tpl/popup.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/popup.tpl	2012-07-11 19:25:44.000000000 +0300
@@ -0,0 +1,19 @@
+<html>
+<head>
+<title>{=str.title}</title>
+<script language="javascript" type="text/javascript">
+<!--
+{.wc.js}
+//-->
+</script>
+<style type="text/css">
+{.wc.css}
+</style>
+</head>
+<body leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0" marginheight="0" onload="if (run) { run(); }">
+<table width="800" border="0" cellspacing="0" cellpadding="0" class="page">
+	<tr>
+		<td class="cont">{.contents.tpl}</td></tr>
+</table>
+</body>
+</html>
diff -Nru a/www/cgi/tpl/sec_form.tpl b/www/cgi/tpl/sec_form.tpl
--- a/www/cgi/tpl/sec_form.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/sec_form.tpl	2011-05-10 20:00:47.000000000 +0300
@@ -0,0 +1,14 @@
+<script language="javascript">
+<!--
+run = function()
+{
+	ge('pwd').focus();
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td>{=str.sec.0}</td>
+		<td><input id="pwd" name="pwd" type="password" value="" maxlength="8"></td></tr>
+	<tr><td>{=str.sec.1}</td>
+		<td><input name="pwdr" type="password" value="" maxlength="8"></td></tr>
+</table>
diff -Nru a/www/cgi/tpl/submenu_item.tpl b/www/cgi/tpl/submenu_item.tpl
--- a/www/cgi/tpl/submenu_item.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/submenu_item.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -0,0 +1 @@
+<td class="mi{=sp_i.s}"><a href="{=script}?p={=pg}&sp={=sp_i.n}">{=sp_i.t}</a></td>
diff -Nru a/www/cgi/tpl/submenu.tpl b/www/cgi/tpl/submenu.tpl
--- a/www/cgi/tpl/submenu.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/submenu.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -0,0 +1,13 @@
+<tr>
+	<td class="page"><table width="100%" cellpadding="0" cellspacing="0">
+		<tr class="submsep"><td>&nbsp;</td></tr>
+		<tr>
+			<td><table width="100%" cellpadding="5" cellspacing="5">
+				<tr>{#sp_i.c:.submenu_item.tpl}
+					<td class="mi" width="99%">&nbsp;</td>
+				</tr>
+				</table></td>
+		</tr>
+		<tr class="submsep"><td>&nbsp;</td></tr>
+	</table></td>
+</tr>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_act_cell_confirm.tpl b/www/cgi/tpl/tab_act_cell_confirm.tpl
--- a/www/cgi/tpl/tab_act_cell_confirm.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_act_cell_confirm.tpl	2012-06-27 18:23:10.000000000 +0300
@@ -0,0 +1 @@
+ onClick="return a_confirm(this, '{=ta_i.m}');"
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_act_cell_popup.tpl b/www/cgi/tpl/tab_act_cell_popup.tpl
--- a/www/cgi/tpl/tab_act_cell_popup.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_act_cell_popup.tpl	2012-07-11 15:15:32.000000000 +0300
@@ -0,0 +1 @@
+ target="{=tdr_i.i}_{=ppp}" onClick="return popup(this);"
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_act_cell.tpl b/www/cgi/tpl/tab_act_cell.tpl
--- a/www/cgi/tpl/tab_act_cell.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_act_cell.tpl	2012-07-11 15:15:32.000000000 +0300
@@ -0,0 +1 @@
+<td{=ta_i.s}><a href="{=script}?p={=pg}&sp={=sp}&iid={=tdr_i.i}&cmd={=ta_i.a}"{?ta_i.o=confirm:.tab_act_cell_confirm.tpl}{?ta_i.o=popup:.tab_act_cell_popup.tpl}>{=ta_i.n}</a></td>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_act.tpl b/www/cgi/tpl/tab_act.tpl
--- a/www/cgi/tpl/tab_act.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_act.tpl	2012-07-01 21:32:14.000000000 +0300
@@ -0,0 +1,2 @@
+{?ta_i.e=0:.tab_no_act_cell.tpl}
+{?ta_i.e=1:.tab_act_cell.tpl}
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_data_cell.tpl b/www/cgi/tpl/tab_data_cell.tpl
--- a/www/cgi/tpl/tab_data_cell.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_data_cell.tpl	2012-06-20 19:30:17.000000000 +0300
@@ -0,0 +1 @@
+<td>{=td_i.v}</td>
diff -Nru a/www/cgi/tpl/tab_data_row.tpl b/www/cgi/tpl/tab_data_row.tpl
--- a/www/cgi/tpl/tab_data_row.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_data_row.tpl	2012-07-01 21:32:14.000000000 +0300
@@ -0,0 +1,4 @@
+<tr>
+	{#td_i.c:.tab_data_cell.tpl}
+	{#ta_i.c:.tab_act.tpl}
+</tr>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_data.tpl b/www/cgi/tpl/tab_data.tpl
--- a/www/cgi/tpl/tab_data.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_data.tpl	2012-06-27 18:23:10.000000000 +0300
@@ -0,0 +1,4 @@
+<table rules="all" class="ft" cellpadding="5" cellspacing="0">
+	<tr>{#th_i.c:.tab_head_cell.tpl}</tr>
+	{#tdr_i.c:.tab_data_row.tpl}
+</table>
diff -Nru a/www/cgi/tpl/tab_head_cell.tpl b/www/cgi/tpl/tab_head_cell.tpl
--- a/www/cgi/tpl/tab_head_cell.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_head_cell.tpl	2012-06-20 19:30:17.000000000 +0300
@@ -0,0 +1 @@
+<th{=th_i.s}>{=th_i.t}</th>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_no_act_cell.tpl b/www/cgi/tpl/tab_no_act_cell.tpl
--- a/www/cgi/tpl/tab_no_act_cell.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_no_act_cell.tpl	2012-07-01 21:32:14.000000000 +0300
@@ -0,0 +1 @@
+<td>&nbsp;</td>
\ No newline at end of file
diff -Nru a/www/cgi/tpl/tab_no_data.tpl b/www/cgi/tpl/tab_no_data.tpl
--- a/www/cgi/tpl/tab_no_data.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/tab_no_data.tpl	2012-07-12 18:43:53.000000000 +0300
@@ -0,0 +1,3 @@
+<table rules="all" class="ft" cellpadding="5" cellspacing="5">
+	<tr><td>{=str.norec}</td></tr>
+</table>
diff -Nru a/www/cgi/tpl/test_cont.tpl b/www/cgi/tpl/test_cont.tpl
--- a/www/cgi/tpl/test_cont.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/test_cont.tpl	2012-07-02 23:02:16.000000000 +0300
@@ -0,0 +1 @@
+{?sp=ping:.test_ping.tpl}
diff -Nru a/www/cgi/tpl/test_ping.tpl b/www/cgi/tpl/test_ping.tpl
--- a/www/cgi/tpl/test_ping.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/test_ping.tpl	2011-05-11 12:40:25.000000000 +0300
@@ -0,0 +1,6 @@
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td class="head">{=str.net.2}</td>
+		<td><input name="pip" id="pip" value="{=ping.0}"></td></tr>
+	<tr><td class="head">Result</td>
+		<td><textarea name="pr" id="pr" value="" disabled="1" class="res"></textarea></td></tr>
+</table>
diff -Nru a/www/cgi/tpl/under_construct.tpl b/www/cgi/tpl/under_construct.tpl
--- a/www/cgi/tpl/under_construct.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/under_construct.tpl	2012-06-21 19:03:42.000000000 +0300
@@ -0,0 +1 @@
+UNDER CONSTRUCTION - UNKNOWN
\ No newline at end of file
diff -Nru a/www/cgi/tpl/utils_form_ping.tpl b/www/cgi/tpl/utils_form_ping.tpl
--- a/www/cgi/tpl/utils_form_ping.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/utils_form_ping.tpl	2012-07-12 18:25:29.000000000 +0300
@@ -0,0 +1,17 @@
+<script language="javascript">
+<!--
+function set_click()
+{
+	s = ge('status');
+	if (s) {
+		h = ge('host');
+		s.innerHTML = '{=str.utils.1} ' + (h ? h.value : '') + ' ...';
+	}
+	return true;
+}
+//-->
+</script>
+<table class="ft" cellpadding="5" cellspacing="5">
+	<tr><td>Host{=str.utils.0}</td>
+		<td><input id="host" name="host" type="text" value="{=ping.h}" maxlength="64" size="40"></td></tr>
+</table>
diff -Nru a/www/cgi/tpl/utils.tpl b/www/cgi/tpl/utils.tpl
--- a/www/cgi/tpl/utils.tpl	1970-01-01 03:00:00.000000000 +0300
+++ b/www/cgi/tpl/utils.tpl	2012-07-12 18:25:29.000000000 +0300
@@ -0,0 +1 @@
+{?sp=ping:.utils_form_ping.tpl}
diff -Nru a/www/cgi/tpl/wc.css b/www/cgi/tpl/wc.css
--- a/www/cgi/tpl/wc.css	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/wc.css	2012-06-27 18:23:10.000000000 +0300
@@ -19,12 +19,18 @@
 td {
 	font-size: 11pt;
 }
+td.head {
+	white-space: nowrap;
+}
 td.mis {
 	background-color: #e0e0e0;
 }
 td.mi {
 	background-color: #d0d0d0;
 }
+td.sh {
+	background-color: #d8d8d8;
+}
 table.ft {
 	width: 100%;
 	border: solid 2px white;
@@ -32,3 +38,12 @@
 .status {
 	font-family: monospace;
 }
+.submsep {
+	line-height: 4px;
+}
+.res {
+	font-size: 8pt;
+	width: 450;
+	height: 200;
+	background-color: #f0f0f0;
+}
diff -Nru a/www/cgi/tpl/wc.js b/www/cgi/tpl/wc.js
--- a/www/cgi/tpl/wc.js	2011-02-28 16:04:30.000000000 +0200
+++ b/www/cgi/tpl/wc.js	2012-09-18 12:58:35.000000000 +0300
@@ -5,14 +5,21 @@
 
 function v_r(field, vmin, vmax)
 {
-	if (!((field.value >= vmin) && (field.value <= vmax)))
+	if (!field.value.length ||
+		!/^[0-9]+$/.test(field.value) ||
+		!((field.value >= vmin) && (field.value <= vmax)))
 	{
 		field.value = vmin;
 	}
 }
+function v_re(field, vmin, vmax)
+{
+	if (!field.value.length) return;
+	v_r(field, vmin, vmax);
+}
 function v_hn(item) 
 {
-	var ok = /^[A-Za-z0-9_]+$/.test(item.value);
+	var ok = /^[A-Za-z0-9][A-Za-z0-9_\-]*$/.test(item.value);
 	if (!ok) {
 		item.focus();
 		item.select();
@@ -20,3 +27,41 @@
 	return ok;
 }
 
+var redir_u;
+var redir_d;
+var redir_id;
+function cntdn()
+{
+	redir_d--;
+	ge('cntdn').innerHTML = redir_d;
+	if (redir_d <= 0)
+	{
+		window.clearInterval(redir_id);
+		location.replace(redir_u);
+	}
+}
+function set_cntdn(delay, url)
+{
+	ge('cntdn').innerHTML = delay;
+	redir_d = delay;
+	redir_u = url;
+	redir_id = window.setInterval('cntdn()', 1000);
+}
+function a_confirm(e, m)
+{
+	if (confirm(m)) {
+		if (e.href) e.href += '&set=1';
+		return true;
+	}
+	return false;
+}
+function popup(e)
+{
+	w = screen.width > 800 ? 800 : screen.width - 100;
+	h = screen.height > 600 ? 600 : screen.height - 100;
+	nw=window.open(e.href, e.target, 'width=' + w + ',height=' + h + ',menubar=no,location=no,status=no,toolbar=no,titlebar=no');
+	if (nw) {
+		nw.focus();
+	}
+	return false;
+}
