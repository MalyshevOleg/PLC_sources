diff -Nru a/mkspecs/common/g++.conf b/mkspecs/common/g++.conf
--- a/mkspecs/common/g++.conf	2009-06-20 08:02:14.000000000 +0300
+++ b/mkspecs/common/g++.conff	2011-02-21 18:28:10.000000000 +0200
@@ -7,7 +7,7 @@
 QMAKE_CFLAGS_DEPS	+= -M
 QMAKE_CFLAGS_WARN_ON	+= -Wall -W
 QMAKE_CFLAGS_WARN_OFF	+= -w
-QMAKE_CFLAGS_RELEASE	+= -O2
+QMAKE_CFLAGS_RELEASE	+= -O0
 QMAKE_CFLAGS_DEBUG	+= -g
 QMAKE_CFLAGS_SHLIB	+= -fPIC
 QMAKE_CFLAGS_STATIC_LIB	+= -fPIC
@@ -35,7 +35,7 @@
 QMAKE_LINK_C		= gcc
 QMAKE_LINK_C_SHLIB	= gcc
 QMAKE_LFLAGS		+=
-QMAKE_LFLAGS_RELEASE	+= -Wl,-O1
+QMAKE_LFLAGS_RELEASE	+= -Wl,-O0
 QMAKE_LFLAGS_DEBUG	+=
 QMAKE_LFLAGS_APP	+=
 QMAKE_LFLAGS_SHLIB	+= -shared
diff -Nru a/mkspecs/qws/linux-at91sam926x/qmake.conf b/mkspecs/qws/linux-at91sam926x/qmake.conf
--- a/mkspecs/qws/linux-at91sam926x/qmake.conf	1970-01-01 03:00:00.000000000 +0300
+++ b/mkspecs/qws/linux-at91sam926x/qmake.conf	2011-02-09 16:39:59.000000000 +0200
@@ -0,0 +1,21 @@
+#
+# qmake configuration for building with arm-unknown-linux-gnueabi-g++
+#
+
+include(../../common/g++.conf)
+include(../../common/linux.conf)
+include(../../common/qws.conf)
+
+# modifications to g++.conf
+QMAKE_CC                = arm-unknown-linux-gnueabi-gcc
+QMAKE_CXX               = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK              = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK_SHLIB        = arm-unknown-linux-gnueabi-g++
+
+# modifications to linux.conf
+QMAKE_AR                = arm-unknown-linux-gnueabi-ar cqs
+QMAKE_OBJCOPY           = arm-unknown-linux-gnueabi-objcopy
+QMAKE_STRIP             = arm-unknown-linux-gnueabi-strip
+
+load(qt_config)
+
diff -Nru a/mkspecs/qws/linux-at91sam926x/qplatformdefs.h b/mkspecs/qws/linux-at91sam926x/qplatformdefs.h
--- a/mkspecs/qws/linux-at91sam926x/qplatformdefs.h	1970-01-01 03:00:00.000000000 +0300
+++ b/mkspecs/qws/linux-at91sam926x/qplatformdefs.h	2009-06-20 08:02:14.000000000 +0300
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the qmake spec of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at http://www.qtsoftware.com/contact.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "../../linux-g++/qplatformdefs.h"
diff -Nru a/src/plugins/kbddrivers/kbddrivers.pro b/src/plugins/kbddrivers/kbddrivers.pro
--- a/src/plugins/kbddrivers/kbddrivers.pro	2011-04-11 18:00:40.000000000 +0300
+++ b/src/plugins/kbddrivers/kbddrivers.pro	2011-04-11 16:42:11.000000000 +0300
@@ -4,3 +4,4 @@
 contains(kbd-plugins, vr41xx): SUBDIRS += vr41xx
 contains(kbd-plugins, yopy): SUBDIRS += yopy
 contains(kbd-plugins, linuxis): SUBDIRS += linuxis
+contains(kbd-plugins, AT91SAM926xKbd): SUBDIRS += AT91SAM926xKbd
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp	2010-03-26 14:51:35.000000000 +0200
@@ -0,0 +1,471 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <linux/input.h>
+
+struct SNameToInputBtn
+{
+    const char* m_pName;
+    unsigned int m_InputBtn;
+};
+
+static SNameToInputBtn sBtnNames[]=
+{
+    { "KEY_RESERVED", KEY_RESERVED },
+    { "KEY_ESC", KEY_ESC },
+    { "KEY_1", KEY_1 },
+    { "KEY_2", KEY_2 },
+    { "KEY_3", KEY_3 },
+    { "KEY_4", KEY_4 },
+    { "KEY_5", KEY_5 },
+    { "KEY_6", KEY_6 },
+    { "KEY_7", KEY_7 },
+    { "KEY_8", KEY_8 },
+    { "KEY_9", KEY_9 },
+    { "KEY_0", KEY_0 },
+    { "KEY_MINUS", KEY_MINUS },
+    { "KEY_EQUAL", KEY_EQUAL },
+    { "KEY_BACKSPACE", KEY_BACKSPACE },
+    { "KEY_TAB", KEY_TAB },
+    { "KEY_Q", KEY_Q },
+    { "KEY_W", KEY_W },
+    { "KEY_E", KEY_E },
+    { "KEY_R", KEY_R },
+    { "KEY_T", KEY_T },
+    { "KEY_Y", KEY_Y },
+    { "KEY_U", KEY_U },
+    { "KEY_I", KEY_I },
+    { "KEY_O", KEY_O },
+    { "KEY_P", KEY_P },
+    { "KEY_LEFTBRACE", KEY_LEFTBRACE },
+    { "KEY_RIGHTBRACE", KEY_RIGHTBRACE },
+    { "KEY_ENTER", KEY_ENTER },
+    { "KEY_LEFTCTRL", KEY_LEFTCTRL },
+    { "KEY_A", KEY_A },
+    { "KEY_S", KEY_S },
+    { "KEY_D", KEY_D },
+    { "KEY_F", KEY_F },
+    { "KEY_G", KEY_G },
+    { "KEY_H", KEY_H },
+    { "KEY_J", KEY_J },
+    { "KEY_K", KEY_K },
+    { "KEY_L", KEY_L },
+    { "KEY_SEMICOLON", KEY_SEMICOLON },
+    { "KEY_APOSTROPHE", KEY_APOSTROPHE },
+    { "KEY_GRAVE", KEY_GRAVE },
+    { "KEY_LEFTSHIFT", KEY_LEFTSHIFT },
+    { "KEY_BACKSLASH", KEY_BACKSLASH },
+    { "KEY_Z", KEY_Z },
+    { "KEY_X", KEY_X },
+    { "KEY_C", KEY_C },
+    { "KEY_V", KEY_V },
+    { "KEY_B", KEY_B },
+    { "KEY_N", KEY_N },
+    { "KEY_M", KEY_M },
+    { "KEY_COMMA", KEY_COMMA },
+    { "KEY_DOT", KEY_DOT },
+    { "KEY_SLASH", KEY_SLASH },
+    { "KEY_RIGHTSHIFT", KEY_RIGHTSHIFT },
+    { "KEY_KPASTERISK", KEY_KPASTERISK },
+    { "KEY_LEFTALT", KEY_LEFTALT },
+    { "KEY_SPACE", KEY_SPACE },
+    { "KEY_CAPSLOCK", KEY_CAPSLOCK },
+    { "KEY_F1", KEY_F1 },
+    { "KEY_F2", KEY_F2 },
+    { "KEY_F3", KEY_F3 },
+    { "KEY_F4", KEY_F4 },
+    { "KEY_F5", KEY_F5 },
+    { "KEY_F6", KEY_F6 },
+    { "KEY_F7", KEY_F7 },
+    { "KEY_F8", KEY_F8 },
+    { "KEY_F9", KEY_F9 },
+    { "KEY_F10", KEY_F10 },
+    { "KEY_NUMLOCK", KEY_NUMLOCK },
+    { "KEY_SCROLLLOCK", KEY_SCROLLLOCK },
+    { "KEY_KP7", KEY_KP7 },
+    { "KEY_KP8", KEY_KP8 },
+    { "KEY_KP9", KEY_KP9 },
+    { "KEY_KPMINUS", KEY_KPMINUS },
+    { "KEY_KP4", KEY_KP4 },
+    { "KEY_KP5", KEY_KP5 },
+    { "KEY_KP6", KEY_KP6 },
+    { "KEY_KPPLUS", KEY_KPPLUS },
+    { "KEY_KP1", KEY_KP1 },
+    { "KEY_KP2", KEY_KP2 },
+    { "KEY_KP3", KEY_KP3 },
+    { "KEY_KP0", KEY_KP0 },
+    { "KEY_KPDOT", KEY_KPDOT },
+    { "KEY_102ND", KEY_102ND },
+    { "KEY_F11", KEY_F11 },
+    { "KEY_F12", KEY_F12 },
+    { "KEY_RO", KEY_RO },
+    { "KEY_KPENTER", KEY_KPENTER },
+    { "KEY_RIGHTCTRL", KEY_RIGHTCTRL },
+    { "KEY_KPSLASH", KEY_KPSLASH },
+    { "KEY_SYSRQ", KEY_SYSRQ },
+    { "KEY_RIGHTALT", KEY_RIGHTALT },
+    { "KEY_LINEFEED", KEY_LINEFEED },
+    { "KEY_HOME", KEY_HOME },
+    { "KEY_UP", KEY_UP },
+    { "KEY_PAGEUP", KEY_PAGEUP },
+    { "KEY_LEFT", KEY_LEFT },
+    { "KEY_RIGHT", KEY_RIGHT },
+    { "KEY_END", KEY_END },
+    { "KEY_DOWN", KEY_DOWN },
+    { "KEY_PAGEDOWN", KEY_PAGEDOWN },
+    { "KEY_INSERT", KEY_INSERT },
+    { "KEY_DELETE", KEY_DELETE },
+    { "KEY_MACRO", KEY_MACRO },
+    { "KEY_MUTE", KEY_MUTE },
+    { "KEY_VOLUMEDOWN", KEY_VOLUMEDOWN },
+    { "KEY_VOLUMEUP", KEY_VOLUMEUP },
+    { "KEY_POWER", KEY_POWER },
+    { "KEY_KPEQUAL", KEY_KPEQUAL },
+    { "KEY_KPPLUSMINUS", KEY_KPPLUSMINUS },
+    { "KEY_PAUSE", KEY_PAUSE },
+    { "KEY_SCALE", KEY_SCALE },
+    { "KEY_KPCOMMA", KEY_KPCOMMA },
+    { "KEY_HANGEUL", KEY_HANGEUL },
+    { "KEY_HANGUEL", KEY_HANGUEL },
+    { "KEY_HANJA", KEY_HANJA },
+    { "KEY_YEN", KEY_YEN },
+    { "KEY_LEFTMETA", KEY_LEFTMETA },
+    { "KEY_RIGHTMETA", KEY_RIGHTMETA },
+    { "KEY_COMPOSE", KEY_COMPOSE },
+    { "KEY_STOP", KEY_STOP },
+    { "KEY_AGAIN", KEY_AGAIN },
+    { "KEY_PROPS", KEY_PROPS },
+    { "KEY_UNDO", KEY_UNDO },
+    { "KEY_FRONT", KEY_FRONT },
+    { "KEY_COPY", KEY_COPY },
+    { "KEY_OPEN", KEY_OPEN },
+    { "KEY_PASTE", KEY_PASTE },
+    { "KEY_FIND", KEY_FIND },
+    { "KEY_CUT", KEY_CUT },
+    { "KEY_HELP", KEY_HELP },
+    { "KEY_MENU", KEY_MENU },
+    { "KEY_CALC", KEY_CALC },
+    { "KEY_SETUP", KEY_SETUP },
+    { "KEY_SLEEP", KEY_SLEEP },
+    { "KEY_WAKEUP", KEY_WAKEUP },
+    { "KEY_FILE", KEY_FILE },
+    { "KEY_SENDFILE", KEY_SENDFILE },
+    { "KEY_DELETEFILE", KEY_DELETEFILE },
+    { "KEY_XFER", KEY_XFER },
+    { "KEY_PROG1", KEY_PROG1 },
+    { "KEY_PROG2", KEY_PROG2 },
+    { "KEY_WWW", KEY_WWW },
+    { "KEY_MSDOS", KEY_MSDOS },
+    { "KEY_COFFEE", KEY_COFFEE },
+    { "KEY_SCREENLOCK", KEY_SCREENLOCK },
+    { "KEY_DIRECTION", KEY_DIRECTION },
+    { "KEY_CYCLEWINDOWS", KEY_CYCLEWINDOWS },
+    { "KEY_MAIL", KEY_MAIL },
+    { "KEY_BOOKMARKS", KEY_BOOKMARKS },
+    { "KEY_COMPUTER", KEY_COMPUTER },
+    { "KEY_BACK", KEY_BACK },
+    { "KEY_FORWARD", KEY_FORWARD },
+    { "KEY_CLOSECD", KEY_CLOSECD },
+    { "KEY_EJECTCD", KEY_EJECTCD },
+    { "KEY_EJECTCLOSECD", KEY_EJECTCLOSECD },
+    { "KEY_NEXTSONG", KEY_NEXTSONG },
+    { "KEY_PLAYPAUSE", KEY_PLAYPAUSE },
+    { "KEY_PREVIOUSSONG", KEY_PREVIOUSSONG },
+    { "KEY_STOPCD", KEY_STOPCD },
+    { "KEY_RECORD", KEY_RECORD },
+    { "KEY_REWIND", KEY_REWIND },
+    { "KEY_PHONE", KEY_PHONE },
+    { "KEY_ISO", KEY_ISO },
+    { "KEY_CONFIG", KEY_CONFIG },
+    { "KEY_HOMEPAGE", KEY_HOMEPAGE },
+    { "KEY_REFRESH", KEY_REFRESH },
+    { "KEY_EXIT", KEY_EXIT },
+    { "KEY_MOVE", KEY_MOVE },
+    { "KEY_EDIT", KEY_EDIT },
+    { "KEY_SCROLLUP", KEY_SCROLLUP },
+    { "KEY_SCROLLDOWN", KEY_SCROLLDOWN },
+    { "KEY_KPLEFTPAREN", KEY_KPLEFTPAREN },
+    { "KEY_KPRIGHTPAREN", KEY_KPRIGHTPAREN },
+    { "KEY_NEW", KEY_NEW },
+    { "KEY_REDO", KEY_REDO },
+    { "KEY_F13", KEY_F13 },
+    { "KEY_F14", KEY_F14 },
+    { "KEY_F15", KEY_F15 },
+    { "KEY_F16", KEY_F16 },
+    { "KEY_F17", KEY_F17 },
+    { "KEY_F18", KEY_F18 },
+    { "KEY_F19", KEY_F19 },
+    { "KEY_F20", KEY_F20 },
+    { "KEY_F21", KEY_F21 },
+    { "KEY_F22", KEY_F22 },
+    { "KEY_F23", KEY_F23 },
+    { "KEY_F24", KEY_F24 },
+    { "KEY_PLAYCD", KEY_PLAYCD },
+    { "KEY_PAUSECD", KEY_PAUSECD },
+    { "KEY_PROG3", KEY_PROG3 },
+    { "KEY_PROG4", KEY_PROG4 },
+    { "KEY_DASHBOARD", KEY_DASHBOARD },
+    { "KEY_SUSPEND", KEY_SUSPEND },
+    { "KEY_CLOSE", KEY_CLOSE },
+    { "KEY_PLAY", KEY_PLAY },
+    { "KEY_FASTFORWARD", KEY_FASTFORWARD },
+    { "KEY_BASSBOOST", KEY_BASSBOOST },
+    { "KEY_PRINT", KEY_PRINT },
+    { "KEY_HP", KEY_HP },
+    { "KEY_CAMERA", KEY_CAMERA },
+    { "KEY_SOUND", KEY_SOUND },
+    { "KEY_QUESTION", KEY_QUESTION },
+    { "KEY_EMAIL", KEY_EMAIL },
+    { "KEY_CHAT", KEY_CHAT },
+    { "KEY_SEARCH", KEY_SEARCH },
+    { "KEY_CONNECT", KEY_CONNECT },
+    { "KEY_FINANCE", KEY_FINANCE },
+    { "KEY_SPORT", KEY_SPORT },
+    { "KEY_SHOP", KEY_SHOP },
+    { "KEY_ALTERASE", KEY_ALTERASE },
+    { "KEY_CANCEL", KEY_CANCEL },
+    { "KEY_BRIGHTNESSDOWN", KEY_BRIGHTNESSDOWN },
+    { "KEY_BRIGHTNESSUP", KEY_BRIGHTNESSUP },
+    { "KEY_MEDIA", KEY_MEDIA },
+    { "KEY_SWITCHVIDEOMODE", KEY_SWITCHVIDEOMODE },
+    { "KEY_KBDILLUMTOGGLE", KEY_KBDILLUMTOGGLE },
+    { "KEY_KBDILLUMDOWN", KEY_KBDILLUMDOWN },
+    { "KEY_KBDILLUMUP", KEY_KBDILLUMUP },
+    { "KEY_SEND", KEY_SEND },
+    { "KEY_REPLY", KEY_REPLY },
+    { "KEY_FORWARDMAIL", KEY_FORWARDMAIL },
+    { "KEY_SAVE", KEY_SAVE },
+    { "KEY_DOCUMENTS", KEY_DOCUMENTS },
+    { "KEY_BATTERY", KEY_BATTERY },
+    { "KEY_BLUETOOTH", KEY_BLUETOOTH },
+    { "KEY_WLAN", KEY_WLAN },
+    { "KEY_UWB", KEY_UWB },
+    { "KEY_UNKNOWN", KEY_UNKNOWN },
+    { "KEY_VIDEO_NEXT", KEY_VIDEO_NEXT },
+    { "KEY_VIDEO_PREV", KEY_VIDEO_PREV },
+    { "KEY_BRIGHTNESS_CYCLE", KEY_BRIGHTNESS_CYCLE },
+    { "KEY_BRIGHTNESS_ZERO", KEY_BRIGHTNESS_ZERO },
+    { "KEY_DISPLAY_OFF", KEY_DISPLAY_OFF },
+    { "KEY_WIMAX", KEY_WIMAX },
+    { "BTN_MISC", BTN_MISC },
+    { "BTN_0", BTN_0 },
+    { "BTN_1", BTN_1 },
+    { "BTN_2", BTN_2 },
+    { "BTN_3", BTN_3 },
+    { "BTN_4", BTN_4 },
+    { "BTN_5", BTN_5 },
+    { "BTN_6", BTN_6 },
+    { "BTN_7", BTN_7 },
+    { "BTN_8", BTN_8 },
+    { "BTN_9", BTN_9 },
+    { "BTN_MOUSE", BTN_MOUSE },
+    { "BTN_LEFT", BTN_LEFT },
+    { "BTN_RIGHT", BTN_RIGHT },
+    { "BTN_MIDDLE", BTN_MIDDLE },
+    { "BTN_SIDE", BTN_SIDE },
+    { "BTN_EXTRA", BTN_EXTRA },
+    { "BTN_FORWARD", BTN_FORWARD },
+    { "BTN_BACK", BTN_BACK },
+    { "BTN_TASK", BTN_TASK },
+    { "BTN_JOYSTICK", BTN_JOYSTICK },
+    { "BTN_TRIGGER", BTN_TRIGGER },
+    { "BTN_THUMB", BTN_THUMB },
+    { "BTN_THUMB2", BTN_THUMB2 },
+    { "BTN_TOP", BTN_TOP },
+    { "BTN_TOP2", BTN_TOP2 },
+    { "BTN_PINKIE", BTN_PINKIE },
+    { "BTN_BASE", BTN_BASE },
+    { "BTN_BASE2", BTN_BASE2 },
+    { "BTN_BASE3", BTN_BASE3 },
+    { "BTN_BASE4", BTN_BASE4 },
+    { "BTN_BASE5", BTN_BASE5 },
+    { "BTN_BASE6", BTN_BASE6 },
+    { "BTN_DEAD", BTN_DEAD },
+    { "BTN_GAMEPAD", BTN_GAMEPAD },
+    { "BTN_A", BTN_A },
+    { "BTN_B", BTN_B },
+    { "BTN_C", BTN_C },
+    { "BTN_X", BTN_X },
+    { "BTN_Y", BTN_Y },
+    { "BTN_Z", BTN_Z },
+    { "BTN_TL", BTN_TL },
+    { "BTN_TR", BTN_TR },
+    { "BTN_TL2", BTN_TL2 },
+    { "BTN_TR2", BTN_TR2 },
+    { "BTN_SELECT", BTN_SELECT },
+    { "BTN_START", BTN_START },
+    { "BTN_MODE", BTN_MODE },
+    { "BTN_THUMBL", BTN_THUMBL },
+    { "BTN_THUMBR", BTN_THUMBR },
+    { "BTN_DIGI", BTN_DIGI },
+    { "BTN_TOOL_PEN", BTN_TOOL_PEN },
+    { "BTN_TOOL_RUBBER", BTN_TOOL_RUBBER },
+    { "BTN_TOOL_BRUSH", BTN_TOOL_BRUSH },
+    { "BTN_TOOL_PENCIL", BTN_TOOL_PENCIL },
+    { "BTN_TOOL_AIRBRUSH", BTN_TOOL_AIRBRUSH },
+    { "BTN_TOOL_FINGER", BTN_TOOL_FINGER },
+    { "BTN_TOOL_MOUSE", BTN_TOOL_MOUSE },
+    { "BTN_TOOL_LENS", BTN_TOOL_LENS },
+    { "BTN_TOUCH", BTN_TOUCH },
+    { "BTN_STYLUS", BTN_STYLUS },
+    { "BTN_STYLUS2", BTN_STYLUS2 },
+    { "BTN_TOOL_DOUBLETAP", BTN_TOOL_DOUBLETAP },
+    { "BTN_TOOL_TRIPLETAP", BTN_TOOL_TRIPLETAP },
+    { "BTN_TOOL_QUADTAP", BTN_TOOL_QUADTAP },
+    { "BTN_WHEEL", BTN_WHEEL },
+    { "BTN_GEAR_DOWN", BTN_GEAR_DOWN },
+    { "BTN_GEAR_UP", BTN_GEAR_UP },
+    { "KEY_OK", KEY_OK },
+    { "KEY_SELECT", KEY_SELECT },
+    { "KEY_GOTO", KEY_GOTO },
+    { "KEY_CLEAR", KEY_CLEAR },
+    { "KEY_POWER2", KEY_POWER2 },
+    { "KEY_OPTION", KEY_OPTION },
+    { "KEY_INFO", KEY_INFO },
+    { "KEY_TIME", KEY_TIME },
+    { "KEY_VENDOR", KEY_VENDOR },
+    { "KEY_ARCHIVE", KEY_ARCHIVE },
+    { "KEY_PROGRAM", KEY_PROGRAM },
+    { "KEY_CHANNEL", KEY_CHANNEL },
+    { "KEY_FAVORITES", KEY_FAVORITES },
+    { "KEY_EPG", KEY_EPG },
+    { "KEY_PVR", KEY_PVR },
+    { "KEY_MHP", KEY_MHP },
+    { "KEY_LANGUAGE", KEY_LANGUAGE },
+    { "KEY_TITLE", KEY_TITLE },
+    { "KEY_SUBTITLE", KEY_SUBTITLE },
+    { "KEY_ANGLE", KEY_ANGLE },
+    { "KEY_ZOOM", KEY_ZOOM },
+    { "KEY_MODE", KEY_MODE },
+    { "KEY_KEYBOARD", KEY_KEYBOARD },
+    { "KEY_SCREEN", KEY_SCREEN },
+    { "KEY_PC", KEY_PC },
+    { "KEY_TV", KEY_TV },
+    { "KEY_TV2", KEY_TV2 },
+    { "KEY_VCR", KEY_VCR },
+    { "KEY_VCR2", KEY_VCR2 },
+    { "KEY_SAT", KEY_SAT },
+    { "KEY_SAT2", KEY_SAT2 },
+    { "KEY_CD", KEY_CD },
+    { "KEY_TAPE", KEY_TAPE },
+    { "KEY_RADIO", KEY_RADIO },
+    { "KEY_TUNER", KEY_TUNER },
+    { "KEY_PLAYER", KEY_PLAYER },
+    { "KEY_TEXT", KEY_TEXT },
+    { "KEY_DVD", KEY_DVD },
+    { "KEY_AUX", KEY_AUX },
+    { "KEY_MP3", KEY_MP3 },
+    { "KEY_AUDIO", KEY_AUDIO },
+    { "KEY_VIDEO", KEY_VIDEO },
+    { "KEY_DIRECTORY", KEY_DIRECTORY },
+    { "KEY_LIST", KEY_LIST },
+    { "KEY_MEMO", KEY_MEMO },
+    { "KEY_CALENDAR", KEY_CALENDAR },
+    { "KEY_RED", KEY_RED },
+    { "KEY_GREEN", KEY_GREEN },
+    { "KEY_YELLOW", KEY_YELLOW },
+    { "KEY_BLUE", KEY_BLUE },
+    { "KEY_CHANNELUP", KEY_CHANNELUP },
+    { "KEY_CHANNELDOWN", KEY_CHANNELDOWN },
+    { "KEY_FIRST", KEY_FIRST },
+    { "KEY_LAST", KEY_LAST },
+    { "KEY_AB", KEY_AB },
+    { "KEY_NEXT", KEY_NEXT },
+    { "KEY_RESTART", KEY_RESTART },
+    { "KEY_SLOW", KEY_SLOW },
+    { "KEY_SHUFFLE", KEY_SHUFFLE },
+    { "KEY_BREAK", KEY_BREAK },
+    { "KEY_PREVIOUS", KEY_PREVIOUS },
+    { "KEY_DIGITS", KEY_DIGITS },
+    { "KEY_TEEN", KEY_TEEN },
+    { "KEY_TWEN", KEY_TWEN },
+    { "KEY_VIDEOPHONE", KEY_VIDEOPHONE },
+    { "KEY_GAMES", KEY_GAMES },
+    { "KEY_ZOOMIN", KEY_ZOOMIN },
+    { "KEY_ZOOMOUT", KEY_ZOOMOUT },
+    { "KEY_ZOOMRESET", KEY_ZOOMRESET },
+    { "KEY_WORDPROCESSOR", KEY_WORDPROCESSOR },
+    { "KEY_EDITOR", KEY_EDITOR },
+    { "KEY_SPREADSHEET", KEY_SPREADSHEET },
+    { "KEY_GRAPHICSEDITOR", KEY_GRAPHICSEDITOR },
+    { "KEY_PRESENTATION", KEY_PRESENTATION },
+    { "KEY_DATABASE", KEY_DATABASE },
+    { "KEY_NEWS", KEY_NEWS },
+    { "KEY_VOICEMAIL", KEY_VOICEMAIL },
+    { "KEY_ADDRESSBOOK", KEY_ADDRESSBOOK },
+    { "KEY_MESSENGER", KEY_MESSENGER },
+    { "KEY_DISPLAYTOGGLE", KEY_DISPLAYTOGGLE },
+    { "KEY_SPELLCHECK", KEY_SPELLCHECK },
+    { "KEY_LOGOFF", KEY_LOGOFF },
+    { "KEY_DOLLAR", KEY_DOLLAR },
+    { "KEY_EURO", KEY_EURO },
+    { "KEY_FRAMEBACK", KEY_FRAMEBACK },
+    { "KEY_FRAMEFORWARD", KEY_FRAMEFORWARD },
+    { "KEY_CONTEXT_MENU", KEY_CONTEXT_MENU },
+    { "KEY_MEDIA_REPEAT", KEY_MEDIA_REPEAT },
+    { "KEY_DEL_EOL", KEY_DEL_EOL },
+    { "KEY_DEL_EOS", KEY_DEL_EOS },
+    { "KEY_INS_LINE", KEY_INS_LINE },
+    { "KEY_DEL_LINE", KEY_DEL_LINE },
+    { "KEY_FN", KEY_FN },
+    { "KEY_FN_ESC", KEY_FN_ESC },
+    { "KEY_FN_F1", KEY_FN_F1 },
+    { "KEY_FN_F2", KEY_FN_F2 },
+    { "KEY_FN_F3", KEY_FN_F3 },
+    { "KEY_FN_F4", KEY_FN_F4 },
+    { "KEY_FN_F5", KEY_FN_F5 },
+    { "KEY_FN_F6", KEY_FN_F6 },
+    { "KEY_FN_F7", KEY_FN_F7 },
+    { "KEY_FN_F8", KEY_FN_F8 },
+    { "KEY_FN_F9", KEY_FN_F9 },
+    { "KEY_FN_F10", KEY_FN_F10 },
+    { "KEY_FN_F11", KEY_FN_F11 },
+    { "KEY_FN_F12", KEY_FN_F12 },
+    { "KEY_FN_1", KEY_FN_1 },
+    { "KEY_FN_2", KEY_FN_2 },
+    { "KEY_FN_D", KEY_FN_D },
+    { "KEY_FN_E", KEY_FN_E },
+    { "KEY_FN_F", KEY_FN_F },
+    { "KEY_FN_S", KEY_FN_S },
+    { "KEY_FN_B", KEY_FN_B },
+    { "KEY_BRL_DOT1", KEY_BRL_DOT1 },
+    { "KEY_BRL_DOT2", KEY_BRL_DOT2 },
+    { "KEY_BRL_DOT3", KEY_BRL_DOT3 },
+    { "KEY_BRL_DOT4", KEY_BRL_DOT4 },
+    { "KEY_BRL_DOT5", KEY_BRL_DOT5 },
+    { "KEY_BRL_DOT6", KEY_BRL_DOT6 },
+    { "KEY_BRL_DOT7", KEY_BRL_DOT7 },
+    { "KEY_BRL_DOT8", KEY_BRL_DOT8 },
+    { "KEY_BRL_DOT9", KEY_BRL_DOT9 },
+    { "KEY_BRL_DOT10", KEY_BRL_DOT10 },
+    { "KEY_NUMERIC_0", KEY_NUMERIC_0 },
+    { "KEY_NUMERIC_1", KEY_NUMERIC_1 },
+    { "KEY_NUMERIC_2", KEY_NUMERIC_2 },
+    { "KEY_NUMERIC_3", KEY_NUMERIC_3 },
+    { "KEY_NUMERIC_4", KEY_NUMERIC_4 },
+    { "KEY_NUMERIC_5", KEY_NUMERIC_5 },
+    { "KEY_NUMERIC_6", KEY_NUMERIC_6 },
+    { "KEY_NUMERIC_7", KEY_NUMERIC_7 },
+    { "KEY_NUMERIC_8", KEY_NUMERIC_8 },
+    { "KEY_NUMERIC_9", KEY_NUMERIC_9 },
+    { "KEY_NUMERIC_STAR", KEY_NUMERIC_STAR },
+    { "KEY_NUMERIC_POUND", KEY_NUMERIC_POUND }
+};
+
+unsigned int AT91SAM926xKbdHandler::get_input_btn(const char* pBtnName)
+{
+    QString lBtnName=QString(pBtnName).trimmed().toUpper();
+    for(unsigned int iBtnName=0;iBtnName<(sizeof(sBtnNames)/sizeof(struct SNameToInputBtn));++iBtnName)
+    {
+	if(lBtnName == sBtnNames[iBtnName].m_pName) return sBtnNames[iBtnName].m_InputBtn;
+    };
+    return 0xFFFFFFFF;
+}
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp	2010-03-29 15:01:06.000000000 +0300
@@ -0,0 +1,234 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <QFile>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+bool AT91SAM926xKbdHandler::loadConfig(QString& configPath)
+{
+    QFile xmlFile(configPath);
+
+    if (!xmlFile.exists() || (xmlFile.error() != QFile::NoError))
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "ERROR {AT91SAM926xKbdHandler::loadConfig} : Unable to open config file" << configPath.toAscii().data() << "!" << endl;
+	#endif
+	return false;
+    };
+
+    m_keys.clear();
+    m_Modifiers.clear();
+
+    xmlFile.open(QIODevice::ReadOnly);
+    QXmlStreamReader reader(&xmlFile);
+
+    while(!reader.atEnd() && !reader.hasError())
+    {
+	QXmlStreamReader::TokenType token = reader.readNext();
+
+	/* If token is just StartDocument, we'll go to next.*/
+	if(token == QXmlStreamReader::StartDocument) continue;
+
+	if(token == QXmlStreamReader::StartElement)
+	{
+		QString lname=reader.name().toString().trimmed().toLower();
+		if(lname == "keyboard") continue;
+		if(lname == "key") parseKey(reader);
+		if(lname == "modifier") parseModifier(reader);
+		if(lname == "buzzer") parseBuzzer(reader);
+	};
+    };
+
+    return true;
+}
+
+
+void AT91SAM926xKbdHandler::parseKey(QXmlStreamReader& reader)
+{
+    AT91SAM926xKbdHandler::CKey lKey;
+
+    lKey.m_btn=0xFFFFFFFF;
+    lKey.m_qt_key=Qt::Key_unknown;
+    lKey.m_unicode=0xFFFF;
+    lKey.m_buzzer=false;
+    lKey.m_led=QString();
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "key") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "scancode") parseScancode(reader, lKey.m_btn);
+		if(lname == "qtkey") parseQtKey(reader, lKey.m_qt_key);
+		if(lname == "unicode") parseUnicode(reader, lKey.m_unicode);
+		if(lname == "buzzer") parseBuzzer(reader, lKey.m_buzzer);
+		if(lname == "led") parseLed(reader, lKey.m_led);
+	};
+	reader.readNext();
+	lname=reader.name().toString().trimmed().toLower();
+    };
+
+    m_keys << lKey;
+}
+
+
+void AT91SAM926xKbdHandler::parseModifier(QXmlStreamReader& reader)
+{
+    AT91SAM926xKbdHandler::CModifier lModifier;
+
+    lModifier.m_btn=0xFFFFFFFF;
+    lModifier.m_qt_modifier=Qt::NoModifier;
+    lModifier.m_buzzer=false;
+    lModifier.m_led=QString();
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "modifier") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "scancode") parseScancode(reader, lModifier.m_btn);
+		if(lname == "modkey") parseQtModKey(reader, lModifier.m_qt_modifier);
+		if(lname == "buzzer") parseBuzzer(reader, lModifier.m_buzzer);
+		if(lname == "led") parseLed(reader, lModifier.m_led);
+	};
+	reader.readNext();
+	QString lname=reader.name().toString().trimmed().toLower();
+    };
+
+    m_Modifiers << lModifier;
+}
+
+
+void AT91SAM926xKbdHandler::parseBuzzer(QXmlStreamReader& reader)
+{
+    QString lBuzzer;
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "buzzer") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "path")
+		{
+			if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+			reader.readNext();
+			
+			if(reader.tokenType() != QXmlStreamReader::Characters) return;
+			lBuzzer=reader.text().toString().trimmed().toAscii().data();
+			
+			#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+			cout << "INFO {AT91SAM926xKbdHandler::parseBuzzer(1)}:" << "path:" << lBuzzer.toAscii().data() << endl;
+			#endif
+		};
+	};
+	reader.readNext();
+	lname=reader.name().toString().trimmed().toLower();
+    };
+    m_buzzer=lBuzzer;
+}
+
+
+void AT91SAM926xKbdHandler::parseScancode(QXmlStreamReader& reader, unsigned int& _Key)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _Key=get_input_btn(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseScancode}:" << "\tScancode:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _Key << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseQtKey(QXmlStreamReader& reader, unsigned int& _QtKey)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _QtKey=get_qt_key(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseQtKey}:" << "\tQtKey:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _QtKey << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseQtModKey(QXmlStreamReader& reader, Qt::KeyboardModifiers& _QtKey)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _QtKey=get_qt_modifier(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseQtKey}:" << "\tQtKey:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _QtKey << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseUnicode(QXmlStreamReader& reader, unsigned short& _Unicode)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    sscanf(reader.text().toString().trimmed().toAscii().data(), "0x%8X", &_Unicode);
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseUnicode}:" << "\tUnicode:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: 0x" << hex << (int)_Unicode << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseBuzzer(QXmlStreamReader& reader, bool& _Buzzer)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    if(reader.text().toString().trimmed().toLower() == "on") _Buzzer=true;
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseBuzzer(2)}:" << "\tBuzzer:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << ((_Buzzer)? "true": "false") << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseLed(QXmlStreamReader& reader, QString& _Led)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _Led=reader.text().toString().trimmed();
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseLed}:" << "Led:" << reader.text().toString().trimmed().toAscii().data() << endl;
+    #endif
+}
+
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp	2010-03-27 20:51:07.000000000 +0200
@@ -0,0 +1,263 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+
+int AT91SAM926xKbdHandler::set_buzzer()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_buzzer == QString()) return -1;
+
+    if(m_fdBuzzer < 0)
+    {
+	int fdBuzzer;
+	if((fdBuzzer=::open(m_buzzer.trimmed().toAscii().data(), O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::set_buzzer (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+	m_fdBuzzer=fdBuzzer;
+    };
+
+    if(write(m_fdBuzzer, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::set_buzzer (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return -1;
+    };
+
+    return 0;
+}
+
+int AT91SAM926xKbdHandler::clear_buzzer()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_buzzer == QString()) return -1;
+
+    if(m_fdBuzzer < 0)
+    {
+	int fdBuzzer;
+	if((fdBuzzer=::open(m_buzzer.trimmed().toAscii().data(), O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::clear_buzzer (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+	m_fdBuzzer=fdBuzzer;
+    };
+
+    if(write(m_fdBuzzer, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::clear_buzzer (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return -1;
+    };
+
+    return 0;
+}
+
+AT91SAM926xKbdHandler::CKey::CKey() : m_fd(-1)
+{
+}
+
+AT91SAM926xKbdHandler::CKey::~CKey()
+{
+    if(m_fd<0) ::close(m_fd);
+}
+
+
+bool AT91SAM926xKbdHandler::CKey::set_led()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CKey::set_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CKey::set_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+bool AT91SAM926xKbdHandler::CKey::clear_led()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CKey::clear_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CKey::clear_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+AT91SAM926xKbdHandler::CModifier::CModifier() : m_fd(-1)
+{
+}
+
+AT91SAM926xKbdHandler::CModifier::~CModifier()
+{
+    if(m_fd<0) ::close(m_fd);
+}
+
+
+bool AT91SAM926xKbdHandler::CModifier::set_led()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CModifier::set_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CModifier::set_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+bool AT91SAM926xKbdHandler::CModifier::clear_led()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CModifier::clear_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CModifier::clear_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+AT91SAM926xKbdHandler::CModifier* AT91SAM926xKbdHandler::getModifier(unsigned int _btn)
+{
+    for (int i = 0; i < m_Modifiers.size(); ++i)
+    {
+	AT91SAM926xKbdHandler::CModifier& lModifier=const_cast<AT91SAM926xKbdHandler::CModifier&>(m_Modifiers.at(i));
+	if(lModifier.m_btn == _btn) return &lModifier;
+    }
+    return NULL;
+}
+
+
+AT91SAM926xKbdHandler::CKey* AT91SAM926xKbdHandler::getKey(unsigned int _btn)
+{
+    for (int i = 0; i < m_keys.size(); ++i)
+    {
+	AT91SAM926xKbdHandler::CKey& lKey=const_cast<AT91SAM926xKbdHandler::CKey&>(m_keys.at(i));
+	if(lKey.m_btn == _btn) return &lKey;
+    }
+   return NULL;
+}
+
+
+
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp	2010-03-26 19:33:06.000000000 +0200
@@ -0,0 +1,47 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+
+#include "AT91SAM926xKbdDriverPlugin.h"
+#include "AT91SAM926xKbdHandler.h"
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+AT91SAM926xKbdDriverPlugin::AT91SAM926xKbdDriverPlugin( QObject *parent )
+    : QKbdDriverPlugin( parent )
+{}
+
+AT91SAM926xKbdDriverPlugin::~AT91SAM926xKbdDriverPlugin()
+{}
+
+QWSKeyboardHandler* AT91SAM926xKbdDriverPlugin::create(const QString& driver, const QString&)
+{
+    cout << "[ AT91SAM926xKbdDriverPlugin:create ]" << endl;
+    return create( driver );
+}
+
+QWSKeyboardHandler* AT91SAM926xKbdDriverPlugin::create( const QString& driver)
+{
+    if( driver.toLower() == QLatin1String("at91sam926xkbdhandler") ) {
+        cout << "[ Loading AT91SAM926xKbdHandler ]" << endl;
+        return new AT91SAM926xKbdHandler();
+    }
+    return 0;
+}
+
+QStringList AT91SAM926xKbdDriverPlugin::keys() const
+{
+    return QStringList() << "at91sam926xkbdhandler";
+}
+
+Q_EXPORT_PLUGIN2(qwsAT91SAM926xKbdDriverPlugin, AT91SAM926xKbdDriverPlugin)
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h	2010-03-26 19:28:40.000000000 +0200
@@ -0,0 +1,26 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xKBDDRIVERPLUGIN_H
+#define AT91SAM926xKBDDRIVERPLUGIN_H
+
+#include <qkbddriverplugin_qws.h>
+
+class AT91SAM926xKbdDriverPlugin : public QKbdDriverPlugin {
+    Q_OBJECT
+public:
+    AT91SAM926xKbdDriverPlugin( QObject *parent  = 0 );
+    ~AT91SAM926xKbdDriverPlugin();
+
+    QWSKeyboardHandler* create(const QString& driver, const QString& device);
+    QWSKeyboardHandler* create(const QString& driver);
+    QStringList keys()const;
+};
+
+#endif // AT91SAM926xKBDDRIVERPLUGIN_H
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp	2010-10-19 16:19:10.000000000 +0300
@@ -0,0 +1,170 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <linux/input.h>
+
+#include <QFile>
+#include <QTextStream>
+#include <QScreen>
+#include <QSocketNotifier>
+
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+int AT91SAM926xKbdHandler::open_device()
+{
+    close_device();
+    
+    int kbdFD;
+    char* pKbdDev=NULL;
+
+    if((pKbdDev = getenv("AT91SAM926x_KBD_CONF_FILE")) != NULL) m_ConfigFile=QString(pKbdDev);else m_ConfigFile=QString("/etc/at91sam9263xKbd.xml");
+
+    if((pKbdDev = getenv("AT91SAM926x_KBD_DEV")) == NULL)
+    {
+	if((kbdFD=open("/dev/input/event0", O_RDWR))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open gpio device /dev/input/event0 !" << endl;
+		cout << "{AT91SAM926xKbdHandler::open_device(1)} Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+    }
+    else
+    {
+	if((kbdFD=open(pKbdDev, O_RDWR))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open gpio device " << pKbdDev << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::open_device(2)} Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+    };
+
+    m_kbdFD=kbdFD;
+    m_pKbdNotify = new QSocketNotifier( m_kbdFD, QSocketNotifier::Read, this );
+    connect( m_pKbdNotify, SIGNAL(activated(int)), this, SLOT(readKbdData()));
+
+    return 0;
+}
+
+void AT91SAM926xKbdHandler::close_device()
+{
+    if(m_kbdFD > 0)
+    {
+	::close(m_kbdFD);
+	m_kbdFD=-1;
+    };
+
+    if(m_fdBuzzer > 0)
+    {
+	::close(m_fdBuzzer);
+	m_fdBuzzer=-1;
+    };
+
+    if(m_pKbdNotify)
+    {
+	delete m_pKbdNotify;
+	m_pKbdNotify=NULL;
+    };
+}
+
+AT91SAM926xKbdHandler::AT91SAM926xKbdHandler()
+        : m_kbdFD(-1), m_fdBuzzer(-1), m_pKbdNotify(NULL),
+          m_unicode(0xffff), m_qtKeyCode(0x00), m_buzzer(QString()),
+          m_modifiers(Qt::NoModifier),
+          m_ConfigFile("/etc/at91sam9263xKbd.xml")
+{
+#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "Loaded AT91SAM926x keypad plugin" << endl;
+    cout << "AT91SAM926x Keypad Handler" << endl;
+#endif
+
+    open_device();
+    loadConfig(m_ConfigFile);
+}
+
+AT91SAM926xKbdHandler::~AT91SAM926xKbdHandler()
+{
+    close_device();
+
+    if(m_fdBuzzer>0) ::close(m_fdBuzzer);
+}
+
+void AT91SAM926xKbdHandler::readKbdData()
+{
+    struct input_event event;
+
+    int n = read(m_kbdFD, &event, sizeof(struct input_event));
+    if(n != (int)sizeof(struct input_event)) return;
+
+    bool isPress = (event.value);
+    bool bBuzzer=false;
+
+    if(!event.type) return;
+
+#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::readPowerKbdData}: receive keyboard event:" << endl
+         << "isPress: " << ((isPress)? "true": "false") << "; Kode : 0x" << hex << (int)event.value
+         << ", Type : 0x" << hex << (int)event.type << endl;
+#endif
+
+    AT91SAM926xKbdHandler::CKey* pKey=NULL;
+    AT91SAM926xKbdHandler::CModifier* pModifier=getModifier(event.code);
+    if(pModifier)
+    {
+	if(isPress)
+	{
+		m_modifiers|=pModifier->m_qt_modifier;
+		pModifier->set_led();
+		if(pModifier->m_buzzer) bBuzzer=true;
+	}
+	else
+	{
+		m_modifiers&= ~(pModifier->m_qt_modifier);
+		pModifier->clear_led();
+	};
+    }else pKey=getKey(event.code);
+
+    if(pKey)
+    {
+	m_qtKeyCode=pKey->m_qt_key;
+	m_unicode=pKey->m_unicode;
+	if(isPress)
+	{
+		m_unicode=pKey->set_led();
+		if(pKey->m_buzzer) bBuzzer|=true;
+	}
+	else m_unicode=pKey->clear_led();
+    };
+
+    if(bBuzzer) set_buzzer();else clear_buzzer();
+
+    if(!pKey) return;
+
+    processKeyEvent(m_unicode, m_qtKeyCode, m_modifiers, isPress, false);
+
+    //if(isPress) {
+    //   beginAutoRepeat(m_unicode, m_qtKeyCode, m_modifiers);
+    //} else endAutoRepeat();
+}
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h	2010-05-19 17:50:53.000000000 +0300
@@ -0,0 +1,106 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xKbdHandler_H
+#define AT91SAM926xKbdHandler_H
+
+// Uncomment this for debus-messages enabling
+//#define DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+
+#include <QObject>
+#include <QList>
+#include <QString>
+#include <QXmlStreamReader>
+
+#include <QWSKeyboardHandler>
+
+
+class QSocketNotifier;
+class AT91SAM926xKbdHandler : public QObject, public QWSKeyboardHandler
+{
+    Q_OBJECT
+public:
+    class CKey
+    {
+	int m_fd;
+      public:
+	unsigned int	m_btn;
+	unsigned int	m_qt_key;
+	unsigned short	m_unicode;
+	bool		m_buzzer;
+	QString		m_led;
+
+	CKey();
+	bool set_led();
+	bool clear_led();
+	~CKey();
+    };
+
+    class CModifier
+    {
+	int m_fd;
+      public:
+	unsigned int		m_btn;
+	Qt::KeyboardModifiers	m_qt_modifier;
+	bool			m_buzzer;
+	QString			m_led;
+
+	CModifier();
+	bool set_led();
+	bool clear_led();
+	~CModifier();
+    };
+
+public:
+    AT91SAM926xKbdHandler();
+    ~AT91SAM926xKbdHandler();
+
+private:
+    QSocketNotifier		*m_pKbdNotify;
+    QString			m_ConfigFile;
+    unsigned int		m_Autorepeat;
+
+    int				m_fdBuzzer;
+    int				m_kbdFD;
+
+    unsigned short		m_unicode;
+    unsigned int		m_qtKeyCode;
+    bool			m_isPressed;
+    Qt::KeyboardModifiers	m_modifiers;
+
+    QString m_buzzer;
+    QList<AT91SAM926xKbdHandler::CKey>  m_keys;
+    QList<AT91SAM926xKbdHandler::CModifier>  m_Modifiers;
+protected:
+    int open_device();
+    void close_device();
+
+    bool loadConfig(QString& configPath);
+    void parseKey(QXmlStreamReader& reader);
+    void parseModifier(QXmlStreamReader& reader);
+    void parseBuzzer(QXmlStreamReader& reader);
+    void parseScancode(QXmlStreamReader& reader, unsigned int& _Key);
+    void parseQtKey(QXmlStreamReader& reader, unsigned int& _QtKey);
+    void parseQtModKey(QXmlStreamReader& reader, Qt::KeyboardModifiers& _QtKey);
+    void parseUnicode(QXmlStreamReader& reader, unsigned short& _Unicode);
+    void parseBuzzer(QXmlStreamReader& reader, bool& _Buzzer);
+    void parseLed(QXmlStreamReader& reader, QString& _Led);
+    unsigned int get_qt_key(const char* pKeyName);
+    unsigned int get_input_btn(const char* pBtnName);
+    Qt::KeyboardModifiers get_qt_modifier(const char* pKeyName);
+
+    int set_buzzer();
+    int clear_buzzer();
+    AT91SAM926xKbdHandler::CModifier* getModifier(unsigned int _btn);
+    AT91SAM926xKbdHandler::CKey* getKey(unsigned int _btn);
+private Q_SLOTS:
+    void readKbdData();
+};
+
+#endif // AT91SAM926xKbdHandler_H
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp	2010-03-26 18:56:37.000000000 +0200
@@ -0,0 +1,343 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+struct SQtNameToKey
+{
+    const char* m_pName;
+    unsigned int m_QtKey;
+};
+
+static SQtNameToKey sQtNames[]=
+{
+    { "key_escape", Qt::Key_Escape},
+    { "key_tab", Qt::Key_Tab},
+    { "key_backtab", Qt::Key_Backtab},
+    { "key_backspace", Qt::Key_Backspace},
+    { "key_return", Qt::Key_Return},
+    { "key_enter", Qt::Key_Enter},
+    { "key_insert", Qt::Key_Insert},
+    { "key_delete", Qt::Key_Delete},
+    { "key_pause", Qt::Key_Pause},
+    { "key_print", Qt::Key_Print},
+    { "key_sysreq", Qt::Key_SysReq},
+    { "key_clear", Qt::Key_Clear},
+    { "key_home", Qt::Key_Home},
+    { "key_end", Qt::Key_End},
+    { "key_left", Qt::Key_Left},
+    { "key_up", Qt::Key_Up},
+    { "key_right", Qt::Key_Right},
+    { "key_down", Qt::Key_Down},
+    { "key_pageup", Qt::Key_PageUp},
+    { "key_pagedown", Qt::Key_PageDown},
+    { "key_shift", Qt::Key_Shift},
+    { "key_control", Qt::Key_Control},
+    { "key_meta", Qt::Key_Meta},
+    { "key_alt", Qt::Key_Alt},
+    { "key_capslock", Qt::Key_CapsLock},
+    { "key_numlock", Qt::Key_NumLock},
+    { "key_scrolllock", Qt::Key_ScrollLock},
+    { "key_f1", Qt::Key_F1},
+    { "key_f2", Qt::Key_F2},
+    { "key_f3", Qt::Key_F3},
+    { "key_f4", Qt::Key_F4},
+    { "key_f5", Qt::Key_F5},
+    { "key_f6", Qt::Key_F6},
+    { "key_f7", Qt::Key_F7},
+    { "key_f8", Qt::Key_F8},
+    { "key_f9", Qt::Key_F9},
+    { "key_f10", Qt::Key_F10},
+    { "key_f11", Qt::Key_F11},
+    { "key_f12", Qt::Key_F12},
+    { "key_f13", Qt::Key_F13},
+    { "key_f14", Qt::Key_F14},
+    { "key_f15", Qt::Key_F15},
+    { "key_f16", Qt::Key_F16},
+    { "key_f17", Qt::Key_F17},
+    { "key_f18", Qt::Key_F18},
+    { "key_f19", Qt::Key_F19},
+    { "key_f20", Qt::Key_F20},
+    { "key_f21", Qt::Key_F21},
+    { "key_f22", Qt::Key_F22},
+    { "key_f23", Qt::Key_F23},
+    { "key_f24", Qt::Key_F24},
+    { "key_f25", Qt::Key_F25},
+    { "key_f26", Qt::Key_F26},
+    { "key_f27", Qt::Key_F27},
+    { "key_f28", Qt::Key_F28},
+    { "key_f29", Qt::Key_F29},
+    { "key_f30", Qt::Key_F30},
+    { "key_f31", Qt::Key_F31},
+    { "key_f32", Qt::Key_F32},
+    { "key_f33", Qt::Key_F33},
+    { "key_f34", Qt::Key_F34},
+    { "key_f35", Qt::Key_F35},
+    { "key_super_l", Qt::Key_Super_L},
+    { "key_super_r", Qt::Key_Super_R},
+    { "key_menu", Qt::Key_Menu},
+    { "key_hyper_l", Qt::Key_Hyper_L},
+    { "key_hyper_r", Qt::Key_Hyper_R},
+    { "key_help", Qt::Key_Help},
+    { "key_direction_l", Qt::Key_Direction_L},
+    { "key_direction_r", Qt::Key_Direction_R},
+    { "key_space", Qt::Key_Space},
+    { "key_any", Qt::Key_Any},
+    { "key_exclam", Qt::Key_Exclam},
+    { "key_quotedbl", Qt::Key_QuoteDbl},
+    { "key_numbersign", Qt::Key_NumberSign},
+    { "key_dollar", Qt::Key_Dollar},
+    { "key_percent", Qt::Key_Percent},
+    { "key_ampersand", Qt::Key_Ampersand},
+    { "key_apostrophe", Qt::Key_Apostrophe},
+    { "key_parenleft", Qt::Key_ParenLeft},
+    { "key_parenright", Qt::Key_ParenRight},
+    { "key_asterisk", Qt::Key_Asterisk},
+    { "key_plus", Qt::Key_Plus},
+    { "key_comma", Qt::Key_Comma},
+    { "key_minus", Qt::Key_Minus},
+    { "key_period", Qt::Key_Period},
+    { "key_slash", Qt::Key_Slash},
+    { "key_0", Qt::Key_0},
+    { "key_1", Qt::Key_1},
+    { "key_2", Qt::Key_2},
+    { "key_3", Qt::Key_3},
+    { "key_4", Qt::Key_4},
+    { "key_5", Qt::Key_5},
+    { "key_6", Qt::Key_6},
+    { "key_7", Qt::Key_7},
+    { "key_8", Qt::Key_8},
+    { "key_9", Qt::Key_9},
+    { "key_colon", Qt::Key_Colon},
+    { "key_semicolon", Qt::Key_Semicolon},
+    { "key_less", Qt::Key_Less},
+    { "key_equal", Qt::Key_Equal},
+    { "key_greater", Qt::Key_Greater},
+    { "key_question", Qt::Key_Question},
+    { "key_at", Qt::Key_At},
+    { "key_a", Qt::Key_A},
+    { "key_b", Qt::Key_B},
+    { "key_c", Qt::Key_C},
+    { "key_d", Qt::Key_D},
+    { "key_e", Qt::Key_E},
+    { "key_f", Qt::Key_F},
+    { "key_g", Qt::Key_G},
+    { "key_h", Qt::Key_H},
+    { "key_i", Qt::Key_I},
+    { "key_j", Qt::Key_J},
+    { "key_k", Qt::Key_K},
+    { "key_l", Qt::Key_L},
+    { "key_m", Qt::Key_M},
+    { "key_n", Qt::Key_N},
+    { "key_o", Qt::Key_O},
+    { "key_p", Qt::Key_P},
+    { "key_q", Qt::Key_Q},
+    { "key_r", Qt::Key_R},
+    { "key_s", Qt::Key_S},
+    { "key_t", Qt::Key_T},
+    { "key_u", Qt::Key_U},
+    { "key_v", Qt::Key_V},
+    { "key_w", Qt::Key_W},
+    { "key_x", Qt::Key_X},
+    { "key_y", Qt::Key_Y},
+    { "key_z", Qt::Key_Z},
+    { "key_bracketleft", Qt::Key_BracketLeft},
+    { "key_backslash", Qt::Key_Backslash},
+    { "key_bracketright", Qt::Key_BracketRight},
+    { "key_asciicircum", Qt::Key_AsciiCircum},
+    { "key_underscore", Qt::Key_Underscore},
+    { "key_quoteleft", Qt::Key_QuoteLeft},
+    { "key_braceleft", Qt::Key_BraceLeft},
+    { "key_bar", Qt::Key_Bar},
+    { "key_araceright", Qt::Key_BraceRight},
+    { "key_asciitilde", Qt::Key_AsciiTilde},
+
+    { "key_nobreakspace", Qt::Key_nobreakspace},
+    { "key_exclamdown", Qt::Key_exclamdown},
+    { "key_cent", Qt::Key_cent},
+    { "key_sterling", Qt::Key_sterling},
+    { "key_currency", Qt::Key_currency},
+    { "key_yen", Qt::Key_yen},
+    { "key_brokenbar", Qt::Key_brokenbar},
+    { "key_section", Qt::Key_section},
+    { "key_diaeresis", Qt::Key_diaeresis},
+    { "key_copyright", Qt::Key_copyright},
+    { "key_ordfeminine", Qt::Key_ordfeminine},
+    { "key_guillemotleft", Qt::Key_guillemotleft},
+    { "key_notsign", Qt::Key_notsign},
+    { "key_hyphen", Qt::Key_hyphen},
+    { "key_registered", Qt::Key_registered},
+    { "key_macron", Qt::Key_macron},
+    { "key_degree", Qt::Key_degree},
+    { "key_plusminus", Qt::Key_plusminus},
+    { "key_twosuperior", Qt::Key_twosuperior},
+    { "key_threesuperior", Qt::Key_threesuperior},
+    { "key_acute", Qt::Key_acute},
+    { "key_mu", Qt::Key_mu},
+    { "key_paragraph", Qt::Key_paragraph},
+    { "key_periodcentered", Qt::Key_periodcentered},
+    { "key_cedilla", Qt::Key_cedilla},
+    { "key_onesuperior", Qt::Key_onesuperior},
+    { "key_masculine", Qt::Key_masculine},
+    { "key_guillemotright", Qt::Key_guillemotright},
+    { "key_onequarter", Qt::Key_onequarter},
+    { "key_onehalf", Qt::Key_onehalf},
+    { "key_threequarters", Qt::Key_threequarters},
+    { "key_questiondown", Qt::Key_questiondown},
+    { "key_agrave", Qt::Key_Agrave},
+    { "key_aacute", Qt::Key_Aacute},
+    { "key_acircumflex", Qt::Key_Acircumflex},
+    { "key_atilde", Qt::Key_Atilde},
+    { "key_adiaeresis", Qt::Key_Adiaeresis},
+    { "key_aring", Qt::Key_Aring},
+    { "key_ae", Qt::Key_AE},
+    { "key_ccedilla", Qt::Key_Ccedilla},
+    { "key_egrave", Qt::Key_Egrave},
+    { "key_eacute", Qt::Key_Eacute},
+    { "key_ecircumflex", Qt::Key_Ecircumflex},
+    { "key_ediaeresis", Qt::Key_Ediaeresis},
+    { "key_igrave", Qt::Key_Igrave},
+    { "key_iacute", Qt::Key_Iacute},
+    { "key_icircumflex", Qt::Key_Icircumflex},
+    { "key_idiaeresis", Qt::Key_Idiaeresis},
+    { "key_eth", Qt::Key_ETH},
+    { "key_ntilde", Qt::Key_Ntilde},
+    { "key_ograve", Qt::Key_Ograve},
+    { "key_oacute", Qt::Key_Oacute},
+    { "key_ocircumflex", Qt::Key_Ocircumflex},
+    { "key_otilde", Qt::Key_Otilde},
+    { "key_odiaeresis", Qt::Key_Odiaeresis},
+    { "key_multiply", Qt::Key_multiply},
+    { "key_ooblique", Qt::Key_Ooblique},
+    { "key_ugrave", Qt::Key_Ugrave},
+    { "key_uacute", Qt::Key_Uacute},
+    { "key_ucircumflex", Qt::Key_Ucircumflex},
+    { "key_udiaeresis", Qt::Key_Udiaeresis},
+    { "key_yacute", Qt::Key_Yacute},
+    { "key_thorn", Qt::Key_THORN},
+    { "key_ssharp", Qt::Key_ssharp},
+    { "key_division", Qt::Key_division},
+    { "key_ydiaeresis", Qt::Key_ydiaeresis},
+    { "key_altgr", Qt::Key_AltGr},
+    { "key_multi_key", Qt::Key_Multi_key},
+    { "key_codeinput", Qt::Key_Codeinput},
+    { "key_singlecandidate", Qt::Key_SingleCandidate},
+    { "key_multiplecandidate", Qt::Key_MultipleCandidate},
+    { "key_previouscandidate", Qt::Key_PreviousCandidate},
+    { "key_mode_switch", Qt::Key_Mode_switch},
+    { "key_back", Qt::Key_Back},
+    { "key_forward", Qt::Key_Forward},
+    { "key_stop", Qt::Key_Stop},
+    { "key_refresh", Qt::Key_Refresh},
+
+    { "key_volumedown", Qt::Key_VolumeDown},
+    { "key_volumemute", Qt::Key_VolumeMute},
+    { "key_volumeup", Qt::Key_VolumeUp},
+    { "key_bassboost", Qt::Key_BassBoost},
+    { "key_bassup", Qt::Key_BassUp},
+    { "key_bassdown", Qt::Key_BassDown},
+    { "key_trebleup", Qt::Key_TrebleUp},
+    { "key_trebledown", Qt::Key_TrebleDown},
+
+    { "key_mediaplay", Qt::Key_MediaPlay},
+    { "key_mediastop", Qt::Key_MediaStop},
+    { "key_mediaprevious", Qt::Key_MediaPrevious},
+    { "key_medianext", Qt::Key_MediaNext},
+    { "key_mediarecord", Qt::Key_MediaRecord},
+
+    { "key_homepage", Qt::Key_HomePage},
+    { "key_favorites", Qt::Key_Favorites},
+    { "key_search", Qt::Key_Search},
+    { "key_standby", Qt::Key_Standby},
+    { "key_openurl", Qt::Key_OpenUrl},
+
+    { "key_launchmail", Qt::Key_LaunchMail},
+    { "key_launchmedia", Qt::Key_LaunchMedia},
+    { "key_launch0", Qt::Key_Launch0},
+    { "key_launch1", Qt::Key_Launch1},
+    { "key_launch2", Qt::Key_Launch2},
+    { "key_launch3", Qt::Key_Launch3},
+    { "key_launch4", Qt::Key_Launch4},
+    { "key_launch5", Qt::Key_Launch5},
+    { "key_launch6", Qt::Key_Launch6},
+    { "key_launch7", Qt::Key_Launch7},
+    { "key_launch8", Qt::Key_Launch8},
+    { "key_launch9", Qt::Key_Launch9},
+    { "key_launcha", Qt::Key_LaunchA},
+    { "key_launchb", Qt::Key_LaunchB},
+    { "key_launchc", Qt::Key_LaunchC},
+    { "key_launchd", Qt::Key_LaunchD},
+    { "key_launche", Qt::Key_LaunchE},
+    { "key_launchf", Qt::Key_LaunchF},
+
+    { "key_medialast", Qt::Key_MediaLast},
+
+    // Keypad navigation keys
+    { "key_select", Qt::Key_Select},
+    { "key_yes", Qt::Key_Yes},
+    { "key_no", Qt::Key_No},
+
+    // Newer misc keys
+    { "key_cancel", Qt::Key_Cancel},
+    { "key_printer", Qt::Key_Printer},
+    { "key_execute", Qt::Key_Execute},
+    { "key_sleep", Qt::Key_Sleep},
+    { "key_play", Qt::Key_Play},
+    { "key_zoom", Qt::Key_Zoom},
+
+    // Device keys
+    { "key_context1", Qt::Key_Context1},
+    { "key_context2", Qt::Key_Context2},
+    { "key_context3", Qt::Key_Context3},
+    { "key_context4", Qt::Key_Context4},
+    { "key_call", Qt::Key_Call},
+    { "key_hangup", Qt::Key_Hangup},
+    { "key_flip", Qt::Key_Flip}
+};
+
+unsigned int AT91SAM926xKbdHandler::get_qt_key(const char* pKeyName)
+{
+    QString lKeyName=QString(pKeyName).trimmed().toLower();
+    for(unsigned int iKeyName=0;iKeyName<(sizeof(sQtNames)/sizeof(struct SQtNameToKey));++iKeyName)
+    {
+	if(lKeyName == sQtNames[iKeyName].m_pName) return sQtNames[iKeyName].m_QtKey;
+    };
+    return Qt::Key_unknown;
+}
+
+
+struct SQtModifiersNameToKey
+{
+    const char*			m_pName;
+    Qt::KeyboardModifiers	m_qt_modifier;
+};
+
+
+static SQtModifiersNameToKey sQtModifiersNames[]=
+{
+    { "shift", Qt::ShiftModifier },
+    { "control", Qt::ControlModifier },
+    { "alt", Qt::AltModifier },
+    { "meta", Qt::MetaModifier },
+    { "keypad", Qt::KeypadModifier },
+    { "groupswitch", Qt::GroupSwitchModifier }
+};
+
+
+Qt::KeyboardModifiers AT91SAM926xKbdHandler::get_qt_modifier(const char* pKeyName)
+{
+    QString lKeyName=QString(pKeyName).trimmed().toLower();
+    for(unsigned int iKeyName=0;iKeyName<(sizeof(sQtModifiersNames)/sizeof(struct SQtModifiersNameToKey));++iKeyName)
+    {
+	if(lKeyName == sQtModifiersNames[iKeyName].m_pName) return sQtModifiersNames[iKeyName].m_qt_modifier;
+    };
+    return Qt::NoModifier;
+}
+
+
diff -Nru a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro
--- a/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro	2010-03-27 19:06:59.000000000 +0200
@@ -0,0 +1,13 @@
+TARGET = AT91SAM926xKbdhandler
+include(../../qpluginbase.pri)
+
+target.path = $$[QT_INSTALL_PLUGINS]/kbddrivers
+INSTALLS += target
+
+HEADERS = AT91SAM926xKbdDriverPlugin.h AT91SAM926xKbdHandler.h
+SOURCES = AT91SAM926xKbdDriverPlugin.cpp \
+          AT91SAM926xKbdHandler.cpp \
+          AT91SAM926xKbdBtns.cpp \
+          AT91SAM926xKbdKeys.cpp \
+          AT91SAM926xKbdConfig.cpp \
+          AT91SAM926xKbdControls.cpp
diff -Nru a/src/plugins/mousedrivers/mousedrivers.pro b/src/plugins/mousedrivers/mousedrivers.pro
--- a/src/plugins/mousedrivers/mousedrivers.pro	2011-04-11 18:00:06.000000000 +0300
+++ b/src/plugins/mousedrivers/mousedrivers.pro	2011-04-11 16:47:00.000000000 +0300
@@ -6,3 +6,4 @@
 contains(mouse-plugins, vr41xx): SUBDIRS += vr41xx
 contains(mouse-plugins, yopy): SUBDIRS += yopy
 contains(mouse-plugins, linuxis): SUBDIRS += linuxis
+contains(mouse-plugins, AT91SAM926xMouse): SUBDIRS += AT91SAM926xMouse
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp	2009-05-08 12:44:13.000000000 +0300
@@ -0,0 +1,46 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousedriverplugin.h"
+#include "AT91SAM926xmousehandler.h"
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+AT91SAM926xMouseDriverPlugin::AT91SAM926xMouseDriverPlugin()
+    : QMouseDriverPlugin()
+{
+}
+
+AT91SAM926xMouseDriverPlugin::~AT91SAM926xMouseDriverPlugin()
+{
+}
+
+QWSMouseHandler* AT91SAM926xMouseDriverPlugin::create(const QString &driver,
+						      const QString &device)
+{
+    cout << "[ AT91SAM926xMouseDriverPlugin:create ]" << endl;
+
+    if( driver.toLower() == QLatin1String("at91sam926xmousehandler") )
+    {
+        cout << "[ Loading AT91SAM926xMouseHandler ]" << endl;
+        return new AT91SAM926xMouseHandler(driver, device);
+    }
+    return 0;
+}
+
+QStringList AT91SAM926xMouseDriverPlugin::keys() const
+{
+    return (QStringList() << QLatin1String("at91sam926xmousehandler"));
+}
+
+Q_EXPORT_PLUGIN2(qwsAT91SAM926xMouseDriverPlugin, AT91SAM926xMouseDriverPlugin)
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h	2009-05-08 11:31:45.000000000 +0300
@@ -0,0 +1,25 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xMOUSEDRIVERPLUGIN_H
+#define AT91SAM926xMOUSEDRIVERPLUGIN_H
+
+#include <qmousedriverplugin_qws.h>
+
+class AT91SAM926xMouseDriverPlugin : public QMouseDriverPlugin
+{
+public:
+    AT91SAM926xMouseDriverPlugin();
+    ~AT91SAM926xMouseDriverPlugin();
+
+    QWSMouseHandler* create(const QString& driver, const QString& device);
+    QStringList keys()const;
+};
+
+#endif // AT91SAM926xMOUSEDRIVERPLUGIN_H
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp	2010-09-08 16:23:15.000000000 +0300
@@ -0,0 +1,265 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include "qsocketnotifier.h"
+#include "qscreen_qws.h"
+
+#include <string.h>
+#include <strings.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+
+#ifndef QT_QWS_TP_JITTER_LIMIT
+#define QT_QWS_TP_JITTER_LIMIT 3
+#endif
+
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+
+AT91SAM926xMouseHandlerPrivate::AT91SAM926xMouseHandlerPrivate(AT91SAM926xMouseHandler* h, const QString &device)
+    : handler(h), dev(0), mouseNotifier(0)
+{
+    open( (device.isNull())? NULL : device.toAscii().data() );
+
+    if (!open()) return;
+
+    calibrated = true;
+
+    int fd = ts_fd(dev);
+    mouseNotifier = new QSocketNotifier(fd, QSocketNotifier::Read, this);
+    connect(mouseNotifier, SIGNAL(activated(int)),this, SLOT(readMouseData()));
+    resume();
+}
+
+AT91SAM926xMouseHandlerPrivate::~AT91SAM926xMouseHandlerPrivate()
+{
+    close();
+}
+
+
+bool AT91SAM926xMouseHandlerPrivate::open(const char* pDevName)
+{
+    if(!pDevName)
+    {
+	char *tsdevice=NULL;
+	if((tsdevice = getenv("TSLIB_TSDEVICE")) == NULL)
+	{
+		if ((dev = ts_open ("/dev/ts", 1)) == NULL)
+		{
+			#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			cout << "Can't open touch screen device /dev/ts !" << endl;
+			#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			return false;
+    		};
+	}else
+	{
+		if ((dev = ts_open (tsdevice, 1)) == NULL)
+		{
+			#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			cout << "Can't open touch screen device " << tsdevice << "!" << endl;
+			#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			return false;
+    		};
+	};
+    }
+    else
+    {
+	if ((dev = ts_open (pDevName, 1)) == NULL)
+	{
+		#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+		cout << "Can't open touch screen device " << pDevName << "!" << endl;
+		#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+		return false;
+	};
+    };
+
+    if (ts_config(dev))
+    {
+	#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+	cout << "Can't config touch screen device!" << endl;
+	#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+	close();
+	return false;
+    };
+
+    return true;
+}
+
+void AT91SAM926xMouseHandlerPrivate::close()
+{
+    if(dev) ts_close(dev);
+}
+
+void AT91SAM926xMouseHandlerPrivate::suspend()
+{
+    if (mouseNotifier)
+	mouseNotifier->setEnabled(false);
+}
+
+void AT91SAM926xMouseHandlerPrivate::resume()
+{
+    bzero(&lastSample, sizeof(lastSample));
+    wasPressed = false;
+    lastdx = 0;
+    lastdy = 0;
+    if (mouseNotifier)
+        mouseNotifier->setEnabled(true);
+}
+
+bool AT91SAM926xMouseHandlerPrivate::get_sample(struct ts_sample *sample)
+{
+    if (!calibrated)
+        return (ts_read_raw(dev, sample, 1) == 1);
+
+    int retCode=ts_read(dev, sample, 1);
+
+    if(sample->x < 0) sample->x=1;
+    if(sample->x > qt_screen->deviceWidth()) sample->x=qt_screen->deviceWidth()-1;
+    if(sample->y < 0) sample->y=1;
+    if(sample->y > qt_screen->deviceHeight()) sample->y=qt_screen->deviceHeight()-1;
+
+    return (retCode == 1);
+}
+
+void AT91SAM926xMouseHandlerPrivate::readMouseData()
+{
+    if (!qt_screen)
+        return;
+
+    for(;;) {
+        struct ts_sample sample = lastSample;
+        bool pressed = wasPressed;
+
+        // Fast return if there's no events.
+        if (!get_sample(&sample))
+            return;
+        pressed = (sample.pressure > 0);
+
+        // Only return last sample unless there's a press/release event.
+        while (pressed == wasPressed) {
+            if (!get_sample(&sample))
+                break;
+            pressed = (sample.pressure > 0);
+        }
+
+        // work around missing coordinates on mouse release in raw mode
+        if (!calibrated && !pressed && sample.x == 0 && sample.y == 0) {
+            sample.x = lastSample.x;
+            sample.y = lastSample.y;
+        }
+
+        int dx = sample.x - lastSample.x;
+        int dy = sample.y - lastSample.y;
+
+        // Remove small movements in oppsite direction
+        if (dx * lastdx < 0 && qAbs(dx) < QT_QWS_TP_JITTER_LIMIT) {
+            sample.x = lastSample.x;
+            dx = 0;
+        }
+        if (dy * lastdy < 0 && qAbs(dy) < QT_QWS_TP_JITTER_LIMIT) {
+            sample.y = lastSample.y;
+            dy = 0;
+        }
+
+        if (wasPressed == pressed && dx == 0 && dy == 0)
+            return;
+
+#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+        cout << "last ( x=" << lastSample.x << ", y=" << lastSample.y
+             << "); curr ( x=" << sample.x << ", y=" << sample.y
+             << "); dx,dy(" << dx << "," << dy
+             << "); ddx,ddy(" << dx*lastdx << "," << dy*lastdy
+             << "); wasPressed is " << wasPressed << "; pressed is " << pressed << endl;
+#endif
+
+        lastSample = sample;
+        wasPressed = pressed;
+        if (dx != 0)
+            lastdx = dx;
+        if (dy != 0)
+            lastdy = dy;
+
+        const QPoint p(sample.x, sample.y);
+        if (calibrated) {
+            // tslib should do all the translation and filtering, so we send a
+            // "raw" mouse event
+            handler->QWSMouseHandler::mouseChanged(p, pressed);
+        } else {
+            handler->sendFiltered(p, pressed);
+        }
+    }
+}
+
+void AT91SAM926xMouseHandlerPrivate::clearCalibration()
+{
+    suspend();
+    close();
+    handler->QWSCalibratedMouseHandler::clearCalibration();
+    calibrated = false;
+    open();
+    resume();
+}
+
+void AT91SAM926xMouseHandlerPrivate::calibrate(const QWSPointerCalibrationData *data)
+{
+    suspend();
+    close();
+    // default implementation writes to /etc/pointercal
+    // using the same format as the tslib linear module.
+    handler->QWSCalibratedMouseHandler::calibrate(data);
+    calibrated = true;
+    open();
+    resume();
+}
+
+AT91SAM926xMouseHandler::AT91SAM926xMouseHandler(const QString &driver,
+						 const QString &device)
+    : QWSCalibratedMouseHandler(driver, device)
+{
+    #ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    cout << "***Loaded AT91SAM926x touchscreen plugin!" << endl;
+    #endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    d = new AT91SAM926xMouseHandlerPrivate(this, device);
+}
+
+
+AT91SAM926xMouseHandler::~AT91SAM926xMouseHandler()
+{
+    delete d;
+}
+
+void AT91SAM926xMouseHandler::suspend()
+{
+    d->suspend();
+}
+
+void AT91SAM926xMouseHandler::resume()
+{
+    d->resume();
+}
+
+void AT91SAM926xMouseHandler::clearCalibration()
+{
+    d->clearCalibration();
+}
+
+void AT91SAM926xMouseHandler::calibrate(const QWSPointerCalibrationData *data)
+{
+    d->calibrate(data);
+}
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h	2010-09-08 17:41:33.000000000 +0300
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xMOUSEHANDLER_H
+#define AT91SAM926xMOUSEHANDLER_H
+
+#include <qobject.h>
+#include <QtGui/qmouse_qws.h>
+
+#include <tslib.h>
+
+// Uncomment this for printing debug information
+//#define DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+
+class AT91SAM926xMouseHandler;
+class QSocketNotifier;
+
+
+class AT91SAM926xMouseHandlerPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    AT91SAM926xMouseHandlerPrivate(AT91SAM926xMouseHandler* h, const QString &device);
+    ~AT91SAM926xMouseHandlerPrivate();
+
+    void suspend();
+    void resume();
+
+    void calibrate(const QWSPointerCalibrationData *data);
+    void clearCalibration();
+
+private:
+    AT91SAM926xMouseHandler *handler;
+    struct tsdev* dev;
+    QSocketNotifier* mouseNotifier;
+
+    struct ts_sample lastSample;
+    bool wasPressed;
+    int lastdx;
+    int lastdy;
+
+    bool calibrated;
+
+    inline bool get_sample(struct ts_sample *sample);
+
+    bool open(const char* pDevName=NULL);
+    void close();
+
+private slots:
+    void readMouseData();
+};
+
+class AT91SAM926xMouseHandler : public QObject, public QWSCalibratedMouseHandler
+{
+public:
+     AT91SAM926xMouseHandler(const QString &driver = QString(),
+                             const QString &device = QString());
+    ~AT91SAM926xMouseHandler();
+
+    void suspend();
+    void resume();
+
+    void calibrate(const QWSPointerCalibrationData *data);
+    void clearCalibration();
+
+private:
+    friend class AT91SAM926xMouseHandlerPrivate;
+    AT91SAM926xMouseHandlerPrivate *d;
+
+};
+
+#endif // AT91SAM926xMOUSEHANDLER_H
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp	2010-05-31 15:35:12.000000000 +0300
@@ -0,0 +1,409 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+#include "AT91SAM926xMouseLinAlg.h"
+#include "AT91SAM926xMouseLinAlgUtil.h"
+
+#include <sstream>
+#include <iomanip>
+#include <cassert>
+#include <cstring>
+#include <cstdlib>
+#include <cmath>
+
+matrix matrix::addcolumns()
+{
+    long i,j;
+    matrix B(rows);
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		B.A[i][0] += A[i][j];
+    }
+    return(B);
+}
+
+matrix matrix::getrow(long i) const
+{
+    long j;
+    matrix B(1,columns);
+    for (j=0; j<=columns-1;j++)
+	B.A[0][j] = A[i][j];
+    return(B);
+}
+
+matrix matrix::getcolumn(long i) const
+{
+    long j;
+    matrix B(rows);
+    for (j=0; j<=rows-1; j++)
+	B.A[j][0] = A[j][i];
+    return(B);
+}
+
+void matrix::setrow(const matrix &B, long i)
+{
+    long j;
+    if (columns != B.columns)
+    {
+	error("Wrong dimensions in matrix setrow \n");
+	return;
+    };
+    for (j=0; j<=columns-1; j++)
+	A[i][j] = B.A[0][j];
+}
+
+void matrix::setcolumn(const matrix &B, long i)
+{
+    long j;
+    if (rows != B.rows)
+    {
+	error("Wrong dimensions in matrix setcolumn \n");
+	return;
+    };
+    for (j=0; j<=rows-1; j++)
+	A[j][i] = B.A[j][0];
+}
+
+long matrix::operator==(const matrix &B)
+{
+    long i,j,eq=1;
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix equal \n");
+	return 1;
+    }
+    else
+    {
+	for(i=0; (i<=rows-1) & eq; i++)
+	{
+		for(j=0; (j<=columns-1) & eq; j++)
+			eq = (A[i][j] == B.A[i][j]);
+	}
+    }
+    return(eq);
+}
+
+void matrix::print() const
+{
+    long i,j;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+	{
+		std::string ss = numStr(A[i][j]) + "    ";
+	};
+    }
+}
+
+void matrix::stdprint() const
+{
+    long i,j;
+    std::cerr  << "[";
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+	{
+		std::cerr << A[i][j];
+		if (j<columns-1)
+		std::cerr << " ";
+	}
+	if (i<rows-1)
+		std::cerr << ";" << std::endl;
+    }
+    std::cerr << "]";
+}
+
+
+
+matrix matrix::operator*(const double &x)
+{
+    long i,j;
+    matrix C(rows,columns);
+    for(i=0;i <= C.rows-1; i++)
+    {
+	for(j=0; j<=C.columns-1;j++)
+	{
+		C.A[i][j] = x*A[i][j];
+	}
+    }
+    return(C);
+}
+
+
+matrix matrix::operator*(const matrix &B)
+{
+    long i,j,k;
+    matrix C(rows,B.columns);
+    if (columns != B.rows)
+    {
+	error("Wrong dimensions in matrix multiplication \n");
+	return(C);
+    }
+    else
+    {
+	for(i=0;i <= C.rows-1; i++)
+	{
+		for(j=0; j<=C.columns-1;j++)
+		{
+			for(k=0;k<=columns-1;k++)
+				C.A[i][j] += A[i][k]*B.A[k][j];
+		}
+	}
+    }
+    return(C);
+}
+
+matrix matrix::trans() 
+{
+    long i,j;
+    matrix B(columns,rows);
+    for (i=0;i<=columns-1;i++)
+    {
+	for(j=0;j<=rows-1;j++)
+		B.A[i][j] = A[j][i];
+    }
+    return(B);
+}
+
+matrix matrix::operator+(const matrix &B)
+{
+    long i,j;
+    matrix C(rows,columns);
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix plus \n");
+	return (C);
+    }
+    else
+    {
+	for(i=0;i <= rows-1; i++)
+	{
+		for(j=0; j<=columns-1;j++)
+			C.A[i][j] = A[i][j] + B.A[i][j];
+	}
+    }
+    return(C);
+}
+
+matrix matrix::operator-(const matrix &B)
+{
+    long i,j;
+    matrix C(rows,columns);
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix minus \n");
+	return(C);
+    }
+    else
+    {
+	for(i=0;i <= rows-1; i++)
+	{
+		for(j=0; j<=columns-1;j++)
+			C.A[i][j] = A[i][j] - B.A[i][j];
+	}
+    }
+    return(C);
+}
+
+double matrix::twonorm()
+{
+    long i,j;
+    double norm=0;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		norm += A[i][j]*A[i][j];
+    }
+    norm = sqrt(norm);
+    return(norm);
+}
+
+double matrix::onenorm()
+{
+    long i,j;
+    double norm=0;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		norm += num(A[i][j]);
+    }
+    return(norm);
+}
+
+std::vector<double> matrix::mean() const
+{
+    std::vector<double> m(columns);
+    for (long s=0; s<columns; s++)
+    {
+	double sum = 0;
+	for (long r=0; r<rows; r++)
+	{
+		sum += A[r][s];
+	}
+	m[s] = sum/(double)rows;
+    }
+    return m;
+}
+
+std::vector<double> matrix::var() const
+{
+    std::vector<double> mu = mean();
+    std::vector<double> v(columns);
+    for (long s=0; s<columns; s++)
+    {
+	double sum = 0;
+	for (long r=0; r<rows; r++)
+	{
+		double xe = A[r][s]-mu[s];
+		sum +=  xe*xe;
+	}
+	v[s] = sum/((double)rows-1);
+    }
+    return v;
+}
+
+matrix matrix::covar() const
+{
+    std::vector <double> m = mean();
+    matrix res(columns, columns);
+    for (int x=0; x<columns; x++)
+    {
+	for (int y=x; y<columns; y++)
+	{
+		double sum = 0;
+		for (int i=0; i<rows; i++)
+		{
+			sum += (A[i][x]-m[x])*(A[i][y]-m[y]);
+		}
+		double val = sum/(double)(rows-1);
+		res.set(val,x,y);
+		res.set(val,y,x);
+	}
+    }
+    return res;
+}
+
+
+matrix matrix::inv()
+{
+    long *indxc =new long[rows];
+    long *indxr = new long[rows];
+    long *ipiv = new long[rows];
+    long i, icol = 0, irow = 0, j, k, l, ll;
+    double big, dum, pivinv;
+    matrix B(rows,columns);
+
+    for(i=0;i<=rows-1;i++)
+    {
+	indxc[i]=0;
+	indxr[i]=0;
+	ipiv[i]=0;
+    }
+
+    if (columns != rows)
+    {
+	error("Cannot invert non-square matrix \n");
+	return(B);
+    }
+    else
+	for(i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+			B.A[i][j] = A[i][j];
+	}
+
+    for (i=0;i<=columns-1;i++)
+    {
+	big = 0.0;
+	for (j=0;j<=rows-1;j++)
+	{
+		if (ipiv[j] != 1)
+			for (k=0;k<=columns-1;k++)
+			{
+				if (ipiv[k] == 0)
+				{
+					if (fabs(B.A[j][k]) >=big)
+					{
+						big = fabs(B.A[j][k]);
+						irow = j;
+						icol = k;
+					}
+				}
+				else if (ipiv[k] > 1) { error("inv: Singular Matrix-1"); return(B);}
+			}
+	}
+	++(ipiv[icol]);
+	if (irow != icol)
+	{
+		for (l=0;l<=columns-1;l++) B.swap(irow,icol);
+	}
+	indxr[i] = irow;
+	indxc[i] = icol;
+	if (B.A[icol][icol] == 0.0) { error("inv: Singular Matrix-2"); return(B);}
+	pivinv = 1.0/B.A[icol][icol]; 
+	B.A[icol][icol] = 1.0;
+	for (l=0;l<=columns-1;l++) B.A[icol][l] *= pivinv;
+	for (ll=0;ll<=rows-1;ll++)
+		if (ll != icol)
+		{
+			dum = B.A[ll][icol];
+			B.A[ll][icol] = 0.0;
+			for (l=0;l<=columns-1;l++) 
+				B.A[ll][l] -= B.A[icol][l]*dum;
+		}
+    }
+    for(l=columns-1;l>=0;l--)
+    {
+	if (indxr[l] != indxc[l])
+		B.swapc(indxr[l],indxc[l]);
+    }
+    delete(ipiv);
+    delete(indxr);
+    delete(indxc);
+    return(B);
+}
+
+matrix matrix::map(double(*f)(double))
+{
+    matrix res(rows,columns);
+    for (int r=0; r<rows; r++)
+    for (int s=0; s<columns; s++) res.set(f(A[r][s]),r,s);
+    return res;
+}
+
+double matrix::maxvalue()
+{
+    double max=A[0][0];  
+    for(int i=0; i<rows;i++)
+    {
+	for(int j=0; j<columns; j++) {if (A[i][j]>max) max=A[i][j];}
+    }
+    return(max);
+}
+
+
+
+const char* matrix::row2string(int r)
+{
+    assert(r>=0 && r<rows);
+
+    std::ostringstream mstr;
+    mstr.setf(std::ios::fixed);
+    std::string res;
+    for (int i=0; i<columns; i++)
+    {
+	mstr << std::setw(9) << A[r][i] << " ";
+    }
+
+    std::string ss = mstr.str();
+
+    return ss.c_str();
+}
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h	2010-06-01 10:40:47.000000000 +0300
@@ -0,0 +1,150 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_H_
+#define _AT91SAM926xMOUSE_LINALG_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <vector>
+
+#include <math.h>
+
+class matrix
+{
+protected:
+    int rows;
+    int columns;
+    double **A;
+public:
+    matrix(int r = 1, int c = 1)
+    {
+	int i,j;
+	rows=r; columns=c;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j]=0;
+	}
+      }
+    matrix(const matrix &B)
+    {
+	int i,j;
+	rows = B.rows;
+	columns = B.columns;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+	A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+			A[i][j]=B.A[i][j];
+	}
+    }
+    ~matrix() 
+    {
+	long i;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+    }
+    matrix &operator=(const matrix &B)
+    {
+	long i,j;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+	rows = B.rows;
+	columns = B.columns;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j] = B.A[i][j];
+	}
+	return *this;
+    }
+    long *size() {long *dim = new long[2]; dim[0] = rows; dim[1]=columns; return(dim);}
+    long row() const {return(rows);} 
+    long column() const {return(columns);} 
+    void newsize(long r, long c = 1) //warning: This deletes the original matrix
+    {
+	long i,j;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+	rows = r; columns = c;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j]=0;
+	}
+    }
+    double get(long i, long j = 0) const {return(A[i][j]);}
+    void set(double x, long i, long j=0) {A[i][j]=x;}
+    void add(double x, long i, long j=0) {A[i][j] += x;};
+    void sub(double x, long i, long j=0) {A[i][j] -= x;};
+    void mul(double x, long i, long j=0) {A[i][j] *= x;};
+    // Maps function f to every element in matrix
+    matrix map(double(*f)(double));
+    matrix getrow(long i) const;
+    matrix getcolumn(long i) const;
+    matrix addcolumns();
+    void setrow(const matrix &B, long i);
+    void setcolumn(const matrix &B, long i);
+    long operator==(const matrix &B);
+    matrix operator*(const double &x);
+    matrix operator*(const matrix &B);
+    matrix trans();
+    matrix operator+(const matrix &B);
+    matrix operator-(const matrix &B);
+    matrix inv();
+    double twonorm();
+    double onenorm();
+    // calculates empirical mean of each column in matrix
+    std::vector<double> mean() const; 
+    //  calculates empirical variance of each column in matrix
+    std::vector<double> var() const;
+    //  calculates empirical covariance matrix of matrix
+    matrix covar() const;
+
+    double maxvalue();
+    const char* row2string(int r);
+    void print() const;
+    void stdprint() const;
+    void swap(long i, long j)
+    {
+	double *tmp = A[i];
+	A[i]=A[j];
+	A[j] = tmp;
+    }
+    void swapc(long i, long j)
+    {
+	double tmp;
+	long k;
+	for(k=0;k<=rows-1;k++)
+	{
+		tmp=A[k][i];
+		A[k][i]= A[k][j];
+		A[k][j]=tmp;
+	}
+    }
+};
+
+
+
+#endif // _AT91SAM926xMOUSE_LINALG_H_
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp	2010-06-01 10:41:47.000000000 +0300
@@ -0,0 +1,320 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include "AT91SAM926xMouseLinAlgSVD.h"
+#include "AT91SAM926xMouseLinAlgUtil.h"
+#include "AT91SAM926xMouseLinAlg.h"
+
+#include <cmath>
+#include <stdlib.h>
+
+
+#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))
+
+static double maxarg1, maxarg2;
+#define FMAX(a,b) (maxarg1 = (a), maxarg2 = (b), (maxarg1) > (maxarg2) ? (maxarg1) : (maxarg2))
+
+static int iminarg1, iminarg2;
+#define IMIN(a,b) (iminarg1 = (a), iminarg2 = (b), (iminarg1) < (iminarg2) ? (iminarg1) : (iminarg2))
+
+static double sqrarg;
+#define SQR(a) ((sqrarg = (a)) == 0.0 ? 0.0 : sqrarg * sqrarg)
+
+double pythag(double a, double b)
+{
+    // computes (a^2+b^2)^(1/2) without destructive under/over-flow
+    double absa = fabs(a);
+    double absb = fabs(b);
+    if (absa>absb) return absa*sqrt(1.0+SQR(absb/absa));
+    return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+SQR(absa/absb)));
+}
+
+// SVD-decomposition A = U*W*V', where U,V orthogonal and W diagonal. The matrix U is
+// replacing A and notice that V and not the transpose V' is returned. 
+// Blackbox-algorithm from NR.
+void svdcmp(matrix &A, matrix &DD, matrix &VV)
+{
+    int flag,i,its,j,jj,k,l = 0,nm = 0;
+    double anorm,c,f,g,h,s,scale,x,y,z;
+
+    // Dimensions of A;
+    int m = A.row();
+    int n = A.column();
+
+    matrix W(n,n);
+    matrix V(n,n);
+
+    std::vector<double> rv1(n);
+
+    g=scale=anorm=0.0;
+
+    //  cerr << "Start of algorithm\n";
+    // householder reduction to bidiagonal form
+    for (i=0; i<n; i++)
+    {
+	l=i+1;
+	rv1[i] = scale*g;
+	g=s=scale=0.0;
+	if (i<m)
+	{
+		for (k=i; k<m; k++) { scale += fabs(A.get(k,i));};
+		if (scale)
+		{
+			for (k=i; k<m; k++)
+			{
+				A.set(A.get(k,i)/scale, k,i);
+				s += A.get(k,i)*A.get(k,i);
+			};
+			f = A.get(i,i);
+			g = -SIGN((double)sqrt(s),double(f));
+			h = f*g-s;
+			A.set(f-g,i,i);
+			for (j=l; j<n; j++)
+			{
+				for (s=0.0, k=i; k<m; k++) { s += A.get(k,i)*A.get(k,j);};
+				f = s/h;
+				for (k=i; k<m; k++) { A.set(A.get(k,j)+f*A.get(k,i),k,j);};
+			};
+			for (k=i; k<m; k++) { A.set(A.get(k,i)*scale,k,i);};
+		} // if (scale)
+	} // if (i<=m)
+
+	W.set(scale*g,i,i);
+	g=s=scale=0.0;
+	if (i<m && i!=n-1)
+	{
+		for (k=l; k<n; k++) { scale += fabs(A.get(i,k));};
+		if (scale)
+		{
+			for(k=l; k<n; k++)
+			{
+				A.set(A.get(i,k)/scale,i,k);
+				s += A.get(i,k)*A.get(i,k);
+			};
+			f = A.get(i,l);
+			g = -SIGN(sqrt(s),f);
+			h = f*g-s;
+			A.set(f-g,i,l);
+			for (k=l; k<n; k++) { rv1[k]=A.get(i,k)/h;};
+			for (j=l; j<m; j++)
+			{
+				for (s=0.0, k=l; k<n; k++) { s+= A.get(j,k)*A.get(i,k);};
+				for (k=l; k<n; k++) { A.set(s*rv1[k]+A.get(j,k),j,k);};
+			};
+			for (k=l; k<n; k++) { A.set(A.get(i,k)*scale, i,k);};
+		}; // if (scale)
+	}; // if(i<=m && i!=n)
+	anorm = FMAX(anorm, (fabs(W.get(i,i))+fabs(rv1[i])));
+    } //  for (i=1; i<=n; i++)
+
+
+  //  "End of part 1\n";
+
+    for (i=n-1; i>=0; i--)
+    {
+	// Accumulation of right-hand transformations.
+	if (i<n-1)
+	{
+		if (g)
+		{
+			for (j=l; j<n; j++)
+			{
+				// Double division to avoid possible underflow
+				V.set((A.get(i,j)/A.get(i,l))/g ,j,i);
+			};
+			for (j=l; j<n; j++)
+			{
+				for(s=0.0, k=l; k<n; k++) { s +=  A.get(i,k)*V.get(k,j);};
+				for (k=l; k<n; k++) { V.set(V.get(k,j)+s*V.get(k,i), k,j);};
+			};
+		}; // if (g)
+		for (j=l; j<n; j++) { V.set(0,i,j); V.set(0,j,i);};
+	}; // if (i<n)
+	V.set(1.0,i,i);
+	g = rv1[i];
+	l = i;
+    }; // for (i=n; i>=1; i--)
+
+    //  "End of part 2\n";
+    for (i=IMIN(m,n)-1; i>=0; i--)
+    {
+	// Accumulation of left-hand transformations
+	l = i+1;
+	g = W.get(i,i);
+	for (j=l; j<n; j++) { A.set(0.0, i,j);};
+	if (g)
+	{
+		g = 1.0/g;
+		for (j=l; j<n; j++)
+		{
+			for (s=0.0, k=l; k<m; k++) { s += A.get(k,i)*A.get(k,j);};
+			f = (s/A.get(i,i))*g;
+			for (k=i; k<m; k++) { A.set(A.get(k,j)+f*A.get(k,i), k,j);};
+		};
+		for (j=i; j<m; j++) { A.set(g*A.get(j,i), j,i);};
+	} // if (g)
+	else
+	{
+		for (j=i; j<m; j++) { A.set(0.0, j,i);};
+	}
+	A.set(A.get(i,i)+1, i,i);
+    }; // for (i=IMIN(m,n); i>=1; i--)
+
+    //  "End of part 3\n";
+    for (k=n-1; k>=0; k--)
+    {
+	// Diagonalization of the bidiagonal form; Loop over singular values, and over all allowed iterations
+	for (its=1; its<=100; its++)
+	{
+		flag = 1;
+		for (l=k; l>=0; l--)
+		{
+			// Test for splitting
+			nm = l-1; // Note that rv1[0] is always zero.
+			if ((double)(fabs(rv1[l])+anorm) == anorm)
+			{
+				flag = 0;
+				break;
+			};
+			if ((double)(fabs(W.get(nm,nm))+anorm) == anorm) { break;};
+		}; // for (l=k; l>=1; l--)
+		if (l<0) l++;
+		if (flag)
+		{
+			// cancelation of rv1[l], if l>1.
+			c = 0.0;
+			s = 1.0;
+			for (i=l; i<=k; i++)
+			{
+				f = s*rv1[i];
+				rv1[i] = c*rv1[i];
+				if ((double)(fabs(f)+anorm) == anorm) { break;};
+
+				g = W.get(i,i);
+				h = pythag(f,g);
+
+				W.set(h,i,i);
+				h = 1.0/h;
+				c = g*h;
+				s = -f*h;
+
+				for (j=0; j<m; j++)
+				{
+					y = A.get(j,nm);
+					z = A.get(j,i);
+					A.set(y*c+z*c, j, nm);
+					A.set(z*c-y*s, j,i);
+				};
+			}; // for (i=1; i<=k; i++)
+		}; // if (flag)
+
+		//  "End of part 4\n"
+
+		z = W.get(k,k);
+		if (l == k)
+		{
+			// Convergence
+			if (z < 0.0)
+			{
+				// Singular values are made nonnegative
+				W.set(-z, k,k);
+				for (j=0; j<n; j++) { V.set(-V.get(j,k), j,k);};
+			};
+			break;
+		}; // if (l == k)
+
+		if (its == 100)
+		{
+			std::cerr << "No convergence in 100 svdcmp iterations\n";
+			return;
+		}
+
+		//      "End of part 5\n"
+
+		x = W.get(l,l);   // Shift from bottom 2-by-2 mirror
+		nm = k-1;
+		y = W.get(nm,nm);
+		g = rv1[nm];
+		h = rv1[k];
+		f = ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
+		g = pythag(f,1.0);
+		f=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;
+		c=s=1.0;  // Next QR transformation
+		for (j=l; j<=nm; j++)
+		{
+			i = j+1;
+			g = rv1[i];
+			y = W.get(i,i);
+			h = s*g;
+			g = c*g;
+			z = pythag(f,h);
+			rv1[j] = z;
+			c = f/z;
+			s = h/z;
+			f = x*c+g*s;
+			g = g*c-x*s;
+			h = y*s;
+			y *= c;
+			for (jj=0; jj<n; jj++)
+			{
+				x = V.get(jj,j);
+				z = V.get(jj,i);
+				V.set(x*c+z*s, jj,j);
+				V.set(z*c-x*s, jj,i);
+			};
+			z = pythag(f,h);
+			W.set(z, j,j);
+			if  (z)
+			{
+				// Rotation can be arbitrary if z=0;
+				z = 1.0/z;
+				c = f*z;
+				s = h*z;
+			};
+			f = c*g+s*y;
+			x = c*y-s*g;
+
+			for (jj=0; jj<m; jj++)
+			{
+				y = A.get(jj,j);
+				z = A.get(jj,i);
+				A.set(y*c+z*s, jj,j);
+				A.set(z*c-y*s, jj,i);
+			};
+		}; // for (j=1; k<=nm; j++)
+		rv1[l] = 0.0;
+		rv1[k] = f;
+		W.set(x, k,k);
+	}; // for (its=1; its<=30; its++)
+    }; // for (k=n; k>=1; k--)
+
+    DD  = W;
+    VV = V;
+} // end of function
+
+
+matrix pseudoinverse(matrix const& A, double threshold) {
+
+    matrix U=A, D,V;
+    svdcmp(U,D,V);
+
+    matrix iD(D.row(), D.row());
+    for (int i=0; i<D.row(); i++)
+    {
+	// Truncate (near) singular values
+	if (fabs(D.get(i,i))>threshold)
+		iD.set((double)1/D.get(i,i), i,i);
+    };
+
+    matrix res = V*iD;
+    res = res*U.trans();
+    return res;
+}
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h	2010-06-01 10:39:02.000000000 +0300
@@ -0,0 +1,21 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_SVD_H_
+#define _AT91SAM926xMOUSE_LINALG_SVD_H_
+
+#include "AT91SAM926xMouseLinAlgUtil.h"
+#include "AT91SAM926xMouseLinAlg.h"
+
+// SVD-decomposition A = U*W*V', where U,V orthogonal and W diagonal. The matrix U is
+// replacing A and notice that V and not the transpose V' is returned. 
+void svdcmp(matrix &A, matrix &D, matrix &V);
+matrix pseudoinverse(matrix const& A, double threshold=1e-6);
+
+#endif // _AT91SAM926xMOUSE_LINALG_SVD_H_
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp	2010-05-31 15:35:50.000000000 +0300
@@ -0,0 +1,22 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include <stdlib.h>
+#include <fstream>
+#include "AT91SAM926xMouseLinAlgUtil.h"
+
+
+void error(char* error_text)
+{
+#ifdef DEF_AT91SAM926x_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    std::cout << "\n" << error_text;
+#endif
+}
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h	2010-06-01 10:39:00.000000000 +0300
@@ -0,0 +1,34 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_UTIL_H_
+#define _AT91SAM926xMOUSE_LINALG_UTIL_H_
+
+#include <iostream>
+#include <sstream>
+#include <vector>
+
+void error(char* error_text);
+
+inline double num(double x) {
+  double y=x;
+  if (x < 0)
+    y = -x;
+  return(y);
+}
+
+template <class T>
+std::string numStr(T x) {
+  std::ostringstream nmbstr; nmbstr << x;
+  std::string ss = nmbstr.str();
+
+  return ss;
+}
+
+#endif // _AT91SAM926xMOUSE_LINALG_UTIL_H_
diff -Nru a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro
--- a/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro	1970-01-01 03:00:00.000000000 +0300
+++ b/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro	2008-11-14 15:47:12.000000000 +0200
@@ -0,0 +1,8 @@
+TARGET = AT91SAM926xmousehandler
+include(../../qpluginbase.pri)
+
+target.path = $$[QT_INSTALL_PLUGINS]/mousedrivers
+INSTALLS += target
+
+HEADERS = AT91SAM926xmousedriverplugin.h AT91SAM926xmousehandler.h
+SOURCES = AT91SAM926xmousedriverplugin.cpp AT91SAM926xmousehandler.cpp
