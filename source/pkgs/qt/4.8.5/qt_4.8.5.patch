diff -uNr qt-everywhere-opensource-src-4.8.5_org/config.tests/unix/freetype/freetype.pri qt-everywhere-opensource-src-4.8.5_patched/config.tests/unix/freetype/freetype.pri
--- qt-everywhere-opensource-src-4.8.5_org/config.tests/unix/freetype/freetype.pri	2013-06-07 09:16:41.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/config.tests/unix/freetype/freetype.pri	2014-04-18 14:31:12.577089878 +0400
@@ -1,5 +1,5 @@
 !cross_compile {
-    TRY_INCLUDEPATHS = /include /usr/include $$QMAKE_INCDIR $$QMAKE_INCDIR_X11 $$INCLUDEPATH
+    TRY_INCLUDEPATHS = $$QMAKE_INCDIR $$QMAKE_INCDIR_X11 $$INCLUDEPATH
     # LSB doesn't allow using headers from /include or /usr/include
     linux-lsb-g++:TRY_INCLUDEPATHS = $$QMAKE_INCDIR $$QMAKE_INCDIR_X11 $$INCLUDEPATH
     for(p, TRY_INCLUDEPATHS) {
diff -uNr qt-everywhere-opensource-src-4.8.5_org/configure qt-everywhere-opensource-src-4.8.5_patched/configure
--- qt-everywhere-opensource-src-4.8.5_org/configure	2013-06-07 09:16:41.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/configure	2014-04-19 19:31:44.371298276 +0400
@@ -1159,8 +1159,8 @@
         shift
         VAL=$1
         ;;
-    -prefix|-docdir|-headerdir|-plugindir|-importdir|-datadir|-libdir|-bindir|-translationdir|-sysconfdir|-examplesdir|-demosdir|-depths|-make|-nomake|-platform|-xplatform|-device-option|-buildkey|-sdk|-arch|-host-arch|-mysql_config|-sysroot)
-        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+    -prefix|-docdir|-headerdir|-plugindir|-importdir|-datadir|-libdir|-bindir|-translationdir|-sysconfdir|-examplesdir|-demosdir|-depths|-make|-nomake|-platform|-xplatform|-device-option|-buildkey|-sdk|-arch|-host-arch|-mysql_config|-sysroot|-crossarch)
+            VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
         shift
         VAL="$1"
         ;;
@@ -1697,19 +1697,12 @@
             ;;
         esac
         ;;
+    crossarch)
+		CROSSARCH="$VAL"
+	;;
     xplatform)
         XPLATFORM="$VAL"
-        case `basename "$XPLATFORM"` in win32-g++*)
-            XPLATFORM_MINGW=yes
-            CFG_RPATH=no
-            CFG_REDUCE_EXPORTS=no
-            ;;
-        esac
-        case "$XPLATFORM" in *integrity*) XPLATFORM_INTEGRITY=yes;; esac
-        case "$XPLATFORM" in *symbian*) XPLATFORM_SYMBIAN=yes;; esac
-        case "$XPLATFORM" in symbian-sbsv2) XPLATFORM_SYMBIAN_SBSV2=yes;; esac
-        case "$XPLATFORM" in *qnx-*|*blackberry-*) XPLATFORM_QNX=yes;; esac
-        ;;
+	;;
     device-option)
         DEV_VAR=`echo $VAL | sed "s,^\(.*\)=.*,\1,"`
         DEV_VAL=`echo $VAL | sed "s,^.*=\(.*\),\1,"`
@@ -3313,6 +3306,9 @@
     CFG_ARCH=$CFG_HOST_ARCH
 fi
 
+CFG_ARCH="$CROSSARCH"
+
+
 # for compatibility
 COMPAT_ARCH=
 case "$CFG_ARCH" in
@@ -5529,7 +5525,7 @@
         psql)
             if [ "$CFG_SQL_psql" != "no" ]; then
                 # Be careful not to use native pg_config when cross building.
-                if [ "$XPLATFORM_MINGW" != "yes" ] && "$WHICH" pg_config >/dev/null 2>&1; then
+                if [ "$QT_CROSS_COMPILE" = "no" ] && [ "$XPLATFORM_MINGW" != "yes" ] && "$WHICH" pg_config >/dev/null 2>&1; then
                     QT_CFLAGS_PSQL=`pg_config --includedir 2>/dev/null`
                     QT_LFLAGS_PSQL=`pg_config --libdir 2>/dev/null`
                 fi
@@ -7081,6 +7077,7 @@
     echo "Choose pixel-depths to support:"
     echo
     echo "   1. 1bpp, black/white"
+    echo "   2. 2bpp, grayscale"
     echo "   4. 4bpp, grayscale"
     echo "   8. 8bpp, paletted"
     echo "  12. 12bpp, rgb 4-4-4"
@@ -7099,11 +7096,11 @@
 fi
 if [ -n "$CFG_QWS_DEPTHS" -a "$PLATFORM_QWS" = "yes" ]; then
     if [ "$CFG_QWS_DEPTHS" = "all" ]; then
-        CFG_QWS_DEPTHS="1 4 8 12 15 16 18 24 32 generic"
+        CFG_QWS_DEPTHS="1 2 4 8 12 15 16 18 24 32 generic"
     fi
     for D in `echo "$CFG_QWS_DEPTHS" | sed -e 's/,/ /g'`; do
 	case $D in
-	    1|4|8|12|15|16|18|24|32) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_$D";;
+	    1|2|4|8|12|15|16|18|24|32) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_$D";;
 	    generic) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_GENERIC";;
 	esac
     done
diff -uNr qt-everywhere-opensource-src-4.8.5_org/examples/qws/qws.pro qt-everywhere-opensource-src-4.8.5_patched/examples/qws/qws.pro
--- qt-everywhere-opensource-src-4.8.5_org/examples/qws/qws.pro	2013-06-07 09:16:41.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/examples/qws/qws.pro	2014-04-18 16:03:29.969416947 +0400
@@ -1,7 +1,7 @@
 TEMPLATE      = subdirs
 # no /dev/fbX
 !qnx:!vxworks:SUBDIRS = framebuffer
-SUBDIRS      += mousecalibration simpledecoration
+SUBDIRS      += mousecalibration
 
 # install
 sources.files = $$SOURCES $$HEADERS $$RESOURCES $$FORMS README *.pro
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-arm-s3c/qmake.conf qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-arm-s3c/qmake.conf
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-arm-s3c/qmake.conf	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-arm-s3c/qmake.conf	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,21 @@
+#
+# qmake configuration for building with arm-unknown-linux-gnueabi-g++
+#
+
+include(../../common/g++.conf)
+include(../../common/linux.conf)
+include(../../common/qws.conf)
+
+# modifications to g++.conf
+QMAKE_CC                = arm-unknown-linux-gnueabi-gcc
+QMAKE_CXX               = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK              = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK_SHLIB        = arm-unknown-linux-gnueabi-g++
+
+# modifications to linux.conf
+QMAKE_AR                = arm-unknown-linux-gnueabi-ar cqs
+QMAKE_OBJCOPY           = arm-unknown-linux-gnueabi-objcopy
+QMAKE_STRIP             = arm-unknown-linux-gnueabi-strip
+
+load(qt_config)
+
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-arm-s3c/qplatformdefs.h qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-arm-s3c/qplatformdefs.h
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-arm-s3c/qplatformdefs.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-arm-s3c/qplatformdefs.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the qmake spec of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at http://www.qtsoftware.com/contact.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "../../linux-g++/qplatformdefs.h"
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-at91sam926x/qmake.conf qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-at91sam926x/qmake.conf
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-at91sam926x/qmake.conf	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-at91sam926x/qmake.conf	2014-04-18 17:04:08.421635617 +0400
@@ -0,0 +1,22 @@
+#
+# qmake configuration for building with arm-unknown-linux-gnueabi-g++
+#
+include(../../common/linux.conf)
+include(../../common/gcc-base-unix.conf)
+include(../../common/g++-unix.conf)
+include(../../common/qws.conf)
+
+
+# modifications to g++.conf
+QMAKE_CC                = arm-unknown-linux-gnueabi-gcc
+QMAKE_CXX               = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK              = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK_SHLIB        = arm-unknown-linux-gnueabi-g++
+
+# modifications to linux.conf
+QMAKE_AR                = arm-unknown-linux-gnueabi-ar cqs
+QMAKE_OBJCOPY           = arm-unknown-linux-gnueabi-objcopy
+QMAKE_STRIP             = arm-unknown-linux-gnueabi-strip
+
+load(qt_config)
+
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-at91sam926x/qplatformdefs.h qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-at91sam926x/qplatformdefs.h
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-at91sam926x/qplatformdefs.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-at91sam926x/qplatformdefs.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the qmake spec of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at http://www.qtsoftware.com/contact.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "../../linux-g++/qplatformdefs.h"
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-omap3-g++/qmake.conf qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-omap3-g++/qmake.conf
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-omap3-g++/qmake.conf	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-omap3-g++/qmake.conf	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,69 @@
+#
+# qmake configuration for building with linux-omap3-g++
+#
+include(../../common/g++.conf)
+include(../../common/linux.conf)
+include(../../common/qws.conf)
+
+#------------------------------------------------------------------------------
+# Configuration Settings
+#
+# *** YOU MUST MODIFY THE FOLLOWING SETTINGS FOR YOUR SYSTEM ***
+#
+# By default, these settings read their values from environment variables.
+# You may choose to set the relevant environment variables prior to running
+# "make" instead of setting them here.
+#------------------------------------------------------------------------------
+#
+# QMAKE_CSTOOL_DIR  : Location of CodeSourcery 2008q1 Toolset
+# QMAKE_GFX_SDK_DIR : Location of your graphics SDK directory
+# QMAKE_GFX_ES_DIR  : Graphics SDK sub-directory that contains your OpenGL
+#                     libraries.  This should be "gfx_rel" if you have ES 3.x
+#                     silicon, and "gfx_rel_es2.x" if you have ES 2.x silicon.
+#
+QMAKE_CSTOOL_DIR  = 
+QMAKE_GFX_SDK_DIR = 
+QMAKE_GFX_ES_DIR  = 
+
+#------------------------------------------------------------------------------
+# Modifications to g++.conf
+#------------------------------------------------------------------------------
+# Compiler Flags to take advantage of the ARM Cortex-A8 architecture
+#
+# Change the next two lines to efficiently compile Qt for ARM generation if it
+#     is other than Cortex-A8
+#
+QMAKE_CFLAGS_RELEASE   = -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+QMAKE_CXXFLAGS_RELEASE = -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+
+#------------------------------------------------------------------------------
+# It should be ok to leave the remaining settings unmodified
+#------------------------------------------------------------------------------
+
+# Toolchain
+QMAKE_CSTOOL_BIN = $$QMAKE_CSTOOL_DIR/bin
+
+QMAKE_CC         = arm-unknown-linux-gnueabi-gcc
+QMAKE_CXX        = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK       = arm-unknown-linux-gnueabi-g++
+QMAKE_LINK_SHLIB = arm-unknown-linux-gnueabi-g++
+QMAKE_AR         = arm-unknown-linux-gnueabi-ar cqs
+QMAKE_OBJCOPY    = arm-unknown-linux-gnueabi-objcopy
+QMAKE_STRIP      = arm-unknown-linux-gnueabi-strip
+
+# Search Paths
+#QMAKE_INCDIR  = $$QMAKE_GFX_SDK_DIR/GFX_Linux_SDK/OGLES2/SDKPackage/Builds/OGLES2/Include
+#QMAKE_INCDIR += $$QMAKE_GFX_SDK_DIR/GFX_Linux_SDK/OGLES2/SDKPackage/Builds/OGLES2/LinuxOMAP3/Include
+#QMAKE_INCDIR += $$QMAKE_GFX_SDK_DIR/GFX_Linux_SDK/OGLES/SDKPackage/Builds/OGLES/Include
+#QMAKE_INCDIR += $$QMAKE_GFX_SDK_DIR/include
+#QMAKE_INCDIR += $$QMAKE_GFX_SDK_DIR/GFX_Linux_SDK/OVG/SDKPackage/Builds/OVG/Include
+#QMAKE_LIBDIR  = $$QMAKE_GFX_SDK_DIR/$$QMAKE_GFX_ES_DIR
+
+# Specify additional libraries to link
+QMAKE_LIBS_EGL          = -lEGL -lIMGegl -lsrv_um
+QMAKE_LIBS_OPENGL_ES1   = $$QMAKE_LIBS_EGL -lGLES_CM 
+QMAKE_LIBS_OPENGL_ES1CL = $$QMAKE_LIBS_OPENGL_ES1
+QMAKE_LIBS_OPENGL_ES2   = $$QMAKE_LIBS_EGL -lGLESv2 
+QMAKE_LIBS_OPENVG       = $$QMAKE_LIBS_EGL -lOpenVG -lOpenVGU
+
+load(qt_config)
diff -uNr qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-omap3-g++/qplatformdefs.h qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-omap3-g++/qplatformdefs.h
--- qt-everywhere-opensource-src-4.8.5_org/mkspecs/qws/linux-omap3-g++/qplatformdefs.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/mkspecs/qws/linux-omap3-g++/qplatformdefs.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1 @@
+#include "../../linux-g++/qplatformdefs.h"
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/3rdparty/powervr/wsegl2/pvr2d.h qt-everywhere-opensource-src-4.8.5_patched/src/3rdparty/powervr/wsegl2/pvr2d.h
--- qt-everywhere-opensource-src-4.8.5_org/src/3rdparty/powervr/wsegl2/pvr2d.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/3rdparty/powervr/wsegl2/pvr2d.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,669 @@
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+/******************************************************************************
+Modifications :-
+$Log: pvr2d.h $
+
+ --- Revision Logs Removed --- 
+******************************************************************************/
+
+#ifndef _PVR2D_H_
+#define _PVR2D_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+/* PVR2D Platform-specific definitions */
+#if defined (__linux__)
+#define PVR2D_EXPORT __attribute__((visibility("default")))
+#define PVR2D_IMPORT
+#else
+#define PVR2D_EXPORT
+#define PVR2D_IMPORT
+#endif
+
+/* PVR2D header revision */
+#define PVR2D_REV_MAJOR		3
+#define PVR2D_REV_MINOR		5
+
+/* Basic types */
+typedef enum
+{
+	PVR2D_FALSE = 0,
+	PVR2D_TRUE
+} PVR2D_BOOL;
+
+typedef void* PVR2D_HANDLE;
+
+typedef char             PVR2D_CHAR,	*PVR2D_PCHAR;
+typedef unsigned char    PVR2D_UCHAR,	*PVR2D_PUCHAR;
+typedef int              PVR2D_INT,		*PVR2D_PINT;
+typedef unsigned int     PVR2D_UINT,	*PVR2D_PUINT;
+typedef long             PVR2D_LONG,	*PVR2D_PLONG;
+typedef unsigned long    PVR2D_ULONG,	*PVR2D_PULONG;
+
+typedef void             PVR2D_VOID,	*PVR2D_PVOID;
+
+
+/* error codes */
+typedef enum
+{
+	PVR2D_OK = 0,
+	PVR2DERROR_INVALID_PARAMETER = -1,
+	PVR2DERROR_DEVICE_UNAVAILABLE = -2,
+	PVR2DERROR_INVALID_CONTEXT = -3,
+	PVR2DERROR_MEMORY_UNAVAILABLE = -4,
+	PVR2DERROR_DEVICE_NOT_PRESENT = -5,
+	PVR2DERROR_IOCTL_ERROR = -6,
+	PVR2DERROR_GENERIC_ERROR = -7,
+	PVR2DERROR_BLT_NOTCOMPLETE = -8,
+	PVR2DERROR_HW_FEATURE_NOT_SUPPORTED = -9,
+	PVR2DERROR_NOT_YET_IMPLEMENTED = -10,
+	PVR2DERROR_MAPPING_FAILED = -11
+}PVR2DERROR;
+
+/* 32 bit PVR2D pixel format specifier */
+typedef unsigned long PVR2DFORMAT;
+
+/* Standard PVR2D pixel formats */
+#define	PVR2D_1BPP						0x00UL // 1bpp mask surface or palletized 1 bit source with 2x32 bit CLUT
+#define	PVR2D_RGB565					0x01UL // Common rgb 565 format
+#define	PVR2D_ARGB4444					0x02UL // Common argb 4444 format
+#define	PVR2D_RGB888					0x03UL // Common rgb 888 format (not supported)
+#define	PVR2D_ARGB8888					0x04UL // Common argb 8888 format
+#define	PVR2D_ARGB1555					0x05UL // Common argb 1555 format
+#define	PVR2D_ALPHA8					0x06UL // Alpha-only 8 bit per pixel (used with a constant fill colour)
+#define	PVR2D_ALPHA4					0x07UL // Alpha-only 4 bits per pixel (used with a constant fill colour)
+#define	PVR2D_PAL2						0x08UL // Palletized 2 bit format (requires   4x32 bit CLUT)
+#define	PVR2D_PAL4						0x09UL // Palletized 4 bit format (requires  16x32 bit CLUT)
+#define	PVR2D_PAL8						0x0AUL // Palletized 8 bit format (requires 256x32 bit CLUT)
+#define PVR2D_U8						0x10UL // monochrome unsigned 8 bit
+#define PVR2D_U88						0x11UL // monochrome unsigned 16 bit
+#define PVR2D_S8						0x12UL // signed 8 bit
+#define PVR2D_YUV422_YUYV				0x13UL // YUV 422 low-high byte order Y0UY1V
+#define PVR2D_YUV422_UYVY				0x14UL // YUV 422 low-high byte order UY0VY1
+#define PVR2D_YUV422_YVYU				0x15UL // YUV 422 low-high byte order Y0VY1U
+#define PVR2D_YUV422_VYUY				0x16UL // YUV 422 low-high byte order VY0UY1
+#define PVR2D_YUV420_2PLANE				0x17UL // YUV420 2 Plane
+#define PVR2D_YUV420_3PLANE				0x18UL // YUV420 3 Plane
+#define PVR2D_2101010ARGB				0x19UL // 32 bit 2 10 10 10 
+#define PVR2D_888RSGSBS					0x1AUL
+#define PVR2D_16BPP_RAW					0x1BUL // 16 bit raw (no format conversion)
+#define PVR2D_32BPP_RAW					0x1CUL // 32 bit raw
+#define PVR2D_64BPP_RAW					0x1DUL // 64 bit raw
+#define PVR2D_128BPP_RAW				0x1EUL // 128 bit raw
+
+#define	PVR2D_NO_OF_FORMATS				0x1FUL
+
+/* Format modifier bit field (DstFormat and SrcFormat bits 16..23) */
+#define PVR2D_FORMAT_MASK				0x0000FFFFUL	// PVR2D Format bits
+#define PVR2D_FORMAT_LAYOUT_MASK		0x000F0000UL	// Format layout (strided / twiddled / tiled)
+#define PVR2D_FORMAT_FLAGS_MASK			0x0FF00000UL	// Surface Flags mask
+
+/* Layout */
+#define PVR2D_FORMAT_LAYOUT_SHIFT		16
+#define PVR2D_FORMAT_LAYOUT_STRIDED		0x00000000UL
+#define PVR2D_FORMAT_LAYOUT_TILED		0x00010000UL
+#define PVR2D_FORMAT_LAYOUT_TWIDDLED	0x00020000UL
+
+/*
+	PVR2D_SURFACE_PDUMP
+	This flag requests a surface pdump, to capture the pixel state after host writes.
+	Not needed if the surface state has resulted from previous SGX 2D/3D core writes.
+*/
+#define PVR2D_SURFACE_PDUMP				0x00100000UL	// calls PVRSRVPDumpMem to capture the surface (pdump builds only) 
+
+/*
+	Low level 3D format extension - for blts via the 3D core only.
+	If the top bit of the format field is set then PVR2D reads it as a PVRSRV_PIXEL_FORMAT.
+	The outcome is hardware dependant.
+	There is no guarantee that any specific PVRSRV format will be supported.
+*/
+#define PVR2D_FORMAT_PVRSRV				0x80000000
+
+/* wrap surface type */
+typedef enum
+{
+	PVR2D_WRAPFLAG_NONCONTIGUOUS = 0,
+	PVR2D_WRAPFLAG_CONTIGUOUS = 1,
+
+}PVR2DWRAPFLAGS;
+
+#define	PVR2D_CONTEXT_FLAGS_PRIORITY_MASK			0x00000003
+
+#define	PVR2D_CONTEXT_FLAGS_LOW_PRIORITY_CONTEXT	1
+#define	PVR2D_CONTEXT_FLAGS_NORMAL_PRIORITY_CONTEXT	0
+#define	PVR2D_CONTEXT_FLAGS_HIGH_PRIORITY_CONTEXT	2
+
+/* flags for control information of additional blits */
+typedef enum
+{
+	PVR2D_BLIT_DISABLE_ALL					= 0x00000000,	/* disable all additional controls */
+	PVR2D_BLIT_CK_ENABLE					= 0x00000001,	/* enable colour key */
+	PVR2D_BLIT_GLOBAL_ALPHA_ENABLE			= 0x00000002,	/* enable standard global alpha */
+	PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE	= 0x00000004,	/* enable per-pixel alpha bleding */
+	PVR2D_BLIT_PAT_SURFACE_ENABLE			= 0x00000008,	/* enable pattern surf (disable fill) */
+	PVR2D_BLIT_FULLY_SPECIFIED_ALPHA_ENABLE	= 0x00000010,	/* enable fully specified alpha */
+	PVR2D_BLIT_ROT_90						= 0x00000020,	/* apply 90 degree rotation to the blt */
+	PVR2D_BLIT_ROT_180						= 0x00000040,	/* apply 180 degree rotation to the blt */
+	PVR2D_BLIT_ROT_270						= 0x00000080,	/* apply 270 degree rotation to the blt */
+	PVR2D_BLIT_COPYORDER_TL2BR				= 0x00000100,	/* copy order overrides */
+	PVR2D_BLIT_COPYORDER_BR2TL				= 0x00000200,
+	PVR2D_BLIT_COPYORDER_TR2BL				= 0x00000400,
+	PVR2D_BLIT_COPYORDER_BL2TR				= 0x00000800,
+	PVR2D_BLIT_COLKEY_SOURCE				= 0x00001000,	/* Key colour is on the source surface */
+	PVR2D_BLIT_COLKEY_DEST					= 0x00002000,	/* Key colour is on the destination surface */
+	PVR2D_BLIT_COLKEY_MASKED				= 0x00004000,	/* Mask enabled for colour key */
+	PVR2D_BLIT_COLKEY_OP_PASS				= 0x00008000,	/* Colour key op = pass */
+	PVR2D_BLIT_COLKEY_OP_REJECT				= 0x00010000,	/* Colour key op = reject */
+	PVR2D_BLIT_PATH_2DCORE					= 0x00100000,	/* Blt via dedicated 2D Core or PTLA */
+	PVR2D_BLIT_PATH_3DCORE					= 0x00200000,	/* Blt via 3D Core */
+	PVR2D_BLIT_PATH_SWBLT					= 0x00400000,	/* Blt via host software */
+	PVR2D_BLIT_NO_SRC_SYNC_INFO				= 0x00800000,	/* Dont send a source sync info*/
+	PVR2D_BLIT_ISSUE_STATUS_UPDATES			= 0x01000000,	/* Issue status updates */
+
+} PVR2DBLITFLAGS;
+
+/* standard alpha-blending functions, AlphaBlendingFunc field of PVR2DBLTINFO */
+typedef enum
+{
+	PVR2D_ALPHA_OP_SRC_DSTINV = 1,	/* source alpha : Cdst = Csrc*Asrc + Cdst*(1-Asrc) */
+	PVR2D_ALPHA_OP_SRCP_DSTINV = 2	/* premultiplied source alpha : Cdst = Csrc + Cdst*(1-Asrc) */
+} PVR2D_ALPHABLENDFUNC;
+
+/* blend ops for fully specified alpha (SGX 2D Core only) */
+typedef enum
+{
+	PVR2D_BLEND_OP_ZERO = 0,
+	PVR2D_BLEND_OP_ONE = 1,
+	PVR2D_BLEND_OP_SRC = 2,
+	PVR2D_BLEND_OP_DST = 3,
+	PVR2D_BLEND_OP_GLOBAL = 4,
+	PVR2D_BLEND_OP_SRC_PLUS_GLOBAL = 5,
+	PVR2D_BLEND_OP_DST_PLUS_GLOBAL = 6
+}PVR2D_BLEND_OP;
+
+/* SGX 2D Core Fully specified alpha blend :	pAlpha field of PVR2DBLTINFO structure		*/
+/* a fully specified Alpha Blend operation is defined as									*/
+/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (ALPHA_3 * DST (ALPHA))							*/
+/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (ALPHA_4 * DST (RGB))								*/
+/* if the pre-multiplication stage is enabled then the equations become the following:		*/
+/* PRE_MUL     = ((SRC(A)) * (Global Alpha Value))											*/
+/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (PRE_MUL * DST (ALPHA))							*/
+/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (PRE_MUL * DST (RGB))								*/
+/* if the transparent source alpha stage is enabled then a source alpha of zero forces the	*/
+/* source to be transparent for that pixel regardless of the blend equation being used.		*/
+typedef struct _PVR2D_ALPHABLT
+{
+	PVR2D_BLEND_OP	eAlpha1;
+	PVR2D_BOOL		bAlpha1Invert;
+	PVR2D_BLEND_OP	eAlpha2;
+	PVR2D_BOOL		bAlpha2Invert;
+	PVR2D_BLEND_OP	eAlpha3;
+	PVR2D_BOOL		bAlpha3Invert;
+	PVR2D_BLEND_OP	eAlpha4;
+	PVR2D_BOOL		bAlpha4Invert;
+	PVR2D_BOOL		bPremulAlpha;			/* enable pre-multiplication stage */
+	PVR2D_BOOL		bTransAlpha;			/* enable transparent source alpha stage */
+	PVR2D_BOOL		bUpdateAlphaLookup;		/* enable and update the 1555-Lookup alpha table */
+	PVR2D_UCHAR		uAlphaLookup0;			/* 8 bit alpha when A=0 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uAlphaLookup1;			/* 8 bit alpha when A=1 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uGlobalRGB;				/* Global Alpha Value for RGB, 0=transparent 255=opaque */
+	PVR2D_UCHAR		uGlobalA;				/* Global Alpha Value for Alpha */
+
+} PVR2D_ALPHABLT, *PPVR2D_ALPHABLT;
+
+
+/* surface memory info structure */
+typedef struct _PVR2DMEMINFO
+{
+	PVR2D_VOID			*pBase;
+	PVR2D_ULONG			ui32MemSize;
+	PVR2D_ULONG			ui32DevAddr;
+	PVR2D_ULONG			ulFlags;
+	PVR2D_VOID			*hPrivateData;
+	PVR2D_VOID			*hPrivateMapData;
+
+}PVR2DMEMINFO, *PPVR2DMEMINFO;
+
+
+#define PVR2D_MAX_DEVICE_NAME 20
+
+typedef struct _PVR2DDEVICEINFO
+{
+	PVR2D_ULONG		ulDevID;
+	PVR2D_CHAR		szDeviceName[PVR2D_MAX_DEVICE_NAME];
+}PVR2DDEVICEINFO;
+
+
+typedef struct _PVR2DISPLAYINFO
+{
+	PVR2D_ULONG	ulMaxFlipChains;
+	PVR2D_ULONG	ulMaxBuffersInChain;
+	PVR2DFORMAT	eFormat;
+	PVR2D_ULONG	ulWidth;
+	PVR2D_ULONG	ulHeight;
+	PVR2D_LONG	lStride;
+	PVR2D_ULONG	ulMinFlipInterval;
+	PVR2D_ULONG	ulMaxFlipInterval;
+
+}PVR2DDISPLAYINFO;
+
+
+typedef struct _PVR2MISCDISPLAYINFO
+{
+	PVR2D_ULONG ulPhysicalWidthmm;
+	PVR2D_ULONG ulPhysicalHeightmm;
+	PVR2D_ULONG ulUnused[10];
+
+}PVR2DMISCDISPLAYINFO;
+
+
+typedef struct _PVR2DBLTINFO
+{
+	PVR2D_ULONG		CopyCode;			/* rop code  */
+	PVR2D_ULONG		Colour;				/* fill colour */
+	PVR2D_ULONG		ColourKey;			/* colour key argb8888 (see CKEY_ defs below) */
+	PVR2D_UCHAR		GlobalAlphaValue;	/* global alpha blending */
+	PVR2D_UCHAR		AlphaBlendingFunc;	/* per-pixel alpha-blending function */
+
+	PVR2DBLITFLAGS	BlitFlags;			/* additional blit control information */
+
+	PVR2DMEMINFO	*pDstMemInfo;		/* destination memory */
+	PVR2D_ULONG		DstOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		DstStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		DstX, DstY;			/* pixel offset from start of dest surface to start of blt rectangle */
+	PVR2D_LONG		DSizeX,DSizeY;		/* blt size */
+	PVR2DFORMAT		DstFormat;			/* dest format */
+	PVR2D_ULONG		DstSurfWidth;		/* size of dest surface in pixels */
+	PVR2D_ULONG		DstSurfHeight;		/* size of dest surface in pixels */
+
+	PVR2DMEMINFO	*pSrcMemInfo;		/* source mem, (source fields are also used for patterns) */
+	PVR2D_ULONG		SrcOffset;			/* byte offset from start of allocation to src/pat surface pixel 0,0 */
+	PVR2D_LONG		SrcStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		SrcX, SrcY;			/* pixel offset from start of surface to start of source rectangle */
+										/* for patterns this is the start offset within the pattern */
+	PVR2D_LONG		SizeX,SizeY;		/* source rectangle size or pattern size in pixels */
+	PVR2DFORMAT		SrcFormat;			/* source/pattern format */
+	PVR2DMEMINFO	*pPalMemInfo;		/* source/pattern palette memory containing argb8888 colour table */
+	PVR2D_ULONG		PalOffset;			/* byte offset from start of allocation to start of palette */
+	PVR2D_ULONG		SrcSurfWidth;		/* size of source surface in pixels */
+	PVR2D_ULONG		SrcSurfHeight;		/* size of source surface in pixels */
+
+	PVR2DMEMINFO	*pMaskMemInfo;		/* mask memory, 1bpp format implied */
+	PVR2D_ULONG		MaskOffset;			/* byte offset from start of allocation to mask surface pixel 0,0 */
+	PVR2D_LONG		MaskStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		MaskX, MaskY;		/* mask rect top left (mask size = blt size) */
+	PVR2D_ULONG		MaskSurfWidth;		/* size of mask surface in pixels */
+	PVR2D_ULONG		MaskSurfHeight;		/* size of mask surface in pixels */
+	
+	PPVR2D_ALPHABLT pAlpha;				/* fully specified alpha blend (2DCore only) */
+	
+	PVR2D_ULONG		uSrcChromaPlane1;	/* mem offset from start of source alloc to chroma plane 1 */
+	PVR2D_ULONG		uSrcChromaPlane2;	/* mem offset from start of source alloc to chroma plane 2 */
+	PVR2D_ULONG		uDstChromaPlane1;	/* mem offset from start of dest alloc to chroma plane 1 */
+	PVR2D_ULONG		uDstChromaPlane2;	/* mem offset from start of dest alloc to chroma plane 2 */
+	
+	PVR2D_ULONG		ColourKeyMask;		/* 32 bit colour key mask, only valid when PVR2D_BLIT_COLKEY_MASKED is set */
+
+}PVR2DBLTINFO, *PPVR2DBLTINFO;
+
+typedef struct _PVR2DRECT
+{
+	PVR2D_LONG left, top;
+	PVR2D_LONG right, bottom;
+} PVR2DRECT;
+
+typedef struct
+{
+	PVR2DMEMINFO	*pSurfMemInfo;		/* surface memory */
+	PVR2D_ULONG		SurfOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		Stride;				/* signed stride */
+	PVR2DFORMAT		Format;				/* format */
+	PVR2D_ULONG		SurfWidth;			/* surface width in pixels */
+	PVR2D_ULONG		SurfHeight;			/* surface height in pixels */
+
+} PVR2D_SURFACE, *PPVR2D_SURFACE;
+
+typedef struct
+{
+	PVR2D_ULONG		uChromaPlane1;		/* YUV multiplane - byte offset from start of alloc to chroma plane 1 */
+	PVR2D_ULONG		uChromaPlane2;		/* YUV multiplane - byte offset from start of alloc to chroma plane 2 */
+	PVR2D_LONG		Reserved[2];		/* Reserved, must be zero */
+
+} PVR2D_SURFACE_EXT, *PPVR2D_SURFACE_EXT;
+
+typedef struct
+{
+	PVR2D_ULONG		*pUseCode;					/* USSE code */
+	PVR2D_ULONG		UseCodeSize;				/* usse code size in bytes */
+
+} PVR2D_USECODE, *PPVR2D_USECODE;
+
+typedef struct
+{
+	PVR2D_SURFACE			sDst;				/* destination surface */
+	PVR2D_SURFACE			sSrc;				/* source surface */
+	PVR2DRECT				rcDest;				/* destination rectangle */
+	PVR2DRECT				rcSource;			/* source rectangle */
+	PVR2D_HANDLE			hUseCode;			/* custom USE code (NULL implies source copy) */
+	PVR2D_ULONG				UseParams[2];		/* per-blt params for use code */
+
+} PVR2D_3DBLT, *PPVR2D_3DBLT;
+
+typedef struct
+{
+	PVR2D_SURFACE			sDst;						/* destination surface */
+	PVR2DRECT				rcDest;						/* destination rectangle; scaling is supported */
+	PVR2D_SURFACE			sSrc;						/* source surface */
+	PVR2DRECT				rcSource;					/* source rectangle; scaling is supported */
+	PPVR2D_SURFACE			pSrc2;						/* optional second source surface (NULL if not required) */
+	PVR2DRECT*				prcSource2;					/* optional pSrc2 rectangle */
+	PVR2D_HANDLE			hUseCode;					/* custom USSE shader code (NULL implies default source copy) */
+	PVR2D_ULONG				UseParams[2];				/* per-blt params for usse code */
+	PVR2D_ULONG				uiNumTemporaryRegisters;	/* no. of temporary registers used in custom shader code */
+	PVR2D_BOOL				bDisableDestInput;			/* set true if the destination is output only */
+	PPVR2D_SURFACE_EXT		pDstExt;					/* Extended format params for dest */
+	PPVR2D_SURFACE_EXT		pSrcExt[2];					/* Extended format params for source 1 and 2 */
+	PVR2D_LONG				Reserved[4];				/* Reserved, must be zero */
+
+} PVR2D_3DBLT_EXT, *PPVR2D_3DBLT_EXT;
+
+
+#define MAKE_COPY_BLIT(src,soff,dest,doff,sx,sy,dx,dy,sz)
+
+typedef void* PVR2DCONTEXTHANDLE;
+typedef void* PVR2DFLIPCHAINHANDLE;
+
+
+// CopyCode field of PVR2DBLTINFO structure:
+// the CopyCode field of the PVR2DBLTINFO structure should contain a rop3 or rop4 code.
+// a rop3 is an 8 bit code that describes a blt with three inputs : source dest and pattern
+// rop4 is a 16 bit code that describes a blt with four inputs : source dest pattern and mask
+// common rop3 codes are defined below
+// a colour fill blt is processed in the pattern channel as a constant colour with a rop code of 0xF0
+// PVR2D_BLIT_PAT_SURFACE_ENABLE defines whether the pattern channel is a surface or a fill colour.
+// a rop4 is defined by two rop3 codes, and the 1 bit-per-pixel mask surface defines which is used.
+// a common rop4 is 0xAAF0 which is the mask copy blt used for text glyphs.
+// CopyCode is taken to be a rop4 when pMaskMemInfo is non zero, otherwise it is assumed to be a rop3
+// use the PVR2DMASKROP4 macro below to construct a rop4 from two rop3's
+// rop3a is the rop used when mask pixel = 1, and rop3b when mask = 0
+#define PVR2DROP4(rop3b, rop3a)			((rop3b<<8)|rop3a)
+
+/* common rop codes */
+#define PVR2DROPclear				0x00       /* 0 (whiteness) */
+#define PVR2DROPset					0xFF       /* 1 (blackness) */
+#define PVR2DROPnoop				0xAA       /* dst (used for masked blts) */
+
+/* source and  dest rop codes */
+#define PVR2DROPand					0x88       /* src AND dst */
+#define PVR2DROPandReverse			0x44       /* src AND NOT dst */
+#define PVR2DROPcopy				0xCC       /* src (used for source copy and alpha blts) */
+#define PVR2DROPandInverted			0x22       /* NOT src AND dst */
+#define PVR2DROPxor					0x66       /* src XOR dst */
+#define PVR2DROPor					0xEE       /* src OR dst */
+#define PVR2DROPnor					0x11       /* NOT src AND NOT dst */
+#define PVR2DROPequiv				0x99       /* NOT src XOR dst */
+#define PVR2DROPinvert				0x55       /* NOT dst */
+#define PVR2DROPorReverse			0xDD       /* src OR NOT dst */
+#define PVR2DROPcopyInverted		0x33       /* NOT src */
+#define PVR2DROPorInverted			0xBB       /* NOT src OR dst */
+#define PVR2DROPnand				0x77       /* NOT src OR NOT dst */
+
+/* pattern rop codes */
+#define PVR2DPATROPand				0xA0       /* pat AND dst */
+#define PVR2DPATROPandReverse		0x50       /* pat AND NOT dst */
+#define PVR2DPATROPcopy				0xF0       /* pat (used for solid color fills and pattern blts) */
+#define PVR2DPATROPandInverted		0x0A       /* NOT pat AND dst */
+#define PVR2DPATROPxor				0x5A       /* pat XOR dst */
+#define PVR2DPATROPor				0xFA       /* pat OR dst */
+#define PVR2DPATROPnor				0x05       /* NOT pat AND NOT dst */
+#define PVR2DPATROPequiv			0xA5       /* NOT pat XOR dst */
+#define PVR2DPATROPinvert			0x55       /* NOT dst */
+#define PVR2DPATROPorReverse		0xF5       /* pat OR NOT dst */
+#define PVR2DPATROPcopyInverted		0x0F       /* NOT pat */
+#define PVR2DPATROPorInverted		0xAF       /* NOT pat OR dst */
+#define PVR2DPATROPnand				0x5F       /* NOT pat OR NOT dst */
+
+/* common rop4 codes */
+#define PVR2DROP4MaskedCopy              PVR2DROP4(PVR2DROPnoop,PVR2DROPcopy)		/* masked source copy blt (used for rounded window corners etc) */
+#define PVR2DROP4MaskedFill              PVR2DROP4(PVR2DROPnoop,PVR2DPATROPcopy)	/* masked colour fill blt (used for text) */
+
+/* Legacy support */
+#define PVR2DROP3_PATMASK			PVR2DPATROPcopy
+#define PVR2DROP3_SRCMASK			PVR2DROPcopy
+
+/* pixmap memory alignment */
+#define PVR2D_ALIGNMENT_4			4			/* DWORD alignment */
+#define PVR2D_ALIGNMENT_ANY			0			/* no alignment    */
+#define PVR2D_ALIGNMENT_PALETTE		16			/* 16 byte alignment is required for palettes */
+
+/* Heap number for PVR2DGetFrameBuffer */
+#define PVR2D_FB_PRIMARY_SURFACE 0
+
+#define PVR2D_PRESENT_PROPERTY_SRCSTRIDE	(1UL << 0)
+#define PVR2D_PRESENT_PROPERTY_DSTSIZE		(1UL << 1)
+#define PVR2D_PRESENT_PROPERTY_DSTPOS		(1UL << 2)
+#define PVR2D_PRESENT_PROPERTY_CLIPRECTS	(1UL << 3)
+#define PVR2D_PRESENT_PROPERTY_INTERVAL		(1UL << 4)
+
+#define PVR2D_CREATE_FLIPCHAIN_SHARED		(1UL << 0)
+#define PVR2D_CREATE_FLIPCHAIN_QUERY		(1UL << 1)
+#define PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY   (1UL << 2)
+#define PVR2D_CREATE_FLIPCHAIN_AS_BLITCHAIN (1UL << 3)
+
+/* Colour-key colour must be translated into argb8888 format */
+#define CKEY_8888(P)		(P)
+#define CKEY_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CKEY_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CKEY_565(P)			(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+#define CKEY_MASK_8888		0x00FFFFFFUL
+#define CKEY_MASK_4444		0x00F0F0F0UL
+#define CKEY_MASK_1555		0x00F8F8F8UL	/* Alpha is not normally included in the key test */
+#define CKEY_MASK_565		0x00F8FCF8UL
+
+/* Fill colours must be translated into argb8888 format */
+#define CFILL_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CFILL_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CFILL_565(P)		(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+
+/* PVR2DCreateDeviceContext flags */
+#define PVR2D_XSERVER_PROC			0x00000001UL		/*!< Set for the Xserver connection */
+
+/* PVR2DMemAlloc flags */
+#define PVR2D_MEM_UNCACHED			0x00000000UL	/* Default */
+#define PVR2D_MEM_CACHED			0x00000001UL	/* Caller must flush and sync when necessary */
+#define PVR2D_MEM_WRITECOMBINE		0x00000002UL
+
+/* Functions that the library exports */
+
+PVR2D_IMPORT
+int PVR2DEnumerateDevices(PVR2DDEVICEINFO *pDevInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DCreateDeviceContext(PVR2D_ULONG ulDevID,
+									PVR2DCONTEXTHANDLE* phContext,
+									PVR2D_ULONG ulFlags);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DDestroyDeviceContext(PVR2DCONTEXTHANDLE hContext);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetDeviceInfo(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DDISPLAYINFO *pDisplayInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetMiscDisplayInfo(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DMISCDISPLAYINFO *pMiscDisplayInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetScreenMode(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DFORMAT *pFormat,
+							  PVR2D_LONG *plWidth,
+							  PVR2D_LONG *plHeight,
+							  PVR2D_LONG *plStride,
+							  PVR2D_INT *piRefreshRate);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetFrameBuffer(PVR2DCONTEXTHANDLE hContext,
+							   PVR2D_INT nHeap,
+							   PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemAlloc(PVR2DCONTEXTHANDLE hContext,
+						 PVR2D_ULONG ulBytes,
+						 PVR2D_ULONG ulAlign,
+						 PVR2D_ULONG ulFlags,
+						 PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemExport(PVR2DCONTEXTHANDLE hContext,
+						 PVR2D_ULONG ulFlags,
+						 PVR2DMEMINFO *psMemInfo,
+						 PVR2D_HANDLE *phMemHandle);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemWrap(PVR2DCONTEXTHANDLE hContext,
+						PVR2D_VOID *pMem,
+						PVR2D_ULONG ulFlags,
+						PVR2D_ULONG ulBytes,
+						PVR2D_ULONG alPageAddress[],
+						PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemMap(PVR2DCONTEXTHANDLE hContext,
+						PVR2D_ULONG ulFlags,
+						PVR2D_HANDLE hMemHandle,
+						PVR2DMEMINFO **ppsDstMem);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemFree(PVR2DCONTEXTHANDLE hContext,
+						PVR2DMEMINFO *psMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt(PVR2DCONTEXTHANDLE hContext,
+					PVR2DBLTINFO *pBltInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBltClipped(PVR2DCONTEXTHANDLE hContext,
+						   PVR2DBLTINFO *pBltInfo,
+						   PVR2D_ULONG ulNumClipRects,
+						   PVR2DRECT *pClipRects);
+
+PVR2D_EXPORT
+PVR2DERROR PVR2DSet1555Alpha (PVR2DCONTEXTHANDLE hContext,
+							  PVR2D_UCHAR Alpha0, PVR2D_UCHAR Alpha1);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DQueryBlitsComplete(PVR2DCONTEXTHANDLE hContext,
+								   const PVR2DMEMINFO *pMemInfo,
+								   PVR2D_UINT uiWaitForComplete);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DSetPresentBltProperties(PVR2DCONTEXTHANDLE hContext,
+										PVR2D_ULONG ulPropertyMask,
+										PVR2D_LONG lSrcStride,
+										PVR2D_ULONG ulDstWidth,
+										PVR2D_ULONG ulDstHeight,
+										PVR2D_LONG lDstXPos,
+										PVR2D_LONG lDstYPos,
+										PVR2D_ULONG ulNumClipRects,
+										PVR2DRECT *pClipRects,
+										PVR2D_ULONG ulSwapInterval);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DPresentBlt(PVR2DCONTEXTHANDLE hContext,
+						   PVR2DMEMINFO *pMemInfo,
+						   PVR2D_LONG lRenderID);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DCreateFlipChain(PVR2DCONTEXTHANDLE hContext,
+								PVR2D_ULONG ulFlags,
+								PVR2D_ULONG ulNumBuffers,
+								PVR2D_ULONG ulWidth,
+								PVR2D_ULONG ulHeight,
+								PVR2DFORMAT eFormat,
+								PVR2D_LONG *plStride,
+								PVR2D_ULONG *pulFlipChainID,
+								PVR2DFLIPCHAINHANDLE *phFlipChain);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DDestroyFlipChain(PVR2DCONTEXTHANDLE hContext,
+								 PVR2DFLIPCHAINHANDLE hFlipChain);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetFlipChainBuffers(PVR2DCONTEXTHANDLE hContext,
+									PVR2DFLIPCHAINHANDLE hFlipChain,
+									PVR2D_ULONG *pulNumBuffers,
+									PVR2DMEMINFO *psMemInfo[]);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DSetPresentFlipProperties(PVR2DCONTEXTHANDLE hContext,
+										 PVR2DFLIPCHAINHANDLE hFlipChain,
+										 PVR2D_ULONG ulPropertyMask,
+										 PVR2D_LONG lDstXPos,
+										 PVR2D_LONG lDstYPos,
+										 PVR2D_ULONG ulNumClipRects, 
+										 PVR2DRECT *pClipRects,
+										 PVR2D_ULONG ulSwapInterval);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DPresentFlip(PVR2DCONTEXTHANDLE hContext,
+							PVR2DFLIPCHAINHANDLE hFlipChain,
+							PVR2DMEMINFO *psMemInfo,
+							PVR2D_LONG lRenderID);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetAPIRev(PVR2D_LONG *lRevMajor, PVR2D_LONG *lRevMinor);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DLoadUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_UCHAR	*pUseCode,
+									const PVR2D_ULONG UseCodeSize, PVR2D_HANDLE *pUseCodeHandle);
+PVR2D_IMPORT
+PVR2DERROR PVR2DFreeUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_HANDLE hUseCodeHandle);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt3D (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT pBlt3D);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt3DExt (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT_EXT pBlt3D);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* _PVR2D_H_ */
+
+/******************************************************************************
+ End of file (pvr2d.h)
+******************************************************************************/
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/3rdparty/powervr/wsegl2/wsegl.h qt-everywhere-opensource-src-4.8.5_patched/src/3rdparty/powervr/wsegl2/wsegl.h
--- qt-everywhere-opensource-src-4.8.5_org/src/3rdparty/powervr/wsegl2/wsegl.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/3rdparty/powervr/wsegl2/wsegl.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,285 @@
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+#if !defined(__WSEGL_H__)
+#define __WSEGL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+/*
+// WSEGL Platform-specific definitions
+*/
+#if defined(__linux__)
+#define WSEGL_EXPORT __attribute__((visibility("default")))
+#define WSEGL_IMPORT
+#else
+#define WSEGL_EXPORT
+#define WSEGL_IMPORT
+#endif
+
+/*
+// WSEGL API Version Number
+*/
+
+#define WSEGL_VERSION 2
+#define WSEGL_DEFAULT_DISPLAY 0
+#define WSEGL_DEFAULT_NATIVE_ENGINE 0
+
+#define WSEGL_FALSE		0
+#define WSEGL_TRUE		1
+#define WSEGL_NULL		0
+
+#define	WSEGL_UNREFERENCED_PARAMETER(param) (param) = (param)
+
+/*
+// WSEGL handles
+*/
+typedef void *WSEGLDisplayHandle;
+typedef void *WSEGLDrawableHandle;
+
+/*
+// Display capability type
+*/
+typedef enum WSEGLCapsType_TAG
+{
+	WSEGL_NO_CAPS = 0,
+	WSEGL_CAP_MIN_SWAP_INTERVAL = 1, /* System default value = 1 */
+	WSEGL_CAP_MAX_SWAP_INTERVAL = 2, /* System default value = 1 */
+	WSEGL_CAP_WINDOWS_USE_HW_SYNC = 3, /* System default value = 0 (FALSE) */
+	WSEGL_CAP_PIXMAPS_USE_HW_SYNC = 4, /* System default value = 0 (FALSE) */
+
+} WSEGLCapsType;
+
+/*
+// Display capability
+*/
+typedef struct WSEGLCaps_TAG
+{
+	WSEGLCapsType eCapsType;
+	unsigned long ui32CapsValue;
+
+} WSEGLCaps;
+
+/*
+// Drawable type
+*/
+#define WSEGL_NO_DRAWABLE			0x0
+#define WSEGL_DRAWABLE_WINDOW		0x1
+#define WSEGL_DRAWABLE_PIXMAP		0x2
+
+
+/*
+// Pixel format of display/drawable
+*/
+typedef enum WSEGLPixelFormat_TAG
+{
+	/* These must not be re-ordered */
+	WSEGL_PIXELFORMAT_RGB565	= 0,
+	WSEGL_PIXELFORMAT_ARGB4444	= 1,
+	WSEGL_PIXELFORMAT_ARGB8888	= 2,
+	WSEGL_PIXELFORMAT_ARGB1555	= 3,
+	WSEGL_PIXELFORMAT_ABGR8888	= 4,
+	WSEGL_PIXELFORMAT_XBGR8888	= 5,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_PIXELFORMAT_565		= WSEGL_PIXELFORMAT_RGB565,
+	WSEGL_PIXELFORMAT_4444		= WSEGL_PIXELFORMAT_ARGB4444,
+	WSEGL_PIXELFORMAT_8888		= WSEGL_PIXELFORMAT_ARGB8888,
+	WSEGL_PIXELFORMAT_1555		= WSEGL_PIXELFORMAT_ARGB1555,
+
+} WSEGLPixelFormat;
+
+/*
+// Transparent of display/drawable
+*/
+typedef enum WSEGLTransparentType_TAG
+{
+	WSEGL_OPAQUE = 0,
+	WSEGL_COLOR_KEY = 1,
+
+} WSEGLTransparentType;
+
+/*
+// Display/drawable configuration
+*/
+typedef struct WSEGLConfig_TAG
+{
+	/*
+	// Type of drawables this configuration applies to -
+	// OR'd values of drawable types. 
+	*/
+	unsigned long ui32DrawableType;
+
+	/* Pixel format */
+	WSEGLPixelFormat ePixelFormat;
+
+	/* Native Renderable  - set to WSEGL_TRUE if native renderable */
+	unsigned long ulNativeRenderable;
+
+	/* FrameBuffer Level Parameter */
+	unsigned long ulFrameBufferLevel;
+
+	/* Native Visual ID */
+	unsigned long ulNativeVisualID;
+
+	/* Native Visual */
+	void *hNativeVisual;
+
+	/* Transparent Type */
+	WSEGLTransparentType eTransparentType;
+
+	/* Transparent Color - only used if transparent type is COLOR_KEY */
+	unsigned long ulTransparentColor; /* packed as 0x00RRGGBB */
+
+
+} WSEGLConfig;
+
+/*
+// WSEGL errors
+*/
+typedef enum WSEGLError_TAG
+{
+	WSEGL_SUCCESS = 0,
+	WSEGL_CANNOT_INITIALISE = 1,
+	WSEGL_BAD_NATIVE_DISPLAY = 2,
+	WSEGL_BAD_NATIVE_WINDOW = 3,
+	WSEGL_BAD_NATIVE_PIXMAP = 4,
+	WSEGL_BAD_NATIVE_ENGINE = 5,
+	WSEGL_BAD_DRAWABLE = 6,
+	WSEGL_BAD_MATCH = 7,
+	WSEGL_OUT_OF_MEMORY = 8,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_BAD_CONFIG = WSEGL_BAD_MATCH,
+
+} WSEGLError; 
+
+/*
+// Drawable orientation (in degrees anti-clockwise)
+*/
+typedef enum WSEGLRotationAngle_TAG
+{
+	WSEGL_ROTATE_0 = 0,
+	WSEGL_ROTATE_90 = 1,
+	WSEGL_ROTATE_180 = 2,
+	WSEGL_ROTATE_270 = 3
+
+} WSEGLRotationAngle; 
+
+/*
+// Drawable information required by OpenGL-ES driver
+*/
+typedef struct WSEGLDrawableParams_TAG
+{
+	/* Width in pixels of the drawable */
+	unsigned long	ui32Width;
+
+	/* Height in pixels of the drawable */
+	unsigned long	ui32Height;
+
+	/* Stride in pixels of the drawable */
+	unsigned long	ui32Stride;
+
+	/* Pixel format of the drawable */
+	WSEGLPixelFormat	ePixelFormat;
+
+	/* User space cpu virtual address of the drawable */
+	void   			*pvLinearAddress;
+
+	/* HW address of the drawable */
+	unsigned long	ui32HWAddress;
+
+	/* Private data for the drawable */
+	void			*hPrivateData;
+
+
+} WSEGLDrawableParams;
+
+
+/*
+// Table of function pointers that is returned by WSEGL_GetFunctionTablePointer()
+//
+// The first entry in the table is the version number of the wsegl.h header file that
+// the module has been written against, and should therefore be set to WSEGL_VERSION
+*/
+typedef struct WSEGL_FunctionTable_TAG
+{
+	unsigned long ui32WSEGLVersion;
+
+	WSEGLError (*pfnWSEGL_IsDisplayValid)(NativeDisplayType);
+
+	WSEGLError (*pfnWSEGL_InitialiseDisplay)(NativeDisplayType, WSEGLDisplayHandle *, const WSEGLCaps **, WSEGLConfig **);
+
+	WSEGLError (*pfnWSEGL_CloseDisplay)(WSEGLDisplayHandle);
+
+	WSEGLError (*pfnWSEGL_CreateWindowDrawable)(WSEGLDisplayHandle, WSEGLConfig *, WSEGLDrawableHandle *, NativeWindowType, WSEGLRotationAngle *);
+
+	WSEGLError (*pfnWSEGL_CreatePixmapDrawable)(WSEGLDisplayHandle, WSEGLConfig *, WSEGLDrawableHandle *, NativePixmapType, WSEGLRotationAngle *);
+
+	WSEGLError (*pfnWSEGL_DeleteDrawable)(WSEGLDrawableHandle);
+
+	WSEGLError (*pfnWSEGL_SwapDrawable)(WSEGLDrawableHandle, unsigned long);
+
+	WSEGLError (*pfnWSEGL_SwapControlInterval)(WSEGLDrawableHandle, unsigned long);
+
+	WSEGLError (*pfnWSEGL_WaitNative)(WSEGLDrawableHandle, unsigned long);
+
+	WSEGLError (*pfnWSEGL_CopyFromDrawable)(WSEGLDrawableHandle, NativePixmapType);
+
+	WSEGLError (*pfnWSEGL_CopyFromPBuffer)(void *, unsigned long, unsigned long, unsigned long, WSEGLPixelFormat, NativePixmapType);
+
+	WSEGLError (*pfnWSEGL_GetDrawableParameters)(WSEGLDrawableHandle, WSEGLDrawableParams *, WSEGLDrawableParams *);
+
+	WSEGLError (*pfnWSEGL_ConnectDrawable)(WSEGLDrawableHandle);
+
+	WSEGLError (*pfnWSEGL_DisconnectDrawable)(WSEGLDrawableHandle);
+
+
+} WSEGL_FunctionTable;
+
+
+WSEGL_IMPORT const WSEGL_FunctionTable *WSEGL_GetFunctionTablePointer(void);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* __WSEGL_H__ */
+
+/******************************************************************************
+ End of file (wsegl.h)
+******************************************************************************/
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/corelib/global/qlibraryinfo.cpp qt-everywhere-opensource-src-4.8.5_patched/src/corelib/global/qlibraryinfo.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/corelib/global/qlibraryinfo.cpp	2013-06-07 09:16:52.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/corelib/global/qlibraryinfo.cpp	2014-04-18 16:23:10.341486717 +0400
@@ -54,6 +54,7 @@
 QT_BEGIN_NAMESPACE
 extern QString qmake_libraryInfoFile();
 QT_END_NAMESPACE
+#include <stdlib.h>
 #else
 # include "qcoreapplication.h"
 #endif
@@ -112,6 +113,11 @@
 #ifdef BOOTSTRAPPING
     if(!QFile::exists(qtconfig))
         qtconfig = qmake_libraryInfoFile();
+    if (!QFile::exists(qtconfig)) {
+        QByteArray config = getenv("QT_CONF_PATH");
+        qtconfig = QFile::decodeName(config);
+    }
+
 #else
     if (!QFile::exists(qtconfig) && QCoreApplication::instance()) {
 #ifdef Q_OS_MAC
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/gui/embedded/qscreen_qws.cpp qt-everywhere-opensource-src-4.8.5_patched/src/gui/embedded/qscreen_qws.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/gui/embedded/qscreen_qws.cpp	2013-06-07 09:16:59.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/gui/embedded/qscreen_qws.cpp	2014-04-18 16:02:48.409415164 +0400
@@ -469,6 +469,60 @@
 }
 #endif // QT_QWS_DEPTH_4
 
+#ifdef QT_QWS_DEPTH_2
+static inline void qt_rectfill_gray4(quint8 *dest, quint8 value,
+                                     int x, int y, int width, int height,
+                                     int stride)
+{
+    const int pixelsPerByte = 4;
+    const int alignWidth = qMin(width, (4 - (x & 3)) & 3);
+    const int doAlign = (alignWidth > 0 ? 1 : 0);
+    const int alignStart = pixelsPerByte - 1 - (x & 3);
+    const int alignStop = alignStart - (alignWidth - 1);
+    const quint8 alignMask = ((1 << (2 * alignWidth)) - 1) << (2 * alignStop);
+    const int tailWidth = (width - alignWidth) & 3;
+    const int doTail = (tailWidth > 0 ? 1 : 0);
+    const quint8 tailMask = (1 << (2 * (pixelsPerByte - tailWidth))) - 1;
+    const int width8 = (width - alignWidth) / pixelsPerByte;
+
+    dest += y * stride + x / pixelsPerByte;
+    stride -= (doAlign + width8);
+
+    for (int j = 0; j < height; ++j) {
+        if (doAlign) {
+            *dest = (*dest & ~alignMask) | (value & alignMask);
+            ++dest;
+        }
+        if (width8) {
+            qt_memfill<quint8>(dest, value, width8);
+            dest += width8;
+        }
+        if (doTail)
+            *dest = (*dest & tailMask) | (value & ~tailMask);
+        dest += stride;
+    }
+}
+
+static void solidFill_gray2(QScreen *screen, const QColor &color,
+                            const QRegion &region)
+{
+    quint8 *dest = reinterpret_cast<quint8*>(screen->base());
+    const quint8 c = qGray(color.rgba()) >> 6;
+    const quint8 c8 = (c << 6) | (c << 4) | (c << 2) | c;
+
+    const int stride = screen->linestep();
+    const QVector<QRect> rects = region.rects();
+
+    for (int i = 0; i < rects.size(); ++i) {
+        const QRect r = rects.at(i);
+        qt_rectfill_gray2(dest, c8, r.x(), r.y(), r.width(), r.height(),
+                          stride);
+    }
+}
+
+#endif // QT_QWS_DEPTH_2
+
+
 #ifdef QT_QWS_DEPTH_1
 static inline void qt_rectfill_mono(quint8 *dest, quint8 value,
                                     int x, int y, int width, int height,
@@ -576,6 +630,11 @@
         screen->d_ptr->solidFill = solidFill_gray4;
         break;
 #endif
+#ifdef QT_QWS_DEPTH_2
+    case 2:
+        screen->d_ptr->solidFill = solidFill_gray2;
+        break;
+#endif
 #ifdef QT_QWS_DEPTH_1
     case 1:
         screen->d_ptr->solidFill = solidFill_mono;
@@ -865,6 +924,150 @@
 }
 #endif // QT_QWS_DEPTH_8
 
+#ifdef QT_QWS_DEPTH_2
+
+struct qgray2 { quint8 dummy; } Q_PACKED;
+
+template <typename SRC>
+static inline quint8 qt_convertToGray2(SRC color);
+
+template <>
+inline quint8 qt_convertToGray2(quint32 color)
+{
+    return qGray(color) >> 6;
+}
+
+template <>
+inline quint8 qt_convertToGray2(quint16 color)
+{
+    const int r = (color & 0xf800) >> 11;
+    const int g = (color & 0x07e0) >> 6; // only keep 5 bit
+    const int b = (color & 0x001f);
+    return (r * 11 + g * 16 + b * 5) >> 8;
+}
+
+template <>
+inline quint8 qt_convertToGray2(qrgb444 color)
+{
+    return qt_convertToGray2(quint32(color));
+}
+
+template <>
+inline quint8 qt_convertToGray2(qargb4444 color)
+{
+    return qt_convertToGray2(quint32(color));
+}
+
+template <typename SRC>
+static inline void qt_rectconvert_gray2(qgray2 *dest2, const SRC *src,
+                                        int x, int y, int width, int height,
+                                        int dstStride, int srcStride)
+{
+    const int pixelsPerByte = 4;
+    quint8 *dest8 = reinterpret_cast<quint8*>(dest2)
+                    + y * dstStride + x / pixelsPerByte;
+    const int alignWidth = qMin(width, (4 - (x & 3)) & 3);
+    const int doAlign = (alignWidth > 0 ? 1 : 0);
+    const int alignStart = pixelsPerByte - 1 - (x & 3);
+    const int alignStop = alignStart - (alignWidth - 1);
+    const quint8 alignMask = ((1 << (2 * alignWidth)) - 1) << (2 * alignStop);
+    const int tailWidth = (width - alignWidth) & 3;
+    const int doTail = (tailWidth > 0 ? 1 : 0);
+    const quint8 tailMask = (1 << (2 * (pixelsPerByte - tailWidth))) - 1;
+    const int width8 = (width - alignWidth) / pixelsPerByte;
+
+    srcStride = srcStride / sizeof(SRC) - (width8 * pixelsPerByte + alignWidth);
+    dstStride -= (width8 + doAlign);
+
+    for (int j = 0;  j < height; ++j) {
+        if (doAlign) {
+            quint8 d = *dest8 & ~alignMask;
+            for (int i = alignStart; i >= alignStop; --i)
+                d |= qt_convertToGray2<SRC>(*src++) << (2 * i);
+            *dest8++ = d;
+        }
+        for (int i = 0; i < width8; ++i) {
+            *dest8 = (qt_convertToGray2<SRC>(src[0]) << 6)
+                     | (qt_convertToGray2<SRC>(src[1]) << 4)
+                     | (qt_convertToGray2<SRC>(src[2]) << 2)
+                     | (qt_convertToGray2<SRC>(src[3]));
+            src += 4;
+            ++dest8;
+        }
+        if (doTail) {
+            quint8 d = *dest8 & tailMask;
+            switch (tailWidth) {
+            case 3: d |= qt_convertToGray2<SRC>(src[2]) << 2;
+            case 2: d |= qt_convertToGray2<SRC>(src[1]) << 4;
+            case 1: d |= qt_convertToGray2<SRC>(src[0]) << 6;
+            }
+            *dest8 = d;
+        }
+
+        dest8 += dstStride;
+        src += srcStride;
+    }
+}
+
+template <>
+void qt_rectconvert(qgray2 *dest, const quint32 *src,
+                    int x, int y, int width, int height,
+                    int dstStride, int srcStride)
+{
+    qt_rectconvert_gray2<quint32>(dest, src, x, y, width, height,
+                                  dstStride, srcStride);
+}
+
+template <>
+void qt_rectconvert(qgray2 *dest, const quint16 *src,
+                    int x, int y, int width, int height,
+                    int dstStride, int srcStride)
+{
+    qt_rectconvert_gray2<quint16>(dest, src, x, y, width, height,
+                                  dstStride, srcStride);
+}
+
+template <>
+void qt_rectconvert(qgray2 *dest, const qrgb444 *src,
+                    int x, int y, int width, int height,
+                    int dstStride, int srcStride)
+{
+    qt_rectconvert_gray2<qrgb444>(dest, src, x, y, width, height,
+                                  dstStride, srcStride);
+}
+
+template <>
+void qt_rectconvert(qgray2 *dest, const qargb4444 *src,
+                    int x, int y, int width, int height,
+                    int dstStride, int srcStride)
+{
+    qt_rectconvert_gray2<qargb4444>(dest, src, x, y, width, height,
+                                    dstStride, srcStride);
+}
+
+static void blit_2(QScreen *screen, const QImage &image,
+                   const QPoint &topLeft, const QRegion &region)
+{
+    switch (image.format()) {
+    case QImage::Format_ARGB32_Premultiplied:
+        blit_template<qgray2, quint32>(screen, image, topLeft, region);
+        return;
+    case QImage::Format_RGB16:
+        blit_template<qgray2, quint16>(screen, image, topLeft, region);
+        return;
+    case QImage::Format_RGB444:
+        blit_template<qgray2, qrgb444>(screen, image, topLeft, region);
+        return;
+    case QImage::Format_ARGB4444_Premultiplied:
+        blit_template<qgray2, qargb4444>(screen, image, topLeft, region);
+        return;
+    default:
+        qCritical("blit_2(): Image format %d not supported!", image.format());
+    }
+}
+#endif // QT_QWS_DEPTH_2
+
+
 #ifdef QT_QWS_DEPTH_4
 
 struct qgray4 { quint8 dummy; } Q_PACKED;
@@ -1259,6 +1462,11 @@
         screen->d_ptr->blit = blit_4;
         break;
 #endif
+#ifdef QT_QWS_DEPTH_2
+    case 2:
+        screen->d_ptr->blit = blit_2;
+        break;
+#endif
 #ifdef QT_QWS_DEPTH_1
     case 1:
         screen->d_ptr->blit = blit_1;
@@ -2146,6 +2354,8 @@
         }
     } else if (d == 4) {
         ret = qGray(r, g, b) >> 4;
+    } else if (d == 2) {
+        ret = qGray(r, g, b) >> 16;
     } else if (d == 1) {
         ret = qGray(r, g, b) >= 128;
     } else {
@@ -2216,6 +2426,10 @@
     } else if(d==1) {
         return true;
 #endif
+#ifdef QT_QWS_DEPTH_2
+    } else if(d==2) {
+        return true;
+#endif
 #ifdef QT_QWS_DEPTH_4
     } else if(d==4) {
         return true;
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/gui/embedded/qwindowsystem_qws.cpp qt-everywhere-opensource-src-4.8.5_patched/src/gui/embedded/qwindowsystem_qws.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/gui/embedded/qwindowsystem_qws.cpp	2013-06-07 09:16:59.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/gui/embedded/qwindowsystem_qws.cpp	2014-04-18 16:57:42.449610603 +0400
@@ -3499,7 +3499,7 @@
         }
 
 #ifdef QT_QWS_CLIENTBLIT
-#ifdef QT_NO_QWS_CURSOR
+//#ifdef QT_NO_QWS_CURSOR
         // This optimization only really works when there isn't a crazy cursor
         // wizzing around.
         QRegion directPaint = (r - transparentRegion); // in gloal coords
@@ -3510,7 +3510,7 @@
             w->client()->sendRegionEvent(w->winId(), directPaint,
                                          QWSRegionEvent::DirectPaint, id);
         }
-#endif
+//#endif
 #endif
     }
 
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/gfxdrivers/powervr/pvreglscreen/pvreglscreen.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/gfxdrivers/powervr/pvreglscreen/pvreglscreen.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/gfxdrivers/powervr/pvreglscreen/pvreglscreen.cpp	2013-06-07 09:17:00.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/gfxdrivers/powervr/pvreglscreen/pvreglscreen.cpp	2014-04-18 16:55:46.241604307 +0400
@@ -85,6 +85,9 @@
 bool PvrEglScreen::initDevice()
 {
     openTty();
+#ifndef QT_NO_QWS_CURSOR
+    QScreenCursor::initSoftwareCursor();
+#endif
     return true;
 }
 
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c qt-everywhere-opensource-src-4.8.5_patched/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2013-06-07 09:17:00.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2014-04-18 16:54:07.633598676 +0400
@@ -378,6 +378,21 @@
 
     return WSEGL_SUCCESS;
 }
+/* Function stub for ConnectDrawable() */
+static WSEGLError wseglConnectDrawable(WSEGLDrawableHandle hDrawable)
+{
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
+    return WSEGL_SUCCESS;
+}
+
+/* Function stub for DisconnectDrawable() */
+static WSEGLError wseglDisconnectDrawable(WSEGLDrawableHandle hDrawable)
+{
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
+    return WSEGL_SUCCESS;
+}
+
+
 
 static WSEGL_FunctionTable const wseglFunctions = {
     WSEGL_VERSION,
@@ -392,7 +407,9 @@
     wseglWaitNative,
     wseglCopyFromDrawable,
     wseglCopyFromPBuffer,
-    wseglGetDrawableParameters
+    wseglGetDrawableParameters,
+    wseglConnectDrawable,
+    wseglDisconnectDrawable
 };
 
 /* Return the table of WSEGL functions to the EGL implementation */
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdBtns.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,471 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <linux/input.h>
+
+struct SNameToInputBtn
+{
+    const char* m_pName;
+    unsigned int m_InputBtn;
+};
+
+static SNameToInputBtn sBtnNames[]=
+{
+    { "KEY_RESERVED", KEY_RESERVED },
+    { "KEY_ESC", KEY_ESC },
+    { "KEY_1", KEY_1 },
+    { "KEY_2", KEY_2 },
+    { "KEY_3", KEY_3 },
+    { "KEY_4", KEY_4 },
+    { "KEY_5", KEY_5 },
+    { "KEY_6", KEY_6 },
+    { "KEY_7", KEY_7 },
+    { "KEY_8", KEY_8 },
+    { "KEY_9", KEY_9 },
+    { "KEY_0", KEY_0 },
+    { "KEY_MINUS", KEY_MINUS },
+    { "KEY_EQUAL", KEY_EQUAL },
+    { "KEY_BACKSPACE", KEY_BACKSPACE },
+    { "KEY_TAB", KEY_TAB },
+    { "KEY_Q", KEY_Q },
+    { "KEY_W", KEY_W },
+    { "KEY_E", KEY_E },
+    { "KEY_R", KEY_R },
+    { "KEY_T", KEY_T },
+    { "KEY_Y", KEY_Y },
+    { "KEY_U", KEY_U },
+    { "KEY_I", KEY_I },
+    { "KEY_O", KEY_O },
+    { "KEY_P", KEY_P },
+    { "KEY_LEFTBRACE", KEY_LEFTBRACE },
+    { "KEY_RIGHTBRACE", KEY_RIGHTBRACE },
+    { "KEY_ENTER", KEY_ENTER },
+    { "KEY_LEFTCTRL", KEY_LEFTCTRL },
+    { "KEY_A", KEY_A },
+    { "KEY_S", KEY_S },
+    { "KEY_D", KEY_D },
+    { "KEY_F", KEY_F },
+    { "KEY_G", KEY_G },
+    { "KEY_H", KEY_H },
+    { "KEY_J", KEY_J },
+    { "KEY_K", KEY_K },
+    { "KEY_L", KEY_L },
+    { "KEY_SEMICOLON", KEY_SEMICOLON },
+    { "KEY_APOSTROPHE", KEY_APOSTROPHE },
+    { "KEY_GRAVE", KEY_GRAVE },
+    { "KEY_LEFTSHIFT", KEY_LEFTSHIFT },
+    { "KEY_BACKSLASH", KEY_BACKSLASH },
+    { "KEY_Z", KEY_Z },
+    { "KEY_X", KEY_X },
+    { "KEY_C", KEY_C },
+    { "KEY_V", KEY_V },
+    { "KEY_B", KEY_B },
+    { "KEY_N", KEY_N },
+    { "KEY_M", KEY_M },
+    { "KEY_COMMA", KEY_COMMA },
+    { "KEY_DOT", KEY_DOT },
+    { "KEY_SLASH", KEY_SLASH },
+    { "KEY_RIGHTSHIFT", KEY_RIGHTSHIFT },
+    { "KEY_KPASTERISK", KEY_KPASTERISK },
+    { "KEY_LEFTALT", KEY_LEFTALT },
+    { "KEY_SPACE", KEY_SPACE },
+    { "KEY_CAPSLOCK", KEY_CAPSLOCK },
+    { "KEY_F1", KEY_F1 },
+    { "KEY_F2", KEY_F2 },
+    { "KEY_F3", KEY_F3 },
+    { "KEY_F4", KEY_F4 },
+    { "KEY_F5", KEY_F5 },
+    { "KEY_F6", KEY_F6 },
+    { "KEY_F7", KEY_F7 },
+    { "KEY_F8", KEY_F8 },
+    { "KEY_F9", KEY_F9 },
+    { "KEY_F10", KEY_F10 },
+    { "KEY_NUMLOCK", KEY_NUMLOCK },
+    { "KEY_SCROLLLOCK", KEY_SCROLLLOCK },
+    { "KEY_KP7", KEY_KP7 },
+    { "KEY_KP8", KEY_KP8 },
+    { "KEY_KP9", KEY_KP9 },
+    { "KEY_KPMINUS", KEY_KPMINUS },
+    { "KEY_KP4", KEY_KP4 },
+    { "KEY_KP5", KEY_KP5 },
+    { "KEY_KP6", KEY_KP6 },
+    { "KEY_KPPLUS", KEY_KPPLUS },
+    { "KEY_KP1", KEY_KP1 },
+    { "KEY_KP2", KEY_KP2 },
+    { "KEY_KP3", KEY_KP3 },
+    { "KEY_KP0", KEY_KP0 },
+    { "KEY_KPDOT", KEY_KPDOT },
+    { "KEY_102ND", KEY_102ND },
+    { "KEY_F11", KEY_F11 },
+    { "KEY_F12", KEY_F12 },
+    { "KEY_RO", KEY_RO },
+    { "KEY_KPENTER", KEY_KPENTER },
+    { "KEY_RIGHTCTRL", KEY_RIGHTCTRL },
+    { "KEY_KPSLASH", KEY_KPSLASH },
+    { "KEY_SYSRQ", KEY_SYSRQ },
+    { "KEY_RIGHTALT", KEY_RIGHTALT },
+    { "KEY_LINEFEED", KEY_LINEFEED },
+    { "KEY_HOME", KEY_HOME },
+    { "KEY_UP", KEY_UP },
+    { "KEY_PAGEUP", KEY_PAGEUP },
+    { "KEY_LEFT", KEY_LEFT },
+    { "KEY_RIGHT", KEY_RIGHT },
+    { "KEY_END", KEY_END },
+    { "KEY_DOWN", KEY_DOWN },
+    { "KEY_PAGEDOWN", KEY_PAGEDOWN },
+    { "KEY_INSERT", KEY_INSERT },
+    { "KEY_DELETE", KEY_DELETE },
+    { "KEY_MACRO", KEY_MACRO },
+    { "KEY_MUTE", KEY_MUTE },
+    { "KEY_VOLUMEDOWN", KEY_VOLUMEDOWN },
+    { "KEY_VOLUMEUP", KEY_VOLUMEUP },
+    { "KEY_POWER", KEY_POWER },
+    { "KEY_KPEQUAL", KEY_KPEQUAL },
+    { "KEY_KPPLUSMINUS", KEY_KPPLUSMINUS },
+    { "KEY_PAUSE", KEY_PAUSE },
+    { "KEY_SCALE", KEY_SCALE },
+    { "KEY_KPCOMMA", KEY_KPCOMMA },
+    { "KEY_HANGEUL", KEY_HANGEUL },
+    { "KEY_HANGUEL", KEY_HANGUEL },
+    { "KEY_HANJA", KEY_HANJA },
+    { "KEY_YEN", KEY_YEN },
+    { "KEY_LEFTMETA", KEY_LEFTMETA },
+    { "KEY_RIGHTMETA", KEY_RIGHTMETA },
+    { "KEY_COMPOSE", KEY_COMPOSE },
+    { "KEY_STOP", KEY_STOP },
+    { "KEY_AGAIN", KEY_AGAIN },
+    { "KEY_PROPS", KEY_PROPS },
+    { "KEY_UNDO", KEY_UNDO },
+    { "KEY_FRONT", KEY_FRONT },
+    { "KEY_COPY", KEY_COPY },
+    { "KEY_OPEN", KEY_OPEN },
+    { "KEY_PASTE", KEY_PASTE },
+    { "KEY_FIND", KEY_FIND },
+    { "KEY_CUT", KEY_CUT },
+    { "KEY_HELP", KEY_HELP },
+    { "KEY_MENU", KEY_MENU },
+    { "KEY_CALC", KEY_CALC },
+    { "KEY_SETUP", KEY_SETUP },
+    { "KEY_SLEEP", KEY_SLEEP },
+    { "KEY_WAKEUP", KEY_WAKEUP },
+    { "KEY_FILE", KEY_FILE },
+    { "KEY_SENDFILE", KEY_SENDFILE },
+    { "KEY_DELETEFILE", KEY_DELETEFILE },
+    { "KEY_XFER", KEY_XFER },
+    { "KEY_PROG1", KEY_PROG1 },
+    { "KEY_PROG2", KEY_PROG2 },
+    { "KEY_WWW", KEY_WWW },
+    { "KEY_MSDOS", KEY_MSDOS },
+    { "KEY_COFFEE", KEY_COFFEE },
+    { "KEY_SCREENLOCK", KEY_SCREENLOCK },
+    { "KEY_DIRECTION", KEY_DIRECTION },
+    { "KEY_CYCLEWINDOWS", KEY_CYCLEWINDOWS },
+    { "KEY_MAIL", KEY_MAIL },
+    { "KEY_BOOKMARKS", KEY_BOOKMARKS },
+    { "KEY_COMPUTER", KEY_COMPUTER },
+    { "KEY_BACK", KEY_BACK },
+    { "KEY_FORWARD", KEY_FORWARD },
+    { "KEY_CLOSECD", KEY_CLOSECD },
+    { "KEY_EJECTCD", KEY_EJECTCD },
+    { "KEY_EJECTCLOSECD", KEY_EJECTCLOSECD },
+    { "KEY_NEXTSONG", KEY_NEXTSONG },
+    { "KEY_PLAYPAUSE", KEY_PLAYPAUSE },
+    { "KEY_PREVIOUSSONG", KEY_PREVIOUSSONG },
+    { "KEY_STOPCD", KEY_STOPCD },
+    { "KEY_RECORD", KEY_RECORD },
+    { "KEY_REWIND", KEY_REWIND },
+    { "KEY_PHONE", KEY_PHONE },
+    { "KEY_ISO", KEY_ISO },
+    { "KEY_CONFIG", KEY_CONFIG },
+    { "KEY_HOMEPAGE", KEY_HOMEPAGE },
+    { "KEY_REFRESH", KEY_REFRESH },
+    { "KEY_EXIT", KEY_EXIT },
+    { "KEY_MOVE", KEY_MOVE },
+    { "KEY_EDIT", KEY_EDIT },
+    { "KEY_SCROLLUP", KEY_SCROLLUP },
+    { "KEY_SCROLLDOWN", KEY_SCROLLDOWN },
+    { "KEY_KPLEFTPAREN", KEY_KPLEFTPAREN },
+    { "KEY_KPRIGHTPAREN", KEY_KPRIGHTPAREN },
+    { "KEY_NEW", KEY_NEW },
+    { "KEY_REDO", KEY_REDO },
+    { "KEY_F13", KEY_F13 },
+    { "KEY_F14", KEY_F14 },
+    { "KEY_F15", KEY_F15 },
+    { "KEY_F16", KEY_F16 },
+    { "KEY_F17", KEY_F17 },
+    { "KEY_F18", KEY_F18 },
+    { "KEY_F19", KEY_F19 },
+    { "KEY_F20", KEY_F20 },
+    { "KEY_F21", KEY_F21 },
+    { "KEY_F22", KEY_F22 },
+    { "KEY_F23", KEY_F23 },
+    { "KEY_F24", KEY_F24 },
+    { "KEY_PLAYCD", KEY_PLAYCD },
+    { "KEY_PAUSECD", KEY_PAUSECD },
+    { "KEY_PROG3", KEY_PROG3 },
+    { "KEY_PROG4", KEY_PROG4 },
+    { "KEY_DASHBOARD", KEY_DASHBOARD },
+    { "KEY_SUSPEND", KEY_SUSPEND },
+    { "KEY_CLOSE", KEY_CLOSE },
+    { "KEY_PLAY", KEY_PLAY },
+    { "KEY_FASTFORWARD", KEY_FASTFORWARD },
+    { "KEY_BASSBOOST", KEY_BASSBOOST },
+    { "KEY_PRINT", KEY_PRINT },
+    { "KEY_HP", KEY_HP },
+    { "KEY_CAMERA", KEY_CAMERA },
+    { "KEY_SOUND", KEY_SOUND },
+    { "KEY_QUESTION", KEY_QUESTION },
+    { "KEY_EMAIL", KEY_EMAIL },
+    { "KEY_CHAT", KEY_CHAT },
+    { "KEY_SEARCH", KEY_SEARCH },
+    { "KEY_CONNECT", KEY_CONNECT },
+    { "KEY_FINANCE", KEY_FINANCE },
+    { "KEY_SPORT", KEY_SPORT },
+    { "KEY_SHOP", KEY_SHOP },
+    { "KEY_ALTERASE", KEY_ALTERASE },
+    { "KEY_CANCEL", KEY_CANCEL },
+    { "KEY_BRIGHTNESSDOWN", KEY_BRIGHTNESSDOWN },
+    { "KEY_BRIGHTNESSUP", KEY_BRIGHTNESSUP },
+    { "KEY_MEDIA", KEY_MEDIA },
+    { "KEY_SWITCHVIDEOMODE", KEY_SWITCHVIDEOMODE },
+    { "KEY_KBDILLUMTOGGLE", KEY_KBDILLUMTOGGLE },
+    { "KEY_KBDILLUMDOWN", KEY_KBDILLUMDOWN },
+    { "KEY_KBDILLUMUP", KEY_KBDILLUMUP },
+    { "KEY_SEND", KEY_SEND },
+    { "KEY_REPLY", KEY_REPLY },
+    { "KEY_FORWARDMAIL", KEY_FORWARDMAIL },
+    { "KEY_SAVE", KEY_SAVE },
+    { "KEY_DOCUMENTS", KEY_DOCUMENTS },
+    { "KEY_BATTERY", KEY_BATTERY },
+    { "KEY_BLUETOOTH", KEY_BLUETOOTH },
+    { "KEY_WLAN", KEY_WLAN },
+    { "KEY_UWB", KEY_UWB },
+    { "KEY_UNKNOWN", KEY_UNKNOWN },
+    { "KEY_VIDEO_NEXT", KEY_VIDEO_NEXT },
+    { "KEY_VIDEO_PREV", KEY_VIDEO_PREV },
+    { "KEY_BRIGHTNESS_CYCLE", KEY_BRIGHTNESS_CYCLE },
+    { "KEY_BRIGHTNESS_ZERO", KEY_BRIGHTNESS_ZERO },
+    { "KEY_DISPLAY_OFF", KEY_DISPLAY_OFF },
+    { "KEY_WIMAX", KEY_WIMAX },
+    { "BTN_MISC", BTN_MISC },
+    { "BTN_0", BTN_0 },
+    { "BTN_1", BTN_1 },
+    { "BTN_2", BTN_2 },
+    { "BTN_3", BTN_3 },
+    { "BTN_4", BTN_4 },
+    { "BTN_5", BTN_5 },
+    { "BTN_6", BTN_6 },
+    { "BTN_7", BTN_7 },
+    { "BTN_8", BTN_8 },
+    { "BTN_9", BTN_9 },
+    { "BTN_MOUSE", BTN_MOUSE },
+    { "BTN_LEFT", BTN_LEFT },
+    { "BTN_RIGHT", BTN_RIGHT },
+    { "BTN_MIDDLE", BTN_MIDDLE },
+    { "BTN_SIDE", BTN_SIDE },
+    { "BTN_EXTRA", BTN_EXTRA },
+    { "BTN_FORWARD", BTN_FORWARD },
+    { "BTN_BACK", BTN_BACK },
+    { "BTN_TASK", BTN_TASK },
+    { "BTN_JOYSTICK", BTN_JOYSTICK },
+    { "BTN_TRIGGER", BTN_TRIGGER },
+    { "BTN_THUMB", BTN_THUMB },
+    { "BTN_THUMB2", BTN_THUMB2 },
+    { "BTN_TOP", BTN_TOP },
+    { "BTN_TOP2", BTN_TOP2 },
+    { "BTN_PINKIE", BTN_PINKIE },
+    { "BTN_BASE", BTN_BASE },
+    { "BTN_BASE2", BTN_BASE2 },
+    { "BTN_BASE3", BTN_BASE3 },
+    { "BTN_BASE4", BTN_BASE4 },
+    { "BTN_BASE5", BTN_BASE5 },
+    { "BTN_BASE6", BTN_BASE6 },
+    { "BTN_DEAD", BTN_DEAD },
+    { "BTN_GAMEPAD", BTN_GAMEPAD },
+    { "BTN_A", BTN_A },
+    { "BTN_B", BTN_B },
+    { "BTN_C", BTN_C },
+    { "BTN_X", BTN_X },
+    { "BTN_Y", BTN_Y },
+    { "BTN_Z", BTN_Z },
+    { "BTN_TL", BTN_TL },
+    { "BTN_TR", BTN_TR },
+    { "BTN_TL2", BTN_TL2 },
+    { "BTN_TR2", BTN_TR2 },
+    { "BTN_SELECT", BTN_SELECT },
+    { "BTN_START", BTN_START },
+    { "BTN_MODE", BTN_MODE },
+    { "BTN_THUMBL", BTN_THUMBL },
+    { "BTN_THUMBR", BTN_THUMBR },
+    { "BTN_DIGI", BTN_DIGI },
+    { "BTN_TOOL_PEN", BTN_TOOL_PEN },
+    { "BTN_TOOL_RUBBER", BTN_TOOL_RUBBER },
+    { "BTN_TOOL_BRUSH", BTN_TOOL_BRUSH },
+    { "BTN_TOOL_PENCIL", BTN_TOOL_PENCIL },
+    { "BTN_TOOL_AIRBRUSH", BTN_TOOL_AIRBRUSH },
+    { "BTN_TOOL_FINGER", BTN_TOOL_FINGER },
+    { "BTN_TOOL_MOUSE", BTN_TOOL_MOUSE },
+    { "BTN_TOOL_LENS", BTN_TOOL_LENS },
+    { "BTN_TOUCH", BTN_TOUCH },
+    { "BTN_STYLUS", BTN_STYLUS },
+    { "BTN_STYLUS2", BTN_STYLUS2 },
+    { "BTN_TOOL_DOUBLETAP", BTN_TOOL_DOUBLETAP },
+    { "BTN_TOOL_TRIPLETAP", BTN_TOOL_TRIPLETAP },
+    { "BTN_TOOL_QUADTAP", BTN_TOOL_QUADTAP },
+    { "BTN_WHEEL", BTN_WHEEL },
+    { "BTN_GEAR_DOWN", BTN_GEAR_DOWN },
+    { "BTN_GEAR_UP", BTN_GEAR_UP },
+    { "KEY_OK", KEY_OK },
+    { "KEY_SELECT", KEY_SELECT },
+    { "KEY_GOTO", KEY_GOTO },
+    { "KEY_CLEAR", KEY_CLEAR },
+    { "KEY_POWER2", KEY_POWER2 },
+    { "KEY_OPTION", KEY_OPTION },
+    { "KEY_INFO", KEY_INFO },
+    { "KEY_TIME", KEY_TIME },
+    { "KEY_VENDOR", KEY_VENDOR },
+    { "KEY_ARCHIVE", KEY_ARCHIVE },
+    { "KEY_PROGRAM", KEY_PROGRAM },
+    { "KEY_CHANNEL", KEY_CHANNEL },
+    { "KEY_FAVORITES", KEY_FAVORITES },
+    { "KEY_EPG", KEY_EPG },
+    { "KEY_PVR", KEY_PVR },
+    { "KEY_MHP", KEY_MHP },
+    { "KEY_LANGUAGE", KEY_LANGUAGE },
+    { "KEY_TITLE", KEY_TITLE },
+    { "KEY_SUBTITLE", KEY_SUBTITLE },
+    { "KEY_ANGLE", KEY_ANGLE },
+    { "KEY_ZOOM", KEY_ZOOM },
+    { "KEY_MODE", KEY_MODE },
+    { "KEY_KEYBOARD", KEY_KEYBOARD },
+    { "KEY_SCREEN", KEY_SCREEN },
+    { "KEY_PC", KEY_PC },
+    { "KEY_TV", KEY_TV },
+    { "KEY_TV2", KEY_TV2 },
+    { "KEY_VCR", KEY_VCR },
+    { "KEY_VCR2", KEY_VCR2 },
+    { "KEY_SAT", KEY_SAT },
+    { "KEY_SAT2", KEY_SAT2 },
+    { "KEY_CD", KEY_CD },
+    { "KEY_TAPE", KEY_TAPE },
+    { "KEY_RADIO", KEY_RADIO },
+    { "KEY_TUNER", KEY_TUNER },
+    { "KEY_PLAYER", KEY_PLAYER },
+    { "KEY_TEXT", KEY_TEXT },
+    { "KEY_DVD", KEY_DVD },
+    { "KEY_AUX", KEY_AUX },
+    { "KEY_MP3", KEY_MP3 },
+    { "KEY_AUDIO", KEY_AUDIO },
+    { "KEY_VIDEO", KEY_VIDEO },
+    { "KEY_DIRECTORY", KEY_DIRECTORY },
+    { "KEY_LIST", KEY_LIST },
+    { "KEY_MEMO", KEY_MEMO },
+    { "KEY_CALENDAR", KEY_CALENDAR },
+    { "KEY_RED", KEY_RED },
+    { "KEY_GREEN", KEY_GREEN },
+    { "KEY_YELLOW", KEY_YELLOW },
+    { "KEY_BLUE", KEY_BLUE },
+    { "KEY_CHANNELUP", KEY_CHANNELUP },
+    { "KEY_CHANNELDOWN", KEY_CHANNELDOWN },
+    { "KEY_FIRST", KEY_FIRST },
+    { "KEY_LAST", KEY_LAST },
+    { "KEY_AB", KEY_AB },
+    { "KEY_NEXT", KEY_NEXT },
+    { "KEY_RESTART", KEY_RESTART },
+    { "KEY_SLOW", KEY_SLOW },
+    { "KEY_SHUFFLE", KEY_SHUFFLE },
+    { "KEY_BREAK", KEY_BREAK },
+    { "KEY_PREVIOUS", KEY_PREVIOUS },
+    { "KEY_DIGITS", KEY_DIGITS },
+    { "KEY_TEEN", KEY_TEEN },
+    { "KEY_TWEN", KEY_TWEN },
+    { "KEY_VIDEOPHONE", KEY_VIDEOPHONE },
+    { "KEY_GAMES", KEY_GAMES },
+    { "KEY_ZOOMIN", KEY_ZOOMIN },
+    { "KEY_ZOOMOUT", KEY_ZOOMOUT },
+    { "KEY_ZOOMRESET", KEY_ZOOMRESET },
+    { "KEY_WORDPROCESSOR", KEY_WORDPROCESSOR },
+    { "KEY_EDITOR", KEY_EDITOR },
+    { "KEY_SPREADSHEET", KEY_SPREADSHEET },
+    { "KEY_GRAPHICSEDITOR", KEY_GRAPHICSEDITOR },
+    { "KEY_PRESENTATION", KEY_PRESENTATION },
+    { "KEY_DATABASE", KEY_DATABASE },
+    { "KEY_NEWS", KEY_NEWS },
+    { "KEY_VOICEMAIL", KEY_VOICEMAIL },
+    { "KEY_ADDRESSBOOK", KEY_ADDRESSBOOK },
+    { "KEY_MESSENGER", KEY_MESSENGER },
+    { "KEY_DISPLAYTOGGLE", KEY_DISPLAYTOGGLE },
+    { "KEY_SPELLCHECK", KEY_SPELLCHECK },
+    { "KEY_LOGOFF", KEY_LOGOFF },
+    { "KEY_DOLLAR", KEY_DOLLAR },
+    { "KEY_EURO", KEY_EURO },
+    { "KEY_FRAMEBACK", KEY_FRAMEBACK },
+    { "KEY_FRAMEFORWARD", KEY_FRAMEFORWARD },
+    { "KEY_CONTEXT_MENU", KEY_CONTEXT_MENU },
+    { "KEY_MEDIA_REPEAT", KEY_MEDIA_REPEAT },
+    { "KEY_DEL_EOL", KEY_DEL_EOL },
+    { "KEY_DEL_EOS", KEY_DEL_EOS },
+    { "KEY_INS_LINE", KEY_INS_LINE },
+    { "KEY_DEL_LINE", KEY_DEL_LINE },
+    { "KEY_FN", KEY_FN },
+    { "KEY_FN_ESC", KEY_FN_ESC },
+    { "KEY_FN_F1", KEY_FN_F1 },
+    { "KEY_FN_F2", KEY_FN_F2 },
+    { "KEY_FN_F3", KEY_FN_F3 },
+    { "KEY_FN_F4", KEY_FN_F4 },
+    { "KEY_FN_F5", KEY_FN_F5 },
+    { "KEY_FN_F6", KEY_FN_F6 },
+    { "KEY_FN_F7", KEY_FN_F7 },
+    { "KEY_FN_F8", KEY_FN_F8 },
+    { "KEY_FN_F9", KEY_FN_F9 },
+    { "KEY_FN_F10", KEY_FN_F10 },
+    { "KEY_FN_F11", KEY_FN_F11 },
+    { "KEY_FN_F12", KEY_FN_F12 },
+    { "KEY_FN_1", KEY_FN_1 },
+    { "KEY_FN_2", KEY_FN_2 },
+    { "KEY_FN_D", KEY_FN_D },
+    { "KEY_FN_E", KEY_FN_E },
+    { "KEY_FN_F", KEY_FN_F },
+    { "KEY_FN_S", KEY_FN_S },
+    { "KEY_FN_B", KEY_FN_B },
+    { "KEY_BRL_DOT1", KEY_BRL_DOT1 },
+    { "KEY_BRL_DOT2", KEY_BRL_DOT2 },
+    { "KEY_BRL_DOT3", KEY_BRL_DOT3 },
+    { "KEY_BRL_DOT4", KEY_BRL_DOT4 },
+    { "KEY_BRL_DOT5", KEY_BRL_DOT5 },
+    { "KEY_BRL_DOT6", KEY_BRL_DOT6 },
+    { "KEY_BRL_DOT7", KEY_BRL_DOT7 },
+    { "KEY_BRL_DOT8", KEY_BRL_DOT8 },
+    { "KEY_BRL_DOT9", KEY_BRL_DOT9 },
+    { "KEY_BRL_DOT10", KEY_BRL_DOT10 },
+    { "KEY_NUMERIC_0", KEY_NUMERIC_0 },
+    { "KEY_NUMERIC_1", KEY_NUMERIC_1 },
+    { "KEY_NUMERIC_2", KEY_NUMERIC_2 },
+    { "KEY_NUMERIC_3", KEY_NUMERIC_3 },
+    { "KEY_NUMERIC_4", KEY_NUMERIC_4 },
+    { "KEY_NUMERIC_5", KEY_NUMERIC_5 },
+    { "KEY_NUMERIC_6", KEY_NUMERIC_6 },
+    { "KEY_NUMERIC_7", KEY_NUMERIC_7 },
+    { "KEY_NUMERIC_8", KEY_NUMERIC_8 },
+    { "KEY_NUMERIC_9", KEY_NUMERIC_9 },
+    { "KEY_NUMERIC_STAR", KEY_NUMERIC_STAR },
+    { "KEY_NUMERIC_POUND", KEY_NUMERIC_POUND }
+};
+
+unsigned int AT91SAM926xKbdHandler::get_input_btn(const char* pBtnName)
+{
+    QString lBtnName=QString(pBtnName).trimmed().toUpper();
+    for(unsigned int iBtnName=0;iBtnName<(sizeof(sBtnNames)/sizeof(struct SNameToInputBtn));++iBtnName)
+    {
+	if(lBtnName == sBtnNames[iBtnName].m_pName) return sBtnNames[iBtnName].m_InputBtn;
+    };
+    return 0xFFFFFFFF;
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdConfig.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,234 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <QFile>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+bool AT91SAM926xKbdHandler::loadConfig(QString& configPath)
+{
+    QFile xmlFile(configPath);
+
+    if (!xmlFile.exists() || (xmlFile.error() != QFile::NoError))
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "ERROR {AT91SAM926xKbdHandler::loadConfig} : Unable to open config file" << configPath.toAscii().data() << "!" << endl;
+	#endif
+	return false;
+    };
+
+    m_keys.clear();
+    m_Modifiers.clear();
+
+    xmlFile.open(QIODevice::ReadOnly);
+    QXmlStreamReader reader(&xmlFile);
+
+    while(!reader.atEnd() && !reader.hasError())
+    {
+	QXmlStreamReader::TokenType token = reader.readNext();
+
+	/* If token is just StartDocument, we'll go to next.*/
+	if(token == QXmlStreamReader::StartDocument) continue;
+
+	if(token == QXmlStreamReader::StartElement)
+	{
+		QString lname=reader.name().toString().trimmed().toLower();
+		if(lname == "keyboard") continue;
+		if(lname == "key") parseKey(reader);
+		if(lname == "modifier") parseModifier(reader);
+		if(lname == "buzzer") parseBuzzer(reader);
+	};
+    };
+
+    return true;
+}
+
+
+void AT91SAM926xKbdHandler::parseKey(QXmlStreamReader& reader)
+{
+    AT91SAM926xKbdHandler::CKey lKey;
+
+    lKey.m_btn=0xFFFFFFFF;
+    lKey.m_qt_key=Qt::Key_unknown;
+    lKey.m_unicode=0xFFFF;
+    lKey.m_buzzer=false;
+    lKey.m_led=QString();
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "key") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "scancode") parseScancode(reader, lKey.m_btn);
+		if(lname == "qtkey") parseQtKey(reader, lKey.m_qt_key);
+		if(lname == "unicode") parseUnicode(reader, lKey.m_unicode);
+		if(lname == "buzzer") parseBuzzer(reader, lKey.m_buzzer);
+		if(lname == "led") parseLed(reader, lKey.m_led);
+	};
+	reader.readNext();
+	lname=reader.name().toString().trimmed().toLower();
+    };
+
+    m_keys << lKey;
+}
+
+
+void AT91SAM926xKbdHandler::parseModifier(QXmlStreamReader& reader)
+{
+    AT91SAM926xKbdHandler::CModifier lModifier;
+
+    lModifier.m_btn=0xFFFFFFFF;
+    lModifier.m_qt_modifier=Qt::NoModifier;
+    lModifier.m_buzzer=false;
+    lModifier.m_led=QString();
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "modifier") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "scancode") parseScancode(reader, lModifier.m_btn);
+		if(lname == "modkey") parseQtModKey(reader, lModifier.m_qt_modifier);
+		if(lname == "buzzer") parseBuzzer(reader, lModifier.m_buzzer);
+		if(lname == "led") parseLed(reader, lModifier.m_led);
+	};
+	reader.readNext();
+	QString lname=reader.name().toString().trimmed().toLower();
+    };
+
+    m_Modifiers << lModifier;
+}
+
+
+void AT91SAM926xKbdHandler::parseBuzzer(QXmlStreamReader& reader)
+{
+    QString lBuzzer;
+
+    reader.readNext();
+    QString lname=reader.name().toString().trimmed().toLower();
+    while( !( (reader.tokenType() == QXmlStreamReader::EndElement) && (lname == "buzzer") ) )
+    {
+	if(reader.tokenType() == QXmlStreamReader::StartElement)
+	{
+		if(lname == "path")
+		{
+			if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+			reader.readNext();
+			
+			if(reader.tokenType() != QXmlStreamReader::Characters) return;
+			lBuzzer=reader.text().toString().trimmed().toAscii().data();
+			
+			#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+			cout << "INFO {AT91SAM926xKbdHandler::parseBuzzer(1)}:" << "path:" << lBuzzer.toAscii().data() << endl;
+			#endif
+		};
+	};
+	reader.readNext();
+	lname=reader.name().toString().trimmed().toLower();
+    };
+    m_buzzer=lBuzzer;
+}
+
+
+void AT91SAM926xKbdHandler::parseScancode(QXmlStreamReader& reader, unsigned int& _Key)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _Key=get_input_btn(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseScancode}:" << "\tScancode:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _Key << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseQtKey(QXmlStreamReader& reader, unsigned int& _QtKey)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _QtKey=get_qt_key(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseQtKey}:" << "\tQtKey:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _QtKey << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseQtModKey(QXmlStreamReader& reader, Qt::KeyboardModifiers& _QtKey)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _QtKey=get_qt_modifier(reader.text().toString().toAscii().data());
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseQtKey}:" << "\tQtKey:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << dec << _QtKey << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseUnicode(QXmlStreamReader& reader, unsigned short& _Unicode)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    sscanf(reader.text().toString().trimmed().toAscii().data(), "0x%8X", &_Unicode);
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseUnicode}:" << "\tUnicode:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: 0x" << hex << (int)_Unicode << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseBuzzer(QXmlStreamReader& reader, bool& _Buzzer)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    if(reader.text().toString().trimmed().toLower() == "on") _Buzzer=true;
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseBuzzer(2)}:" << "\tBuzzer:" << reader.text().toString().trimmed().toAscii().data()
+         << endl << "\tValue: " << ((_Buzzer)? "true": "false") << endl;
+    #endif
+}
+
+
+void AT91SAM926xKbdHandler::parseLed(QXmlStreamReader& reader, QString& _Led)
+{
+    if(reader.tokenType() != QXmlStreamReader::StartElement) return;
+    reader.readNext();
+
+    if(reader.tokenType() != QXmlStreamReader::Characters) return;
+    _Led=reader.text().toString().trimmed();
+
+    #ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::parseLed}:" << "Led:" << reader.text().toString().trimmed().toAscii().data() << endl;
+    #endif
+}
+
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdControls.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,263 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+
+int AT91SAM926xKbdHandler::set_buzzer()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_buzzer == QString()) return -1;
+
+    if(m_fdBuzzer < 0)
+    {
+	int fdBuzzer;
+	if((fdBuzzer=::open(m_buzzer.trimmed().toAscii().data(), O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::set_buzzer (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+	m_fdBuzzer=fdBuzzer;
+    };
+
+    if(write(m_fdBuzzer, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::set_buzzer (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return -1;
+    };
+
+    return 0;
+}
+
+int AT91SAM926xKbdHandler::clear_buzzer()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_buzzer == QString()) return -1;
+
+    if(m_fdBuzzer < 0)
+    {
+	int fdBuzzer;
+	if((fdBuzzer=::open(m_buzzer.trimmed().toAscii().data(), O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::clear_buzzer (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+	m_fdBuzzer=fdBuzzer;
+    };
+
+    if(write(m_fdBuzzer, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_buzzer.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::clear_buzzer (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return -1;
+    };
+
+    return 0;
+}
+
+AT91SAM926xKbdHandler::CKey::CKey() : m_fd(-1)
+{
+}
+
+AT91SAM926xKbdHandler::CKey::~CKey()
+{
+    if(m_fd<0) ::close(m_fd);
+}
+
+
+bool AT91SAM926xKbdHandler::CKey::set_led()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CKey::set_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CKey::set_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+bool AT91SAM926xKbdHandler::CKey::clear_led()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CKey::clear_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CKey::clear_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+AT91SAM926xKbdHandler::CModifier::CModifier() : m_fd(-1)
+{
+}
+
+AT91SAM926xKbdHandler::CModifier::~CModifier()
+{
+    if(m_fd<0) ::close(m_fd);
+}
+
+
+bool AT91SAM926xKbdHandler::CModifier::set_led()
+{
+    static char lCommand[]= {'2', '5', '5', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CModifier::set_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CModifier::set_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+bool AT91SAM926xKbdHandler::CModifier::clear_led()
+{
+    static char lCommand[]= {'0', '\n'};
+
+    if(m_led == QString()) return false;
+
+    if(m_fd < 0)
+    {
+	int fd;
+	if((fd=::open(m_led.trimmed().toAscii().data(),O_WRONLY))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::CModifier::clear_led (1) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return false;
+	};
+	m_fd=fd;
+    };
+
+    if(write(m_fd, lCommand, sizeof(lCommand)) < 0)
+    {
+	#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	cout << "Can't open led device " << m_led.trimmed().toAscii().data() << "!" << endl;
+	cout << "{AT91SAM926xKbdHandler::CModifier::clear_led (2) } Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+	#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+	return false;
+    };
+
+    return true;
+}
+
+
+AT91SAM926xKbdHandler::CModifier* AT91SAM926xKbdHandler::getModifier(unsigned int _btn)
+{
+    for (int i = 0; i < m_Modifiers.size(); ++i)
+    {
+	AT91SAM926xKbdHandler::CModifier& lModifier=const_cast<AT91SAM926xKbdHandler::CModifier&>(m_Modifiers.at(i));
+	if(lModifier.m_btn == _btn) return &lModifier;
+    }
+    return NULL;
+}
+
+
+AT91SAM926xKbdHandler::CKey* AT91SAM926xKbdHandler::getKey(unsigned int _btn)
+{
+    for (int i = 0; i < m_keys.size(); ++i)
+    {
+	AT91SAM926xKbdHandler::CKey& lKey=const_cast<AT91SAM926xKbdHandler::CKey&>(m_keys.at(i));
+	if(lKey.m_btn == _btn) return &lKey;
+    }
+   return NULL;
+}
+
+
+
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,47 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+
+#include "AT91SAM926xKbdDriverPlugin.h"
+#include "AT91SAM926xKbdHandler.h"
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+AT91SAM926xKbdDriverPlugin::AT91SAM926xKbdDriverPlugin( QObject *parent )
+    : QKbdDriverPlugin( parent )
+{}
+
+AT91SAM926xKbdDriverPlugin::~AT91SAM926xKbdDriverPlugin()
+{}
+
+QWSKeyboardHandler* AT91SAM926xKbdDriverPlugin::create(const QString& driver, const QString&)
+{
+    cout << "[ AT91SAM926xKbdDriverPlugin:create ]" << endl;
+    return create( driver );
+}
+
+QWSKeyboardHandler* AT91SAM926xKbdDriverPlugin::create( const QString& driver)
+{
+    if( driver.toLower() == QLatin1String("at91sam926xkbdhandler") ) {
+        cout << "[ Loading AT91SAM926xKbdHandler ]" << endl;
+        return new AT91SAM926xKbdHandler();
+    }
+    return 0;
+}
+
+QStringList AT91SAM926xKbdDriverPlugin::keys() const
+{
+    return QStringList() << "at91sam926xkbdhandler";
+}
+
+Q_EXPORT_PLUGIN2(qwsAT91SAM926xKbdDriverPlugin, AT91SAM926xKbdDriverPlugin)
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdDriverPlugin.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,26 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xKBDDRIVERPLUGIN_H
+#define AT91SAM926xKBDDRIVERPLUGIN_H
+
+#include <qkbddriverplugin_qws.h>
+
+class AT91SAM926xKbdDriverPlugin : public QKbdDriverPlugin {
+    Q_OBJECT
+public:
+    AT91SAM926xKbdDriverPlugin( QObject *parent  = 0 );
+    ~AT91SAM926xKbdDriverPlugin();
+
+    QWSKeyboardHandler* create(const QString& driver, const QString& device);
+    QWSKeyboardHandler* create(const QString& driver);
+    QStringList keys()const;
+};
+
+#endif // AT91SAM926xKBDDRIVERPLUGIN_H
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,170 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+#include <linux/input.h>
+
+#include <QFile>
+#include <QTextStream>
+#include <QScreen>
+#include <QSocketNotifier>
+
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+int AT91SAM926xKbdHandler::open_device()
+{
+    close_device();
+    
+    int kbdFD;
+    char* pKbdDev=NULL;
+
+    if((pKbdDev = getenv("AT91SAM926x_KBD_CONF_FILE")) != NULL) m_ConfigFile=QString(pKbdDev);else m_ConfigFile=QString("/etc/at91sam9263xKbd.xml");
+
+    if((pKbdDev = getenv("AT91SAM926x_KBD_DEV")) == NULL)
+    {
+	if((kbdFD=open("/dev/input/event0", O_RDWR))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open gpio device /dev/input/event0 !" << endl;
+		cout << "{AT91SAM926xKbdHandler::open_device(1)} Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+    }
+    else
+    {
+	if((kbdFD=open(pKbdDev, O_RDWR))<0)
+	{
+		#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		cout << "Can't open gpio device " << pKbdDev << "!" << endl;
+		cout << "{AT91SAM926xKbdHandler::open_device(2)} Operation is FAILED with error: " << strerror(errno) << " !!!" << endl;
+		#endif // DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+		return -1;
+	};
+    };
+
+    m_kbdFD=kbdFD;
+    m_pKbdNotify = new QSocketNotifier( m_kbdFD, QSocketNotifier::Read, this );
+    connect( m_pKbdNotify, SIGNAL(activated(int)), this, SLOT(readKbdData()));
+
+    return 0;
+}
+
+void AT91SAM926xKbdHandler::close_device()
+{
+    if(m_kbdFD > 0)
+    {
+	::close(m_kbdFD);
+	m_kbdFD=-1;
+    };
+
+    if(m_fdBuzzer > 0)
+    {
+	::close(m_fdBuzzer);
+	m_fdBuzzer=-1;
+    };
+
+    if(m_pKbdNotify)
+    {
+	delete m_pKbdNotify;
+	m_pKbdNotify=NULL;
+    };
+}
+
+AT91SAM926xKbdHandler::AT91SAM926xKbdHandler()
+        : m_kbdFD(-1), m_fdBuzzer(-1), m_pKbdNotify(NULL),
+          m_unicode(0xffff), m_qtKeyCode(0x00), m_buzzer(QString()),
+          m_modifiers(Qt::NoModifier),
+          m_ConfigFile("/etc/at91sam9263xKbd.xml")
+{
+#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "Loaded AT91SAM926x keypad plugin" << endl;
+    cout << "AT91SAM926x Keypad Handler" << endl;
+#endif
+
+    open_device();
+    loadConfig(m_ConfigFile);
+}
+
+AT91SAM926xKbdHandler::~AT91SAM926xKbdHandler()
+{
+    close_device();
+
+    if(m_fdBuzzer>0) ::close(m_fdBuzzer);
+}
+
+void AT91SAM926xKbdHandler::readKbdData()
+{
+    struct input_event event;
+
+    int n = read(m_kbdFD, &event, sizeof(struct input_event));
+    if(n != (int)sizeof(struct input_event)) return;
+
+    bool isPress = (event.value);
+    bool bBuzzer=false;
+
+    if(!event.type) return;
+
+#ifdef DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+    cout << "INFO {AT91SAM926xKbdHandler::readPowerKbdData}: receive keyboard event:" << endl
+         << "isPress: " << ((isPress)? "true": "false") << "; Kode : 0x" << hex << (int)event.value
+         << ", Type : 0x" << hex << (int)event.type << endl;
+#endif
+
+    AT91SAM926xKbdHandler::CKey* pKey=NULL;
+    AT91SAM926xKbdHandler::CModifier* pModifier=getModifier(event.code);
+    if(pModifier)
+    {
+	if(isPress)
+	{
+		m_modifiers|=pModifier->m_qt_modifier;
+		pModifier->set_led();
+		if(pModifier->m_buzzer) bBuzzer=true;
+	}
+	else
+	{
+		m_modifiers&= ~(pModifier->m_qt_modifier);
+		pModifier->clear_led();
+	};
+    }else pKey=getKey(event.code);
+
+    if(pKey)
+    {
+	m_qtKeyCode=pKey->m_qt_key;
+	m_unicode=pKey->m_unicode;
+	if(isPress)
+	{
+		m_unicode=pKey->set_led();
+		if(pKey->m_buzzer) bBuzzer|=true;
+	}
+	else m_unicode=pKey->clear_led();
+    };
+
+    if(bBuzzer) set_buzzer();else clear_buzzer();
+
+    if(!pKey) return;
+
+    processKeyEvent(m_unicode, m_qtKeyCode, m_modifiers, isPress, false);
+
+    //if(isPress) {
+    //   beginAutoRepeat(m_unicode, m_qtKeyCode, m_modifiers);
+    //} else endAutoRepeat();
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdHandler.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,106 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xKbdHandler_H
+#define AT91SAM926xKbdHandler_H
+
+// Uncomment this for debus-messages enabling
+//#define DEF_AT91SAM926xKbdHandler_DEBUG_MESSAGES_ENABLE__
+
+#include <QObject>
+#include <QList>
+#include <QString>
+#include <QXmlStreamReader>
+
+#include <QWSKeyboardHandler>
+
+
+class QSocketNotifier;
+class AT91SAM926xKbdHandler : public QObject, public QWSKeyboardHandler
+{
+    Q_OBJECT
+public:
+    class CKey
+    {
+	int m_fd;
+      public:
+	unsigned int	m_btn;
+	unsigned int	m_qt_key;
+	unsigned short	m_unicode;
+	bool		m_buzzer;
+	QString		m_led;
+
+	CKey();
+	bool set_led();
+	bool clear_led();
+	~CKey();
+    };
+
+    class CModifier
+    {
+	int m_fd;
+      public:
+	unsigned int		m_btn;
+	Qt::KeyboardModifiers	m_qt_modifier;
+	bool			m_buzzer;
+	QString			m_led;
+
+	CModifier();
+	bool set_led();
+	bool clear_led();
+	~CModifier();
+    };
+
+public:
+    AT91SAM926xKbdHandler();
+    ~AT91SAM926xKbdHandler();
+
+private:
+    QSocketNotifier		*m_pKbdNotify;
+    QString			m_ConfigFile;
+    unsigned int		m_Autorepeat;
+
+    int				m_fdBuzzer;
+    int				m_kbdFD;
+
+    unsigned short		m_unicode;
+    unsigned int		m_qtKeyCode;
+    bool			m_isPressed;
+    Qt::KeyboardModifiers	m_modifiers;
+
+    QString m_buzzer;
+    QList<AT91SAM926xKbdHandler::CKey>  m_keys;
+    QList<AT91SAM926xKbdHandler::CModifier>  m_Modifiers;
+protected:
+    int open_device();
+    void close_device();
+
+    bool loadConfig(QString& configPath);
+    void parseKey(QXmlStreamReader& reader);
+    void parseModifier(QXmlStreamReader& reader);
+    void parseBuzzer(QXmlStreamReader& reader);
+    void parseScancode(QXmlStreamReader& reader, unsigned int& _Key);
+    void parseQtKey(QXmlStreamReader& reader, unsigned int& _QtKey);
+    void parseQtModKey(QXmlStreamReader& reader, Qt::KeyboardModifiers& _QtKey);
+    void parseUnicode(QXmlStreamReader& reader, unsigned short& _Unicode);
+    void parseBuzzer(QXmlStreamReader& reader, bool& _Buzzer);
+    void parseLed(QXmlStreamReader& reader, QString& _Led);
+    unsigned int get_qt_key(const char* pKeyName);
+    unsigned int get_input_btn(const char* pBtnName);
+    Qt::KeyboardModifiers get_qt_modifier(const char* pKeyName);
+
+    int set_buzzer();
+    int clear_buzzer();
+    AT91SAM926xKbdHandler::CModifier* getModifier(unsigned int _btn);
+    AT91SAM926xKbdHandler::CKey* getKey(unsigned int _btn);
+private Q_SLOTS:
+    void readKbdData();
+};
+
+#endif // AT91SAM926xKbdHandler_H
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926xKbdKeys.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,343 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xKbdHandler.h"
+
+struct SQtNameToKey
+{
+    const char* m_pName;
+    unsigned int m_QtKey;
+};
+
+static SQtNameToKey sQtNames[]=
+{
+    { "key_escape", Qt::Key_Escape},
+    { "key_tab", Qt::Key_Tab},
+    { "key_backtab", Qt::Key_Backtab},
+    { "key_backspace", Qt::Key_Backspace},
+    { "key_return", Qt::Key_Return},
+    { "key_enter", Qt::Key_Enter},
+    { "key_insert", Qt::Key_Insert},
+    { "key_delete", Qt::Key_Delete},
+    { "key_pause", Qt::Key_Pause},
+    { "key_print", Qt::Key_Print},
+    { "key_sysreq", Qt::Key_SysReq},
+    { "key_clear", Qt::Key_Clear},
+    { "key_home", Qt::Key_Home},
+    { "key_end", Qt::Key_End},
+    { "key_left", Qt::Key_Left},
+    { "key_up", Qt::Key_Up},
+    { "key_right", Qt::Key_Right},
+    { "key_down", Qt::Key_Down},
+    { "key_pageup", Qt::Key_PageUp},
+    { "key_pagedown", Qt::Key_PageDown},
+    { "key_shift", Qt::Key_Shift},
+    { "key_control", Qt::Key_Control},
+    { "key_meta", Qt::Key_Meta},
+    { "key_alt", Qt::Key_Alt},
+    { "key_capslock", Qt::Key_CapsLock},
+    { "key_numlock", Qt::Key_NumLock},
+    { "key_scrolllock", Qt::Key_ScrollLock},
+    { "key_f1", Qt::Key_F1},
+    { "key_f2", Qt::Key_F2},
+    { "key_f3", Qt::Key_F3},
+    { "key_f4", Qt::Key_F4},
+    { "key_f5", Qt::Key_F5},
+    { "key_f6", Qt::Key_F6},
+    { "key_f7", Qt::Key_F7},
+    { "key_f8", Qt::Key_F8},
+    { "key_f9", Qt::Key_F9},
+    { "key_f10", Qt::Key_F10},
+    { "key_f11", Qt::Key_F11},
+    { "key_f12", Qt::Key_F12},
+    { "key_f13", Qt::Key_F13},
+    { "key_f14", Qt::Key_F14},
+    { "key_f15", Qt::Key_F15},
+    { "key_f16", Qt::Key_F16},
+    { "key_f17", Qt::Key_F17},
+    { "key_f18", Qt::Key_F18},
+    { "key_f19", Qt::Key_F19},
+    { "key_f20", Qt::Key_F20},
+    { "key_f21", Qt::Key_F21},
+    { "key_f22", Qt::Key_F22},
+    { "key_f23", Qt::Key_F23},
+    { "key_f24", Qt::Key_F24},
+    { "key_f25", Qt::Key_F25},
+    { "key_f26", Qt::Key_F26},
+    { "key_f27", Qt::Key_F27},
+    { "key_f28", Qt::Key_F28},
+    { "key_f29", Qt::Key_F29},
+    { "key_f30", Qt::Key_F30},
+    { "key_f31", Qt::Key_F31},
+    { "key_f32", Qt::Key_F32},
+    { "key_f33", Qt::Key_F33},
+    { "key_f34", Qt::Key_F34},
+    { "key_f35", Qt::Key_F35},
+    { "key_super_l", Qt::Key_Super_L},
+    { "key_super_r", Qt::Key_Super_R},
+    { "key_menu", Qt::Key_Menu},
+    { "key_hyper_l", Qt::Key_Hyper_L},
+    { "key_hyper_r", Qt::Key_Hyper_R},
+    { "key_help", Qt::Key_Help},
+    { "key_direction_l", Qt::Key_Direction_L},
+    { "key_direction_r", Qt::Key_Direction_R},
+    { "key_space", Qt::Key_Space},
+    { "key_any", Qt::Key_Any},
+    { "key_exclam", Qt::Key_Exclam},
+    { "key_quotedbl", Qt::Key_QuoteDbl},
+    { "key_numbersign", Qt::Key_NumberSign},
+    { "key_dollar", Qt::Key_Dollar},
+    { "key_percent", Qt::Key_Percent},
+    { "key_ampersand", Qt::Key_Ampersand},
+    { "key_apostrophe", Qt::Key_Apostrophe},
+    { "key_parenleft", Qt::Key_ParenLeft},
+    { "key_parenright", Qt::Key_ParenRight},
+    { "key_asterisk", Qt::Key_Asterisk},
+    { "key_plus", Qt::Key_Plus},
+    { "key_comma", Qt::Key_Comma},
+    { "key_minus", Qt::Key_Minus},
+    { "key_period", Qt::Key_Period},
+    { "key_slash", Qt::Key_Slash},
+    { "key_0", Qt::Key_0},
+    { "key_1", Qt::Key_1},
+    { "key_2", Qt::Key_2},
+    { "key_3", Qt::Key_3},
+    { "key_4", Qt::Key_4},
+    { "key_5", Qt::Key_5},
+    { "key_6", Qt::Key_6},
+    { "key_7", Qt::Key_7},
+    { "key_8", Qt::Key_8},
+    { "key_9", Qt::Key_9},
+    { "key_colon", Qt::Key_Colon},
+    { "key_semicolon", Qt::Key_Semicolon},
+    { "key_less", Qt::Key_Less},
+    { "key_equal", Qt::Key_Equal},
+    { "key_greater", Qt::Key_Greater},
+    { "key_question", Qt::Key_Question},
+    { "key_at", Qt::Key_At},
+    { "key_a", Qt::Key_A},
+    { "key_b", Qt::Key_B},
+    { "key_c", Qt::Key_C},
+    { "key_d", Qt::Key_D},
+    { "key_e", Qt::Key_E},
+    { "key_f", Qt::Key_F},
+    { "key_g", Qt::Key_G},
+    { "key_h", Qt::Key_H},
+    { "key_i", Qt::Key_I},
+    { "key_j", Qt::Key_J},
+    { "key_k", Qt::Key_K},
+    { "key_l", Qt::Key_L},
+    { "key_m", Qt::Key_M},
+    { "key_n", Qt::Key_N},
+    { "key_o", Qt::Key_O},
+    { "key_p", Qt::Key_P},
+    { "key_q", Qt::Key_Q},
+    { "key_r", Qt::Key_R},
+    { "key_s", Qt::Key_S},
+    { "key_t", Qt::Key_T},
+    { "key_u", Qt::Key_U},
+    { "key_v", Qt::Key_V},
+    { "key_w", Qt::Key_W},
+    { "key_x", Qt::Key_X},
+    { "key_y", Qt::Key_Y},
+    { "key_z", Qt::Key_Z},
+    { "key_bracketleft", Qt::Key_BracketLeft},
+    { "key_backslash", Qt::Key_Backslash},
+    { "key_bracketright", Qt::Key_BracketRight},
+    { "key_asciicircum", Qt::Key_AsciiCircum},
+    { "key_underscore", Qt::Key_Underscore},
+    { "key_quoteleft", Qt::Key_QuoteLeft},
+    { "key_braceleft", Qt::Key_BraceLeft},
+    { "key_bar", Qt::Key_Bar},
+    { "key_araceright", Qt::Key_BraceRight},
+    { "key_asciitilde", Qt::Key_AsciiTilde},
+
+    { "key_nobreakspace", Qt::Key_nobreakspace},
+    { "key_exclamdown", Qt::Key_exclamdown},
+    { "key_cent", Qt::Key_cent},
+    { "key_sterling", Qt::Key_sterling},
+    { "key_currency", Qt::Key_currency},
+    { "key_yen", Qt::Key_yen},
+    { "key_brokenbar", Qt::Key_brokenbar},
+    { "key_section", Qt::Key_section},
+    { "key_diaeresis", Qt::Key_diaeresis},
+    { "key_copyright", Qt::Key_copyright},
+    { "key_ordfeminine", Qt::Key_ordfeminine},
+    { "key_guillemotleft", Qt::Key_guillemotleft},
+    { "key_notsign", Qt::Key_notsign},
+    { "key_hyphen", Qt::Key_hyphen},
+    { "key_registered", Qt::Key_registered},
+    { "key_macron", Qt::Key_macron},
+    { "key_degree", Qt::Key_degree},
+    { "key_plusminus", Qt::Key_plusminus},
+    { "key_twosuperior", Qt::Key_twosuperior},
+    { "key_threesuperior", Qt::Key_threesuperior},
+    { "key_acute", Qt::Key_acute},
+    { "key_mu", Qt::Key_mu},
+    { "key_paragraph", Qt::Key_paragraph},
+    { "key_periodcentered", Qt::Key_periodcentered},
+    { "key_cedilla", Qt::Key_cedilla},
+    { "key_onesuperior", Qt::Key_onesuperior},
+    { "key_masculine", Qt::Key_masculine},
+    { "key_guillemotright", Qt::Key_guillemotright},
+    { "key_onequarter", Qt::Key_onequarter},
+    { "key_onehalf", Qt::Key_onehalf},
+    { "key_threequarters", Qt::Key_threequarters},
+    { "key_questiondown", Qt::Key_questiondown},
+    { "key_agrave", Qt::Key_Agrave},
+    { "key_aacute", Qt::Key_Aacute},
+    { "key_acircumflex", Qt::Key_Acircumflex},
+    { "key_atilde", Qt::Key_Atilde},
+    { "key_adiaeresis", Qt::Key_Adiaeresis},
+    { "key_aring", Qt::Key_Aring},
+    { "key_ae", Qt::Key_AE},
+    { "key_ccedilla", Qt::Key_Ccedilla},
+    { "key_egrave", Qt::Key_Egrave},
+    { "key_eacute", Qt::Key_Eacute},
+    { "key_ecircumflex", Qt::Key_Ecircumflex},
+    { "key_ediaeresis", Qt::Key_Ediaeresis},
+    { "key_igrave", Qt::Key_Igrave},
+    { "key_iacute", Qt::Key_Iacute},
+    { "key_icircumflex", Qt::Key_Icircumflex},
+    { "key_idiaeresis", Qt::Key_Idiaeresis},
+    { "key_eth", Qt::Key_ETH},
+    { "key_ntilde", Qt::Key_Ntilde},
+    { "key_ograve", Qt::Key_Ograve},
+    { "key_oacute", Qt::Key_Oacute},
+    { "key_ocircumflex", Qt::Key_Ocircumflex},
+    { "key_otilde", Qt::Key_Otilde},
+    { "key_odiaeresis", Qt::Key_Odiaeresis},
+    { "key_multiply", Qt::Key_multiply},
+    { "key_ooblique", Qt::Key_Ooblique},
+    { "key_ugrave", Qt::Key_Ugrave},
+    { "key_uacute", Qt::Key_Uacute},
+    { "key_ucircumflex", Qt::Key_Ucircumflex},
+    { "key_udiaeresis", Qt::Key_Udiaeresis},
+    { "key_yacute", Qt::Key_Yacute},
+    { "key_thorn", Qt::Key_THORN},
+    { "key_ssharp", Qt::Key_ssharp},
+    { "key_division", Qt::Key_division},
+    { "key_ydiaeresis", Qt::Key_ydiaeresis},
+    { "key_altgr", Qt::Key_AltGr},
+    { "key_multi_key", Qt::Key_Multi_key},
+    { "key_codeinput", Qt::Key_Codeinput},
+    { "key_singlecandidate", Qt::Key_SingleCandidate},
+    { "key_multiplecandidate", Qt::Key_MultipleCandidate},
+    { "key_previouscandidate", Qt::Key_PreviousCandidate},
+    { "key_mode_switch", Qt::Key_Mode_switch},
+    { "key_back", Qt::Key_Back},
+    { "key_forward", Qt::Key_Forward},
+    { "key_stop", Qt::Key_Stop},
+    { "key_refresh", Qt::Key_Refresh},
+
+    { "key_volumedown", Qt::Key_VolumeDown},
+    { "key_volumemute", Qt::Key_VolumeMute},
+    { "key_volumeup", Qt::Key_VolumeUp},
+    { "key_bassboost", Qt::Key_BassBoost},
+    { "key_bassup", Qt::Key_BassUp},
+    { "key_bassdown", Qt::Key_BassDown},
+    { "key_trebleup", Qt::Key_TrebleUp},
+    { "key_trebledown", Qt::Key_TrebleDown},
+
+    { "key_mediaplay", Qt::Key_MediaPlay},
+    { "key_mediastop", Qt::Key_MediaStop},
+    { "key_mediaprevious", Qt::Key_MediaPrevious},
+    { "key_medianext", Qt::Key_MediaNext},
+    { "key_mediarecord", Qt::Key_MediaRecord},
+
+    { "key_homepage", Qt::Key_HomePage},
+    { "key_favorites", Qt::Key_Favorites},
+    { "key_search", Qt::Key_Search},
+    { "key_standby", Qt::Key_Standby},
+    { "key_openurl", Qt::Key_OpenUrl},
+
+    { "key_launchmail", Qt::Key_LaunchMail},
+    { "key_launchmedia", Qt::Key_LaunchMedia},
+    { "key_launch0", Qt::Key_Launch0},
+    { "key_launch1", Qt::Key_Launch1},
+    { "key_launch2", Qt::Key_Launch2},
+    { "key_launch3", Qt::Key_Launch3},
+    { "key_launch4", Qt::Key_Launch4},
+    { "key_launch5", Qt::Key_Launch5},
+    { "key_launch6", Qt::Key_Launch6},
+    { "key_launch7", Qt::Key_Launch7},
+    { "key_launch8", Qt::Key_Launch8},
+    { "key_launch9", Qt::Key_Launch9},
+    { "key_launcha", Qt::Key_LaunchA},
+    { "key_launchb", Qt::Key_LaunchB},
+    { "key_launchc", Qt::Key_LaunchC},
+    { "key_launchd", Qt::Key_LaunchD},
+    { "key_launche", Qt::Key_LaunchE},
+    { "key_launchf", Qt::Key_LaunchF},
+
+    { "key_medialast", Qt::Key_MediaLast},
+
+    // Keypad navigation keys
+    { "key_select", Qt::Key_Select},
+    { "key_yes", Qt::Key_Yes},
+    { "key_no", Qt::Key_No},
+
+    // Newer misc keys
+    { "key_cancel", Qt::Key_Cancel},
+    { "key_printer", Qt::Key_Printer},
+    { "key_execute", Qt::Key_Execute},
+    { "key_sleep", Qt::Key_Sleep},
+    { "key_play", Qt::Key_Play},
+    { "key_zoom", Qt::Key_Zoom},
+
+    // Device keys
+    { "key_context1", Qt::Key_Context1},
+    { "key_context2", Qt::Key_Context2},
+    { "key_context3", Qt::Key_Context3},
+    { "key_context4", Qt::Key_Context4},
+    { "key_call", Qt::Key_Call},
+    { "key_hangup", Qt::Key_Hangup},
+    { "key_flip", Qt::Key_Flip}
+};
+
+unsigned int AT91SAM926xKbdHandler::get_qt_key(const char* pKeyName)
+{
+    QString lKeyName=QString(pKeyName).trimmed().toLower();
+    for(unsigned int iKeyName=0;iKeyName<(sizeof(sQtNames)/sizeof(struct SQtNameToKey));++iKeyName)
+    {
+	if(lKeyName == sQtNames[iKeyName].m_pName) return sQtNames[iKeyName].m_QtKey;
+    };
+    return Qt::Key_unknown;
+}
+
+
+struct SQtModifiersNameToKey
+{
+    const char*			m_pName;
+    Qt::KeyboardModifiers	m_qt_modifier;
+};
+
+
+static SQtModifiersNameToKey sQtModifiersNames[]=
+{
+    { "shift", Qt::ShiftModifier },
+    { "control", Qt::ControlModifier },
+    { "alt", Qt::AltModifier },
+    { "meta", Qt::MetaModifier },
+    { "keypad", Qt::KeypadModifier },
+    { "groupswitch", Qt::GroupSwitchModifier }
+};
+
+
+Qt::KeyboardModifiers AT91SAM926xKbdHandler::get_qt_modifier(const char* pKeyName)
+{
+    QString lKeyName=QString(pKeyName).trimmed().toLower();
+    for(unsigned int iKeyName=0;iKeyName<(sizeof(sQtModifiersNames)/sizeof(struct SQtModifiersNameToKey));++iKeyName)
+    {
+	if(lKeyName == sQtModifiersNames[iKeyName].m_pName) return sQtModifiersNames[iKeyName].m_qt_modifier;
+    };
+    return Qt::NoModifier;
+}
+
+
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/AT91SAM926xKbd/AT91SAM926x.pro	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,13 @@
+TARGET = AT91SAM926xKbdhandler
+include(../../qpluginbase.pri)
+
+target.path = $$[QT_INSTALL_PLUGINS]/kbddrivers
+INSTALLS += target
+
+HEADERS = AT91SAM926xKbdDriverPlugin.h AT91SAM926xKbdHandler.h
+SOURCES = AT91SAM926xKbdDriverPlugin.cpp \
+          AT91SAM926xKbdHandler.cpp \
+          AT91SAM926xKbdBtns.cpp \
+          AT91SAM926xKbdKeys.cpp \
+          AT91SAM926xKbdConfig.cpp \
+          AT91SAM926xKbdControls.cpp
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/kbddrivers.pro qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/kbddrivers.pro
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/kbddrivers/kbddrivers.pro	2013-06-07 09:17:00.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/kbddrivers/kbddrivers.pro	2014-04-18 17:06:07.485641065 +0400
@@ -1,2 +1,3 @@
 TEMPLATE = subdirs
 contains(kbd-plugins, linuxinput): SUBDIRS += linuxinput
+contains(kbd-plugins, AT91SAM926xKbd): SUBDIRS += AT91SAM926xKbd
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,46 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousedriverplugin.h"
+#include "AT91SAM926xmousehandler.h"
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+AT91SAM926xMouseDriverPlugin::AT91SAM926xMouseDriverPlugin()
+    : QMouseDriverPlugin()
+{
+}
+
+AT91SAM926xMouseDriverPlugin::~AT91SAM926xMouseDriverPlugin()
+{
+}
+
+QWSMouseHandler* AT91SAM926xMouseDriverPlugin::create(const QString &driver,
+						      const QString &device)
+{
+    cout << "[ AT91SAM926xMouseDriverPlugin:create ]" << endl;
+
+    if( driver.toLower() == QLatin1String("at91sam926xmousehandler") )
+    {
+        cout << "[ Loading AT91SAM926xMouseHandler ]" << endl;
+        return new AT91SAM926xMouseHandler(driver, device);
+    }
+    return 0;
+}
+
+QStringList AT91SAM926xMouseDriverPlugin::keys() const
+{
+    return (QStringList() << QLatin1String("at91sam926xmousehandler"));
+}
+
+Q_EXPORT_PLUGIN2(qwsAT91SAM926xMouseDriverPlugin, AT91SAM926xMouseDriverPlugin)
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousedriverplugin.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,25 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xMOUSEDRIVERPLUGIN_H
+#define AT91SAM926xMOUSEDRIVERPLUGIN_H
+
+#include <qmousedriverplugin_qws.h>
+
+class AT91SAM926xMouseDriverPlugin : public QMouseDriverPlugin
+{
+public:
+    AT91SAM926xMouseDriverPlugin();
+    ~AT91SAM926xMouseDriverPlugin();
+
+    QWSMouseHandler* create(const QString& driver, const QString& device);
+    QStringList keys()const;
+};
+
+#endif // AT91SAM926xMOUSEDRIVERPLUGIN_H
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,265 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include "qsocketnotifier.h"
+#include "qscreen_qws.h"
+
+#include <string.h>
+#include <strings.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+
+#ifndef QT_QWS_TP_JITTER_LIMIT
+#define QT_QWS_TP_JITTER_LIMIT 3
+#endif
+
+
+#include <iostream>
+#include <iomanip>
+#include <cstdlib>
+
+using namespace std;
+
+
+AT91SAM926xMouseHandlerPrivate::AT91SAM926xMouseHandlerPrivate(AT91SAM926xMouseHandler* h, const QString &device)
+    : handler(h), dev(0), mouseNotifier(0)
+{
+    open( (device.isNull())? NULL : device.toAscii().data() );
+
+    if (!open()) return;
+
+    calibrated = true;
+
+    int fd = ts_fd(dev);
+    mouseNotifier = new QSocketNotifier(fd, QSocketNotifier::Read, this);
+    connect(mouseNotifier, SIGNAL(activated(int)),this, SLOT(readMouseData()));
+    resume();
+}
+
+AT91SAM926xMouseHandlerPrivate::~AT91SAM926xMouseHandlerPrivate()
+{
+    close();
+}
+
+
+bool AT91SAM926xMouseHandlerPrivate::open(const char* pDevName)
+{
+    if(!pDevName)
+    {
+	char *tsdevice=NULL;
+	if((tsdevice = getenv("TSLIB_TSDEVICE")) == NULL)
+	{
+		if ((dev = ts_open ("/dev/ts", 1)) == NULL)
+		{
+			#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			cout << "Can't open touch screen device /dev/ts !" << endl;
+			#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			return false;
+    		};
+	}else
+	{
+		if ((dev = ts_open (tsdevice, 1)) == NULL)
+		{
+			#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			cout << "Can't open touch screen device " << tsdevice << "!" << endl;
+			#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+			return false;
+    		};
+	};
+    }
+    else
+    {
+	if ((dev = ts_open (pDevName, 1)) == NULL)
+	{
+		#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+		cout << "Can't open touch screen device " << pDevName << "!" << endl;
+		#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+		return false;
+	};
+    };
+
+    if (ts_config(dev))
+    {
+	#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+	cout << "Can't config touch screen device!" << endl;
+	#endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+	close();
+	return false;
+    };
+
+    return true;
+}
+
+void AT91SAM926xMouseHandlerPrivate::close()
+{
+    if(dev) ts_close(dev);
+}
+
+void AT91SAM926xMouseHandlerPrivate::suspend()
+{
+    if (mouseNotifier)
+	mouseNotifier->setEnabled(false);
+}
+
+void AT91SAM926xMouseHandlerPrivate::resume()
+{
+    bzero(&lastSample, sizeof(lastSample));
+    wasPressed = false;
+    lastdx = 0;
+    lastdy = 0;
+    if (mouseNotifier)
+        mouseNotifier->setEnabled(true);
+}
+
+bool AT91SAM926xMouseHandlerPrivate::get_sample(struct ts_sample *sample)
+{
+    if (!calibrated)
+        return (ts_read_raw(dev, sample, 1) == 1);
+
+    int retCode=ts_read(dev, sample, 1);
+
+    if(sample->x < 0) sample->x=1;
+    if(sample->x > qt_screen->deviceWidth()) sample->x=qt_screen->deviceWidth()-1;
+    if(sample->y < 0) sample->y=1;
+    if(sample->y > qt_screen->deviceHeight()) sample->y=qt_screen->deviceHeight()-1;
+
+    return (retCode == 1);
+}
+
+void AT91SAM926xMouseHandlerPrivate::readMouseData()
+{
+    if (!qt_screen)
+        return;
+
+    for(;;) {
+        struct ts_sample sample = lastSample;
+        bool pressed = wasPressed;
+
+        // Fast return if there's no events.
+        if (!get_sample(&sample))
+            return;
+        pressed = (sample.pressure > 0);
+
+        // Only return last sample unless there's a press/release event.
+        while (pressed == wasPressed) {
+            if (!get_sample(&sample))
+                break;
+            pressed = (sample.pressure > 0);
+        }
+
+        // work around missing coordinates on mouse release in raw mode
+        if (!calibrated && !pressed && sample.x == 0 && sample.y == 0) {
+            sample.x = lastSample.x;
+            sample.y = lastSample.y;
+        }
+
+        int dx = sample.x - lastSample.x;
+        int dy = sample.y - lastSample.y;
+
+        // Remove small movements in oppsite direction
+        if (dx * lastdx < 0 && qAbs(dx) < QT_QWS_TP_JITTER_LIMIT) {
+            sample.x = lastSample.x;
+            dx = 0;
+        }
+        if (dy * lastdy < 0 && qAbs(dy) < QT_QWS_TP_JITTER_LIMIT) {
+            sample.y = lastSample.y;
+            dy = 0;
+        }
+
+        if (wasPressed == pressed && dx == 0 && dy == 0)
+            return;
+
+#ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+        cout << "last ( x=" << lastSample.x << ", y=" << lastSample.y
+             << "); curr ( x=" << sample.x << ", y=" << sample.y
+             << "); dx,dy(" << dx << "," << dy
+             << "); ddx,ddy(" << dx*lastdx << "," << dy*lastdy
+             << "); wasPressed is " << wasPressed << "; pressed is " << pressed << endl;
+#endif
+
+        lastSample = sample;
+        wasPressed = pressed;
+        if (dx != 0)
+            lastdx = dx;
+        if (dy != 0)
+            lastdy = dy;
+
+        const QPoint p(sample.x, sample.y);
+        if (calibrated) {
+            // tslib should do all the translation and filtering, so we send a
+            // "raw" mouse event
+            handler->QWSMouseHandler::mouseChanged(p, pressed);
+        } else {
+            handler->sendFiltered(p, pressed);
+        }
+    }
+}
+
+void AT91SAM926xMouseHandlerPrivate::clearCalibration()
+{
+    suspend();
+    close();
+    handler->QWSCalibratedMouseHandler::clearCalibration();
+    calibrated = false;
+    open();
+    resume();
+}
+
+void AT91SAM926xMouseHandlerPrivate::calibrate(const QWSPointerCalibrationData *data)
+{
+    suspend();
+    close();
+    // default implementation writes to /etc/pointercal
+    // using the same format as the tslib linear module.
+    handler->QWSCalibratedMouseHandler::calibrate(data);
+    calibrated = true;
+    open();
+    resume();
+}
+
+AT91SAM926xMouseHandler::AT91SAM926xMouseHandler(const QString &driver,
+						 const QString &device)
+    : QWSCalibratedMouseHandler(driver, device)
+{
+    #ifdef DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    cout << "***Loaded AT91SAM926x touchscreen plugin!" << endl;
+    #endif // DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    d = new AT91SAM926xMouseHandlerPrivate(this, device);
+}
+
+
+AT91SAM926xMouseHandler::~AT91SAM926xMouseHandler()
+{
+    delete d;
+}
+
+void AT91SAM926xMouseHandler::suspend()
+{
+    d->suspend();
+}
+
+void AT91SAM926xMouseHandler::resume()
+{
+    d->resume();
+}
+
+void AT91SAM926xMouseHandler::clearCalibration()
+{
+    d->clearCalibration();
+}
+
+void AT91SAM926xMouseHandler::calibrate(const QWSPointerCalibrationData *data)
+{
+    d->calibrate(data);
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xmousehandler.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2008 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef AT91SAM926xMOUSEHANDLER_H
+#define AT91SAM926xMOUSEHANDLER_H
+
+#include <qobject.h>
+#include <QtGui/qmouse_qws.h>
+
+#include <tslib.h>
+
+// Uncomment this for printing debug information
+//#define DEF_AT91SAM9261_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+
+class AT91SAM926xMouseHandler;
+class QSocketNotifier;
+
+
+class AT91SAM926xMouseHandlerPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    AT91SAM926xMouseHandlerPrivate(AT91SAM926xMouseHandler* h, const QString &device);
+    ~AT91SAM926xMouseHandlerPrivate();
+
+    void suspend();
+    void resume();
+
+    void calibrate(const QWSPointerCalibrationData *data);
+    void clearCalibration();
+
+private:
+    AT91SAM926xMouseHandler *handler;
+    struct tsdev* dev;
+    QSocketNotifier* mouseNotifier;
+
+    struct ts_sample lastSample;
+    bool wasPressed;
+    int lastdx;
+    int lastdy;
+
+    bool calibrated;
+
+    inline bool get_sample(struct ts_sample *sample);
+
+    bool open(const char* pDevName=NULL);
+    void close();
+
+private slots:
+    void readMouseData();
+};
+
+class AT91SAM926xMouseHandler : public QObject, public QWSCalibratedMouseHandler
+{
+public:
+     AT91SAM926xMouseHandler(const QString &driver = QString(),
+                             const QString &device = QString());
+    ~AT91SAM926xMouseHandler();
+
+    void suspend();
+    void resume();
+
+    void calibrate(const QWSPointerCalibrationData *data);
+    void clearCalibration();
+
+private:
+    friend class AT91SAM926xMouseHandlerPrivate;
+    AT91SAM926xMouseHandlerPrivate *d;
+
+};
+
+#endif // AT91SAM926xMOUSEHANDLER_H
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.cpp	2014-04-18 17:09:01.529651304 +0400
@@ -0,0 +1,412 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+#include "AT91SAM926xMouseLinAlg.h"
+#include "AT91SAM926xMouseLinAlgUtil.h"
+
+#include <sstream>
+#include <iomanip>
+#include <cassert>
+#include <cstring>
+#include <cstdlib>
+#include <cmath>
+
+matrix matrix::addcolumns()
+{
+    long i,j;
+    matrix B(rows);
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		B.A[i][0] += A[i][j];
+    }
+    return(B);
+}
+
+matrix matrix::getrow(long i) const
+{
+    long j;
+    matrix B(1,columns);
+    for (j=0; j<=columns-1;j++)
+	B.A[0][j] = A[i][j];
+    return(B);
+}
+
+matrix matrix::getcolumn(long i) const
+{
+    long j;
+    matrix B(rows);
+    for (j=0; j<=rows-1; j++)
+	B.A[j][0] = A[j][i];
+    return(B);
+}
+
+void matrix::setrow(const matrix &B, long i)
+{
+    long j;
+    if (columns != B.columns)
+    {
+	error("Wrong dimensions in matrix setrow \n");
+	return;
+    };
+    for (j=0; j<=columns-1; j++)
+	A[i][j] = B.A[0][j];
+}
+
+void matrix::setcolumn(const matrix &B, long i)
+{
+    long j;
+    if (rows != B.rows)
+    {
+	error("Wrong dimensions in matrix setcolumn \n");
+	return;
+    };
+    for (j=0; j<=rows-1; j++)
+	A[j][i] = B.A[j][0];
+}
+
+long matrix::operator==(const matrix &B)
+{
+    long i,j,eq=1;
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix equal \n");
+	return 1;
+    }
+    else
+    {
+	for(i=0; (i<=rows-1) & eq; i++)
+	{
+		for(j=0; (j<=columns-1) & eq; j++)
+			eq = (A[i][j] == B.A[i][j]);
+	}
+    }
+    return(eq);
+}
+
+void matrix::print() const
+{
+    long i,j;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+	{
+		std::string ss = numStr(A[i][j]) + "    ";
+	};
+    }
+}
+
+void matrix::stdprint() const
+{
+    long i,j;
+    std::cerr  << "[";
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+	{
+		std::cerr << A[i][j];
+		if (j<columns-1)
+		std::cerr << " ";
+	}
+	if (i<rows-1)
+		std::cerr << ";" << std::endl;
+    }
+    std::cerr << "]";
+}
+
+
+
+matrix matrix::operator*(const double &x)
+{
+    long i,j;
+    matrix C(rows,columns);
+    for(i=0;i <= C.rows-1; i++)
+    {
+	for(j=0; j<=C.columns-1;j++)
+	{
+		C.A[i][j] = x*A[i][j];
+	}
+    }
+    return(C);
+}
+
+
+matrix matrix::operator*(const matrix &B)
+{
+    long i,j,k;
+    matrix C(rows,B.columns);
+    if (columns != B.rows)
+    {
+	error("Wrong dimensions in matrix multiplication \n");
+	return(C);
+    }
+    else
+    {
+	for(i=0;i <= C.rows-1; i++)
+	{
+		for(j=0; j<=C.columns-1;j++)
+		{
+			for(k=0;k<=columns-1;k++)
+				C.A[i][j] += A[i][k]*B.A[k][j];
+		}
+	}
+    }
+    return(C);
+}
+
+matrix matrix::trans() 
+{
+    long i,j;
+    matrix B(columns,rows);
+    for (i=0;i<=columns-1;i++)
+    {
+	for(j=0;j<=rows-1;j++)
+		B.A[i][j] = A[j][i];
+    }
+    return(B);
+}
+
+matrix matrix::operator+(const matrix &B)
+{
+    long i,j;
+    matrix C(rows,columns);
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix plus \n");
+	return (C);
+    }
+    else
+    {
+	for(i=0;i <= rows-1; i++)
+	{
+		for(j=0; j<=columns-1;j++)
+			C.A[i][j] = A[i][j] + B.A[i][j];
+	}
+    }
+    return(C);
+}
+
+matrix matrix::operator-(const matrix &B)
+{
+    long i,j;
+    matrix C(rows,columns);
+    if ((rows != B.rows) & (columns != B.columns))
+    {
+	error("Wrong dimensions in matrix minus \n");
+	return(C);
+    }
+    else
+    {
+	for(i=0;i <= rows-1; i++)
+	{
+		for(j=0; j<=columns-1;j++)
+			C.A[i][j] = A[i][j] - B.A[i][j];
+	}
+    }
+    return(C);
+}
+
+double matrix::twonorm()
+{
+    long i,j;
+    double norm=0;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		norm += A[i][j]*A[i][j];
+    }
+    norm = sqrt(norm);
+    return(norm);
+}
+
+double matrix::onenorm()
+{
+    long i,j;
+    double norm=0;
+    for(i=0;i<=rows-1;i++)
+    {
+	for(j=0;j<=columns-1;j++)
+		norm += num(A[i][j]);
+    }
+    return(norm);
+}
+
+std::vector<double> matrix::mean() const
+{
+    std::vector<double> m(columns);
+    for (long s=0; s<columns; s++)
+    {
+	double sum = 0;
+	for (long r=0; r<rows; r++)
+	{
+		sum += A[r][s];
+	}
+	m[s] = sum/(double)rows;
+    }
+    return m;
+}
+
+std::vector<double> matrix::var() const
+{
+    std::vector<double> mu = mean();
+    std::vector<double> v(columns);
+    for (long s=0; s<columns; s++)
+    {
+	double sum = 0;
+	for (long r=0; r<rows; r++)
+	{
+		double xe = A[r][s]-mu[s];
+		sum +=  xe*xe;
+	}
+	v[s] = sum/((double)rows-1);
+    }
+    return v;
+}
+
+matrix matrix::covar() const
+{
+    std::vector <double> m = mean();
+    matrix res(columns, columns);
+    for (int x=0; x<columns; x++)
+    {
+	for (int y=x; y<columns; y++)
+	{
+		double sum = 0;
+		for (int i=0; i<rows; i++)
+		{
+			sum += (A[i][x]-m[x])*(A[i][y]-m[y]);
+		}
+		double val = sum/(double)(rows-1);
+		res.set(val,x,y);
+		res.set(val,y,x);
+	}
+    }
+    return res;
+}
+
+
+matrix matrix::inv()
+{
+    long *indxc =new long[rows];
+    long *indxr = new long[rows];
+    long *ipiv = new long[rows];
+    long i, icol = 0, irow = 0, j, k, l, ll;
+    double big, dum, pivinv;
+    matrix B(rows,columns);
+
+    for(i=0;i<=rows-1;i++)
+    {
+	indxc[i]=0;
+	indxr[i]=0;
+	ipiv[i]=0;
+    }
+
+    if (columns != rows)
+    {
+	error("Cannot invert non-square matrix \n");
+	delete(ipiv);
+        delete(indxr);
+	delete(indxc);
+	return(B);
+    }
+    else
+	for(i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+			B.A[i][j] = A[i][j];
+	}
+
+    for (i=0;i<=columns-1;i++)
+    {
+	big = 0.0;
+	for (j=0;j<=rows-1;j++)
+	{
+		if (ipiv[j] != 1)
+			for (k=0;k<=columns-1;k++)
+			{
+				if (ipiv[k] == 0)
+				{
+					if (fabs(B.A[j][k]) >=big)
+					{
+						big = fabs(B.A[j][k]);
+						irow = j;
+						icol = k;
+					}
+				}
+				else if (ipiv[k] > 1) { error("inv: Singular Matrix-1"); return(B);}
+			}
+	}
+	++(ipiv[icol]);
+	if (irow != icol)
+	{
+		for (l=0;l<=columns-1;l++) B.swap(irow,icol);
+	}
+	indxr[i] = irow;
+	indxc[i] = icol;
+	if (B.A[icol][icol] == 0.0) { error("inv: Singular Matrix-2"); return(B);}
+	pivinv = 1.0/B.A[icol][icol]; 
+	B.A[icol][icol] = 1.0;
+	for (l=0;l<=columns-1;l++) B.A[icol][l] *= pivinv;
+	for (ll=0;ll<=rows-1;ll++)
+		if (ll != icol)
+		{
+			dum = B.A[ll][icol];
+			B.A[ll][icol] = 0.0;
+			for (l=0;l<=columns-1;l++) 
+				B.A[ll][l] -= B.A[icol][l]*dum;
+		}
+    }
+    for(l=columns-1;l>=0;l--)
+    {
+	if (indxr[l] != indxc[l])
+		B.swapc(indxr[l],indxc[l]);
+    }
+    delete(ipiv);
+    delete(indxr);
+    delete(indxc);
+    return(B);
+}
+
+matrix matrix::map(double(*f)(double))
+{
+    matrix res(rows,columns);
+    for (int r=0; r<rows; r++)
+    for (int s=0; s<columns; s++) res.set(f(A[r][s]),r,s);
+    return res;
+}
+
+double matrix::maxvalue()
+{
+    double max=A[0][0];  
+    for(int i=0; i<rows;i++)
+    {
+	for(int j=0; j<columns; j++) {if (A[i][j]>max) max=A[i][j];}
+    }
+    return(max);
+}
+
+
+
+const char* matrix::row2string(int r)
+{
+    assert(r>=0 && r<rows);
+
+    std::ostringstream mstr;
+    mstr.setf(std::ios::fixed);
+    std::string res;
+    for (int i=0; i<columns; i++)
+    {
+	mstr << std::setw(9) << A[r][i] << " ";
+    }
+
+    std::string ss = mstr.str();
+
+    return ss.c_str();
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlg.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,150 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_H_
+#define _AT91SAM926xMOUSE_LINALG_H_
+
+#include <iostream>
+#include <stdio.h>
+#include <vector>
+
+#include <math.h>
+
+class matrix
+{
+protected:
+    int rows;
+    int columns;
+    double **A;
+public:
+    matrix(int r = 1, int c = 1)
+    {
+	int i,j;
+	rows=r; columns=c;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j]=0;
+	}
+      }
+    matrix(const matrix &B)
+    {
+	int i,j;
+	rows = B.rows;
+	columns = B.columns;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+	A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+			A[i][j]=B.A[i][j];
+	}
+    }
+    ~matrix() 
+    {
+	long i;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+    }
+    matrix &operator=(const matrix &B)
+    {
+	long i,j;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+	rows = B.rows;
+	columns = B.columns;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j] = B.A[i][j];
+	}
+	return *this;
+    }
+    long *size() {long *dim = new long[2]; dim[0] = rows; dim[1]=columns; return(dim);}
+    long row() const {return(rows);} 
+    long column() const {return(columns);} 
+    void newsize(long r, long c = 1) //warning: This deletes the original matrix
+    {
+	long i,j;
+	for (i=0; i<=rows-1; i++)
+		delete [] A[i];
+	delete [] A;
+	rows = r; columns = c;
+	A = new double*[rows];
+	for (i=0;i<=rows-1;i++)
+		A[i] = new double[columns];
+	for (i=0;i<=rows-1;i++)
+	{
+		for(j=0;j<=columns-1;j++)
+		A[i][j]=0;
+	}
+    }
+    double get(long i, long j = 0) const {return(A[i][j]);}
+    void set(double x, long i, long j=0) {A[i][j]=x;}
+    void add(double x, long i, long j=0) {A[i][j] += x;};
+    void sub(double x, long i, long j=0) {A[i][j] -= x;};
+    void mul(double x, long i, long j=0) {A[i][j] *= x;};
+    // Maps function f to every element in matrix
+    matrix map(double(*f)(double));
+    matrix getrow(long i) const;
+    matrix getcolumn(long i) const;
+    matrix addcolumns();
+    void setrow(const matrix &B, long i);
+    void setcolumn(const matrix &B, long i);
+    long operator==(const matrix &B);
+    matrix operator*(const double &x);
+    matrix operator*(const matrix &B);
+    matrix trans();
+    matrix operator+(const matrix &B);
+    matrix operator-(const matrix &B);
+    matrix inv();
+    double twonorm();
+    double onenorm();
+    // calculates empirical mean of each column in matrix
+    std::vector<double> mean() const; 
+    //  calculates empirical variance of each column in matrix
+    std::vector<double> var() const;
+    //  calculates empirical covariance matrix of matrix
+    matrix covar() const;
+
+    double maxvalue();
+    const char* row2string(int r);
+    void print() const;
+    void stdprint() const;
+    void swap(long i, long j)
+    {
+	double *tmp = A[i];
+	A[i]=A[j];
+	A[j] = tmp;
+    }
+    void swapc(long i, long j)
+    {
+	double tmp;
+	long k;
+	for(k=0;k<=rows-1;k++)
+	{
+		tmp=A[k][i];
+		A[k][i]= A[k][j];
+		A[k][j]=tmp;
+	}
+    }
+};
+
+
+
+#endif // _AT91SAM926xMOUSE_LINALG_H_
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,320 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include "AT91SAM926xMouseLinAlgSVD.h"
+#include "AT91SAM926xMouseLinAlgUtil.h"
+#include "AT91SAM926xMouseLinAlg.h"
+
+#include <cmath>
+#include <stdlib.h>
+
+
+#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))
+
+static double maxarg1, maxarg2;
+#define FMAX(a,b) (maxarg1 = (a), maxarg2 = (b), (maxarg1) > (maxarg2) ? (maxarg1) : (maxarg2))
+
+static int iminarg1, iminarg2;
+#define IMIN(a,b) (iminarg1 = (a), iminarg2 = (b), (iminarg1) < (iminarg2) ? (iminarg1) : (iminarg2))
+
+static double sqrarg;
+#define SQR(a) ((sqrarg = (a)) == 0.0 ? 0.0 : sqrarg * sqrarg)
+
+double pythag(double a, double b)
+{
+    // computes (a^2+b^2)^(1/2) without destructive under/over-flow
+    double absa = fabs(a);
+    double absb = fabs(b);
+    if (absa>absb) return absa*sqrt(1.0+SQR(absb/absa));
+    return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+SQR(absa/absb)));
+}
+
+// SVD-decomposition A = U*W*V', where U,V orthogonal and W diagonal. The matrix U is
+// replacing A and notice that V and not the transpose V' is returned. 
+// Blackbox-algorithm from NR.
+void svdcmp(matrix &A, matrix &DD, matrix &VV)
+{
+    int flag,i,its,j,jj,k,l = 0,nm = 0;
+    double anorm,c,f,g,h,s,scale,x,y,z;
+
+    // Dimensions of A;
+    int m = A.row();
+    int n = A.column();
+
+    matrix W(n,n);
+    matrix V(n,n);
+
+    std::vector<double> rv1(n);
+
+    g=scale=anorm=0.0;
+
+    //  cerr << "Start of algorithm\n";
+    // householder reduction to bidiagonal form
+    for (i=0; i<n; i++)
+    {
+	l=i+1;
+	rv1[i] = scale*g;
+	g=s=scale=0.0;
+	if (i<m)
+	{
+		for (k=i; k<m; k++) { scale += fabs(A.get(k,i));};
+		if (scale)
+		{
+			for (k=i; k<m; k++)
+			{
+				A.set(A.get(k,i)/scale, k,i);
+				s += A.get(k,i)*A.get(k,i);
+			};
+			f = A.get(i,i);
+			g = -SIGN((double)sqrt(s),double(f));
+			h = f*g-s;
+			A.set(f-g,i,i);
+			for (j=l; j<n; j++)
+			{
+				for (s=0.0, k=i; k<m; k++) { s += A.get(k,i)*A.get(k,j);};
+				f = s/h;
+				for (k=i; k<m; k++) { A.set(A.get(k,j)+f*A.get(k,i),k,j);};
+			};
+			for (k=i; k<m; k++) { A.set(A.get(k,i)*scale,k,i);};
+		} // if (scale)
+	} // if (i<=m)
+
+	W.set(scale*g,i,i);
+	g=s=scale=0.0;
+	if (i<m && i!=n-1)
+	{
+		for (k=l; k<n; k++) { scale += fabs(A.get(i,k));};
+		if (scale)
+		{
+			for(k=l; k<n; k++)
+			{
+				A.set(A.get(i,k)/scale,i,k);
+				s += A.get(i,k)*A.get(i,k);
+			};
+			f = A.get(i,l);
+			g = -SIGN(sqrt(s),f);
+			h = f*g-s;
+			A.set(f-g,i,l);
+			for (k=l; k<n; k++) { rv1[k]=A.get(i,k)/h;};
+			for (j=l; j<m; j++)
+			{
+				for (s=0.0, k=l; k<n; k++) { s+= A.get(j,k)*A.get(i,k);};
+				for (k=l; k<n; k++) { A.set(s*rv1[k]+A.get(j,k),j,k);};
+			};
+			for (k=l; k<n; k++) { A.set(A.get(i,k)*scale, i,k);};
+		}; // if (scale)
+	}; // if(i<=m && i!=n)
+	anorm = FMAX(anorm, (fabs(W.get(i,i))+fabs(rv1[i])));
+    } //  for (i=1; i<=n; i++)
+
+
+  //  "End of part 1\n";
+
+    for (i=n-1; i>=0; i--)
+    {
+	// Accumulation of right-hand transformations.
+	if (i<n-1)
+	{
+		if (g)
+		{
+			for (j=l; j<n; j++)
+			{
+				// Double division to avoid possible underflow
+				V.set((A.get(i,j)/A.get(i,l))/g ,j,i);
+			};
+			for (j=l; j<n; j++)
+			{
+				for(s=0.0, k=l; k<n; k++) { s +=  A.get(i,k)*V.get(k,j);};
+				for (k=l; k<n; k++) { V.set(V.get(k,j)+s*V.get(k,i), k,j);};
+			};
+		}; // if (g)
+		for (j=l; j<n; j++) { V.set(0,i,j); V.set(0,j,i);};
+	}; // if (i<n)
+	V.set(1.0,i,i);
+	g = rv1[i];
+	l = i;
+    }; // for (i=n; i>=1; i--)
+
+    //  "End of part 2\n";
+    for (i=IMIN(m,n)-1; i>=0; i--)
+    {
+	// Accumulation of left-hand transformations
+	l = i+1;
+	g = W.get(i,i);
+	for (j=l; j<n; j++) { A.set(0.0, i,j);};
+	if (g)
+	{
+		g = 1.0/g;
+		for (j=l; j<n; j++)
+		{
+			for (s=0.0, k=l; k<m; k++) { s += A.get(k,i)*A.get(k,j);};
+			f = (s/A.get(i,i))*g;
+			for (k=i; k<m; k++) { A.set(A.get(k,j)+f*A.get(k,i), k,j);};
+		};
+		for (j=i; j<m; j++) { A.set(g*A.get(j,i), j,i);};
+	} // if (g)
+	else
+	{
+		for (j=i; j<m; j++) { A.set(0.0, j,i);};
+	}
+	A.set(A.get(i,i)+1, i,i);
+    }; // for (i=IMIN(m,n); i>=1; i--)
+
+    //  "End of part 3\n";
+    for (k=n-1; k>=0; k--)
+    {
+	// Diagonalization of the bidiagonal form; Loop over singular values, and over all allowed iterations
+	for (its=1; its<=100; its++)
+	{
+		flag = 1;
+		for (l=k; l>=0; l--)
+		{
+			// Test for splitting
+			nm = l-1; // Note that rv1[0] is always zero.
+			if ((double)(fabs(rv1[l])+anorm) == anorm)
+			{
+				flag = 0;
+				break;
+			};
+			if ((double)(fabs(W.get(nm,nm))+anorm) == anorm) { break;};
+		}; // for (l=k; l>=1; l--)
+		if (l<0) l++;
+		if (flag)
+		{
+			// cancelation of rv1[l], if l>1.
+			c = 0.0;
+			s = 1.0;
+			for (i=l; i<=k; i++)
+			{
+				f = s*rv1[i];
+				rv1[i] = c*rv1[i];
+				if ((double)(fabs(f)+anorm) == anorm) { break;};
+
+				g = W.get(i,i);
+				h = pythag(f,g);
+
+				W.set(h,i,i);
+				h = 1.0/h;
+				c = g*h;
+				s = -f*h;
+
+				for (j=0; j<m; j++)
+				{
+					y = A.get(j,nm);
+					z = A.get(j,i);
+					A.set(y*c+z*c, j, nm);
+					A.set(z*c-y*s, j,i);
+				};
+			}; // for (i=1; i<=k; i++)
+		}; // if (flag)
+
+		//  "End of part 4\n"
+
+		z = W.get(k,k);
+		if (l == k)
+		{
+			// Convergence
+			if (z < 0.0)
+			{
+				// Singular values are made nonnegative
+				W.set(-z, k,k);
+				for (j=0; j<n; j++) { V.set(-V.get(j,k), j,k);};
+			};
+			break;
+		}; // if (l == k)
+
+		if (its == 100)
+		{
+			std::cerr << "No convergence in 100 svdcmp iterations\n";
+			return;
+		}
+
+		//      "End of part 5\n"
+
+		x = W.get(l,l);   // Shift from bottom 2-by-2 mirror
+		nm = k-1;
+		y = W.get(nm,nm);
+		g = rv1[nm];
+		h = rv1[k];
+		f = ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
+		g = pythag(f,1.0);
+		f=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;
+		c=s=1.0;  // Next QR transformation
+		for (j=l; j<=nm; j++)
+		{
+			i = j+1;
+			g = rv1[i];
+			y = W.get(i,i);
+			h = s*g;
+			g = c*g;
+			z = pythag(f,h);
+			rv1[j] = z;
+			c = f/z;
+			s = h/z;
+			f = x*c+g*s;
+			g = g*c-x*s;
+			h = y*s;
+			y *= c;
+			for (jj=0; jj<n; jj++)
+			{
+				x = V.get(jj,j);
+				z = V.get(jj,i);
+				V.set(x*c+z*s, jj,j);
+				V.set(z*c-x*s, jj,i);
+			};
+			z = pythag(f,h);
+			W.set(z, j,j);
+			if  (z)
+			{
+				// Rotation can be arbitrary if z=0;
+				z = 1.0/z;
+				c = f*z;
+				s = h*z;
+			};
+			f = c*g+s*y;
+			x = c*y-s*g;
+
+			for (jj=0; jj<m; jj++)
+			{
+				y = A.get(jj,j);
+				z = A.get(jj,i);
+				A.set(y*c+z*s, jj,j);
+				A.set(z*c-y*s, jj,i);
+			};
+		}; // for (j=1; k<=nm; j++)
+		rv1[l] = 0.0;
+		rv1[k] = f;
+		W.set(x, k,k);
+	}; // for (its=1; its<=30; its++)
+    }; // for (k=n; k>=1; k--)
+
+    DD  = W;
+    VV = V;
+} // end of function
+
+
+matrix pseudoinverse(matrix const& A, double threshold) {
+
+    matrix U=A, D,V;
+    svdcmp(U,D,V);
+
+    matrix iD(D.row(), D.row());
+    for (int i=0; i<D.row(); i++)
+    {
+	// Truncate (near) singular values
+	if (fabs(D.get(i,i))>threshold)
+		iD.set((double)1/D.get(i,i), i,i);
+    };
+
+    matrix res = V*iD;
+    res = res*U.trans();
+    return res;
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgSVD.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,21 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_SVD_H_
+#define _AT91SAM926xMOUSE_LINALG_SVD_H_
+
+#include "AT91SAM926xMouseLinAlgUtil.h"
+#include "AT91SAM926xMouseLinAlg.h"
+
+// SVD-decomposition A = U*W*V', where U,V orthogonal and W diagonal. The matrix U is
+// replacing A and notice that V and not the transpose V' is returned. 
+void svdcmp(matrix &A, matrix &D, matrix &V);
+matrix pseudoinverse(matrix const& A, double threshold=1e-6);
+
+#endif // _AT91SAM926xMOUSE_LINALG_SVD_H_
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.cpp	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,22 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#include "AT91SAM926xmousehandler.h"
+
+#include <stdlib.h>
+#include <fstream>
+#include "AT91SAM926xMouseLinAlgUtil.h"
+
+
+void error(char* error_text)
+{
+#ifdef DEF_AT91SAM926x_OUTPUT_TOUCHSCREEN_DEBUG_INFORMATION
+    std::cout << "\n" << error_text;
+#endif
+}
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926xMouseLinAlgUtil.h	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,34 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 by Leonid Dudnick
+**
+** Leonid.Dudnick@gmail.com
+**
+**
+****************************************************************************/
+
+#ifndef _AT91SAM926xMOUSE_LINALG_UTIL_H_
+#define _AT91SAM926xMOUSE_LINALG_UTIL_H_
+
+#include <iostream>
+#include <sstream>
+#include <vector>
+
+void error(char* error_text);
+
+inline double num(double x) {
+  double y=x;
+  if (x < 0)
+    y = -x;
+  return(y);
+}
+
+template <class T>
+std::string numStr(T x) {
+  std::ostringstream nmbstr; nmbstr << x;
+  std::string ss = nmbstr.str();
+
+  return ss;
+}
+
+#endif // _AT91SAM926xMOUSE_LINALG_UTIL_H_
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro
--- qt-everywhere-opensource-src-4.8.5_org/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro	1970-01-01 03:00:00.000000000 +0300
+++ qt-everywhere-opensource-src-4.8.5_patched/src/plugins/mousedrivers/AT91SAM926xMouse/AT91SAM926x.pro	2014-04-08 15:44:55.000000000 +0400
@@ -0,0 +1,8 @@
+TARGET = AT91SAM926xmousehandler
+include(../../qpluginbase.pri)
+
+target.path = $$[QT_INSTALL_PLUGINS]/mousedrivers
+INSTALLS += target
+
+HEADERS = AT91SAM926xmousedriverplugin.h AT91SAM926xmousehandler.h
+SOURCES = AT91SAM926xmousedriverplugin.cpp AT91SAM926xmousehandler.cpp
diff -uNr qt-everywhere-opensource-src-4.8.5_org/src/qt3support/network/q3dns.cpp qt-everywhere-opensource-src-4.8.5_patched/src/qt3support/network/q3dns.cpp
--- qt-everywhere-opensource-src-4.8.5_org/src/qt3support/network/q3dns.cpp	2013-06-07 09:16:59.000000000 +0400
+++ qt-everywhere-opensource-src-4.8.5_patched/src/qt3support/network/q3dns.cpp	2014-04-18 14:06:54.357001326 +0400
@@ -49,7 +49,7 @@
 # include <netinet/in.h>
 # include <arpa/nameser.h>
 # include <resolv.h>
-extern "C" int res_init();
+extern "C" int res_init() throw();
 #endif
 
 // POSIX Large File Support redefines open -> open64
